<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Expressions · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li class="is-active"><a class="tocitem" href>Expressions</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#par_func_docs"><span>Parameter Functions</span></a></li><li><a class="tocitem" href="#Variable-Hierarchy"><span>Variable Hierarchy</span></a></li><li><a class="tocitem" href="#Affine-Expressions"><span>Affine Expressions</span></a></li><li><a class="tocitem" href="#Quadratic-Expressions"><span>Quadratic Expressions</span></a></li><li><a class="tocitem" href="#nlp_guide"><span>Nonlinear Expressions</span></a></li></ul></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../manual/optimize/">Optimization</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Expressions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Expressions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/expression.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="expr_docs"><a class="docs-heading-anchor" href="#expr_docs">Expressions</a><a id="expr_docs-1"></a><a class="docs-heading-anchor-permalink" href="#expr_docs" title="Permalink"></a></h1><p>A guide for the defining and understanding the variable expressions  used in <code>InfiniteOpt</code>. See the <a href="../../manual/expression/#expr_manual">technical manual</a> for more  details.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Nonlinear modeling is handled differently in <code>InfiniteOpt</code> vs <code>JuMP</code>. See  <a href="#nlp_guide">Nonlinear Expressions</a> for more information. </p></div></div><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Expressions in <code>InfiniteOpt</code> (also called functions) refer to mathematical  statements involving variables and numbers. Thus, these comprise the  mathematical expressions used that are used in measures, objectives, and  constraints. Programmatically, <code>InfiniteOpt</code> simply extends <code>JuMP</code> expression  types and methods principally pertaining to affine and quadratic mathematical  expressions. A natively supported abstraction for general nonlinear expressions  is planned for development since that of <code>JuMP</code> is not readily extendable.</p><h2 id="par_func_docs"><a class="docs-heading-anchor" href="#par_func_docs">Parameter Functions</a><a id="par_func_docs-1"></a><a class="docs-heading-anchor-permalink" href="#par_func_docs" title="Permalink"></a></h2><p>As described further below, InfiniteOpt.jl only supports affine and quadratic  expressions in its current rendition. However, there several use cases where we  might want to provide a more complex known function of infinite parameter(s) (e.g.,  nonlinear setpoint tracking). Thus, we provide parameter function objects  that given a particular realization of infinite parameters will output a scalar  value. Note that this can be interpreted as an infinite variable that is  constrained to a particular known function. This is accomplished via  <a href="../../manual/expression/#InfiniteOpt.@parameter_function"><code>@parameter_function</code></a> or <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a> and is exemplified  by defining a parameter function <code>f(t)</code> that uses <code>sin(t)</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using InfiniteOpt;

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @parameter_function(model, f == sin(t))
f(t)</code></pre><p>Here we created a parameter function object, added it to <code>model</code>, and  then created a Julia variable <code>f</code> that serves as a <code>GeneralVariableRef</code> that points  to it. From here we can treat <code>f</code> as a normal infinite variable and use it with  measures, derivatives, and constraints. For example, we can do the following:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, y, Infinite(t));

julia&gt; df = deriv(f, t)
∂/∂t[f(t)]

julia&gt; meas = integral(y - f, t)
∫{t ∈ [0, 10]}[y(t) - f(t)]

julia&gt; @constraint(model, y - f &lt;= 0)
y(t) - f(t) ≤ 0.0, ∀ t ∈ [0, 10]</code></pre><p>We can also define parameter functions that depend on multiple infinite  parameters even use an anonymous function if preferred:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, x[1:2] in [-1, 1]);

julia&gt; @parameter_function(model, myname == (t, x) -&gt; t + sum(x))
myname(t, x)</code></pre><p>In many applications, we may also desire to define an array of parameter functions  that each use a different realization of some parent function by varying some  additional positional/keyword arguments. We readily support this behavior since  parameter functions can be defined with additional known arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; @parameter_function(model, pfunc_alt[i = 1:3] == t -&gt; mysin(t, as[i], b = 0))
3-element Vector{GeneralVariableRef}:
 pfunc_alt[1](t)
 pfunc_alt[2](t)
 pfunc_alt[3](t)</code></pre><p>The main recommended use case for <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a> is that it is  amenable to define complex anonymous functions via a do-block which is useful  for applications like defining a time-varied setpoint:</p><pre><code class="language-julia-repl hljs">julia&gt; setpoint = parameter_function(t, name = &quot;setpoint&quot;) do t_supp
                    if t_supp &lt;= 5
                        return 2.0
                    else 
                        return 10.2
                    end
                 end
setpoint(t)</code></pre><p>Please consult the following links for more information about defining parameter  functions: <a href="../../manual/expression/#InfiniteOpt.@parameter_function"><code>@parameter_function</code></a> and <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a>.</p><p>Beyond this, there are a number of query and modification methods that can be  employed for parameter functions and these are detailed in the  <a href="../../manual/expression/#par_func_manual">technical manual</a> Section below.</p><h2 id="Variable-Hierarchy"><a class="docs-heading-anchor" href="#Variable-Hierarchy">Variable Hierarchy</a><a id="Variable-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Hierarchy" title="Permalink"></a></h2><p>Expressions employ variable reference types inherited from <code>JuMP.AbstractVariableRef</code> to form expression objects. <code>InfiniteOpt</code> uses a hierarchy of such types to organize the complexities associated with modeling infinite dimensional programs. The figure below summarizes this hierarchy of variable reference types where the abstract types are depicted in green and the concrete types are shown blue.</p><p><img src="../../assets/variable_tree.png" alt="tree"/></p><p>In consistently with <code>JuMP</code> expression support, <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> exists as a variable reference type that is able to represent any of the above concrete subtypes of <a href="../../manual/expression/#InfiniteOpt.DispatchVariableRef"><code>DispatchVariableRef</code></a>. This allows the expression containers to be homogeneous in variable type. This is a paradigm shift from previous versions of <code>InfiniteOpt</code> that used the hierarchy of types directly to construct expressions. This behavior led to stability and performance limitations and thus a has been discontinued.</p><p>However, the variable hierarchy is still used to create for variable methods. To accomplish this appropriate <code>GeneralVariableRef</code> dispatch methods are implemented (which are detailed in User Methods section at the bottom of this page) that utilize <a href="../../manual/expression/#InfiniteOpt.dispatch_variable_ref"><code>dispatch_variable_ref</code></a> to create the appropriate concrete subtype of <code>DispatchVariableRef</code> and call the appropriate underlying method. These dispatch methods have been implemented for all public methods and the underlying methods are what are documented in the method manuals throughout the User Guide pages.</p><h2 id="Affine-Expressions"><a class="docs-heading-anchor" href="#Affine-Expressions">Affine Expressions</a><a id="Affine-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-Expressions" title="Permalink"></a></h2><p>An affine expression pertains to a mathematical function of the form:</p><p class="math-container">\[f_a(x) = a_1x_1 + ... + a_nx_n + b\]</p><p>where <span>$x \in \mathbb{R}^n$</span> denote variables, <span>$a \in \mathbb{R}^n$</span> denote  coefficients, and <span>$b \in \mathbb{R}$</span> denotes a constant value. Such  expressions, are prevalent in any problem than involves linear constraints  and/or objectives.</p><p>In <code>InfiniteOpt</code>, affine expressions can be defined directly  using <code>Julia</code>&#39;s arithmetic operators (i.e., <code>+</code>, <code>-</code>, <code>*</code>, etc.) or using  <code>@expression</code>.  For example, let&#39;s define the expression  <span>$2y(t) + z - 3t$</span> noting that the following methods are equivalent:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @variable(model, y, Infinite(t))
y(t)

julia&gt; @variable(model, z)
z

julia&gt; expr = 2y + z - 3t
2 y(t) + z - 3 t

julia&gt; expr = 2 * y + z - 3 * t
2 y(t) + z - 3 t

julia&gt; expr = @expression(model, 2y + z - 3t)
2 y(t) + z - 3 t

julia&gt; typeof(expr)
GenericAffExpr{Float64, GeneralVariableRef}</code></pre><p>Notice that coefficients to variables can simply be put alongside variables  without having to use the <code>*</code> operator. Also, note that all of these expressions  are stored in a container referred to as a <code>GenericAffExpr</code> which is a <code>JuMP</code>  object for storing affine expressions.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Where possible, it is preferable to use  <a href="https://jump.dev/JuMP.jl/v1/reference/expressions/#JuMP.@expression"><code>@expression</code></a>  for defining expressions as it is much more efficient than explicitly using  the standard operators.</p></div></div><p><code>GenericAffExpr</code> objects contain 2 fields which are:</p><ul><li><code>constant::CoefType</code> The constant value of the affine expression.</li><li><code>terms::OrderDict{VarType, CoefType}</code> A dictionary mapping variables to coefficients.</li></ul><p>For example, let&#39;s see what these fields look like in the above example:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.terms
OrderedCollections.OrderedDict{GeneralVariableRef, Float64} with 3 entries:
  y(t) =&gt; 2.0
  z    =&gt; 1.0
  t    =&gt; -3.0

julia&gt; expr.constant
0.0</code></pre><p>Notice that the ordered dictionary preserves the order in which the variables  appear in the expression.</p><p>More information can be found in the documentation for affine expressions in  <a href="https://jump.dev/JuMP.jl/v1/reference/expressions/#Affine-expressions"><code>JuMP</code></a>.</p><h2 id="Quadratic-Expressions"><a class="docs-heading-anchor" href="#Quadratic-Expressions">Quadratic Expressions</a><a id="Quadratic-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Expressions" title="Permalink"></a></h2><p>A quadratic function pertains to a mathematical function of the form:</p><p class="math-container">\[f_q(x) = a_1x_1^2 + a_2 x_1 x_2 + ... + a_m x_n^2 + f_a(x)\]</p><p>where <span>$x \in \mathbb{R}^n$</span> are the variables, <span>$f_a(x): \mathbb{R}^n \mapsto \mathbb{R}$</span> is an affine function, and <span>$m = n(n+1)/2$</span> is the number of unique combinations of variables <span>$x$</span>. Like affine expressions, quadratic expressions can be defined via <code>Julia</code>&#39;s arithmetic operators or via <code>@expression</code>. For example, let&#39;s define <span>$2y^2(t) - zy(t) + 42t - 3$</span> using the following equivalent methods:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = 2y^2 - z * y + 42t - 3
2 y(t)² - z*y(t) + 42 t - 3

julia&gt; expr = @expression(model, 2y^2 - z * y + 42t - 3)
2 y(t)² - y(t)*z + 42 t - 3

julia&gt; typeof(expr)
GenericQuadExpr{Float64, GeneralVariableRef}</code></pre><p>Again, notice that coefficients need not employ <code>*</code>. Also, the object used to  store the expression is a <code>GenericQuadExpr</code> which is a <code>JuMP</code> object used for  storing quadratic expressions.</p><p><code>GenericQuadExpr</code> object contains 2 data fields which are:</p><ul><li><code>aff::GenericAffExpr{CoefType,VarType}</code> An affine expression</li><li><code>terms::OrderedDict{UnorderedPair{VarType}, CoefType}</code> A dictionary mapping quadratic variable pairs to coefficients.</li></ul><p>Here the <code>UnorderedPair</code> type is unique to <code>JuMP</code> and contains the fields:</p><ul><li><code>a::AbstractVariableRef</code> One variable in a quadratic pair</li><li><code>b::AbstractVariableRef</code> The other variable in a quadratic pair.</li></ul><p>Thus, this form can be used to store arbitrary quadratic expressions. For  example, let&#39;s look at what these fields look like in the above example:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.aff
42 t - 3

julia&gt; typeof(expr.aff)
GenericAffExpr{Float64, GeneralVariableRef}

julia&gt; expr.terms
OrderedCollections.OrderedDict{UnorderedPair{GeneralVariableRef}, Float64} with 2 entries:
  UnorderedPair{GeneralVariableRef}(y(t), y(t)) =&gt; 2.0
  UnorderedPair{GeneralVariableRef}(y(t), z)    =&gt; -1.0</code></pre><p>Notice again that the ordered dictionary preserves the order.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Polynomial expressions can be represented by introducing dummy variables  and nested quadratic/affine expressions. For instance, <span>$z^3 + 2$</span> can be  expressed by introducing a dummy variable <span>$x = z^2$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, x == z^2)
-z² + x = 0.0

julia&gt; expr = @expression(model, z * x + 2)
z*x + 2</code></pre><p>Alternatively, can we can just use our nonlinear modeling interface:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = @expression(model, z^3 + 2)
z^3 + 2</code></pre></div></div><p>More information can be found in the documentation for quadratic expressions in  <a href="https://jump.dev/JuMP.jl/v1/reference/expressions/#Quadratic-expressions"><code>JuMP</code></a>.</p><h2 id="nlp_guide"><a class="docs-heading-anchor" href="#nlp_guide">Nonlinear Expressions</a><a id="nlp_guide-1"></a><a class="docs-heading-anchor-permalink" href="#nlp_guide" title="Permalink"></a></h2><p>General nonlinear expressions as generated via <code>JuMP.@NLexpression</code>,  <code>JuMP.@NLobjective</code>, and/or <code>JuMP.@NLconstraint</code> macros in <code>JuMP</code> are not  extendable for extension packages like <code>InfiniteOpt</code>. A fundamental  overhaul is planned to resolve this problem (check the status on  <a href="https://github.com/jump-dev/MathOptInterface.jl/issues/846">GitHub</a>), but this  will likely require 1-3 years to resolve.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><code>JuMP-dev</code> has secured funding to overhaul their nonlinear interface and  hence the timeline for resolving many of the limitations should be expedited.  Check out their <a href="https://jump.dev/announcements/2022/02/21/lanl/">announcement</a>  for more information.</p></div></div><p>Thus, in the interim, we circumvent this problem in <code>InfiniteOpt</code> by implementing  our own general nonlinear expression API. However, we will see that our interface  treats nonlinear expressions as 1st class citizens and thus is generally more  convenient than using <code>JuMP</code>&#39;s current legacy nonlinear modeling interface.  We discuss the ins and outs of this interface in the subsections below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike affine/quadratic expressions, our nonlinear interface differs from  that of <code>JuMP</code>. Thus, it is important to carefully review the sections  below to familiarize yourself with our syntax. </p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Our new general nonlinear modeling interface is experimental and thus is  subject to change to address any unintended behavior. Please notify us on  GitHub if you encounter any unexpected behavior.</p></div></div><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><p>In <code>InfiniteOpt</code> we can define nonlinear expressions in similar manner to how  affine/quadratic expressions are made in <code>JuMP</code>. For instance, we can make an  expression using normal Julia code outside a macro:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, t ∈ [0, 1]); @variable(model, y, Infinite(t));

julia&gt; expr = exp(y^2.3) * y - 42
exp(y(t)^2.3) * y(t) - 42

julia&gt; typeof(expr)
NLPExpr</code></pre><p>Thus, the nonlinear expression <code>expr</code> of type <a href="../../manual/expression/#InfiniteOpt.NLPExpr"><code>NLPExpr</code></a> is created can  be readily incorporated to other expressions, the objective, and/or constraints.  For macro-based definition, we simply use the <code>@expression</code>, <code>@objective</code>, and  <code>@constraint</code> macros (which in <code>JuMP</code> are only able to handle affine/quadratic  expressions):</p><pre><code class="language-julia-repl hljs">julia&gt; @expression(model, expr, exp(y^2.3) * y - 42)
exp(y(t)^2.3) * y(t) - 42

julia&gt; @objective(model, Min, ∫(0.3^cos(y^2), t))
∫{t ∈ [0, 1]}[0.3^cos(y(t)²)]

julia&gt; @constraint(model, constr, y^y * sin(y) + sum(y^i for i in 3:4) == 3)
constr : (y(t)^y(t) * sin(y(t)) + y(t)^3 + y(t)^4) - 3 = 0.0, ∀ t ∈ [0, 1]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>@NLexpression</code>, <code>@NLobjective</code>, and <code>@NLconstraint</code> macros used by <code>JuMP</code> are not supported by <code>InfiniteOpt</code>. Instead, we can more conveniently use the  <code>@expression</code>, <code>@objective</code>, and <code>@constraint</code> macros directly.</p></div></div><p>Natively, we support all the same nonlinear functions/operators that <code>JuMP</code>  does. Note however that there are 3 caveats to this:</p><ul><li>Functions from <a href="https://github.com/JuliaMath/SpecialFunctions.jl"><code>SpecialFunctions.jl</code></a>  can only be used if <code>using SpecialFunctions</code> is included first</li><li>The <code>ifelse</code> function must be specified <a href="../../manual/expression/#InfiniteOpt.ifelse"><code>InfiniteOpt.ifelse</code></a> (because  the native <code>ifelse</code> is a core function that cannot be extended for our purposes)</li><li>The logic operators <code>&amp;</code> and <code>|</code> must be used instead of <code>&amp;&amp;</code> and <code>||</code> when  defining a nonlinear expression.</li></ul><p>Let&#39;s exemplify the above caveats:</p><pre><code class="language-julia-repl hljs">julia&gt; using SpecialFunctions

julia&gt; y^2.3 * gamma(y)
y(t)^2.3 * gamma(y(t))

julia&gt; InfiniteOpt.ifelse(y == 0, y^2.3, exp(y))
ifelse(y(t) == 0, y(t)^2.3, exp(y(t)))

julia&gt; InfiniteOpt.ifelse((y &lt;= 0) | (y &gt;= 3), y^2.3, exp(y))
ifelse(y(t) &lt;= 0 || y(t) &gt;= 3, y(t)^2.3, exp(y(t)))</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The logical comparison operator <code>==</code> will yield an <code>NLPExpr</code> instead of a  <code>Bool</code> when one side is a variable reference or an expression. Thus, for  creating Julia code that needs to determine if the Julia variables are equal  then <code>isequal</code> should be used instead:</p><pre><code class="language-julia-repl hljs">julia&gt; isequal(y, y)
true

julia&gt; y == t
y(t) == t</code></pre></div></div><p>We can interrogate which nonlinear functions/operators our model currently  supports by invoking <a href="../../manual/expression/#InfiniteOpt.all_registered_functions"><code>all_registered_functions</code></a>. Moreover, we can add  additional functions via registration (see <a href="#Function-Registration">Function Registration</a> for  more details). </p><p>Finally, we highlight that nonlinear expressions in <code>InfiniteOpt</code> support the  same linear algebra operations as affine/quadratic expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, v[1:2]); @variable(model, Q[1:2, 1:2]);

julia&gt; @expression(model, v&#39; * Q * v)
0 + (Q[1,1]*v[1] + Q[2,1]*v[2]) * v[1] + (Q[1,2]*v[1] + Q[2,2]*v[2]) * v[2]</code></pre><h3 id="Function-Tracing"><a class="docs-heading-anchor" href="#Function-Tracing">Function Tracing</a><a id="Function-Tracing-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Tracing" title="Permalink"></a></h3><p>In similar manner to <code>Symbolics.jl</code>, we support function tracing. This means  that we can create nonlinear modeling expression using Julia functions that  satisfy certain criteria. For instance:</p><pre><code class="language-julia-repl hljs">julia&gt; myfunc(x) = sin(x^3) / tan(2^x);

julia&gt; expr = myfunc(y)
sin(y(t)^3) / tan(2^y(t))</code></pre><p>However, there are certain limitations as to what internal code these functions  can contain. The following CANNOT be used:</p><ul><li>loops (unless it only uses very simple operations)</li><li>if-statements (see workaround below)</li><li>non-registered functions (if they cannot be traced).</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If a particular function is not amendable for tracing, try registering it  instead. See <a href="#Function-Registration">Function Registration</a> for details.</p></div></div><p>We can readily workaround the if-statement limitation using  <a href="../../manual/expression/#InfiniteOpt.ifelse"><code>InfiniteOpt.ifelse</code></a>. For example, the function:</p><pre><code class="language-julia hljs">function mylogicfunc(x)
    if x &gt;= 0
        return x^3
    else
        return 0
    end
end</code></pre><p>is not amendable for function tracing, but we can rewrite it as:</p><pre><code class="language-julia-repl hljs">julia&gt; function mylogicfunc(x)
          return InfiniteOpt.ifelse(x &gt;= 0, x^3, 0)
       end
mylogicfunc (generic function with 1 method)

julia&gt; mylogicfunc(y)
ifelse(y(t) &gt;= 0, y(t)^3, 0)</code></pre><p>which is amendable for function tracing.</p><h3 id="Linear-Algebra"><a class="docs-heading-anchor" href="#Linear-Algebra">Linear Algebra</a><a id="Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra" title="Permalink"></a></h3><p>As described above in the Basic Usage Section, we support linear algebra  operations with nonlinear expressions! This relies on our basic extensions of  <a href="https://github.com/jump-dev/MutableArithmetics.jl"><code>MutableArithmetics</code></a>, but  admittedly this implementation is not perfect in terms of efficiency. </p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Using linear algebra operations with nonlinear expression provides user  convenience, but is less efficient than using <code>sum</code>s. Thus, <code>sum</code> should be  used instead when efficiency is critical.</p><pre><code class="language-julia-repl hljs">julia&gt; v&#39; * Q * v # convenient linear algebra syntax
0 + (Q[1,1]*v[1] + Q[2,1]*v[2]) * v[1] + (Q[1,2]*v[1] + Q[2,2]*v[2]) * v[2]

julia&gt; sum(v[i] * Q[i, j] * v[j] for i in 1:2, j in 1:2) # more efficient
v[1] * Q[1,1] * v[1] + v[2] * Q[2,1] * v[1] + v[1] * Q[1,2] * v[2] + v[2] * Q[2,2] * v[2]</code></pre></div></div><p>We can also set vectorized constraints using the <code>.==</code>, <code>.&lt;=</code>, and <code>.&gt;=</code>  operators:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, W[1:2, 1:2]);

julia&gt; @constraint(model, W * Q * v .== 0)
2-element Vector{InfOptConstraintRef}:
 (0 + (W[1,1]*Q[1,1] + W[1,2]*Q[2,1]) * v[1] + (W[1,1]*Q[1,2] + W[1,2]*Q[2,2]) * v[2]) - 0 == 0.0
 (0 + (W[2,1]*Q[1,1] + W[2,2]*Q[2,1]) * v[1] + (W[2,1]*Q[1,2] + W[2,2]*Q[2,2]) * v[2]) - 0 == 0.0</code></pre><p>However, it is important to note that although vector constraints can be  expressed in <code>InfiniteOpt</code>, they are not supported by <code>JuMP</code> and thus an error  is incurred if we try to solve an <code>InfiniteOpt</code> model using the  <code>TranscriptionOpt</code> backend:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, W * Q * v in MOI.Zeros(2)) # will cause solution error 
[0 + (W[1,1]*Q[1,1] + W[1,2]*Q[2,1]) * v[1] + (W[1,1]*Q[1,2] + W[1,2]*Q[2,2]) * v[2], 0 + (W[2,1]*Q[1,1] + W[2,2]*Q[2,1]) * v[1] + (W[2,1]*Q[1,2] + W[2,2]*Q[2,2]) * v[2]] in MathOptInterface.Zeros(2)

julia&gt; optimize!(model)
ERROR: TranscriptionOpt does not support vector constraints of general nonlinear expressions because this is not yet supported by JuMP.</code></pre><h3 id="Function-Registration"><a class="docs-heading-anchor" href="#Function-Registration">Function Registration</a><a id="Function-Registration-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Registration" title="Permalink"></a></h3><p>In a similar spirit to <code>JuMP</code> and <code>Symbolics</code>, we can register user-defined  functions such that they can be directly incorporated into nonlinear expressions.  This is done via the <a href="../../manual/expression/#InfiniteOpt.@register"><code>@register</code></a> macro. We can register any function  that takes scalar arguments (which can accept inputs of type <code>Real</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; h(a, b) = a * b^2; # an overly simple example user-defined function

julia&gt; @register(model, h(a, b));

julia&gt; h(y, 42)
h(y(t), 42)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Where possible it is preferred to use function tracing instead of function  registration. This improves performance and can prevent unintentional errors.  See <a href="#Function-Tracing">Function Tracing</a> for more details.</p></div></div><p>To highlight the difference between function tracing and function  registration consider the following example:</p><pre><code class="language-julia-repl hljs">julia&gt; f(a) = a^3;

julia&gt; f(y) # user-function gets traced
y(t)^3

julia&gt; @register(model, f(a)) # register function
f (generic function with 2 methods)

julia&gt; f(y) # function is no longer traced
f(y(t))</code></pre><p>Thus, registered functions are incorporated directly. This means that their  gradients and hessians will need to determined as well (typically occurs  behind the scenes via auto-differentiation with the selected optimizer model  backend). However, again please note that in this case tracing is preferred  since <code>f</code> can be traced. </p><p>Let&#39;s consider a more realistic example where the function is not amenable to  tracing:</p><pre><code class="language-julia-repl hljs">julia&gt; function g(a)
          v = 0
          for i in 1:4
              v *= v^a
              if v &gt;= 1
                 return v
              end
          end
          return a
       end;

julia&gt; @register(model, g(a));

julia&gt; g(y)
g(y(t))</code></pre><p>Notice this example is a little contrived still, highlighting that in most cases  we can avoid registration. However, one exception to this trend, are functions  from other packages that we might want to use. For example, perhaps we would  like to use the <code>eta</code> function from <code>SpecialFunctions.jl</code> which is not natively  supported:</p><pre><code class="language-julia-repl hljs">julia&gt; using SpecialFunctions

julia&gt; my_eta(a) = eta(a);

julia&gt; @register(model, my_eta(a));

julia&gt; my_eta(y)
my_eta(y(t))</code></pre><p>Notice that we cannot register <code>SpecialFunctions.eta</code> directly due to  scoping limitations that are inherited in generating constructor functions on the  fly (which necessarily occurs behind the scenes with <a href="../../manual/expression/#InfiniteOpt.@register"><code>@register</code></a>).</p><p>Now in some cases we might wish to specify the gradient and hessian of a  univariate function we register to avoid the need for auto-differentiation. We  can do this, simply by adding them as additional arguments when we register:</p><pre><code class="language-julia-repl hljs">julia&gt; my_squared(a) = a^2; gradient(a) = 2 * a; hessian(a) = 2;

julia&gt; @register(model, my_squared(a), gradient, hessian);

julia&gt; my_squared(y)
my_squared(y(t))</code></pre><p>Note the specification of the hessian is optional (it can separately be  computed via auto-differentiation if need be).</p><p>For multivariate functions, we can specify the gradient (the hessian is not  currently supported by <code>JuMP</code> optimizer models) following the same gradient  function structure that <code>JuMP</code> uses:</p><pre><code class="language-julia-repl hljs">julia&gt; w(a, b) = a * b^2;

julia&gt; function wg(v, a, b)
          v[1] = b^2
          v[2] = 2 * a * b
          return
       end;

julia&gt; @register(model, w(a, b), wg) # register multi-argument function
w (generic function with 4 methods)

julia&gt; w(42, y)
w(42, y(t))</code></pre><p>Note that the first argument of the gradient needs to accept an  <code>AbstractVector{Real}</code> that is then filled in place.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We do not currently support vector inputs or vector valued functions  directly, since typically <code>JuMP</code> optimizer model backends don&#39;t support them.  However, this limitation can readily be removed if there is a use case for it  (please reach out to us if such an addition is needed).</p></div></div><h3 id="Expression-Tree-Abstraction"><a class="docs-heading-anchor" href="#Expression-Tree-Abstraction">Expression Tree Abstraction</a><a id="Expression-Tree-Abstraction-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Tree-Abstraction" title="Permalink"></a></h3><p>The nonlinear interface in <code>InfiniteOpt</code> is enabled through the <a href="../../manual/expression/#InfiniteOpt.NLPExpr"><code>NLPExpr</code></a>  type which uses an intelligent expression tree structure. In particular, we use  a memory efficient <a href="https://en.wikipedia.org/wiki/Left-child_right-sibling_binary_tree">Left-Child Right-Sibling Tree</a>  whose leaves (nodes with no children) can be:</p><ul><li>constants (i.e., <code>Int</code>, <code>Float64</code>, and/or <code>Bool</code>)</li><li>variables (<a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>s)</li><li>affine expressions (<code>GenericAffExpr{Float64, GeneralVariableRef}</code>)</li><li>quadratic expressions (<code>GenericQuadExpr{Float64, GeneralVariableRef}</code>)</li></ul><p>Moreover, the internal tree nodes correspond to functions/operators which are  stored as <code>Symbol</code> names (which correspond to registered functions via  <a href="../../manual/expression/#InfiniteOpt.name_to_function"><code>name_to_function</code></a>). We accomplish this via  <a href="https://github.com/JuliaCollections/LeftChildRightSiblingTrees.jl"><code>LeftChildRightSiblingTrees.jl</code></a>  in combination with <a href="../../manual/expression/#InfiniteOpt.NodeData"><code>NodeData</code></a> to store the content of each node. </p><p>We can view the tree structure of an <a href="../../manual/expression/#InfiniteOpt.NLPExpr"><code>NLPExpr</code></a> using  <a href="../../manual/expression/#InfiniteOpt.print_expression_tree-Tuple{NLPExpr}"><code>print_expression_tree</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = exp(y^2.3) * y - 42
exp(y(t)^2.3) * y(t) - 42

julia&gt; print_expression_tree(expr)
-
├─ *
│  ├─ exp
│  │  └─ ^
│  │     ├─ y(t)
│  │     └─ 2.3
│  └─ y(t)
└─ 42</code></pre><p>Here, we can see the algebraic expression is decomposed into an expression  tree were the leaves contain the variables/constants (and can contain  affine/quadratic expressions) and the intermediate nodes contain function  names. Note that the top most node is called the root node and that is what  <a href="../../manual/expression/#InfiniteOpt.NLPExpr"><code>NLPExpr</code></a> stores in its <code>tree_root</code> field:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.tree_root
Node(-)

julia&gt; typeof(expr.tree_root)
LeftChildRightSiblingTrees.Node{NodeData}</code></pre><p>The rest of the tree can then be interrogated by traversing the tree as enabled  by the API of  <a href="https://github.com/JuliaCollections/LeftChildRightSiblingTrees.jl"><code>LeftChildRightSiblingTrees.jl</code></a>.</p><p>In addition to the API of <code>LeftChildRightSiblingTrees.jl</code>, we provide some  mapping functions that are useful for extensions. First, with  <a href="../../manual/expression/#InfiniteOpt.map_expression"><code>map_expression</code></a> we can create a new <code>NLPExpr</code> based on an existing  <code>NLPExpr</code> where a transformation is applied to each variable:</p><pre><code class="language-julia-repl hljs">julia&gt; map_expression(v -&gt; v^2, expr)
exp((y(t)²)^2.3) * (y(t)²) - 42</code></pre><p>We also provide <a href="../../manual/expression/#InfiniteOpt.map_nlp_to_ast"><code>map_nlp_to_ast</code></a> which can be used to map an <code>NLPExpr</code> to a  Julia Abstract Syntax Tree (AST) where a transformation is applied to each  variable:</p><pre><code class="language-julia-repl hljs">julia&gt; jump_model = Model(); @variable(jump_model, y_jump);

julia&gt; map_nlp_to_ast(v -&gt; y_jump, expr)
:(exp(y_jump ^ 2.3) * y_jump - 42)</code></pre><p>This is useful for converting <code>NLPExpr</code>s into ASTs that can be used in <code>JuMP</code>  via its <a href="https://jump.dev/JuMP.jl/v1/manual/nlp/#Raw-expression-input"><code>add_nonlinear_expression</code></a>  API.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../derivative/">« Derivatives</a><a class="docs-footer-nextpage" href="../measure/">Measures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 24 May 2022 03:03">Tuesday 24 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
