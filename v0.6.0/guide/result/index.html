<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Results · InfiniteOpt.jl</title><meta name="title" content="Results · InfiniteOpt.jl"/><meta property="og:title" content="Results · InfiniteOpt.jl"/><meta property="twitter:title" content="Results · InfiniteOpt.jl"/><meta name="description" content="Documentation for InfiniteOpt.jl."/><meta property="og:description" content="Documentation for InfiniteOpt.jl."/><meta property="twitter:description" content="Documentation for InfiniteOpt.jl."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/Fishing/">Fishing Optimal Control</a></li><li><a class="tocitem" href="../../examples/Optimal Control/Hanging Chain/">Hanging Chain Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/Jennings/">Minimizing Final Time (Jennings Problem)</a></li><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li class="is-active"><a class="tocitem" href>Results</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Interpolation-Based-Continuous-Values"><span>Interpolation-Based Continuous Values</span></a></li><li><a class="tocitem" href="#Termination-Queries"><span>Termination Queries</span></a></li><li><a class="tocitem" href="#Variable-Queries"><span>Variable Queries</span></a></li><li><a class="tocitem" href="#Constraint-Queries"><span>Constraint Queries</span></a></li><li><a class="tocitem" href="#LP-Sensitivity"><span>LP Sensitivity</span></a></li><li><a class="tocitem" href="#Direct-Queries"><span>Direct Queries</span></a></li></ul></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/backend/">Backends</a></li><li><a class="tocitem" href="../../manual/transcribe/">TranscriptionOpt</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li><li><a class="tocitem" href="../../manual/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Results</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Results</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/infiniteopt/InfiniteOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/docs/src/guide/result.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="result_docs"><a class="docs-heading-anchor" href="#result_docs">Results</a><a id="result_docs-1"></a><a class="docs-heading-anchor-permalink" href="#result_docs" title="Permalink"></a></h1><p>A guide for querying optimized <code>InfiniteOpt</code> models. See the respective  <a href="../../manual/result/#result_manual">technical manual</a> for more details.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>So far we have covered defining, transforming, and optimizing <code>InfiniteModel</code>s.  Now comes the point to extract information from our optimized model. This is done  following extended versions of <code>JuMP</code>s querying functions in combination with  the mapping information stored in the transformation backend. Thus, this page will  walk through the use of these result query functions.</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Let&#39;s revisit the example from the optimization page to get us started:</p><pre><code class="language-julia-repl hljs">julia&gt; using InfiniteOpt, Ipopt;

julia&gt; model = InfiniteModel(Ipopt.Optimizer);

julia&gt; set_attribute(model, &quot;print_level&quot;, 0);

julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10);

julia&gt; @variable(model, y &gt;= 0, Infinite(t));

julia&gt; @variable(model, z &gt;= 0);

julia&gt; @objective(model, Min, 2z);

julia&gt; @constraint(model, c1, z &gt;= y);

julia&gt; @constraint(model, c2, y(0) == 42);

julia&gt; print(model)
Min 2 z
Subject to
 y(t) ≥ 0, ∀ t ∈ [0, 10]
 z ≥ 0
 c1 : z - y(t) ≥ 0, ∀ t ∈ [0, 10]
 c2 : y(0) = 42

julia&gt; optimize!(model)
</code></pre><p>Now that the model has been optimized, let&#39;s find out what happened. To determine  why the optimizer stopped, we can use  <a href="../../manual/result/#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a> to report the corresponding <code>MathOptInterface</code>  termination code (possible codes are explained  <a href="https://jump.dev/JuMP.jl/v1/api/JuMP/#MathOptInterface.TerminationStatusCode">here</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4</code></pre><p>Here we see that our model was locally solved via Ipopt and that is why it  stopped. Furthermore, we can query the primal and dual problem optimalities via  <a href="../../manual/result/#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a> and  <a href="../../manual/result/#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, respectively.</p><pre><code class="language-julia-repl hljs">julia&gt; primal_status(model)
FEASIBLE_POINT::ResultStatusCode = 1

julia&gt; dual_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre><p>The possible statuses are detailed <a href="https://jump.dev/JuMP.jl/v1/api/JuMP/#MathOptInterface.ResultStatusCode">here</a>.  These results are useful in knowing if information can be drawn from the primal  and/or dual and what it means. We can also verify that we indeed have answers  via <a href="../../manual/result/#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a> which indicates if our model has optimized variable  values.</p><pre><code class="language-julia-repl hljs">julia&gt; has_values(model)
true</code></pre><p>And indeed we do have values.</p><p>Now we can query the objective value via <a href="../../manual/result/#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a> which reports the optimal objective value.</p><pre><code class="language-julia-repl hljs">julia&gt; objective_value(model)
83.99999998250514</code></pre><p>Great now we can inquire about variable values via  <a href="../../manual/result/#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a>. First, let&#39;s retrieve the value of <code>z</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; value(z)
41.99999999125257</code></pre><p>We get a single value since <code>z</code> is a <code>FiniteVariable</code> and therefore finite. Now  let&#39;s retrieve the &quot;value&quot; of <code>y(t)</code> which is infinite with respect to <code>t</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; value(y)
10-element Vector{Float64}:
 42.0
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495</code></pre><p>Notice here we obtain an array of values since these correspond to the  transcribed finite (discretized) variables used to solve the problem. We obtain  the corresponding support (discretized <code>t</code>) values via <code>supports</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; supports(y)
10-element Vector{Tuple}:
 (0.0,)
 (1.11111111111,)
 (2.22222222222,)
 (3.33333333333,)
 (4.44444444444,)
 (5.55555555556,)
 (6.66666666667,)
 (7.77777777778,)
 (8.88888888889,)
 (10.0,)</code></pre><p>There is 1-to-1 correspondence between these supports and the values reported  above. Note that these are stored in tuples to facilitate multiple infinite  parameter dependencies.</p><div class="admonition is-info" id="Note-301d2237fc251c34"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-301d2237fc251c34" title="Permalink"></a></header><div class="admonition-body"><p>The values for an array of variables is obtained via the vectorized call  of <code>value</code> following the syntax:</p><pre><code class="language-julia hljs">value.(::AbstractArray{&lt;:GeneralVariableRef})</code></pre><p>This also holds true for many other methods in <code>InfiniteOpt</code>. For example,  adding the dot also vectorizes <code>dual</code> and <code>set_binary</code>.</p></div></div><p>We can query the dual of a constraint via  <a href="../../manual/result/#JuMP.dual-Tuple{InfOptConstraintRef}"><code>dual</code></a> if a model has duals available as indicated by <a href="../../manual/result/#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; has_duals(model)
true

julia&gt; dual(c1)
10-element Vector{Float64}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p><code>c1</code> is an infinite constraint, and thus we obtain the duals of its transcribed  versions. The underlying infinite parameter(s) and support values are queried  via <code>parameter_refs</code> and <code>supports</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; parameter_refs(c1)
(t,)

julia&gt; supports(c1)
10-element Vector{Tuple}:
 (0.0,)
 (1.11111111111,)
 (2.22222222222,)
 (3.33333333333,)
 (4.44444444444,)
 (5.55555555556,)
 (6.66666666667,)
 (7.77777777778,)
 (8.88888888889,)
 (10.0,)</code></pre><p>These again all have a 1-to-1 correspondence.</p><div class="admonition is-info" id="Note-57f53d4b601eccd1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-57f53d4b601eccd1" title="Permalink"></a></header><div class="admonition-body"><p>In the case that our variables/constraints depend on multiple infinite  parameters, an n-dimensional array will typically be returned whose dimensions correspond to the supports of the infinite parameters. </p></div></div><h2 id="Interpolation-Based-Continuous-Values"><a class="docs-heading-anchor" href="#Interpolation-Based-Continuous-Values">Interpolation-Based Continuous Values</a><a id="Interpolation-Based-Continuous-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-Based-Continuous-Values" title="Permalink"></a></h2><p>We can use interpolations to obtain continuous functions instead of discretized value arrays. See the <a href="../extensions/#interpolate">InfiniteInterpolations guide</a> to learn more.</p><h2 id="Termination-Queries"><a class="docs-heading-anchor" href="#Termination-Queries">Termination Queries</a><a id="Termination-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-Queries" title="Permalink"></a></h2><p>Termination queries are those that question about how the infinite model was  solved and what its optimized state entails. Programmatically, such queries on  the <code>InfiniteModel</code> are simply routed to its optimizer model.</p><p>The commonly used queries include <a href="../../manual/result/#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a>,  <a href="../../manual/result/#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a>, <a href="../../manual/result/#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, <a href="../../manual/result/#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a>, <a href="../../manual/result/#JuMP.result_count-Tuple{InfiniteModel}"><code>result_count</code></a>, and <a href="../../manual/result/#JuMP.solve_time-Tuple{InfiniteModel}"><code>solve_time</code></a>. The first four are well  exemplified in the Basic Usage section above and are helpful in quickly  understanding the optimality status of a given model following the many possible  statuses reported by <code>MathOptInterface</code> which are documented  <a href="https://jump.dev/MathOptInterface.jl/v1/manual/solutions/#Solutions">here</a>.  We use <code>result_count</code> to determine how many solutions are recorded in the  optimizer.</p><pre><code class="language-julia-repl hljs">julia&gt; result_count(model)
1</code></pre><p>This is useful since it informs what results there are which can be specified  via the <code>result</code> keyword argument in many methods such as <code>primal_status</code>,  <code>dual_status</code>, <code>objective_value</code>, <code>value</code>, <code>dual</code>, and more.</p><p>We use <code>solve_time</code> to determine the time in seconds used by the optimizer until  it terminated its search.</p><pre><code class="language-julia-repl hljs">julia&gt; solve_time(model)
0.004999876022338867</code></pre><p>Note that this query might not be supported with all solvers.</p><p>The above status queries are designed to report information in a consistent  format irrespective of the chosen optimizer. However, <a href="../../manual/result/#JuMP.raw_status-Tuple{InfiniteModel}"><code>raw_status</code></a> will  provide the optimality status verbatim as reported by the optimizer. Thus,  following our example with Ipopt we obtain:</p><pre><code class="language-julia-repl hljs">julia&gt; raw_status(model)
&quot;Solve_Succeeded&quot;</code></pre><p>Also, we obtain the best objective bound via <a href="../../manual/result/#JuMP.objective_bound-Tuple{InfiniteModel}"><code>objective_bound</code></a> which  becomes particularly useful solutions that are suboptimal. However, this method  is not supported by all optimizers and in this case Ipopt is one such optimizer.</p><p>Finally, we get the best dual objective value via <a href="../../manual/result/#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>dual_objective_value</code></a>  if the optimizer supplies this information which again Ipopt does not.</p><h2 id="Variable-Queries"><a class="docs-heading-anchor" href="#Variable-Queries">Variable Queries</a><a id="Variable-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Queries" title="Permalink"></a></h2><p>Information about the optimized variables is gathered consistently in comparison  to typical <code>JuMP</code> models. With <code>InfiniteModel</code>s this is done by querying the  transformation backend and using its stored variable mappings to return the correct  information. Thus, here the queries are extended to work with the specifics of  the transformation backend to return the appropriate info.</p><div class="admonition is-info" id="Note-9211ab51a8e5f9b1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9211ab51a8e5f9b1" title="Permalink"></a></header><div class="admonition-body"><p>Like <code>supports</code> the all variable based query methods below also employ the  <code>label::Type{AbstractSupportLabel} = PublicLabel</code> keyword argument that by  default will return the desired information associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via <code>label = All</code>.</p></div></div><p>First, we should verify that the transformed variable in fact has variable values  via <a href="../../manual/result/#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a>. In our example, we have:</p><pre><code class="language-julia-repl hljs">julia&gt; has_values(model)
true</code></pre><p>So we have values readily available to be extracted.</p><p>Now <a href="../../manual/result/#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a> can be used to query the  values as shown above in the Basic Usage section. This works by calling the  appropriate <a href="../../manual/result/#InfiniteOpt.map_value-Tuple{Any, AbstractTransformationBackend}"><code>map_value</code></a> defined by the transformation backend. By default, this employs the <code>map_value</code> fallback which uses  <code>transformation_variable</code> to do the mapping. Details on how to extend these  methods for user-defined transformation backends is explained on the Extensions page.</p><p>We also, support call to <code>value</code> that use an expression of variables as input.</p><p>Finally, the optimizer index of a variable is queried via  <a href="../../manual/result/#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>optimizer_index</code></a> which  reports back the index of the variable as used in the <code>MathOptInterface</code>  backend:</p><pre><code class="language-julia-repl hljs">julia&gt; optimizer_index(z)
MathOptInterface.VariableIndex(1)

julia&gt; optimizer_index(y)
10-element Vector{MathOptInterface.VariableIndex}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)
 MathOptInterface.VariableIndex(6)
 MathOptInterface.VariableIndex(7)
 MathOptInterface.VariableIndex(8)
 MathOptInterface.VariableIndex(9)
 MathOptInterface.VariableIndex(10)
 MathOptInterface.VariableIndex(11)</code></pre><p>As noted previously, an array is returned for <code>y(t)</code> in accordance with its  transcription variables. In similar manner to <code>value</code>, this is enabled by  appropriate versions of <a href="../../manual/result/#InfiniteOpt.map_optimizer_index-Tuple{GeneralVariableRef, AbstractTransformationBackend}"><code>map_optimizer_index</code></a>.</p><h2 id="Constraint-Queries"><a class="docs-heading-anchor" href="#Constraint-Queries">Constraint Queries</a><a id="Constraint-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Queries" title="Permalink"></a></h2><p>Like variables, a variety of information can be queried about constraints.</p><div class="admonition is-info" id="Note-28bd20e107326006"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-28bd20e107326006" title="Permalink"></a></header><div class="admonition-body"><p>Like <code>supports</code>, all the constraint query methods below also employ the  <code>label::Type{AbstractSupportLabel} = PublicLabel</code> keyword argument that by  default will return the desired information associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via <code>label = All</code>.</p></div></div><p>First, recall that constraints are stored in the form <code>function-in-set</code> where  generally <code>function</code> contains the variables and coefficients and the set contains  the relational operator and the constant value. With this understanding, we  query the value of a constraint&#39;s <code>function</code> via  <a href="../../manual/result/#JuMP.value-Tuple{InfOptConstraintRef}"><code>value</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; constraint_object(c1).func # show the function expression of c1
z - y(t)

julia&gt; value(c1)
10-element Vector{Float64}:
 -8.747427671096375e-9
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077</code></pre><p>Again, we obtain an array of values since <code>c1</code> is infinite due to its dependence  on <code>x(t)</code>. Behind the scenes this is implemented via the appropriate extensions  of <a href="../../manual/result/#InfiniteOpt.map_value-Tuple{Any, AbstractTransformationBackend}"><code>map_value</code></a>.</p><p>Next the optimizer index(es) of the transcribed constraints in the  <code>MathOptInterface</code> backend provided via  <a href="../../manual/result/#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>optimizer_index</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; optimizer_index(c1)
10-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(5)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(6)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(7)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(8)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(9)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(10)</code></pre><p>Here 10 indices are given in accordance with the transcription constraints.  The mapping between these and the original infinite constraints is managed via  the appropriate extensions of <a href="../../manual/result/#InfiniteOpt.map_optimizer_index-Tuple{GeneralVariableRef, AbstractTransformationBackend}"><code>map_optimizer_index</code></a>.</p><p>We can also query dual information from our constraints if it is available.  First, we should verify that dual information is available via  <a href="../../manual/result/#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; has_duals(model)
true</code></pre><p>Now we can query the duals via <a href="../../manual/result/#JuMP.dual-Tuple{InfOptConstraintRef}"><code>dual</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; dual(c1)
10-element Vector{Float64}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p>Here we obtain the optimal dual values for each transcribed version of <code>c1</code>. This  is enabled via the proper extensions of <a href="../../manual/result/#InfiniteOpt.map_dual-Tuple{InfOptConstraintRef, AbstractTransformationBackend}"><code>map_dual</code></a>.</p><p>Finally, we query the shadow price of a constraint via  <a href="../../manual/result/#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>shadow_price</code></a>. This denotes  the change in the objective value due to an infinitesimal relaxation of the  constraint. For <code>c1</code> we get:</p><pre><code class="language-julia-repl hljs">julia&gt; shadow_price(c1)
10-element Vector{Float64}:
 -1.9999999988666093
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10</code></pre><p>This is computed via interrogating the duals and the objective sense.</p><h2 id="LP-Sensitivity"><a class="docs-heading-anchor" href="#LP-Sensitivity">LP Sensitivity</a><a id="LP-Sensitivity-1"></a><a class="docs-heading-anchor-permalink" href="#LP-Sensitivity" title="Permalink"></a></h2><p>We also conduct sensitivity analysis for linear problems using  <a href="../../manual/result/#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}"><code>lp_sensitivity_report</code></a>. This  will generate a <a href="../../manual/result/#InfiniteOpt.InfOptSensitivityReport"><code>InfOptSensitivityReport</code></a> which contains mapping to the  ranges indicating how much a constraint RHS constant or an objective  coefficient can be changed without violating the feasibility of the solution.  This is further explained in the <code>JuMP</code> documentation  <a href="https://jump.dev/JuMP.jl/v1/manual/solutions/#Sensitivity-analysis-for-LP">here</a>.  Furthermore, this analysis can only be employed for a solver that implements  <code>MOI.ConstraintBasisStatus</code>. In our running example up above, <code>Ipopt.jl</code> does not  support this A solver like <code>Gurobi.jl</code> does.</p><pre><code class="language-julia-repl hljs">julia&gt; report = lp_sensitivity_report(model);

julia&gt; report[c1]
10-element Vector{Tuple{Float64, Float64}}:
 (-42.0, Inf)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)

julia&gt; report[z]
(-2.0, Inf)</code></pre><p>Note that like other query methods, an array of ranges will be provided with testing the sensitivity of an infinite constraint RHS in accordance with the discretization scheme. Also, keyword arguments (like <code>label</code>) can  be invoked when indexing the report:</p><pre><code class="language-julia-repl hljs">julia&gt; report[c1, label = All]
10-element Vector{Tuple{Float64, Float64}}:
 (-42.0, Inf)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)</code></pre><h2 id="Direct-Queries"><a class="docs-heading-anchor" href="#Direct-Queries">Direct Queries</a><a id="Direct-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Queries" title="Permalink"></a></h2><p>We can directly interrogate the transformation backend to get more  information. For instance, with <code>TranscriptionBackend</code>s we can get  the underlying <code>JuMP.Model</code> via <a href="../../manual/backend/#InfiniteOpt.transformation_model-Tuple{InfiniteModel}"><code>transformation_model</code></a> and  then call whatever <code>JuMP</code> query we want:</p><pre><code class="language-julia-repl hljs">julia&gt; solution_summary(transformation_model(model))
* Solver : Ipopt

* Status
  Termination status : LOCALLY_SOLVED
  Primal status      : FEASIBLE_POINT
  Dual status        : FEASIBLE_POINT
  Message from the solver:
  &quot;Solve_Succeeded&quot;

* Candidate solution
  Objective value      : 83.99999998250514

* Work counters
  Solve time (sec)   : 0.01000</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimize/">« Optimization</a><a class="docs-footer-nextpage" href="../extensions/">Extensions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 5 November 2025 05:54">Wednesday 5 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
