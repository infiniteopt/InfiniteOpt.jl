<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Infinite Parameters · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start Guide</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li class="is-active"><a class="tocitem" href>Infinite Parameters</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Parameter-Definition"><span>Parameter Definition</span></a></li><li><a class="tocitem" href="#Supports"><span>Supports</span></a></li><li><a class="tocitem" href="#Parameter-Queries"><span>Parameter Queries</span></a></li><li><a class="tocitem" href="#Parameter-Modification"><span>Parameter Modification</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods/Macros"><span>Methods/Macros</span></a></li></ul></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Infinite Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Infinite Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/parameter.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="inf_par_page"><a class="docs-heading-anchor" href="#inf_par_page">Infinite Parameters</a><a id="inf_par_page-1"></a><a class="docs-heading-anchor-permalink" href="#inf_par_page" title="Permalink"></a></h1><p>A guide and manual to the definition and use of infinite parameters in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Infinite parameters are what parameterize the infinite decision spaces for infinite dimensional mathematical programs. In dynamic optimization this corresponds to time and in stochastic optimization this to uncertain parameters that follow a certain underlying statistical distribution. <code>InfiniteOpt</code> considers principally two kinds of infinite parameters, ones defined over continuous intervals and ones characterized by a distribution (others can be added by defining a user-defined type). These can be used to parameterize infinite variables, point variables, derivatives, measures, and can be used  directly inside constraints.</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>First, we need to initialize and add infinite parameters to our <code>InfiniteModel</code>. This can be accomplished using <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. For example, let&#39;s define a parameter for time in a time interval from 0 to 10:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10])
t</code></pre><p>Now <code>t</code> is a Julia variable that stores a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> which points to where the time parameter is stored in <code>model</code>. It can now be used with infinite variables, derivatives, measures, and constraints as described in their  respective user guide sections.</p><p>When the model is optimized, <code>t</code> will be transcripted (discretized) over its domain following its support points. If none are specified by the user than the default  amount support points are generated according to the default support generation  scheme. In this case, equidistant supports over the interval would be added. Note that this default addition will not occur until <code>optimize!</code> is called. However, users may wish to employ their own support scheme. This can be done by using the <code>num_supports</code> or <code>supports</code> keyword arguments. For example, if we desire to have only 10 equi-distant supports then we could have instead defined <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10)
t</code></pre><p>More complex support schemes can be specified via <code>supports</code> such as:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0; 2; 7; 10])
t</code></pre><p>Where we specified <code>t</code> to use 4 supports: 0, 2, 7, and 10.</p><p>We can also add supports after <code>t</code> has been initialized. This can be accomplished with <a href="../expression/#InfiniteOpt.add_supports-Tuple{GeneralVariableRef,Union{Real, Array{#s37,1} where #s37&lt;:Real}}"><code>add_supports</code></a>. For example, consider the initial case where <code>t</code> has no supports and we now wish to add 4 supports:</p><pre><code class="language-julia-repl">julia&gt; add_supports(t, [0., 2.5, 7.5, 10.])

julia&gt; supports(t)
4-element Array{Float64,1}:
  0.0
  2.5
  7.5
 10.0</code></pre><p>Here only 4 supports are specified for the sake of example. Alternatively, we could have initialized the parameter and added supports in just one step using the <code>supports</code> keyword argument:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0., 2.5, 7.5, 10.])
t</code></pre><p>We could also define a random parameter described by a statistical distribution. This can be accomplished using <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> in combination with a distribution from <a href="https://github.com/JuliaStats/Distributions.jl"><code>Distributions.jl</code></a>. For example let&#39;s define a vector of independent random parameters described by a Normal distribution:</p><pre><code class="language-julia-repl">julia&gt; using Distributions

julia&gt; @infinite_parameter(model, ξ[i = 1:3] in Normal(), independent = true)
3-element Array{GeneralVariableRef,1}:
 ξ[1]
 ξ[2]
 ξ[3]</code></pre><p>Note that we could have used <code>i</code> as an index to assign a different distribution to each parameter. Supports can also be specified for each parameter as shown above. Similarly, the <code>num_supports</code> keyword is used to generate random supports.</p><p>More interestingly, we can also define multi-variate random parameters, for example:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, θ[1:2] in MvNormal([0, 0], [1, 1]))
2-element Array{GeneralVariableRef,1}:
 θ[1]
 θ[2]</code></pre><p>Now we have infinite parameters <code>t</code> and <code>ξ</code> that are ready to be used in defining infinite variables and constraints. We also mention here that the <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> macro is designed to closely emulate <a href="../../JuMP/#JuMP.@variable"><code>JuMP.@variable</code></a> and thus handles arrays and keyword arguments in the same way. This is described in more detail below.</p><h2 id="Parameter-Definition"><a class="docs-heading-anchor" href="#Parameter-Definition">Parameter Definition</a><a id="Parameter-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Definition" title="Permalink"></a></h2><p>Defining/initializing an infinite parameter principally involves the following steps:</p><ol><li>Define an <a href="../sets/#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a></li><li>Define support points within the set to later discretize the parameter</li><li>Construct an <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> to store this information</li><li>Add the <code>InfOptParameter</code> object to an <code>InfiniteModel</code> and assign a name</li><li>Create a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> that points to the parameter object</li></ol><h3 id="Manual-Definition"><a class="docs-heading-anchor" href="#Manual-Definition">Manual Definition</a><a id="Manual-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Definition" title="Permalink"></a></h3><p>Infinite set definition is described above in the <a href="../sets/#infinite_sets_normal">Infinite Sets</a> section. The supports should be a vector of finite numbers that are drawn from the domain of the infinite set. These supports will be used to transcribe the <code>InfiniteModel</code> in preparation for it to be optimized. If desired, the supports can be specified after the parameter is defined and the support container of the defined parameter will be temporarily empty.</p><p><a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> is an abstract data type that encompasses all concrete infinite parameter types. The concrete type for individual infinite parameters is <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a>, since these parameters are independent from other parameters. On the other hand, <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> handle multivariate infinite parameters, within which each individual parameter is not independent. These are useful for characterizing, for example, parameters subject to multivariate distribution.</p><p>Regardless of the specific concrete type, the <a href="#InfiniteOpt.build_parameter-Tuple{Function,InfiniteScalarSet}"><code>build_parameter</code></a> function is used to construct an <code>InfOptParameter</code>. For example, let&#39;s create a time parameter <span>$t \in [0, 10]$</span> with supports <code>[0, 2, 5, 7, 10]</code>:</p><pre><code class="language-julia-repl">julia&gt; set = IntervalSet(0, 10)
[0, 10]

julia&gt; t_param = build_parameter(error, set, supports = [0, 2, 5, 7, 10])
IndependentParameter{IntervalSet,FiniteDifference}([0, 10], DataStructures.SortedDict(0.0=&gt;Set([UserDefined]),2.0=&gt;Set([UserDefined]),5.0=&gt;Set([UserDefined]),7.0=&gt;Set([UserDefined]),10.0=&gt;Set([UserDefined])), 12, FiniteDifference(Backward, true))</code></pre><p>Now that we have a <code>InfOptParameter</code> that contains an <code>IntervalSet</code> and supports, let&#39;s now add <code>t_param</code> to our <code>InfiniteModel</code> using <a href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,IndependentParameter,String}"><code>add_parameter</code></a> and assign it the name of <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; t_ref = add_parameter(model, t_param, &quot;t&quot;)
t</code></pre><p>We can also create an anonymous infinite parameter by dropping the name from the <code>add_parameter</code> function call. For example:</p><pre><code class="language-julia-repl">julia&gt; t_ref_noname = add_parameter(model, t_param)
noname</code></pre><p>Now suppose we want to create an infinite parameter that is a random variable with a given distribution. We follow the same procedure as above, except we use distributions from <code>Distributions.jl</code> to define a <a href="../sets/#InfiniteOpt.UniDistributionSet"><code>UniDistributionSet</code></a>. For example, let&#39;s consider a random variable <span>$x \in \mathcal{N}(0,1)$</span> with supports <code>[-0.5, 0.5]</code>:</p><pre><code class="language-julia-repl">julia&gt; dist = Normal(0., 1.)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; set = UniDistributionSet(dist)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; x_param = build_parameter(error, set, supports = [-0.5, 0.5])
IndependentParameter{UniDistributionSet{Normal{Float64}},FiniteDifference}(Normal{Float64}(μ=0.0, σ=1.0), DataStructures.SortedDict(-0.5=&gt;Set([UserDefined]),0.5=&gt;Set([UserDefined])), 12, FiniteDifference(Backward, true))</code></pre><p>Again, we use <a href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,IndependentParameter,String}"><code>add_parameter</code></a> to add <code>x_param</code> to the <code>InfiniteModel</code> and assign it the name <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; x_ref = add_parameter(model, x_param, &quot;x&quot;)
x</code></pre><p>Note that <code>add_parameter</code> does not register the name of the parameters into the model that it adds to. As shown in <a href="#param_macro">Macro Definition</a>, the macro definition does not allow for multiple parameters sharing the same name and will throw an error if it happens.</p><p>For dependent parameters, we do not provide a publicly available <code>build_parameter</code>  method due to inherent complexities. Thus, it is recommended to construct these  using <a href="#InfiniteOpt.@dependent_parameters"><code>@dependent_parameters</code></a> or <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. However,  these can be constructed manually via the basic constructor for  <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> and then invoking <a href="#InfiniteOpt.add_parameters"><code>add_parameters</code></a>. Note that  this should be done with caution since most error checking will be omitted in this  case.</p><h3 id="param_macro"><a class="docs-heading-anchor" href="#param_macro">Macro Definition</a><a id="param_macro-1"></a><a class="docs-heading-anchor-permalink" href="#param_macro" title="Permalink"></a></h3><h4 id="One-Dimensional-Parameters"><a class="docs-heading-anchor" href="#One-Dimensional-Parameters">One-Dimensional Parameters</a><a id="One-Dimensional-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#One-Dimensional-Parameters" title="Permalink"></a></h4><p>One user-friendly way of defining infinite parameters is by macro <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. The macro executes the same process as the manual definition (steps listed in <a href="#Parameter-Definition">Parameter Definition</a>), but allows the users to manipulate several features of the defined infinite parameters. Again, let&#39;s consider a time parameter <span>$t \in [0, 10]$</span> with supports <code>[0, 2, 5, 7, 10]</code>. Similar to <a href="../../JuMP/#JuMP.@variable"><code>JuMP.@variable</code></a>, we can use comparison operators to set lower bounds and upper bounds for the infinite parameter:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, 0 &lt;= t &lt;= 10, supports = [0, 2, 5, 7, 10])
t</code></pre><p>More generally, we use <code>in</code> (or <code>∈</code>) to define the set that an infinite parameter is subject to. The set could be an interval set, or a distribution set. For example, we can define the same parameter <code>t</code> as above in the following way:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0, 2, 5, 7, 10])
t</code></pre><p>In a similar way, we can define a random infinite parameter subject to some distribution. For example, a Gaussian infinite parameter with mean 0 and standard deviation 1 can be defined by</p><pre><code class="language-julia-repl">julia&gt; dist = Normal(0., 1.)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; @infinite_parameter(model, x in dist, supports = [-0.5, 0.5])
x</code></pre><p>Additional ways of defining infinite parameters are provided using keyword arguments. For example, we can use <code>lower_bound</code> and <code>upper_bound</code> to define an infinite parameter in an interval set:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t, lower_bound = 0, upper_bound = 10, supports = [0, 2, 5, 7, 10])
t</code></pre><p>A bit more generally, we can also use <code>set</code> to directly input the <code>AbstractInfiniteSet</code> that the parameter is in. For example:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t, set = IntervalSet(0, 10), supports = [0, 2, 5, 7, 10])
t</code></pre><p>The parameter definition methods using keyword arguments will be useful later when we introduce how to define anonymous parameters. See the part for anonymous parameter definition for more details.</p><p>All the definitions above return a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> that refer to the defined parameter. Note that we can also ignore the <code>supports</code> keyword argument and the macro will define an empty array of supports for that parameter.</p><h4 id="Multi-Dimensional-Parameter"><a class="docs-heading-anchor" href="#Multi-Dimensional-Parameter">Multi-Dimensional Parameter</a><a id="Multi-Dimensional-Parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Dimensional-Parameter" title="Permalink"></a></h4><p>Using macro definition, we can also define multi-dimensional infinite parameters in a concise way. For example, consider a position parameter <code>x</code> in a 3-dimensional space constrained in a unit cube (i.e. in the interval <code>[0, 1]</code>   for all dimensions). This parameter can be defined in one line as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], independent = true, supports = [0.3, 0.7])
3-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]
 x[3]</code></pre><p>For multi-dimensional parameters, the macro calls for an internal function that works similar to <a href="#InfiniteOpt.build_parameter-Tuple{Function,InfiniteScalarSet}"><code>build_parameter</code></a> for univariate infinite parameter and then <a href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,IndependentParameter,String}"><code>add_parameter</code></a> to add the multi-dimensional parameters. If an array of supports is provided, the macro will assign that array of supports to all dimensions. Otherwise, the indexed syntax can be used to feed in different array of supports to each dimension, similar to <a href="../../JuMP/#JuMP.@variable"><code>JuMP.@variable</code></a>. For example:</p><pre><code class="language-julia-repl">julia&gt; points = [0.2 0.8; 0.3 0.7]
2×2 Array{Float64,2}:
 0.2  0.8
 0.3  0.7

julia&gt; @infinite_parameter(model, a[i = 1:2] in [0, 1], supports = points[i, :])
2-element Array{GeneralVariableRef,1}:
 a[1]
 a[2]

julia&gt; supports(a[1])
2-element Array{Float64,1}:
 0.2
 0.8

julia&gt; supports(a[2])
2-element Array{Float64,1}:
 0.3
 0.7</code></pre><p>In a similar way we can define an infinite parameter subject to a multivariate distribution. For example, a 2-dimensional parameter <code>ξ</code> subject to a 2D normal distribution can be created as follows:</p><pre><code class="language-julia-repl">julia&gt; dist = MvNormal([0., 0.], [1. 0.; 0. 2.])
FullNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 2.0]
)

julia&gt; @infinite_parameter(model, ξ[1:2] in dist)
2-element Array{GeneralVariableRef,1}:
 ξ[1]
 ξ[2]</code></pre><h4 id="Containers-for-Multi-Dimensional-Parameters"><a class="docs-heading-anchor" href="#Containers-for-Multi-Dimensional-Parameters">Containers for Multi-Dimensional Parameters</a><a id="Containers-for-Multi-Dimensional-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Containers-for-Multi-Dimensional-Parameters" title="Permalink"></a></h4><p>Note that for all the cases of multi-dimensional parameter definition above, the macro always returns an <code>Array</code> of <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>. For most cases this is true. However, we can explicitly dictate the kind of containers we want to hold the defined parameters using the keyword <code>container</code>. For example, we use <code>SparseAxisArray</code> from the <code>JuMP</code> package for the space parameter <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], container = SparseAxisArray)
JuMP.Containers.SparseAxisArray{GeneralVariableRef,1,Tuple{Int64}} with 3 entries:
  [3]  =  x[3]
  [2]  =  x[2]
  [1]  =  x[1]</code></pre><p>More information on <code>JuMP</code> containers is located  <a href="https://jump.dev/JuMP.jl/stable/variables/#Variable-containers-1">here</a>.</p><h4 id="Specifying-independence-of-infinite-parameters"><a class="docs-heading-anchor" href="#Specifying-independence-of-infinite-parameters">Specifying independence of infinite parameters</a><a id="Specifying-independence-of-infinite-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-independence-of-infinite-parameters" title="Permalink"></a></h4><p>The concrete data object that stores information of infinite parameters are <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a> and <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a>, both under the abstract data type <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a>. <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a> stores scalar infinite parameters that are independent from other infinite parameters. <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> stores multiple infinite parameters that are dependent on each other, e.g. multi-dimensional random parameters. Each <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a> or <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> stores the <a href="../sets/#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a> that the parameters are in and supports that discretize the parameters.</p><p>For examples up to now we did not specify the value for the keyword <code>independent</code>, which is set as <code>false</code> by default. In the case of scalar infinite parameter, <code>independent</code> is ignored and an <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a> is always created. The keyword <code>independent</code> applies to multi-dimensional infinite parameters and dictates whether the supports for different dimensions are independent. Setting <code>independent</code> as <code>true</code> would be useful if the users want to generate a grid of supports for a multi-dimensional parameter. In this case the macro call creates an array of <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a>. Otherwise, the macro call creates <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a>. For example, consider the position parameter <code>x</code> in a 3D space. Say <code>x</code> is bounded in <code>[0, 1]</code> in all three dimensions, and the user wants to generate grid points with interval <code>0.5</code> in all three dimensions. In this case, we can define <code>x</code> in the following way:</p><pre><code class="language-julia-repl">julia&gt; pts = collect(range(0, stop = 1, length = 3))
3-element Array{Float64,1}:
 0.0
 0.5
 1.0

julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], supports = pts, independent = true)
3-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]
 x[3]

julia&gt; typeof(dispatch_variable_ref(x[1]))
IndependentParameterRef</code></pre><p>If <code>independent</code> is set as <code>false</code>, the transcription step will generate JuMP variables for values of any variable parameterized by <code>x</code> at <code>[0.0, 0.0, 0.0]</code>, <code>[0.5, 0.5, 0.5]</code> and <code>[1.0, 1.0, 1.0]</code>, a total of 3 transcribed variables. Instead, if <code>independent</code> is set as <code>true</code>, the transcription step will obtain a unique permutation of these supports and each transcribe parameterized variable accordingly, leading to a total of 27 transcribed variables in this case.</p><h4 id="Anonymous-Parameter-Definition-and-base_name"><a class="docs-heading-anchor" href="#Anonymous-Parameter-Definition-and-base_name">Anonymous Parameter Definition and <code>base_name</code></a><a id="Anonymous-Parameter-Definition-and-base_name-1"></a><a class="docs-heading-anchor-permalink" href="#Anonymous-Parameter-Definition-and-base_name" title="Permalink"></a></h4><p>As mentioned above, we can define anonymous parameters using keyword arguments in the macro <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. For instance, we can create an anonymous position parameter in a 3D space, referred to by a list of <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> called <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; x = @infinite_parameter(model, [1:3], lower_bound = 0, upper_bound = 1)
3-element Array{GeneralVariableRef,1}:
 noname
 noname
 noname

julia&gt; typeof(x)
Array{GeneralVariableRef,1}

julia&gt; name(x[1])
&quot;&quot;</code></pre><p>This syntax creates a 1D parameter if the part <code>[1:3]</code> is neglected.</p><p>Note that this macro definition automatically assigns an empty string to the <code>base_name</code>. We can also assign a nontrivial base name to an anonymous parameter using the keyword argument <code>base_name</code>. For example,</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, [1:3], lower_bound = 0, upper_bound = 1, base_name = &quot;x&quot;)
3-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]
 x[3]

julia&gt; @infinite_parameter(model, [1:3], lower_bound = -1, upper_bound = 0, base_name = &quot;x&quot;)
3-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]
 x[3]</code></pre><p>We can see that anonymous parameter definition allows for multiple parameters sharing the same base name. This is not permitted with non-anonymous parameter definition. In fact, in anonymous parameter definition, the macro does not register the name of the parameters in the model, so when the model checks for repeated names it will not detect the <code>x</code>. Refer to <a href="#Detailed-Mechanism-of-Macro-Definition">Detailed Mechanism of Macro Definition</a> if more details are desired.</p><h4 id="Detailed-Mechanism-of-Macro-Definition"><a class="docs-heading-anchor" href="#Detailed-Mechanism-of-Macro-Definition">Detailed Mechanism of Macro Definition</a><a id="Detailed-Mechanism-of-Macro-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-Mechanism-of-Macro-Definition" title="Permalink"></a></h4><p>This section is for people who wish to know more about how the macro <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> works in the backend. Users who only want to learn about the setting up the model can skip over this part.</p><p>In general, the macro <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> follows the same steps as the manual definition. First, it parses the arguments and identifies any recognizable keyword arguments. Specifically, the first argument must be the model, and the second argument, if exists, must be an expression that declares the parameter or simply specify the dimension of the parameter if users choose to define it anonymously. If the information in the keyword arguments is not sufficient to define the set the parameter is in, the users also need to specify the sets in the second argument using expressions like <code>a &lt;= x &lt;= b</code> or <code>x in set</code>.</p><p>The keyword arguments give users flexibility in how to define their parameters. As mentioned above, the users can choose to specify the set either in the second argument (nonanonymous parameter definition only), or in the keyword arguments. However, the users cannot do both at the same time. The macro will check this behavior and throw an error if this happens. For example,</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model,  y in [0, 1], lower_bound = 0, upper_bound = 1)
ERROR: LoadError: At none:1: `@infinite_parameter(model, y in [0, 1], lower_bound = 0, upper_bound = 1)`: Cannot specify parameter lower_bound twice
[...]

julia&gt; @infinite_parameter(model,  y in [0, 1], set = IntervalSet(0, 1))
ERROR: LoadError: At none:1: `@infinite_parameter(model, y in [0, 1], set = IntervalSet(0, 1))`: Cannot specify parameter lower_bound and set
[...]</code></pre><p>Once the check on arguments and keyword arguments is done, the macro will create the <a href="../sets/#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a> based on given information, and create the infinite parameter accordingly. If the users create a multi-dimensional parameter, the macro will create looped code to define individual infinite parameter for each dimension. The looped code will also incorporate different supports for different dimensions.</p><p>In the end, if the created parameter is not anonymous, the macro will register the name to the model. In this way, we prevent parameters created by <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> non-anonymously to share the same name.</p><h2 id="Supports"><a class="docs-heading-anchor" href="#Supports">Supports</a><a id="Supports-1"></a><a class="docs-heading-anchor-permalink" href="#Supports" title="Permalink"></a></h2><p>For an infinite parameter, its supports are a finite set of points that the parameter will take (or possibly take, if the parameter is random). During the transcription stage, the supports specified will become part of the grid points that approximate all functions parameterized by the infinite parameter.</p><p>Once an infinite parameter is defined, users can access the supports using <a href="../expression/#InfiniteOpt.supports-Tuple{GeneralVariableRef}"><code>supports</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, 0 &lt;= t &lt;= 10, supports = [0, 2, 5, 7, 10])
t

julia&gt; supports(t)
5-element Array{Float64,1}:
  0.0
  2.0
  5.0
  7.0
 10.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Most support query functions have a keyword argument <code>label</code> that is used  the specify the type of supports that will be involved in the query. By default,  this will be <code>PublicLabel</code> which will correspond to any supports that are  reported to the user by default, but will exclude any supports that have  <code>InternalLabel</code>s (e.g., internal collocation nodes). The full set can always  be obtained via <code>label = All</code>. We can also query more specific subsets of  support information with more specific labels such as <code>label = UniformGrid</code>.</p></div></div><p>We also provide functions that access other related information about the supports. For example, <a href="../expression/#InfiniteOpt.has_supports-Tuple{GeneralVariableRef}"><code>has_supports</code></a> checks whether a parameter has supports, while <a href="../expression/#InfiniteOpt.num_supports-Tuple{GeneralVariableRef}"><code>num_supports</code></a> gives the number of supports associated with a parameter:</p><pre><code class="language-julia-repl">julia&gt; has_supports(t)
true

julia&gt; num_supports(t)
5</code></pre><p>Now suppose we want to add more supports to the <code>t</code>, which is already assigned with some supports. We can use <a href="../expression/#InfiniteOpt.add_supports-Tuple{GeneralVariableRef,Union{Real, Array{#s37,1} where #s37&lt;:Real}}"><code>add_supports</code></a> function to achieve this goal:</p><pre><code class="language-julia-repl">julia&gt; add_supports(t, [3, 8])

julia&gt; supports(t)
7-element Array{Float64,1}:
  0.0
  2.0
  3.0
  5.0
  7.0
  8.0
 10.0</code></pre><p>At times we might want to change the supports completely. In those cases, the function <a href="../expression/#InfiniteOpt.set_supports-Tuple{GeneralVariableRef,Union{Real, Array{#s37,1} where #s37&lt;:Real}}"><code>set_supports</code></a> resets the supports for a certain parameter with new supports provided:</p><pre><code class="language-julia-repl">julia&gt; set_supports(t, [0,3,5,8,10], force = true)

julia&gt; supports(t)
5-element Array{Float64,1}:
  0.0
  3.0
  5.0
  8.0
 10.0</code></pre><p>Note that the keyword argument [<code>force</code>] must be set as [<code>true</code>] if the parameter has been assigned with supports. Users can also delete all the supports of a parameter with <a href="../expression/#InfiniteOpt.delete_supports-Tuple{GeneralVariableRef}"><code>delete_supports</code></a>.</p><h3 id="Automatic-Support-Generation-During-Parameter-Definition"><a class="docs-heading-anchor" href="#Automatic-Support-Generation-During-Parameter-Definition">Automatic Support Generation During Parameter Definition</a><a id="Automatic-Support-Generation-During-Parameter-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Support-Generation-During-Parameter-Definition" title="Permalink"></a></h3><p>For the examples in the <a href="#Parameter-Definition">Parameter Definition</a>, we have seen how to manually add supports to an infinite parameter. For a quick automatic generation of support points, though, users do not have to input the support points. Instead, the number of support points generated is supplied.</p><p>For an infinite parameter subject to an <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>, uniformly spaced supports including both ends are generated across the interval. For example, defining a time parameter <span>$t \in [0, 10]$</span> with 4 supports using <a href="#InfiniteOpt.build_parameter-Tuple{Function,InfiniteScalarSet}"><code>build_parameter</code></a> gives</p><pre><code class="language-julia-repl">julia&gt; set = IntervalSet(0, 10)
[0, 10]

julia&gt; t_param = build_parameter(error, set, num_supports = 4, sig_digits = 3)
IndependentParameter{IntervalSet,FiniteDifference}([0, 10], DataStructures.SortedDict(0.0=&gt;Set([UniformGrid]),3.33=&gt;Set([UniformGrid]),6.67=&gt;Set([UniformGrid]),10.0=&gt;Set([UniformGrid])), 3, FiniteDifference(Backward, true))</code></pre><p>Using macro definition we have</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, 0 &lt;= t &lt;= 10, num_supports = 4, sig_digits = 3)
t

julia&gt; supports(t)
4-element Array{Float64,1}:
  0.0   
  3.33
  6.67
 10.0   
</code></pre><p>Note that the user can use the keyword argument <code>sig_digits</code> to dictate the significant figures for the supports. The default value of <code>sig_digits</code> is 12.</p><p>For an infinite parameter that follows a univariate distribution, supports are sampled from the underlying distribution. For example, we can define an infinite parameter subject to a normal distribution with mean 0 and variance 1:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in dist, num_supports = 4)
x

julia&gt; supports(x)
4-element Array{Float64,1}:
 -0.353007400301
 -0.134853871931
  0.679107426036
  0.8284134829  </code></pre><p>For multivariate distributions, though, we require support points are provided in the definition. However, we can use <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> to generate supports for parameters following multivariate distributions. See <a href="#Automatic-Support-Generation-For-Defined-Parameters">Automatic Support Generation For Defined Parameters</a> for details.</p><h3 id="Automatic-Support-Generation-For-Defined-Parameters"><a class="docs-heading-anchor" href="#Automatic-Support-Generation-For-Defined-Parameters">Automatic Support Generation For Defined Parameters</a><a id="Automatic-Support-Generation-For-Defined-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Support-Generation-For-Defined-Parameters" title="Permalink"></a></h3><p>So far, we have seen that in both definition methods it is allowed to initialize a parameter with no supports. This is done by not specifying <code>supports</code> and <code>num_supports</code>. However, infinite parameters would not be allowed at the transcription step since it needs information about how to discretize the infinite parameters. In previous examples, we have shown that users can add supports to a defined parameter using methods <a href="../expression/#InfiniteOpt.add_supports-Tuple{GeneralVariableRef,Union{Real, Array{#s37,1} where #s37&lt;:Real}}"><code>add_supports</code></a> and <a href="../expression/#InfiniteOpt.set_supports-Tuple{GeneralVariableRef,Union{Real, Array{#s37,1} where #s37&lt;:Real}}"><code>set_supports</code></a>.</p><p>In this section we introduce automatic support generation for defined parameters with no associated supports. This can be done using the <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> functions. <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> can take as argument a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> or an <code>AbstractArray{&lt;:GeneralVariableRef}</code>, in which case it will generate supports for the associated infinite parameter. Alternatively, <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> can also take an <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> as an argument, in which case it will generate supports for all infinite parameters of the <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> with no supports.</p><p>The <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> method allows users to specify integer keyword arguments <code>num_supports</code> and <code>sig_digits</code>. <code>num_supports</code> dictates the number of supports to be generated, and <code>sig_digits</code> dictates the significant figures of generated supports desired. The default values are 10 and 12, respectively.</p><p>The ways by which supports are automatically generated are as follows. If the parameter is in an <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>, then we generate an array of supports that are uniformly distributed along the interval, including the two ends. For example, consider a 3D position parameter <code>x</code> distributed in the unit cube <code>[0, 1]</code>. We can generate supports for that point in the following way:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], independent = true);

julia&gt; fill_in_supports!.(x, num_supports = 3);

julia&gt; supports.(x)
3-element Array{Array{Float64,1},1}:
 [0.0, 0.5, 1.0]
 [0.0, 0.5, 1.0]
 [0.0, 0.5, 1.0]</code></pre><p>Note that the dot syntax because <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> takes single <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> as argument. In each dimension, three equally spaced supports (<code>[0.0, 0.5, 1.0]</code>) are generated. Since the <code>independent</code> keyword is set as <code>true</code>, the transcription stage will create a three-dimensional grid for all variables parameterized by <code>x</code>, with each point separated by 0.5 units in each dimension. We can view this grid by simply invoking <code>supports</code> without the  vectorized syntax:</p><pre><code class="language-julia-repl">julia&gt; supports(x)
3×27 Array{Float64,2}:
 0.0  0.5  1.0  0.0  0.5  1.0  0.0  0.5  …  1.0  0.0  0.5  1.0  0.0  0.5  1.0
 0.0  0.0  0.0  0.5  0.5  0.5  1.0  1.0     0.0  0.5  0.5  0.5  1.0  1.0  1.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0</code></pre><p>If the parameter is in a <a href="../sets/#InfiniteOpt.UniDistributionSet"><code>UniDistributionSet</code></a> or <a href="../sets/#InfiniteOpt.MultiDistributionSet"><code>MultiDistributionSet</code></a>, <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> samples <code>num_supports</code> supports from the distribution. Recall that support generation is not allowed for parameters under multivariate distribution during parameter definition. However, if the parameter is defined first without supports, <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> allows for supports generation. For example, for a 2D random variable <code>ξ</code> under a multivariate Gaussian distribution, we can generate supports for it in the following way:</p><pre><code class="language-julia-repl">julia&gt; dist = MvNormal([0., 0.], [1. 0.; 0. 2.])
FullNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 2.0]
)


julia&gt; @infinite_parameter(model, ξ[1:2] in dist);

julia&gt; fill_in_supports!(ξ, num_supports = 3)

julia&gt; supports(ξ)
2×3 Array{Float64,2}:
 -0.353007  0.679107  0.586617
 -0.190712  1.17155   0.420496</code></pre><p>Note that <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> only fill in supports for parameters with no associated supports. To modify the supports of parameters already associated with some supports, refer to <a href="#Supports">Supports</a> for how to do that.</p><h2 id="Parameter-Queries"><a class="docs-heading-anchor" href="#Parameter-Queries">Parameter Queries</a><a id="Parameter-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Queries" title="Permalink"></a></h2><p>In addition to the modeling framework, this package provides many functions for users to access information about the model. This section will go over basic functions for accessing parameter information.</p><p>Once a (possibly large-scale) <code>InfiniteModel</code> is built, the users might want to check if an infinite parameter is actually used in any way. This could be checked by <a href="../expression/#InfiniteOpt.is_used-Tuple{ParameterFunctionRef}"><code>is_used</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1])
x

julia&gt; is_used(x)
false
</code></pre><p>This function checks if the parameter is used by any constraint, measure, or variable. In a similar way, functions <a href="../expression/#InfiniteOpt.used_by_constraint-Tuple{ParameterFunctionRef}"><code>used_by_constraint</code></a>, <a href="../expression/#InfiniteOpt.used_by_measure-Tuple{ParameterFunctionRef}"><code>used_by_measure</code></a> and <a href="../expression/#InfiniteOpt.used_by_infinite_variable-Tuple{GeneralVariableRef}"><code>used_by_infinite_variable</code></a> can be applied to find out any dependency of specific types on the infinite parameter.</p><p>In addition, sometimes we need to check if a certain <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> for an infinite parameter is valid with an <code>InfiniteModel</code> model, meaning that the parameter reference actually refers to some parameter associated with the model. We extend the <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> function from JuMP for that purpose. To see how to use this, for example,</p><pre><code class="language-julia-repl">julia&gt; pref1 = GeneralVariableRef(model, 1, IndependentParameterIndex);

julia&gt; pref2 = GeneralVariableRef(model, 2, IndependentParameterIndex);

julia&gt; is_valid(model, pref1)
true

julia&gt; is_valid(model, pref2)
false</code></pre><p>The second call of <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>is_valid</code></a> returns <code>false</code> because the model does not have parameter with index 2 yet.</p><p>We can also access different information about the set that the infinite parameter is in. This is given by <a href="../expression/#InfiniteOpt.infinite_set-Tuple{GeneralVariableRef}"><code>infinite_set</code></a>, which takes a [<code>GeneralVariableRef</code>] as argument. For example, we have</p><pre><code class="language-julia-repl">julia&gt; infinite_set(x)
[0, 1]</code></pre><p><a href="../expression/#InfiniteOpt.infinite_set-Tuple{GeneralVariableRef}"><code>infinite_set</code></a> might be more useful if the infinite parameter is in a <a href="../sets/#InfiniteOpt.UniDistributionSet"><code>UniDistributionSet</code></a> or <a href="../sets/#InfiniteOpt.MultiDistributionSet"><code>MultiDistributionSet</code></a>, by which users can access information about the underlying distribution. On the other hand, if we already know that the parameter is in an interval set, we can use <a href="../../JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a>, <a href="../../JuMP/#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a>, <a href="../../JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a>, <a href="../../JuMP/#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> to retrieve information about the interval set in a more specific way:</p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(x)
true

julia&gt; lower_bound(x)
0.0

julia&gt; has_upper_bound(x)
true

julia&gt; upper_bound(x)
1.0</code></pre><p>A quick way for users to obtain a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> for a parameter with a known name would be through <a href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>parameter_by_name</code></a> function. This function takes an <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> and the parameter name in string, and returns a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> for that parameter. For example,</p><pre><code class="language-julia-repl">julia&gt; pref = parameter_by_name(model, &quot;x&quot;)
x</code></pre><p>If there is no parameter associated with that name, the function would return nothing. Otherwise, if multiple parameters share the same name, the function would throw an error.</p><p>Now we introduce two additional functions that we can use to access parameter information for an  <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a>. The function <a href="#InfiniteOpt.num_parameters"><code>num_parameters</code></a> returns the number of infinite parameters associated with a model, while <a href="#InfiniteOpt.all_parameters"><code>all_parameters</code></a> returns the list of all infinite parameter references in the model. For a quick example:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, y[1:2] in [0, 5])
2-element Array{GeneralVariableRef,1}:
 y[1]
 y[2]

julia&gt; num_parameters(model)
3

julia&gt; all_parameters(model)
3-element Array{GeneralVariableRef,1}:
 x   
 y[1]
 y[2]</code></pre><h2 id="Parameter-Modification"><a class="docs-heading-anchor" href="#Parameter-Modification">Parameter Modification</a><a id="Parameter-Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Modification" title="Permalink"></a></h2><p>In this section we introduce a few shortcuts for users to modify defined infinite parameters.</p><p>First, once an infinite parameter is defined, we can change its name by calling the [<code>JuMP.set_name</code>] function, which takes the [<code>GeneralVariableRef</code>] of the parameter that needs a name change and the name string as arguments. For example, to change the parameter <code>x</code> to <code>t</code> we can do:</p><pre><code class="language-julia-repl">julia&gt; JuMP.set_name(x, &quot;t&quot;)

julia&gt; all_parameters(model)
3-element Array{GeneralVariableRef,1}:
 t   
 y[1]
 y[2]</code></pre><p>In a similar way, we can also change the infinite set that the parameter is in using the <a href="../expression/#InfiniteOpt.set_infinite_set-Tuple{GeneralVariableRef,InfiniteScalarSet}"><code>set_infinite_set</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; t = parameter_by_name(model, &quot;t&quot;)
t

julia&gt; set_infinite_set(t, IntervalSet(0, 5))

julia&gt; infinite_set(t)
[0, 5]</code></pre><p>For parameters in an <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>, we extend <a href="../../JuMP/#JuMP.set_lower_bound-Tuple{VariableRef,Number}"><code>JuMP.set_lower_bound</code></a> and <a href="../../JuMP/#JuMP.set_upper_bound-Tuple{VariableRef,Number}"><code>JuMP.set_upper_bound</code></a> functions for users to modify the lower bounds and upper bounds. For example,</p><pre><code class="language-julia-repl">julia&gt; JuMP.set_lower_bound(t, 1)

julia&gt; JuMP.set_upper_bound(t, 4)

julia&gt; infinite_set(t)
[1, 4]</code></pre><p>We do not support setting lower bounds and upper bounds for random parameters in a <a href="../sets/#InfiniteOpt.UniDistributionSet"><code>UniDistributionSet</code></a> and will throw an error if users attempt to do so. If users want to set lower bound and upper bound for a random infinite parameter, consider using <code>Distributions.Truncated</code>, which creates a truncated distribution from a univariate distribution.</p><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.DependentParameterIndex"><code>InfiniteOpt.DependentParameterIndex</code></a></li><li><a href="#InfiniteOpt.DependentParameterRef"><code>InfiniteOpt.DependentParameterRef</code></a></li><li><a href="#InfiniteOpt.DependentParameters"><code>InfiniteOpt.DependentParameters</code></a></li><li><a href="#InfiniteOpt.DependentParametersIndex"><code>InfiniteOpt.DependentParametersIndex</code></a></li><li><a href="#InfiniteOpt.IndependentParameter"><code>InfiniteOpt.IndependentParameter</code></a></li><li><a href="#InfiniteOpt.IndependentParameterIndex"><code>InfiniteOpt.IndependentParameterIndex</code></a></li><li><a href="#InfiniteOpt.IndependentParameterRef"><code>InfiniteOpt.IndependentParameterRef</code></a></li><li><a href="#InfiniteOpt.InfOptParameter"><code>InfiniteOpt.InfOptParameter</code></a></li><li><a href="#InfiniteOpt.MultiParameterData"><code>InfiniteOpt.MultiParameterData</code></a></li><li><a href="#InfiniteOpt.ScalarParameter"><code>InfiniteOpt.ScalarParameter</code></a></li><li><a href="#InfiniteOpt.ScalarParameterData"><code>InfiniteOpt.ScalarParameterData</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptParameter" href="#InfiniteOpt.InfOptParameter"><code>InfiniteOpt.InfOptParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfOptParameter &lt;: JuMP.AbstractVariable</code></pre><p>An abstract type for all parameters used in InfiniteOpt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL447-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ScalarParameter" href="#InfiniteOpt.ScalarParameter"><code>InfiniteOpt.ScalarParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarParameter &lt;: InfOptParameter</code></pre><p>An abstract type for scalar parameters used in InfiniteOpt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL454-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.IndependentParameter" href="#InfiniteOpt.IndependentParameter"><code>InfiniteOpt.IndependentParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndependentParameter{T &lt;: InfiniteScalarSet,
                     M &lt;: AbstractDerivativeMethod} &lt;: ScalarParameter</code></pre><p>A <code>DataType</code> for storing independent scalar infinite parameters.</p><p><strong>Fields</strong></p><ul><li><code>set::T</code>: The infinite set that characterizes the parameter.</li><li><code>supports::DataStructures.SortedDict{Float64, Set{DataType}}</code>: The support points  used to discretize the parameter and their associated type labels stored as  <code>DataTypes</code>s which should be a subtype of <a href="../sets/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</li><li><code>sig_digits::Int</code>: The number of significant digits used to round the support values.</li><li><code>derivative_method::M</code>: The derivative evaluation method used for derivatives that  are conducted with respect to this parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL461-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DependentParameters" href="#InfiniteOpt.DependentParameters"><code>InfiniteOpt.DependentParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DependentParameters{T &lt;: InfiniteArraySet, 
                    M &lt;: NonGenerativeDerivativeMethod} &lt;: InfOptParameter</code></pre><p>A <code>DataType</code> for storing a collection of dependent infinite parameters.</p><p><strong>Fields</strong></p><ul><li><code>set::T</code>: The infinite set that characterizes the parameters.</li><li><code>supports::Dict{Vector{Float64}, Set{DataType}}</code>: Support dictionary where keys             are supports and the values are the set of labels for each support.</li><li><code>sig_digits::Int</code>: The number of significant digits used to round the support values.</li><li><code>derivative_methods::Vector{M}</code>: The derivative evaluation methods associated with  each parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL497-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ScalarParameterData" href="#InfiniteOpt.ScalarParameterData"><code>InfiniteOpt.ScalarParameterData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarParameterData{P &lt;: ScalarParameter} &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing <code>ScalarParameter</code>s and their data.</p><p><strong>Fields</strong></p><ul><li><code>parameter::P</code>: The scalar parameter.</li><li><code>object_num::Int</code>: The location of the corresponding <code>ObjectIndex</code> in   <code>InfiniteModel.param_object_indices</code> (given by <code>InfiniteModel.last_object_num</code>).</li><li><code>parameter_num::Int</code>: Given by <code>InfiniteModel.last_param_num</code> (updated when                       prior parameters are deleted)</li><li><code>name::String</code>: The name used for printing.</li><li><code>parameter_func_indices::Vector{ParameterFunctionIndex}</code>: Indices of dependent  infinite parameter functions.</li><li><code>infinite_var_indices::Vector{InfiniteVariableIndex}</code>: Indices of dependent  infinite variables.</li><li><code>derivative_indices::Vector{DerivativeIndex}</code>: Indices of dependent derivatives.</li><li><code>measure_indices::Vector{MeasureIndex}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{ConstraintIndex}</code>: Indices of dependent constraints.</li><li><code>in_objective::Bool</code>: Is this used in objective? This should be true only for finite parameters.</li><li><code>has_internal_supports::Bool</code>: Does this parameter have internal supports?</li><li><code>has_derivative_supports::Bool</code>: Have any derivative specfic supports been added?</li><li><code>has_deriv_constrs::Bool</code>: Have any derivative evaluation constraints been added                             to the infinite model associated with this parameter?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL531-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MultiParameterData" href="#InfiniteOpt.MultiParameterData"><code>InfiniteOpt.MultiParameterData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiParameterData{P &lt;: DependentParameters} &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> and their data.</p><p><strong>Fields</strong></p><ul><li><code>parameters::P</code>: The parameter collection.</li><li><code>object_num::Int</code>: The location of the corresponding <code>ObjectIndex</code> in  <code>InfiniteModel.param_object_indices</code> (given by <code>InfiniteModel.last_object_num</code>).</li><li><code>parameter_nums::UnitRange{Int}</code>: Given by <code>InfiniteModel.last_param_num</code>                                   (updated when prior parameters are deleted)</li><li><code>names::Vector{String}</code>: The names used for printing each parameter.</li><li><code>parameter_func_indices::Vector{ParameterFunctionIndex}</code>: Indices of  dependent infinite parameter functions.</li><li><code>infinite_var_indices::Vector{InfiniteVariableIndex}</code>: Indices of  dependent infinite variables.</li><li><code>derivative_indices::Vector{Vector{DerivativeIndex}}</code>: Indices of dependent derivatives.</li><li><code>measure_indices::Vector{Vector{MeasureIndex}}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{Vector{ConstraintIndex}}</code>: Indices of dependent constraints.</li><li><code>has_internal_supports::Bool</code>: Does this parameter have internal supports?</li><li><code>has_deriv_constrs::Bool</code>: Have any derivative evaluation constraints been added                             to the infinite model associated with this parameter?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL584-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.IndependentParameterIndex" href="#InfiniteOpt.IndependentParameterIndex"><code>InfiniteOpt.IndependentParameterIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndependentParameterIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DependentParametersIndex" href="#InfiniteOpt.DependentParametersIndex"><code>InfiniteOpt.DependentParametersIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DependentParametersIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DependentParameterIndex" href="#InfiniteOpt.DependentParameterIndex"><code>InfiniteOpt.DependentParameterIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DependentParameterIndex &lt;: AbstractInfOptIndex</code></pre><p>A <code>DataType</code> for storing the index of an indiviudal parameter in a <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object.</p><p><strong>Fields</strong></p><ul><li><code>object_index::DependentParametersIndex</code>: The index of the parameter collection.</li><li><code>param_index::Int</code>: The index of the individual parameter in the above object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL42-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.IndependentParameterRef" href="#InfiniteOpt.IndependentParameterRef"><code>InfiniteOpt.IndependentParameterRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndependentParameterRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for independent infinite parameters references that parameterize infinite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::IndependentParameterIndex</code>: Index of the parameter in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL1394-L1403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DependentParameterRef" href="#InfiniteOpt.DependentParameterRef"><code>InfiniteOpt.DependentParameterRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DependentParameterRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for dependent infinite parameter references that parameterize infinite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::DependentParameterIndex</code>: Index of the dependent parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/datatypes.jl#LL1409-L1418">source</a></section></article><h2 id="Methods/Macros"><a class="docs-heading-anchor" href="#Methods/Macros">Methods/Macros</a><a id="Methods/Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Methods/Macros" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.@dependent_parameters"><code>InfiniteOpt.@dependent_parameters</code></a></li><li><a href="#InfiniteOpt.@independent_parameter"><code>InfiniteOpt.@independent_parameter</code></a></li><li><a href="#InfiniteOpt.@infinite_parameter"><code>InfiniteOpt.@infinite_parameter</code></a></li><li><a href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,IndependentParameter,String}"><code>InfiniteOpt.add_parameter</code></a></li><li><a href="#InfiniteOpt.add_parameters"><code>InfiniteOpt.add_parameters</code></a></li><li><a href="#InfiniteOpt.add_supports-Tuple{IndependentParameterRef,Union{Real, Array{#s37,1} where #s37&lt;:Real}}"><code>InfiniteOpt.add_supports</code></a></li><li><a href="#InfiniteOpt.add_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,AbstractArray{#s10,N} where N where #s10&lt;:(Array{#s5,1} where #s5&lt;:Real)}"><code>InfiniteOpt.add_supports</code></a></li><li><a href="#InfiniteOpt.all_parameters"><code>InfiniteOpt.all_parameters</code></a></li><li><a href="#InfiniteOpt.build_parameter-Tuple{Function,InfiniteScalarSet}"><code>InfiniteOpt.build_parameter</code></a></li><li><a href="#InfiniteOpt.build_parameter-Tuple{Function,Real}"><code>InfiniteOpt.build_parameter</code></a></li><li><a href="#InfiniteOpt.delete_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.delete_supports</code></a></li><li><a href="#InfiniteOpt.delete_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.delete_supports</code></a></li><li><a href="#InfiniteOpt.derivative_method-Tuple{DependentParameterRef}"><code>InfiniteOpt.derivative_method</code></a></li><li><a href="#InfiniteOpt.derivative_method-Tuple{IndependentParameterRef}"><code>InfiniteOpt.derivative_method</code></a></li><li><a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>InfiniteOpt.fill_in_supports!</code></a></li><li><a href="#InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.fill_in_supports!</code></a></li><li><a href="#InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}"><code>InfiniteOpt.fill_in_supports!</code></a></li><li><a href="#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef,AbstractInfiniteSet}"><code>InfiniteOpt.generate_and_add_supports!</code></a></li><li><a href="#InfiniteOpt.generate_and_add_supports!-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,InfiniteArraySet}"><code>InfiniteOpt.generate_and_add_supports!</code></a></li><li><a href="#InfiniteOpt.has_derivative_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.has_derivative_supports</code></a></li><li><a href="#InfiniteOpt.has_internal_supports-Tuple{Union{DependentParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.has_internal_supports</code></a></li><li><a href="#InfiniteOpt.has_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.has_supports</code></a></li><li><a href="#InfiniteOpt.has_supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.has_supports</code></a></li><li><a href="#InfiniteOpt.has_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.has_supports</code></a></li><li><a href="#InfiniteOpt.infinite_set-Tuple{IndependentParameterRef}"><code>InfiniteOpt.infinite_set</code></a></li><li><a href="#InfiniteOpt.infinite_set-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.infinite_set</code></a></li><li><a href="#InfiniteOpt.infinite_set-Tuple{DependentParameterRef}"><code>InfiniteOpt.infinite_set</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{DependentParameterRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.num_parameters"><code>InfiniteOpt.num_parameters</code></a></li><li><a href="#InfiniteOpt.num_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.num_supports</code></a></li><li><a href="#InfiniteOpt.num_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.num_supports</code></a></li><li><a href="#InfiniteOpt.num_supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.num_supports</code></a></li><li><a href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>InfiniteOpt.parameter_by_name</code></a></li><li><a href="#InfiniteOpt.set_infinite_set-Tuple{IndependentParameterRef,InfiniteScalarSet}"><code>InfiniteOpt.set_infinite_set</code></a></li><li><a href="#InfiniteOpt.set_infinite_set-Tuple{DependentParameterRef,InfiniteScalarSet}"><code>InfiniteOpt.set_infinite_set</code></a></li><li><a href="#InfiniteOpt.set_infinite_set-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,InfiniteArraySet}"><code>InfiniteOpt.set_infinite_set</code></a></li><li><a href="#InfiniteOpt.set_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,AbstractArray{#s10,N} where N where #s10&lt;:(Array{#s5,1} where #s5&lt;:Real)}"><code>InfiniteOpt.set_supports</code></a></li><li><a href="#InfiniteOpt.set_supports-Tuple{IndependentParameterRef,Array{#s37,1} where #s37&lt;:Real}"><code>InfiniteOpt.set_supports</code></a></li><li><a href="#InfiniteOpt.significant_digits-Tuple{DependentParameterRef}"><code>InfiniteOpt.significant_digits</code></a></li><li><a href="#InfiniteOpt.significant_digits-Tuple{IndependentParameterRef}"><code>InfiniteOpt.significant_digits</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_infinite_variable-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_infinite_variable</code></a></li><li><a href="#InfiniteOpt.used_by_infinite_variable-Tuple{IndependentParameterRef}"><code>InfiniteOpt.used_by_infinite_variable</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{FiniteParameterRef}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#InfiniteOpt.used_by_parameter_function-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_parameter_function</code></a></li><li><a href="#InfiniteOpt.used_by_parameter_function-Tuple{IndependentParameterRef}"><code>InfiniteOpt.used_by_parameter_function</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,IndependentParameterRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{DependentParameterRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{IndependentParameterRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{DependentParameterRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{IndependentParameterRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.lower_bound-Tuple{IndependentParameterRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.lower_bound-Tuple{DependentParameterRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.name-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}"><code>JuMP.name</code></a></li><li><a href="#JuMP.name-Tuple{DependentParameterRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.set_lower_bound-Tuple{DependentParameterRef,Real}"><code>JuMP.set_lower_bound</code></a></li><li><a href="#JuMP.set_lower_bound-Tuple{IndependentParameterRef,Real}"><code>JuMP.set_lower_bound</code></a></li><li><a href="#JuMP.set_name-Tuple{Union{FiniteParameterRef, IndependentParameterRef},String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{DependentParameterRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_upper_bound-Tuple{IndependentParameterRef,Real}"><code>JuMP.set_upper_bound</code></a></li><li><a href="#JuMP.set_upper_bound-Tuple{DependentParameterRef,Real}"><code>JuMP.set_upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{IndependentParameterRef}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{DependentParameterRef}"><code>JuMP.upper_bound</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@infinite_parameter" href="#InfiniteOpt.@infinite_parameter"><code>InfiniteOpt.@infinite_parameter</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@infinite_parameter(model::InfiniteModel, kw_args...)::GeneralVariableRef</code></pre><p>Add <em>anonymous</em> infinite parameter to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the parameter reference.</p><pre><code class="language-julia">@infinite_parameter(model::InfiniteModel, expr, kw_args...)::GeneralVariableRef</code></pre><p>Add an infinite parameter to the model <code>model</code> described by the expression <code>expr</code>, and the keyword arguments <code>kw_args</code>. This is just a wrapper macro that will make the appropriate call to either <a href="#InfiniteOpt.@independent_parameter"><code>@independent_parameter</code></a> or <a href="#InfiniteOpt.@dependent_parameters"><code>@dependent_parameters</code></a>. (Note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code>, the symbol <code>&gt;=</code>can be used instead of <code>≥</code>, and the symbol <code>in</code> can be used instead of <code>∈</code>) The expression <code>expr</code> can be of the form:</p><ul><li><code>paramexpr</code> creating parameters described by <code>paramexpr</code>.</li><li><code>lb ≤ paramexpr ≤ ub</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ [lb, ub]</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ dist</code> creating parameters described by <code>paramexpr</code> characterized  by the <code>Distributions.jl</code> distribution object <code>dist</code>.</li><li><code>paramexpr ∈ set</code> creating parameters described by <code>paramexpr</code> characterized by the <code>AbstractInfiniteSet</code> object <code>set</code>.</li></ul><p>The expression <code>paramexpr</code> can be of the form:</p><ul><li><code>paramname</code> creating a scalar parameter of name <code>paramname</code></li><li><code>paramname[...]</code> or <code>[...]</code> creating a container of parameters</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the parameter lower bound for an interval set.</li><li><code>upper_bound</code>: Sets the value of the parameter upper bound for an interval set.</li><li><code>set</code>: The <code>InfiniteSet</code> characterizing the parameters see subtypes of        <a href="../sets/#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a>.</li><li><code>distribution</code>: Sets the <code>Distributions.jl</code> distribution object that characterizes the parameters.</li><li><code>supports</code>: Sets the support points for the parameters.</li><li><code>num_supports</code>: Specifies the number of supports to be automatically generated.                 Note that <code>supports</code> takes precedence. Defaults to <code>DefaultNumSupports</code>.</li><li><code>derivative_method</code>: Specify the numerical method to evaluate derivatives that are                      taken with respect to the parameter.</li><li><code>sig_digits</code>: Specifies the number of significant digits that should be used             in automatic support generation. Defaults to <code>DefaultSigDigits</code>.</li><li><code>independent</code>: Specifies if the each parameter is independent from each other or not. Defaults to false.</li><li><code>container</code>: Specify the container type. Defaults to <code>automatic</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, x in [0, 1])
x

julia&gt; @infinite_parameter(m, y[i = 1:2] in MvNormal(ones(2)), num_supports = 10)
2-element Array{GeneralVariableRef,1}:
 y[1]
 y[2]

julia&gt; z = @infinite_parameter(m, [[&quot;a&quot;, &quot;b&quot;]], distribution = Normal(),
                               independent = true)
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, [&quot;a&quot;, &quot;b&quot;]
And data, a 2-element Array{GeneralVariableRef,1}:
 noname[a]
 noname[b]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/macros.jl#LL544-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@independent_parameter" href="#InfiniteOpt.@independent_parameter"><code>InfiniteOpt.@independent_parameter</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@independent_parameter(model::InfiniteModel, kw_args...)::GeneralVariableRef</code></pre><p>Add an <em>anonymous</em> infinite parameter to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the parameter reference.</p><pre><code class="language-julia">@independent_parameter(model::InfiniteModel, expr, kw_args...)::GeneralVariableRef</code></pre><p>Add a parameter to the model <code>model</code> described by the expression <code>expr</code> and the keyword arguments <code>kw_args</code>. (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code>, the symbol <code>&gt;=</code>can be used instead of <code>≥</code>, and the symbol <code>in</code> can be used instead of <code>∈</code>) The expression <code>expr</code> can be of the form:</p><ul><li><code>paramexpr</code> creating parameters described by <code>paramexpr</code>.</li><li><code>lb ≤ paramexpr ≤ ub</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ [lb, ub]</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ dist</code> creating parameters described by <code>paramexpr</code> characterized  by the <code>Distributions.jl</code> distribution object <code>dist</code>.</li></ul><p>The expression <code>paramexpr</code> can be of the form:</p><ul><li><code>paramname</code> creating a scalar parameter of name <code>paramname</code></li><li><code>paramname[...]</code> or <code>[...]</code> creating a container of parameters</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the parameter lower bound for an interval set.</li><li><code>upper_bound</code>: Sets the value of the parameter upper bound for an interval set.</li><li><code>set</code>: The <code>InfiniteSet</code> characterizing the parameters see <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>  and <a href="../sets/#InfiniteOpt.UniDistributionSet"><code>UniDistributionSet</code></a>.</li><li><code>distribution</code>: Sets the <code>Distributions.jl</code> distribution object that characterizes the parameters.</li><li><code>supports</code>: Sets the support points for the parameters.</li><li><code>num_supports</code>: Specifies the number of supports to be automatically generated.                 Note that <code>supports</code> takes precedence. Defaults to <code>DefaultNumSupports</code>.</li><li><code>derivative_method</code>: Specifies the numerical method used to evaluate derivatives that                       are taken with respect to the parameter.</li><li><code>sig_digits</code>: Specifies the number of significant digits that should be used             in automatic support generation. Defaults to <code>DefaultSigDigits</code>.</li><li><code>container</code>: Specify the container type. Defaults to <code>automatic</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @independent_parameter(m, x in [0, 1])
x

julia&gt; @independent_parameter(m, y[i = 1:2] in Normal(), num_supports = 10)
2-element Array{GeneralVariableRef,1}:
 y[1]
 y[2]

julia&gt; z = @independent_parameter(m, [[&quot;a&quot;, &quot;b&quot;]], lower_bound = 0,
                                  upper_bound = 1, supports = [0, 0.5, 1])
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
   Dimension 1, [&quot;a&quot;, &quot;b&quot;]
And data, a 2-element Array{GeneralVariableRef,1}:
noname[a]
noname[b]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/macros.jl#LL89-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@dependent_parameters" href="#InfiniteOpt.@dependent_parameters"><code>InfiniteOpt.@dependent_parameters</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@dependent_parameters(model::InfiniteModel, kw_args...)::GeneralVariableRef</code></pre><p>Add <em>anonymous</em> dependent infinite parameters to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the container of parameter references.</p><pre><code class="language-julia">@dependent_parameters(model::InfiniteModel, expr, kw_args...)::GeneralVariableRef</code></pre><p>Add a container of dependent infinite parameters to the model <code>model</code> described by the expression <code>expr</code>, and the keyword arguments <code>kw_args</code>. (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code>, the symbol <code>&gt;=</code>can be used instead of <code>≥</code>, and the symbol <code>in</code> can be used instead of <code>∈</code>) The expression <code>expr</code> can be of the form:</p><ul><li><code>paramexpr</code> creating parameters described by <code>paramexpr</code>.</li><li><code>lb ≤ paramexpr ≤ ub</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ [lb, ub]</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ dist</code> creating parameters described by <code>paramexpr</code> characterized  by the <code>Distributions.jl</code> distribution object <code>dist</code>.</li><li><code>paramexpr ∈ set</code> creating parameters described by <code>paramexpr</code> characterized  by the <code>AbstractInfiniteSet</code> object <code>set</code>.</li></ul><p>The expression <code>paramexpr</code> must be of the form:</p><ul><li><code>paramname[...]</code> or <code>[...]</code> creating a container of parameters</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the parameter lower bound for an interval set.</li><li><code>upper_bound</code>: Sets the value of the parameter upper bound for an interval set.</li><li><code>set</code>: The <code>InfiniteSet</code> characterizing the parameters that are subtypes of        <a href="../sets/#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a>.</li><li><code>distribution</code>: Sets the <code>Distributions.jl</code> distribution object that characterizes the parameters.</li><li><code>supports</code>: Sets the support points for the parameters.</li><li><code>num_supports</code>: Specifies the number of supports to be automatically generated.                 Note that <code>supports</code> takes precedence. Defaults to <code>DefaultNumSupports</code>.</li><li><code>derivative_method</code>: Specifies the numerical derivative method used to evaluate                       derivatives that depend on a particular dependent parameter.</li><li><code>sig_digits</code>: Specifies the number of significant digits that should be used             in automatic support generation. Defaults to <code>DefaultSigDigits</code>.</li><li><code>container</code>: Specify the container type. Defaults to <code>automatic</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @dependent_parameters(m, x[1:2] in [0, 1])
2-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]

julia&gt; @dependent_parameters(m, y[i = 1:2] in MvNormal(ones(2)), num_supports = 10)
2-element Array{GeneralVariableRef,1}:
 y[1]
 y[2]

julia&gt; z = @dependent_parameters(m, [i = [&quot;a&quot;, &quot;b&quot;], j = 1:2],
                                 distribution = MatrixBeta(2, 2, 2))
2-dimensional DenseAxisArray{GeneralVariableRef,2,...} with index sets:
    Dimension 1, [&quot;a&quot;, &quot;b&quot;]
    Dimension 2, Base.OneTo(2)
And data, a 2×2 Array{GeneralVariableRef,2}:
 noname[a,1]  noname[a,2]
 noname[b,1]  noname[b,2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/macros.jl#LL363-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_parameter-Tuple{Function,InfiniteScalarSet}" href="#InfiniteOpt.build_parameter-Tuple{Function,InfiniteScalarSet}"><code>InfiniteOpt.build_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_parameter(_error::Function, set::InfiniteScalarSet;
                [num_supports::Int = 0,
                supports::Union{Real, Vector{&lt;:Real}} = Real[],
                sig_digits::Int = DefaultSigDigits,
                derivative_method::AbstractDerivativeMethod = DefaultDerivativeMethod]
                )::IndependentParameter</code></pre><p>Returns a <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a> given the appropriate information. This is analagous to <code>JuMP.build_variable</code>. Errors if supports violate the bounds associated with <code>set</code>. This is meant to primarily serve as a helper method for <a href="#InfiniteOpt.@independent_parameter"><code>@independent_parameter</code></a>. Here <code>derivative_method</code>  specifies the numerical evalution method that will be applied to derivatives that  are taken with respect to this infinite parameter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))
IndependentParameter{IntervalSet,FiniteDifference}([0, 3], DataStructures.SortedDict(0.0 =&gt; Set([UserDefined]),1.0 =&gt; Set([UserDefined]),2.0 =&gt; Set([UserDefined]),3.0 =&gt; Set([UserDefined])), 12, FiniteDifference())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL235-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_parameter-Tuple{Function,Real}" href="#InfiniteOpt.build_parameter-Tuple{Function,Real}"><code>InfiniteOpt.build_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_parameter(_error::Function, value::Real)::FiniteParameter</code></pre><p>Returns a <a href="../finite_parameter/#InfiniteOpt.FiniteParameter"><code>FiniteParameter</code></a> given the appropriate information. This is analagous to <code>JuMP.build_variable</code>. This is meant to primarily serve as a helper method for <a href="../finite_parameter/#InfiniteOpt.@finite_parameter"><code>@finite_parameter</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; build_finite_parameter(error, 1)
FiniteParameter(1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL285-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_parameter-Tuple{InfiniteModel,IndependentParameter,String}" href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,IndependentParameter,String}"><code>InfiniteOpt.add_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_parameter(model::InfiniteModel,
              p::Union{IndependentParameterRef, FiniteParameterRef},
              [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Returns a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> associated with the parameter <code>p</code> that is added to <code>model</code>. This adds a parameter to the model in a manner similar to <code>JuMP.add_variable</code>. This can be used to add parameters with the use of <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. <a href="#InfiniteOpt.build_parameter-Tuple{Function,InfiniteScalarSet}"><code>build_parameter</code></a> should be used to construct <code>p</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; p = build_independent_parameter(error, IntervalSet(0, 3), supports = Vector(0:3));

julia&gt; param_ref = add_parameter(model, p, &quot;name&quot;)
name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL306-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_parameters" href="#InfiniteOpt.add_parameters"><code>InfiniteOpt.add_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_parameters(model::InfiniteModel,
               params::DependentParameters,
               names::Vector{String} = [&quot;noname&quot;, &quot;noname&quot;, ...],
               indices = nothing
               )::AbstractArray{&lt;:GeneralVariableRef}</code></pre><p>Add <code>params</code> to <code>model</code> and return an appropriate container of the dependent infinite parameter references. This is intended as an internal method for use with <a href="#InfiniteOpt.@dependent_parameters"><code>@dependent_parameters</code></a>. However, if desired users can use this to create a container of infinite dependent parameter without the use of a macro. <code>names</code> denote the name of each parameter and <code>indices</code> denote the indices of the expected container as used by <code>Containers._make_array</code> (implemented by <code>VectorTuple</code>s), by default a <code>Vector</code> is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Distributions

julia&gt; dist = MvNormal(ones(3)); # 3 dimensional

julia&gt; set = MultiDistributionSet(dist); # 3 dimensional

julia&gt; params = DependentParameters(set, Dict{Vector{Float64}, Set{DatatType}}(), 10);

julia&gt; prefs = add_parameters(model, params, [&quot;par1&quot;, &quot;par2&quot;, &quot;par3&quot;])
3-element Array{GeneralVariableRef,1}:
 par1
 par2
 par3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL230-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}" href="#JuMP.name-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(pref::Union{IndependentParameterRef, FiniteParameterRef})::String</code></pre><p>Extend the <a href="../../JuMP/#JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> function to accomodate infinite parameters. Returns the name string associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(t)
&quot;t&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL499-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{DependentParameterRef}" href="#JuMP.name-Tuple{DependentParameterRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(pref::DependentParameterRef)::String</code></pre><p>Extend <a href="../../JuMP/#JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> to return the names of infinite dependent parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(pref)
&quot;par_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL315-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{Union{FiniteParameterRef, IndependentParameterRef},String}" href="#JuMP.set_name-Tuple{Union{FiniteParameterRef, IndependentParameterRef},String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(pref::ScalarParameterRef, name::String)</code></pre><p>Extend the <a href="../../JuMP/#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> function to accomodate infinite parameters. Set a new base name to be associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(t, &quot;time&quot;)

julia&gt; name(t)
&quot;time&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL516-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{DependentParameterRef,String}" href="#JuMP.set_name-Tuple{DependentParameterRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(pref::DependentParameterRef, name::String)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> to set names of dependent infinite parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(vref, &quot;par_name&quot;)

julia&gt; name(vref)
&quot;para_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL332-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_infinite_variable-Tuple{IndependentParameterRef}" href="#InfiniteOpt.used_by_infinite_variable-Tuple{IndependentParameterRef}"><code>InfiniteOpt.used_by_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_infinite_variable(pref::IndependentParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by an infinite variable or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_infinite_variable(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL378-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_infinite_variable-Tuple{DependentParameterRef}" href="#InfiniteOpt.used_by_infinite_variable-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_infinite_variable(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used by an infinite variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_infinite_variable(pref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL385-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_parameter_function-Tuple{IndependentParameterRef}" href="#InfiniteOpt.used_by_parameter_function-Tuple{IndependentParameterRef}"><code>InfiniteOpt.used_by_parameter_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_parameter_function(pref::IndependentParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by an infinite parameter function or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_parameter_function(t)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL396-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_parameter_function-Tuple{DependentParameterRef}" href="#InfiniteOpt.used_by_parameter_function-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_parameter_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_parameter_function(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used by an infinite parameter function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_parameter_function(pref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL401-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}" href="#InfiniteOpt.used_by_measure-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool</code></pre><p>Return true if <code>pref</code> is used by a measure or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(t)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL414-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{DependentParameterRef}" href="#InfiniteOpt.used_by_measure-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(pref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL417-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}" href="#InfiniteOpt.used_by_constraint-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool</code></pre><p>Return true if <code>pref</code> is used by a constraint or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL429-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{DependentParameterRef}" href="#InfiniteOpt.used_by_constraint-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(pref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL433-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{FiniteParameterRef}" href="#InfiniteOpt.used_by_objective-Tuple{FiniteParameterRef}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_objective(pref::FiniteParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by the objective function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL444-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}" href="#InfiniteOpt.is_used-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool</code></pre><p>Return true if <code>pref</code> is used in the model or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL478-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{DependentParameterRef}" href="#InfiniteOpt.is_used-Tuple{DependentParameterRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(pref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL468-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}" href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>InfiniteOpt.parameter_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_by_name(model::InfiniteModel,
                  name::String)::Union{GeneralVariableRef, Nothing}</code></pre><p>Return the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_by_name(model, &quot;t&quot;)
t</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL598-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_set-Tuple{IndependentParameterRef}" href="#InfiniteOpt.infinite_set-Tuple{IndependentParameterRef}"><code>InfiniteOpt.infinite_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_set(pref::IndependentParameterRef)::InfiniteScalarSet</code></pre><p>Return the infinite set associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_set(t)
[0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL751-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_set-Tuple{DependentParameterRef}" href="#InfiniteOpt.infinite_set-Tuple{DependentParameterRef}"><code>InfiniteOpt.infinite_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_set(pref::DependentParameterRef)::InfiniteScalarSet</code></pre><p>Return the infinite set associated with the particular infinite dependent parameter <code>pref</code> if valid. Errors if the underlying <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object does not use a <a href="../sets/#InfiniteOpt.CollectionSet"><code>CollectionSet</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_set(x[1])
[-1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL683-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_set-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}" href="#InfiniteOpt.infinite_set-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.infinite_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_set(prefs::AbstractArray{&lt;:DependentParameterRef})::InfiniteArraySet</code></pre><p>Return the infinite set associated with the container of infinite dependent parameters <code>prefs</code>. Errors if the container <code>prefs</code> is incomplete.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_set(x)
ZeroMeanDiagNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 1.0]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL711-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_infinite_set-Tuple{IndependentParameterRef,InfiniteScalarSet}" href="#InfiniteOpt.set_infinite_set-Tuple{IndependentParameterRef,InfiniteScalarSet}"><code>InfiniteOpt.set_infinite_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_infinite_set(pref::IndependentParameterRef,
                 set::InfiniteScalarSet)::Nothing</code></pre><p>Reset the infinite set of <code>pref</code> with another <code>InfiniteScalarSet</code>. An error will  be thrown if <code>pref</code> is being used by some measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_infinite_set(t, IntervalSet(0, 2))

julia&gt; infinite_set(t)
[0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL766-L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_infinite_set-Tuple{DependentParameterRef,InfiniteScalarSet}" href="#InfiniteOpt.set_infinite_set-Tuple{DependentParameterRef,InfiniteScalarSet}"><code>InfiniteOpt.set_infinite_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_infinite_set(pref::DependentParameterRef,
                 set::InfiniteScalarSet)::Nothing</code></pre><p>Specify the scalar infinite set of the dependent infinite parameter <code>pref</code> to <code>set</code> if <code>pref</code> is part of a <a href="../sets/#InfiniteOpt.CollectionSet"><code>CollectionSet</code></a>, otherwise an error is thrown. Note this will reset/delete all the supports contained in the underlying <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object. Also, errors if <code>pref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_infinite_set(x[1], IntervalSet(0, 2))

julia&gt; infinite_set(x[1])
[0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL754-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_infinite_set-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,InfiniteArraySet}" href="#InfiniteOpt.set_infinite_set-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,InfiniteArraySet}"><code>InfiniteOpt.set_infinite_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_infinite_set(prefs::AbstractArray{&lt;:DependentParameterRef},
                 set::InfiniteArraySet)::Nothing</code></pre><p>Specify the multi-dimensional infinite set of the dependent infinite parameters <code>prefs</code> to <code>set</code>. Note this will reset/delete all the supports contained in the underlying <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object. This will error if the not all of the dependent infinite parameters are included, if any of them are used by measures.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_infinite_set(x, CollectionSet([IntervalSet(0, 1), IntervalSet(0, 2)]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL789-L803">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{IndependentParameterRef}" href="#JuMP.has_lower_bound-Tuple{IndependentParameterRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(pref::IndependentParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_lower_bound</code> function to accomodate infinite parameters. Return true if the set associated with <code>pref</code> has a defined lower bound or if a lower bound can be found. Extensions with user-defined infinite set types should extend <code>JuMP.has_lower_bound(set::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL794-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{DependentParameterRef}" href="#JuMP.has_lower_bound-Tuple{DependentParameterRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(pref::DependentParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_lower_bound</code> function to accomodate a single dependent infinite parameter. Return true if the set associated with <code>pref</code> has a defined lower bound or if a lower bound can be found. Extensions with user-defined scalar infinite set types should extend <code>JuMP.has_lower_bound(set::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(x[1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL815-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{IndependentParameterRef}" href="#JuMP.lower_bound-Tuple{IndependentParameterRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(pref::IndependentParameterRef)::Real</code></pre><p>Extend the <code>JuMP.lower_bound</code> function to accomodate infinite parameters. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(t)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL813-L825">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{DependentParameterRef}" href="#JuMP.lower_bound-Tuple{DependentParameterRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(pref::DependentParameterRef)::Number</code></pre><p>Extend the <code>JuMP.lower_bound</code> function to accomodate a single dependent infinite parameter. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(x[1])
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL839-L851">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{IndependentParameterRef,Real}" href="#JuMP.set_lower_bound-Tuple{IndependentParameterRef,Real}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_lower_bound(pref::IndependentParameterRef, lower::Real)::Nothing</code></pre><p>Extend the <code>JuMP.set_lower_bound</code> function to accomodate infinite parameters. Updates the infinite set lower bound if such an operation is supported. Set extensions that seek to employ this should extend <code>JuMP.set_lower_bound(set::NewType, lower::Number)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(t, -1)

julia&gt; lower_bound(t)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL834-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{DependentParameterRef,Real}" href="#JuMP.set_lower_bound-Tuple{DependentParameterRef,Real}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_lower_bound(pref::DependentParameterRef, lower::Real)::Nothing</code></pre><p>Extend the <code>JuMP.set_lower_bound</code> function to accomodate a single dependent infinite parameter. Updates the infinite set lower bound if such an operation is supported. Infinite scalar set extensions that seek to employ this should extend <code>JuMP.set_lower_bound(set::NewType, lower::Number)</code>. This will call <a href="../expression/#InfiniteOpt.set_infinite_set-Tuple{GeneralVariableRef,InfiniteScalarSet}"><code>set_infinite_set</code></a> and will error if this is not well-defined. Note that existing supports will be deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(t, -1)

julia&gt; lower_bound(t)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL859-L876">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{IndependentParameterRef}" href="#JuMP.has_upper_bound-Tuple{IndependentParameterRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(pref::IndependentParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_upper_bound</code> function to accomodate infinite parameters. Return true if the set associated with <code>pref</code> has a defined upper bound or if a upper bound can be found. Extensions with user-defined sets should extend <code>JuMP.has_upper_bound(set::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL857-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{DependentParameterRef}" href="#JuMP.has_upper_bound-Tuple{DependentParameterRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(pref::DependentParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_upper_bound</code> function to accomodate a single dependent infinite parameter. Return true if the set associated with <code>pref</code> has a defined upper bound or if a upper bound can be found. Extensions with user-defined scalar infinite set types should extend <code>JuMP.has_upper_bound(set::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(x[1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL884-L898">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{IndependentParameterRef}" href="#JuMP.upper_bound-Tuple{IndependentParameterRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(pref::IndependentParameterRef)::Real</code></pre><p>Extend the <code>JuMP.upper_bound</code> function to accomodate infinite parameters. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined. Extensions with user-defined set types should extend <code>JuMP.has_upper_bound(set::NewType)</code> and <code>JuMP.upper_bound(set::NewType)</code> if appropriate.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(t)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL876-L890">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{DependentParameterRef}" href="#JuMP.upper_bound-Tuple{DependentParameterRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(pref::DependentParameterRef)::Number</code></pre><p>Extend the <code>JuMP.upper_bound</code> function to accomodate a single dependent infinite parameter. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(x[1])
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL908-L920">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{IndependentParameterRef,Real}" href="#JuMP.set_upper_bound-Tuple{IndependentParameterRef,Real}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_upper_bound(pref::IndependentParameterRef, lower::Real)::Nothing</code></pre><p>Extend the <code>JuMP.set_upper_bound</code> function to accomodate infinite parameters. Updates the infinite set upper bound if and only if it is an IntervalSet. Errors otherwise. Extensions with user-defined infinite sets should extend <code>JuMP.set_upper_bound(set::NewType, upper::Number)</code> if appropriate.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_upper_bound(t, 2)

julia&gt; upper_bound(t)
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL899-L914">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{DependentParameterRef,Real}" href="#JuMP.set_upper_bound-Tuple{DependentParameterRef,Real}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_upper_bound(pref::DependentParameterRef, upper::Real)::Nothing</code></pre><p>Extend the <code>JuMP.set_upper_bound</code> function to accomodate a single dependent infinite parameter. Updates the infinite set upper bound if such an operation is supported. Infinite scalar set extensions that seek to employ this should extend <code>JuMP.set_upper_bound(set::NewType, upper::Number)</code>. This will call <a href="../expression/#InfiniteOpt.set_infinite_set-Tuple{GeneralVariableRef,InfiniteScalarSet}"><code>set_infinite_set</code></a> and will error if this is not well-defined. Note that existing supports will be deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_upper_bound(t, -1)

julia&gt; upper_bound(t)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL928-L945">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.significant_digits-Tuple{IndependentParameterRef}" href="#InfiniteOpt.significant_digits-Tuple{IndependentParameterRef}"><code>InfiniteOpt.significant_digits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">significant_digits(pref::IndependentParameterRef)::Int</code></pre><p>Return the number of significant digits enforced on the supports of <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; significant_digits(t)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL967-L977">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.significant_digits-Tuple{DependentParameterRef}" href="#InfiniteOpt.significant_digits-Tuple{DependentParameterRef}"><code>InfiniteOpt.significant_digits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">significant_digits(pref::DependentParameterRef)::Int</code></pre><p>Return the number of significant digits enforced on the supports of <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; significant_digits(x[1])
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL962-L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.num_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(pref::IndependentParameterRef; 
             [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Int</code></pre><p>Return the number of support points associated with <code>pref</code>. By default, only the  number of public supports are counted. The full amount can be determined by setting  <code>label = All</code>. Moreover, the amount of labels that satisfy <code>label</code> is obtained  using an <a href="../sets/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_supports(t)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL982-L996">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{DependentParameterRef}" href="#InfiniteOpt.num_supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(pref::DependentParameterRef; 
             [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Int</code></pre><p>Return the number of support points associated with a single dependent infinite parameter <code>pref</code>. Specify a subset of supports via <code>label</code> to only count the supports with <code>label</code>. By default only the amount of public supports are given, but  the full amount is obtained via <code>label == All</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_supports(x[1])
2

julia&gt; num_supports(x[1], label = MCSample)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL977-L994">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}" href="#InfiniteOpt.num_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(prefs::AbstractArray{&lt;:DependentParameterRef};
             [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Int</code></pre><p>Return the number of support points associated with dependent infinite parameters <code>prefs</code>. Errors if not all from the same underlying object. Specify a subset of supports via <code>label</code> to only count the supports with <code>label</code>. By default only the amount of public supports are given, but the full amount is  obtained via <code>label == All</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_supports(x)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1005-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.has_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.has_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_supports(pref::IndependentParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> has supports or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_supports(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL1007-L1017">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_supports-Tuple{DependentParameterRef}" href="#InfiniteOpt.has_supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.has_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_supports(pref::DependentParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> has supports or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_supports(x[1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1028-L1038">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}" href="#InfiniteOpt.has_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.has_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_supports(prefs::AbstractArray{&lt;:DependentParameterRef})::Bool</code></pre><p>Return true if <code>prefs</code> have supports or false otherwise. Errors if not all of the infinite dependent parameters are from the same object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_supports(x)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1041-L1052">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(pref::IndependentParameterRef; 
         [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Vector{Float64}</code></pre><p>Return the support points associated with <code>pref</code>. Errors if there are no supports. Users can query just support points generated by a certain method using the keyword argument <code>label</code>. By default, the function returns all public support points regardless of the associated label. The full collection is given by setting  <code>label = All</code>. Moreover, the amount of labels that satisfy <code>label</code> is obtained  using an <a href="../sets/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(t)
2-element Array{Float64,1}:
 0.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL1020-L1038">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{DependentParameterRef}" href="#InfiniteOpt.supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(pref::DependentParameterRef; 
         [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Vector{Float64}</code></pre><p>Return the support points associated with <code>pref</code>. A subset of supports can be returned via <code>label</code> to return just the supports associated with <code>label</code>. By  default only the public supports are given, but the full set is  obtained via <code>label == All</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(x[1])
2-element Array{Float64,1}:
 0.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1058-L1074">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}" href="#InfiniteOpt.supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(prefs::AbstractArray{&lt;:DependentParameterRef};
         [label::Type{&lt;:AbstractSupportLabel} = PublicLabel]
         )::Union{AbstractArray{&lt;:Vector{&lt;:Float64}}, Array{Float64, 2}}</code></pre><p>Return the support points associated with <code>prefs</code>. Errors if not all of the infinite dependent parameters are from the same object. This will return a matrix if <code>prefs</code> is <code>Vector</code>, otherwise an array of vectors is returned by calling <code>supports.(prefs)</code>. A subset of supports can be returned via <code>label</code> to return just the supports associated with <code>label</code>. By  default only the public supports are given, but the full set is  obtained via  <code>label == All</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(x) # columns are supports
2×2 Array{Float64,2}:
 0.0  1.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1087-L1107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_supports-Tuple{IndependentParameterRef,Array{#s37,1} where #s37&lt;:Real}" href="#InfiniteOpt.set_supports-Tuple{IndependentParameterRef,Array{#s37,1} where #s37&lt;:Real}"><code>InfiniteOpt.set_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_supports(pref::IndependentParameterRef, supports::Vector{&lt;:Real};
             [force::Bool = false,
             label::Type{&lt;:AbstractSupportLabel} = UserDefined]
             )::Nothing</code></pre><p>Specify the support points for <code>pref</code>. Errors if the supports violate the bounds associated with the infinite set. Warns if the points are not unique. If <code>force</code> this will overwrite exisiting supports otherwise it will error if there are existing supports.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_supports(t, [0, 1])

julia&gt; supports(t)
2-element Array{Int64,1}:
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL1079-L1099">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,AbstractArray{#s10,N} where N where #s10&lt;:(Array{#s5,1} where #s5&lt;:Real)}" href="#InfiniteOpt.set_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,AbstractArray{#s10,N} where N where #s10&lt;:(Array{#s5,1} where #s5&lt;:Real)}"><code>InfiniteOpt.set_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_supports(prefs::AbstractArray{&lt;:DependentParameterRef},
             supports::AbstractArray{&lt;:Vector{&lt;:Real}};
             [force::Bool = false,
             label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Specify the support points for <code>prefs</code>. Errors if the supports violate the domain of the infinite set, if the dimensions don&#39;t match up properly, if <code>prefs</code> and <code>supports</code> have different indices, not all of the <code>prefs</code> are from the same dependent infinite parameter container, there are existing supports and <code>force = false</code>. Note that it is strongly preferred to use <code>add_supports</code> if possible to avoid destroying measure dependencies.</p><pre><code class="language-julia">    set_supports(prefs::Vector{DependentParameterRef},
                 supports::Array{&lt;:Real, 2};
                 [force::Bool = false,
                 label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Specify the supports for a vector <code>prefs</code> of dependent infinite parameters. Here rows of <code>supports</code> correspond to <code>prefs</code> and the columns correspond to the supports. This is more efficient than the above method and will error for the same reasons.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_supports(y, [[0, 1], [0, 1]])

julia&gt; set_supports(x, [0 1; 0 1])

julia&gt; supports(x)
2×2 Array{Float64,2}:
 0.0  1.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1174-L1209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_supports-Tuple{IndependentParameterRef,Union{Real, Array{#s37,1} where #s37&lt;:Real}}" href="#InfiniteOpt.add_supports-Tuple{IndependentParameterRef,Union{Real, Array{#s37,1} where #s37&lt;:Real}}"><code>InfiniteOpt.add_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_supports(pref::IndependentParameterRef,
             supports::Union{Real, Vector{&lt;:Real}};
             [label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Add additional support points for <code>pref</code> with identifying label <code>label</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; add_supports(t, 0.5)

julia&gt; supports(t)
3-element Array{Float64,1}:
 0.0
 0.5
 1.0

julia&gt; add_supports(t, [0.25, 1])

julia&gt; supports(t)
4-element Array{Float64,1}:
 0.0
 0.25
 0.5
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL1122-L1148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,AbstractArray{#s10,N} where N where #s10&lt;:(Array{#s5,1} where #s5&lt;:Real)}" href="#InfiniteOpt.add_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,AbstractArray{#s10,N} where N where #s10&lt;:(Array{#s5,1} where #s5&lt;:Real)}"><code>InfiniteOpt.add_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_supports(prefs::AbstractArray{&lt;:DependentParameterRef},
             supports::AbstractArray{&lt;:Vector{&lt;:Real}};
             [label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Add additional support points for <code>prefs</code>. Errors if the supports violate the domain of the infinite set, if the dimensions don&#39;t match up properly, if <code>prefs</code> and <code>supports</code> have different indices, or not all of the <code>prefs</code> are from the same dependent infinite parameter container.</p><pre><code class="language-julia">    add_supports(prefs::Vector{DependentParameterRef},
                 supports::Array{&lt;:Real, 2};
                 [label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Specify the supports for a vector <code>prefs</code> of dependent infinite parameters. Here rows of <code>supports</code> correspond to <code>prefs</code> and the columns correspond to the supports. This is more efficient than the above method and will error for the same reasons.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; add_supports(x, [[1], [1]])

julia&gt; supports(x)
2×2 Array{Float64,2}:
 0.0  1.0
 0.0  1.0

julia&gt; add_supports(x, ones(2, 1) * 0.5)

julia&gt; supports(t)
2×3 Array{Float64,2}:
 0.0  1.0  0.5
 0.0  1.0  0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1244-L1280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.delete_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.delete_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_supports(pref::IndependentParameterRef; 
                [label::Type{&lt;:AbstractSupportLabel} = All])::Nothing</code></pre><p>Delete the support points for <code>pref</code>. If <code>label != All</code> then delete <code>label</code> and  any supports that solely depend on it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_supports(t)

julia&gt; supports(t)
ERROR: Parameter t does not have supports.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL1174-L1188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}" href="#InfiniteOpt.delete_supports-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.delete_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_supports(prefs::AbstractArray{&lt;:DependentParameterRef};
                [label::Type{&lt;:AbstractSupportLabel} = All])::Nothing</code></pre><p>Delete the support points for <code>prefs</code>. Errors if any of the parameters are used by a measure or if not all belong to the same set of dependent parameters. If <code>label != All</code> then that label is removed along with any supports that solely  contain that label.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_supports(w)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1326-L1340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef,AbstractInfiniteSet}" href="#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef,AbstractInfiniteSet}"><code>InfiniteOpt.generate_and_add_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_and_add_supports!(pref::IndependentParameterRef,
                           set::AbstractInfiniteSet,
                           [method::Type{&lt;:AbstractSupportLabel}];
                           [num_supports::Int = DefaultNumSupports])::Nothing</code></pre><p>Generate supports for independent parameter <code>pref</code> via <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> and add them to <code>pref</code>. This is intended as an extendable internal method for <a href="#InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}"><code>fill_in_supports!</code></a>. Most extensions that empoy user-defined infinite sets can typically enable this by extending <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a>. Errors if the infinite set type is not recognized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL1311-L1323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generate_and_add_supports!-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,InfiniteArraySet}" href="#InfiniteOpt.generate_and_add_supports!-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef,InfiniteArraySet}"><code>InfiniteOpt.generate_and_add_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_and_add_supports!(prefs::AbstractArray{&lt;:DependentParameterRef},
                           set::InfiniteArraySet,
                           [method::Type{&lt;:AbstractSupportLabel}];
                           [num_supports::Int = DefaultNumSupports])::Nothing</code></pre><p>Generate supports for <code>prefs</code> via <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> and add them to <code>pref</code>. This is intended as an extendable internal method for <a href="#InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>fill_in_supports!</code></a>. Most extensions that employ user-defined infinite sets can typically enable this by extending <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a>. However, in some cases it may be necessary to extend this when more complex operations need to take place then just adding supports to a set of infinite parameters. Errors if the infinite set type is not recognized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1376-L1390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}" href="#InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}"><code>InfiniteOpt.fill_in_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_in_supports!(pref::IndependentParameterRef;
                  [num_supports::Int = DefaultNumSupports])::Nothing</code></pre><p>Automatically generate support points for a particular independent parameter <code>pref</code>. Generating <code>num_supports</code> for the parameter. The supports are generated uniformly if the underlying infinite set is an <code>IntervalSet</code> or they are generating randomly accordingly to the distribution if the set is a <code>UniDistributionSet</code>. Will add nothing if there are supports and <code>modify = false</code>. Extensions that use user defined set types should extend <a href="#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef,AbstractInfiniteSet}"><code>generate_and_add_supports!</code></a> and/or <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> as needed. Errors if the infinite set type is not recognized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(x, num_supports = 4)

julia&gt; supports(x)
4-element Array{Number,1}:
 0.0
 0.333
 0.667
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL1272-L1297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}" href="#InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>InfiniteOpt.fill_in_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_in_supports!(prefs::AbstractArray{&lt;:DependentParameterRef};
                  [num_supports::Int = DefaultNumSupports,
                   modify::Bool = true])::Nothing</code></pre><p>Automatically generate support points for a container of dependent infinite parameters <code>prefs</code>. Generating up to <code>num_supports</code> for the parameters in accordance with <code>generate_and_add_supports!</code>. Will add nothing if there are supports and <code>modify = false</code>. Extensions that use user defined set types should extend <a href="#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef,AbstractInfiniteSet}"><code>generate_and_add_supports!</code></a> and/or <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> as needed. Errors if the infinite set type is not recognized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(x, num_supports = 4)

julia&gt; supports(x)
2×4 Array{Float64,2}:
 0.0  0.333  0.667  1.0
 0.0  0.333  0.667  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1413-L1435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}" href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>InfiniteOpt.fill_in_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_in_supports!(model::InfiniteModel; [num_supports::Int = DefaultNumSupports,
                  modify::Bool = true])::Nothing</code></pre><p>Automatically generate support points for all infinite parameters in model. This calls <code>fill_in_supports!</code> for each parameter in the model. See <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> for more information. Errors if one of the infinite set types is unrecognized. Note that no supports will be added to a particular parameter if it already has some and <code>modify = false</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(model, num_supports = 4)

julia&gt; supports(t)
4-element Array{Float64,1}:
 0.0
 0.333
 0.667
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1453-L1475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_method-Tuple{IndependentParameterRef}" href="#InfiniteOpt.derivative_method-Tuple{IndependentParameterRef}"><code>InfiniteOpt.derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_method(pref::IndependentParameterRef)::AbstractDerivativeMethod</code></pre><p>Returns the numerical derivative evaluation method employed with <code>pref</code> when it  is used as an operator parameter in a derivative.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_method(pref) 
FiniteDifference(Backward, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL661-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_method-Tuple{DependentParameterRef}" href="#InfiniteOpt.derivative_method-Tuple{DependentParameterRef}"><code>InfiniteOpt.derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_method(pref::DependentParameterRef)::NonGenerativeDerivativeMethod</code></pre><p>Returns the numerical derivative evaluation method employed with <code>pref</code> when it  is used as an operator parameter in a derivative.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_method(pref) 
FiniteDifference</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL569-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_parameters" href="#InfiniteOpt.num_parameters"><code>InfiniteOpt.num_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_parameters(model::InfiniteModel,
               [type::Type{InfOptParameter} = InfOptParameter])::Int</code></pre><p>Return the number of <code>InfiniteOpt</code> parameters assigned to <code>model</code>. By default, the total number of infinite and finite parameters is returned. The amount of a particular type is obtained by specifying the concrete parameter type of <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> via <code>type</code>. Type options include:</p><ul><li><code>InfOptParameter</code>: all parameters</li><li><code>ScalarParameter</code>: all scalar parameters</li><li><code>InfiniteParameter</code>: all infinite parameters</li><li><code>FiniteParameter</code>: all finite parameters</li><li><code>IndependentParameter</code>: all independent infinite parameters</li><li><code>DependentParameters</code>: all dependent infinite parameters</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_parameters(model)
3

julia&gt; num_parameters(model, IndependentParameter)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1495-L1518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_parameters" href="#InfiniteOpt.all_parameters"><code>InfiniteOpt.all_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_parameters(model::InfiniteModel,
               type::Type{InfOptParameter} = InfOptParameter
               )::Vector{GeneralVariableRef}</code></pre><p>Return a list of all the <code>InfiniteOpt</code> parameters assigned to <code>model</code>. By default, all of the infinite and finite parameters is returned. The search is reduced to a particular type is obtained by specifying the concrete parameter type of <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> via <code>type</code>. Type options include:</p><ul><li><code>InfOptParameter</code>: all parameters</li><li><code>ScalarParameter</code>: all scalar parameters</li><li><code>InfiniteParameter</code>: all infinite parameters</li><li><code>FiniteParameter</code>: all finite parameters</li><li><code>IndependentParameter</code>: all independent infinite parameters</li><li><code>DependentParameters</code>: all dependent infinite parameters</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all_parameters(model)
4-element Array{GeneralVariableRef,1}:
 t
 x[1]
 x[2]
 alpha

julia&gt; all_parameters(model, FiniteParameter)
1-element Array{GeneralVariableRef,1}:
 alpha</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1560-L1589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,IndependentParameterRef}" href="#JuMP.delete-Tuple{InfiniteModel,IndependentParameterRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, pref::ScalarParameterRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete scalar parameters and their dependencies. All variables, constraints, and measure functions that depend on <code>pref</code> are updated to exclude it. Errors if the parameter is contained in an <code>AbstractMeasureData</code> datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that <a href="../measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>parameter_refs</code></a> needs to be extended to allow deletion of parameters when custom <code>AbstractMeasureData</code> datatypes are used. Note that any dependent infinite variables will have their start values reset via <a href="../derivative/#InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}"><code>reset_start_value_function</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t, x)*t + x) + z
Subject to
 z ≥ 0.0
 g(t, x) + z ≥ 42.0, ∀ t ∈ [0, 6], x ∈ [-1, 1]
 g(0.5, x) = 0, ∀ x ∈ [-1, 1]

julia&gt; delete(model, x)

julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL1485-L1516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}" href="#JuMP.delete-Tuple{InfiniteModel,AbstractArray{#s37,N} where N where #s37&lt;:DependentParameterRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel,
            prefs::AbstractArray{&lt;:DependentParameterRef})::Nothing</code></pre><p>Extend <code>JuMP.delete</code> to delete dependent infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on <code>prefs</code> are updated to exclude them. Errors if the parameters are contained in an <code>AbstractMeasureData</code> datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that <a href="../measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>parameter_refs</code></a> needs to be extended to allow deletion of parameters when custom <code>AbstractMeasureData</code> datatypes are used. Note that any dependent infinite variables will have their start values reset to the default via <a href="../derivative/#InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}"><code>reset_start_value_function</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t, x)*t + x) + z
Subject to
 z ≥ 0.0
 g(t, x) + z ≥ 42.0, ∀ t ∈ [0, 6], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]
 g(0.5, x) = 0, x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]

julia&gt; delete(model, x)

julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/array_parameters.jl#LL1646-L1678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_internal_supports-Tuple{Union{DependentParameterRef, IndependentParameterRef}}" href="#InfiniteOpt.has_internal_supports-Tuple{Union{DependentParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.has_internal_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_internal_supports(pref::Union{IndependentParameterRef, DependentParameterRef})::Bool</code></pre><p>Indicate if <code>pref</code> has internal supports that will be hidden from the user by  default. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL946-L951">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_derivative_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.has_derivative_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.has_derivative_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_derivative_supports(pref::IndependentParameterRef)::Bool</code></pre><p>Return whether derivative specific supports have been added to <code>pref</code> in accordance  with its derivative method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/10ac751a0cd1670d234c9f99f2b5fd140732059e/src/scalar_parameters.jl#LL632-L637">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sets/">« Infinite Sets</a><a class="docs-footer-nextpage" href="../finite_parameter/">Finite Parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 25 November 2020 22:43">Wednesday 25 November 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
