<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Infinite Parameters · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li class="is-active"><a class="tocitem" href>Infinite Parameters</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Parameter-Definition"><span>Parameter Definition</span></a></li><li><a class="tocitem" href="#param_macro"><span>Macro Definition</span></a></li><li><a class="tocitem" href="#Supports"><span>Supports</span></a></li><li><a class="tocitem" href="#Parameter-Queries"><span>Parameter Queries</span></a></li><li><a class="tocitem" href="#Parameter-Modification"><span>Parameter Modification</span></a></li><li><a class="tocitem" href="#gen_supp_docs"><span>Generative Supports</span></a></li></ul></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../manual/optimize/">Optimization</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Infinite Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Infinite Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/parameter.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="inf_par_docs"><a class="docs-heading-anchor" href="#inf_par_docs">Infinite Parameters</a><a id="inf_par_docs-1"></a><a class="docs-heading-anchor-permalink" href="#inf_par_docs" title="Permalink"></a></h1><p>A guide for infinite parameters in <code>InfiniteOpt</code>. See the respective  <a href="../../manual/parameter/#inf_par_manual">technical manual</a> for more details.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Infinite parameters are what live on the infinite domains of infinite dimensional   mathematical optimization problems. In dynamic optimization this  corresponds to time and in stochastic optimization this to uncertain parameters  that follow a certain underlying statistical distribution. <code>InfiniteOpt</code>  considers natively two kinds of infinite parameters, ones defined over  continuous intervals and ones characterized by a distribution (others can be  added by defining a user-defined type). These can be used to parameterize  infinite variables, semi-infinite variables, point variables, derivatives,   measures, and can be used directly inside constraints. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Previous versions of <code>InfiniteOpt</code> used the syntax  <code>@infinite_parameter(model, ξ in distribution)</code> for defining random infinite  parameters. This has been updated to  <code>@infinite_parameter(model, ξ ~ distribution)</code>.</p></div></div><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>First, we need to initialize and add infinite parameters to our <code>InfiniteModel</code>.  This can be accomplished using <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. For example, let&#39;s  define a parameter for time in a time interval from 0 to 10:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10])
t</code></pre><p>Now <code>t</code> is a Julia variable that stores a <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> which  points to where the time parameter is stored in <code>model</code>. It can now be used with  infinite variables, derivatives, measures, and constraints as described in their   respective user guide sections.</p><p>When the model is optimized, <code>t</code> will be transcribed (discretized) over its domain  following its support points. Users can specify support points via the   <code>num_supports</code> or <code>supports</code> keyword arguments. For example, if we desire to  have only 10 equi-distant supports then we could have instead defined <code>t</code>: </p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10)
t</code></pre><p>More complex support schemes can be specified via <code>supports</code> such as:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0, 2, 7, 10])
t</code></pre><p>Where we specified <code>t</code> to use 4 supports: 0, 2, 7, and 10.</p><p>We can also add supports after <code>t</code> has been initialized. This can be accomplished  with <a href="../../manual/expression/#InfiniteOpt.add_supports-Tuple{GeneralVariableRef, Union{Real, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}}"><code>add_supports</code></a>. For example, consider the initial case where <code>t</code> has  no supports and we now wish to add 4 supports:</p><pre><code class="language-julia-repl">julia&gt; add_supports(t, [0., 2.5, 7.5, 10.])

julia&gt; supports(t)
4-element Vector{Float64}:
  0.0
  2.5
  7.5
 10.0</code></pre><p>Here only 4 supports are specified for the sake of example. Alternatively, we  could have initialized the parameter and added supports in just one step using  the <code>supports</code> keyword argument:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0., 2.5, 7.5, 10.])
t</code></pre><p>We could also define a random parameter described by a distribution. This can be  accomplished using <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> in combination with a  distribution from  <a href="https://github.com/JuliaStats/Distributions.jl"><code>Distributions.jl</code></a>. For  example let&#39;s define a vector of independent random parameters described by a  Normal distribution:</p><pre><code class="language-julia-repl">julia&gt; using Distributions

julia&gt; @infinite_parameter(model, ξ[i = 1:3] ~ Normal(), independent = true)
3-element Vector{GeneralVariableRef}:
 ξ[1]
 ξ[2]
 ξ[3]</code></pre><p>Note that we use <code>~</code> instead of <code>in</code> when specifying distributions. We could have  used <code>i</code> as an index to assign a different distribution to each parameter.  Supports can also be specified for each parameter as shown above. Similarly, the  <code>num_supports</code> keyword is used to generate random supports.</p><p>More interestingly, we can also define multi-variate random parameters, for example:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, θ[1:2] ~ MvNormal([0, 0], [1, 1]))
2-element Vector{GeneralVariableRef}:
 θ[1]
 θ[2]</code></pre><p>Now we have infinite parameters <code>t</code> and <code>ξ</code> that are ready to be used in  defining infinite variables and constraints. We also mention here that the  <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> macro is designed to closely emulate  <code>JuMP.@variable</code> and thus handles arrays and keyword arguments in the same way.  This is described in more detail below.</p><h2 id="Parameter-Definition"><a class="docs-heading-anchor" href="#Parameter-Definition">Parameter Definition</a><a id="Parameter-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Definition" title="Permalink"></a></h2><p>Defining/initializing an infinite parameter principally involves the following  steps (these are typically automated by <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>):</p><ol><li>Define an <a href="../../manual/domains/#InfiniteOpt.AbstractInfiniteDomain"><code>AbstractInfiniteDomain</code></a></li><li>Define support points within the domain to later discretize the parameter</li><li>Construct an <a href="../../manual/parameter/#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> to store this information</li><li>Add the <code>InfOptParameter</code> object to an <code>InfiniteModel</code> and assign a name</li><li>Create a <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>(s) that points to the parameter object</li></ol><p>Infinite domain definition is described above in the  <a href="../domains/#infinite_domains_docs">Infinite Domains</a> section. The supports should be  a vector of finite numbers that are drawn from the domain of the infinite domain.  These supports will be used to transcribe the <code>InfiniteModel</code> in preparation for  it to be optimized. If desired, the supports can be specified after the parameter  is defined and the support container of the defined parameter will be temporarily  empty.</p><p><a href="../../manual/parameter/#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> is an abstract data type that encompasses all concrete  infinite parameter types. The concrete type for individual infinite parameters  is <a href="../../manual/parameter/#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a>, since these parameters are independent from  other parameters. On the other hand, <a href="../../manual/parameter/#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> handle  multivariate infinite parameters, within which each individual parameter is not  independent. These are useful for characterizing, for example, parameters  subject to multivariate distribution.</p><p>Regardless of the specific concrete type, the <a href="../../manual/finite_parameter/#InfiniteOpt.build_parameter-Tuple{Function, Real}"><code>build_parameter</code></a> function  is used to construct an <code>InfOptParameter</code>. For example, let&#39;s create a time  parameter <span>$t \in [0, 10]$</span> with supports <code>[0, 2, 5, 7, 10]</code>:</p><pre><code class="language-julia-repl">julia&gt; domain = IntervalDomain(0, 10)
[0, 10]

julia&gt; t_param = build_parameter(error, domain, supports = [0, 2, 5, 7, 10]);</code></pre><p>Now that we have a <code>InfOptParameter</code> that contains an <code>IntervalDomain</code> and supports,  let&#39;s now add <code>t_param</code> to our <code>InfiniteModel</code> using <a href="../../manual/finite_parameter/#InfiniteOpt.add_parameter-Tuple{InfiniteModel, FiniteParameter, String}"><code>add_parameter</code></a>  and assign it the name of <code>t</code>: </p><pre><code class="language-julia-repl">julia&gt; t_ref = add_parameter(model, t_param, &quot;t&quot;)
t</code></pre><p>We can also create an anonymous infinite parameter by dropping the name from  the <code>add_parameter</code> function call. For example:</p><pre><code class="language-julia-repl">julia&gt; t_ref_noname = add_parameter(model, t_param)
noname</code></pre><p>Now suppose we want to create an infinite parameter that is a random variable  with a given distribution. We follow the same procedure as above, except we use  distributions from <code>Distributions.jl</code> to define a <a href="../../manual/domains/#InfiniteOpt.UniDistributionDomain"><code>UniDistributionDomain</code></a>.  For example, let&#39;s consider a random variable <span>$x \in \mathcal{N}(0,1)$</span> with  supports <code>[-0.5, 0.5]</code>:</p><pre><code class="language-julia-repl">julia&gt; dist = Normal(0., 1.)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; domain = UniDistributionDomain(dist)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; x_param = build_parameter(error, domain, supports = [-0.5, 0.5]);</code></pre><p>Again, we use <a href="../../manual/finite_parameter/#InfiniteOpt.add_parameter-Tuple{InfiniteModel, FiniteParameter, String}"><code>add_parameter</code></a> to add <code>x_param</code> to the <code>InfiniteModel</code> and  assign it the name <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; x_ref = add_parameter(model, x_param, &quot;x&quot;)
x</code></pre><p>Note that <code>add_parameter</code> does not register the name of the parameters into the  model that it adds to. As shown in <a href="#param_macro">Macro Definition</a>, the  macro definition does not allow for multiple parameters sharing the same name and  will throw an error if it happens.</p><p>For dependent parameters, we do not provide a publicly available <code>build_parameter</code>   method due to inherent complexities. Thus, it is recommended to construct these   using <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. However, these can be constructed manually  via the basic constructor for <a href="../../manual/parameter/#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> and then invoking  <a href="../../manual/parameter/#InfiniteOpt.add_parameters"><code>add_parameters</code></a>. Note that this should be done with caution since most  error checking will be omitted in this case.</p><h2 id="param_macro"><a class="docs-heading-anchor" href="#param_macro">Macro Definition</a><a id="param_macro-1"></a><a class="docs-heading-anchor-permalink" href="#param_macro" title="Permalink"></a></h2><h3 id="One-Dimensional-Parameters"><a class="docs-heading-anchor" href="#One-Dimensional-Parameters">One-Dimensional Parameters</a><a id="One-Dimensional-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#One-Dimensional-Parameters" title="Permalink"></a></h3><p>One user-friendly way of defining infinite parameters is by macro  <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. The macro executes the same process as the  manual definition (steps listed in <a href="#Parameter-Definition">Parameter Definition</a>), but allows  the users to manipulate several features of the defined infinite parameters.  Again, let&#39;s consider a time parameter <span>$t \in [0, 10]$</span> with supports  <code>[0, 2, 5, 7, 10]</code>. We use <code>in</code> (or <code>∈</code>) to define the domain that an infinite  parameter is subject to (any <a href="../../manual/domains/#InfiniteOpt.InfiniteScalarDomain"><code>InfiniteScalarDomain</code></a> for single  parameters). For example, we can define <span>$t \in [0, 10]$</span>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0, 2, 5, 7, 10])
t</code></pre><p>In a similar way, we can define a random infinite parameter subject to some  distribution using <code>~</code> as the operator. For example, a Gaussian infinite  parameter with mean 0 and standard deviation 1 can be defined:</p><pre><code class="language-julia-repl">julia&gt; using Distributions

julia&gt; dist = Normal(0., 1.)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; @infinite_parameter(model, ξ ~ dist, num_supports = 10)
ξ</code></pre><p>For anonymous definition, we use either the <code>domain</code> or <code>distribution</code> keywords:</p><pre><code class="language-julia-repl">julia&gt; t = @infinite_parameter(model, domain = [0, 10], supports = [0, 2, 5, 7, 10], 
                               base_name = &quot;t&quot;)
t

julia&gt; ξ = @infinite_parameter(model, distribution = dist, num_supports = 10, 
                               base_name = &quot;ξ&quot;)
ξ</code></pre><p>All the definitions above return a <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> that refers to  the parameter object.</p><h3 id="Multi-Dimensional-Parameters"><a class="docs-heading-anchor" href="#Multi-Dimensional-Parameters">Multi-Dimensional Parameters</a><a id="Multi-Dimensional-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Dimensional-Parameters" title="Permalink"></a></h3><p>We can also define multi-dimensional infinite parameters in a concise way. For  example, consider a position parameter <span>$x \in [0, 1]^3$</span>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], independent = true, num_supports = 3)
3-element Vector{GeneralVariableRef}:
 x[1]
 x[2]
 x[3]</code></pre><p>Here we used <code>independent = true</code> to signify that each <code>x[i]</code> can be treated  independently. Hence, the overall infinite domain is the cartesian product of  their individual domains. In this example, we defined 3 supports for each <code>x[i]</code>  such that there will be <span>$3^3 = 27$</span> supports for the overall domain:</p><pre><code class="language-julia-repl">julia&gt; supports(x[1])
3-element Vector{Float64}:
 0.0
 0.5
 1.0

julia&gt; supports(x)
3×27 Matrix{Float64}:
 0.0  0.5  1.0  0.0  0.5  1.0  0.0  0.5  …  1.0  0.0  0.5  1.0  0.0  0.5  1.0
 0.0  0.0  0.0  0.5  0.5  0.5  1.0  1.0     0.0  0.5  0.5  0.5  1.0  1.0  1.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0</code></pre><p>For multivariate random infinite parameters, we commonly wish their individual  domains to not be treated independently. Hence, we&#39;ll want <code>independent = false</code>  (the default value). For example, a 2-dimensional parameter  <span>$\theta \sim \mathcal{N}(\mu, \Sigma)$</span> is defined:</p><pre><code class="language-julia-repl">julia&gt; dist = MvNormal([0, 0], [1 0; 0 2])
FullNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 2.0]
)

julia&gt; @infinite_parameter(model, θ[1:2] ~ dist, num_supports = 3)
2-element Vector{GeneralVariableRef}:
 θ[1]
 θ[2]</code></pre><p>Here 3 supports are generated for all the parameters simultaneously according to  the distribution. </p><pre><code class="language-julia-repl">julia&gt; supports(θ)
2×3 Matrix{Float64}:
 -0.353007  0.679107  0.586617
 -0.190712  1.17155   0.420496</code></pre><p>We refer to groups of parameters defined this way as dependent infinite  parameters. In principle, nonrandom infinite parameter types can be made  dependent as well when users wish to avoid the cartesian product of their  supports.</p><p>Anonymous groups of parameters can be defined as follows:</p><pre><code class="language-julia-repl">julia&gt; x = @infinite_parameter(model, [1:3] in [0, 1], independent = true, 
                               num_supports = 3, base_name = &quot;x&quot;)
3-element Vector{GeneralVariableRef}:
 x[1]
 x[2]
 x[3]

julia&gt; θ = @infinite_parameter(model, [1:2] ~ dist, num_supports = 3, base_name = &quot;θ&quot;)
2-element Vector{GeneralVariableRef}:
 θ[1]
 θ[2]</code></pre><h3 id="Containers-for-Multi-Dimensional-Parameters"><a class="docs-heading-anchor" href="#Containers-for-Multi-Dimensional-Parameters">Containers for Multi-Dimensional Parameters</a><a id="Containers-for-Multi-Dimensional-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Containers-for-Multi-Dimensional-Parameters" title="Permalink"></a></h3><p>Because we build on JuMP, we can use any indices we like when making containers  (e.g., arrays) for multi-dimensional parameters. For example, we can define:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[i = [:a, :b]] in [0, 1])
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, [:a, :b]
And data, a 2-element Vector{GeneralVariableRef}:
 x[a]
 x[b]</code></pre><p>See  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/containers/"><code>JuMP</code>&#39;s documentation on containers</a>  for more information.</p><h2 id="Supports"><a class="docs-heading-anchor" href="#Supports">Supports</a><a id="Supports-1"></a><a class="docs-heading-anchor-permalink" href="#Supports" title="Permalink"></a></h2><p>For an infinite parameter, its supports are a finite set of points that the  parameter will take (or possibly take, if the parameter is random). During the  transcription stage, the supports specified will become part of the grid points  that approximate all functions parameterized by the infinite parameter.</p><p>Once an infinite parameter is defined, users can access the supports using  <a href="../../manual/expression/#InfiniteOpt.supports-Tuple{GeneralVariableRef}"><code>supports</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0, 2, 5, 7, 10])
t

julia&gt; supports(t)
5-element Vector{Float64}:
  0.0
  2.0
  5.0
  7.0
 10.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Most support query functions have a keyword argument <code>label</code> that is used  the specify the type of supports that will be involved in the query. By default,  this will be <code>PublicLabel</code> which will correspond to any supports that are  reported to the user by default, but will exclude any supports that have  <code>InternalLabel</code>s (e.g., internal collocation nodes). The full set can always  be obtained via <code>label = All</code>. We can also query more specific subsets of  support information with more specific labels such as <code>label = UniformGrid</code>.</p></div></div><p>We also provide functions that access other related information about the  supports. For example, <a href="../../manual/expression/#InfiniteOpt.has_supports-Tuple{GeneralVariableRef}"><code>has_supports</code></a> checks whether a parameter has  supports, while <a href="../../manual/expression/#InfiniteOpt.num_supports-Tuple{GeneralVariableRef}"><code>num_supports</code></a> gives the number of supports associated  with a parameter:</p><pre><code class="language-julia-repl">julia&gt; has_supports(t)
true

julia&gt; num_supports(t)
5</code></pre><p>Now suppose we want to add more supports to the <code>t</code>, which is already assigned  with some supports. We can use <a href="../../manual/expression/#InfiniteOpt.add_supports-Tuple{GeneralVariableRef, Union{Real, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}}"><code>add_supports</code></a> function to achieve this  goal:</p><pre><code class="language-julia-repl">julia&gt; add_supports(t, [3, 8])

julia&gt; supports(t)
7-element Vector{Float64}:
  0.0
  2.0
  3.0
  5.0
  7.0
  8.0
 10.0</code></pre><p>At times we might want to change the supports completely. In those cases, the  function <a href="../../manual/expression/#InfiniteOpt.set_supports-Tuple{GeneralVariableRef, Union{Real, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}}"><code>set_supports</code></a> resets the supports for a certain parameter with  new supports provided:</p><pre><code class="language-julia-repl">julia&gt; set_supports(t, [0,3,5,8,10], force = true)

julia&gt; supports(t)
5-element Vector{Float64}:
  0.0
  3.0
  5.0
  8.0
 10.0</code></pre><p>Note that the keyword argument [<code>force</code>] must be set as [<code>true</code>] if the  parameter has been assigned with supports. Users can also delete all the  supports of a parameter with <a href="../../manual/expression/#InfiniteOpt.delete_supports-Tuple{GeneralVariableRef}"><code>delete_supports</code></a>.</p><h3 id="Automatic-Support-Generation-During-Parameter-Definition"><a class="docs-heading-anchor" href="#Automatic-Support-Generation-During-Parameter-Definition">Automatic Support Generation During Parameter Definition</a><a id="Automatic-Support-Generation-During-Parameter-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Support-Generation-During-Parameter-Definition" title="Permalink"></a></h3><p>For the examples in the <a href="#Parameter-Definition">Parameter Definition</a>, we have seen how to  manually add supports to an infinite parameter. For a quick automatic  generation of support points, though, users do not have to input the support  points. Instead, the number of support points generated is supplied.</p><p>For an infinite parameter subject to an <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a>, uniformly spaced  supports including both ends are generated across the interval. For example,  defining a time parameter <span>$t \in [0, 10]$</span> with 4 supports using  <a href="../../manual/finite_parameter/#InfiniteOpt.build_parameter-Tuple{Function, Real}"><code>build_parameter</code></a> gives</p><pre><code class="language-julia-repl">julia&gt; domain = IntervalDomain(0, 10)
[0, 10]

julia&gt; t_param = build_parameter(error, domain, num_supports = 4, sig_digits = 3);</code></pre><p>Using macro definition we have</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 4, sig_digits = 3)
t

julia&gt; supports(t)
4-element Vector{Float64}:
  0.0   
  3.33
  6.67
 10.0   
</code></pre><p>Note that the user can use the keyword argument <code>sig_digits</code> to dictate the  significant figures for the supports. The default value of <code>sig_digits</code> is 12.</p><p>For an infinite parameter that follows a univariate distribution,  supports are sampled from the underlying distribution. For example, we can  define an infinite parameter subject to a normal distribution with mean 0 and  variance 1:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x ~ Normal(), num_supports = 4)
x

julia&gt; supports(x)
4-element Vector{Float64}:
 -0.353007400301
 -0.134853871931
  0.679107426036
  0.8284134829  </code></pre><p>For multivariate distributions, though, we require support points are provided  in the definition. However, we can use <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> to generate  supports for parameters following multivariate distributions. See  <a href="#Automatic-Support-Generation-For-Defined-Parameters">Automatic Support Generation For Defined Parameters</a> for details.</p><h3 id="Automatic-Support-Generation-For-Defined-Parameters"><a class="docs-heading-anchor" href="#Automatic-Support-Generation-For-Defined-Parameters">Automatic Support Generation For Defined Parameters</a><a id="Automatic-Support-Generation-For-Defined-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Support-Generation-For-Defined-Parameters" title="Permalink"></a></h3><p>So far, we have seen that in both definition methods it is allowed to initialize  a parameter with no supports. This is done by not specifying <code>supports</code> and  <code>num_supports</code>. However, infinite parameters would not be allowed at the  transcription step since it needs information about how to discretize the  infinite parameters. In previous examples, we have shown that users can add  supports to a defined parameter using methods <a href="../../manual/expression/#InfiniteOpt.add_supports-Tuple{GeneralVariableRef, Union{Real, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}}"><code>add_supports</code></a> and  <a href="../../manual/expression/#InfiniteOpt.set_supports-Tuple{GeneralVariableRef, Union{Real, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}}"><code>set_supports</code></a>.</p><p>In this section we introduce automatic support generation for defined  parameters with no associated supports. This can be done using the  <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> functions. <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> can take as  argument a <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> or an  <code>AbstractArray{&lt;:GeneralVariableRef}</code>, in which case it will generate  supports for the associated infinite parameter. Alternatively,  <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> can also take an <a href="../../manual/model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> as an  argument, in which case it will generate supports for all infinite parameters  of the <a href="../../manual/model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> with no supports.</p><p>The <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> method allows users to specify integer keyword  arguments <code>num_supports</code> and <code>sig_digits</code>. <code>num_supports</code> dictates the  number of supports to be generated, and <code>sig_digits</code> dictates the significant  figures of generated supports desired. The default values are 10 and 12,  respectively.</p><p>The ways by which supports are automatically generated are as follows. If the  parameter is in an <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a>, then we generate an array of supports  that are uniformly distributed along the interval, including the two ends. For  example, consider a 3D position parameter <code>x</code> distributed in the unit cube  <code>[0, 1]</code>. We can generate supports for that point in the following way:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], independent = true);

julia&gt; fill_in_supports!.(x, num_supports = 3);

julia&gt; supports.(x)
3-element Vector{Vector{Float64}}:
 [0.0, 0.5, 1.0]
 [0.0, 0.5, 1.0]
 [0.0, 0.5, 1.0]</code></pre><p>Note that the dot syntax because <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> takes single  <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> as argument. In each dimension, three equally spaced  supports (<code>[0.0, 0.5, 1.0]</code>) are generated. Since the <code>independent</code> keyword is  set as <code>true</code>, the transcription stage will create a three-dimensional grid for  all variables parameterized by <code>x</code>, with each point separated by 0.5 units in  each dimension. We can view this grid by simply invoking <code>supports</code> without the   vectorized syntax:</p><pre><code class="language-julia-repl">julia&gt; supports(x)
3×27 Matrix{Float64}:
 0.0  0.5  1.0  0.0  0.5  1.0  0.0  0.5  …  1.0  0.0  0.5  1.0  0.0  0.5  1.0
 0.0  0.0  0.0  0.5  0.5  0.5  1.0  1.0     0.0  0.5  0.5  0.5  1.0  1.0  1.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0</code></pre><p>If the parameter is in a <a href="../../manual/domains/#InfiniteOpt.UniDistributionDomain"><code>UniDistributionDomain</code></a> or  <a href="../../manual/domains/#InfiniteOpt.MultiDistributionDomain"><code>MultiDistributionDomain</code></a>, <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a>  samples <code>num_supports</code> supports from the distribution. Recall that support  generation is not allowed for parameters under multivariate distribution during  parameter definition. However, if the parameter is defined first without  supports, <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> allows for supports generation. For  example, for a 2D random variable <code>ξ</code> under a multivariate Gaussian  distribution, we can generate supports for it in the following way:</p><pre><code class="language-julia-repl">julia&gt; dist = MvNormal([0., 0.], [1. 0.; 0. 2.])
FullNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 2.0]
)


julia&gt; @infinite_parameter(model, ξ[1:2] ~ dist);

julia&gt; fill_in_supports!(ξ, num_supports = 3)

julia&gt; supports(ξ)
2×3 Matrix{Float64}:
 -0.353007  0.679107  0.586617
 -0.190712  1.17155   0.420496</code></pre><p>Note that <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> only fill in supports for parameters with no  associated supports. To modify the supports of parameters already associated  with some supports, refer to <a href="#Supports">Supports</a> for how to do that.</p><h2 id="Parameter-Queries"><a class="docs-heading-anchor" href="#Parameter-Queries">Parameter Queries</a><a id="Parameter-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Queries" title="Permalink"></a></h2><p>In addition to the modeling framework, this package provides many functions for  users to access information about the model. This section will go over basic  functions for accessing parameter information.</p><p>Once a (possibly large-scale) <code>InfiniteModel</code> is built, the users might want to  check if an infinite parameter is actually used in any way. This could be  checked by <a href="../../manual/expression/#InfiniteOpt.is_used-Tuple{ParameterFunctionRef}"><code>is_used</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1])
x

julia&gt; is_used(x)
false
</code></pre><p>This function checks if the parameter is used by any constraint, measure, or  variable. In a similar way, functions <a href="../../manual/expression/#InfiniteOpt.used_by_constraint-Tuple{ParameterFunctionRef}"><code>used_by_constraint</code></a>,  <a href="../../manual/expression/#InfiniteOpt.used_by_measure-Tuple{ParameterFunctionRef}"><code>used_by_measure</code></a> and <a href="../../manual/expression/#InfiniteOpt.used_by_infinite_variable-Tuple{GeneralVariableRef}"><code>used_by_infinite_variable</code></a> can be applied to  find out any dependency of specific types on the infinite parameter.</p><p>In addition, sometimes we need to check if a certain <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>  for an infinite parameter is valid with an <code>InfiniteModel</code> model, meaning that the  parameter reference actually refers to some parameter associated with the model. We  extend the <a href="../../manual/constraint/#JuMP.is_valid-Tuple{InfiniteModel, InfOptConstraintRef}"><code>JuMP.is_valid</code></a> function from JuMP for that purpose. To see how  to use this, for example,</p><pre><code class="language-julia-repl">julia&gt; pref1 = GeneralVariableRef(model, 1, IndependentParameterIndex);

julia&gt; pref2 = GeneralVariableRef(model, 2, IndependentParameterIndex);

julia&gt; is_valid(model, pref1)
true

julia&gt; is_valid(model, pref2)
false</code></pre><p>The second call of <a href="../../manual/constraint/#JuMP.is_valid-Tuple{InfiniteModel, InfOptConstraintRef}"><code>is_valid</code></a> returns <code>false</code> because the model does  not have parameter with index 2 yet.</p><p>We can also access different information about the domain that the infinite  parameter is in. This is given by <a href="../../manual/expression/#InfiniteOpt.infinite_domain-Tuple{GeneralVariableRef}"><code>infinite_domain</code></a>, which takes a  [<code>GeneralVariableRef</code>] as argument. For example, we have</p><pre><code class="language-julia-repl">julia&gt; infinite_domain(x)
[0, 1]</code></pre><p><a href="../../manual/expression/#InfiniteOpt.infinite_domain-Tuple{GeneralVariableRef}"><code>infinite_domain</code></a> might be more useful if the infinite parameter is in a  <a href="../../manual/domains/#InfiniteOpt.UniDistributionDomain"><code>UniDistributionDomain</code></a> or <a href="../../manual/domains/#InfiniteOpt.MultiDistributionDomain"><code>MultiDistributionDomain</code></a>, by which users  can access information about the underlying distribution. On the other hand,  if we already know that the parameter is in an interval domain, we can use  <a href="../../manual/domains/#JuMP.has_lower_bound-Tuple{AbstractInfiniteDomain}"><code>JuMP.has_lower_bound</code></a>, <a href="../../manual/domains/#JuMP.lower_bound-Tuple{AbstractInfiniteDomain}"><code>JuMP.lower_bound</code></a>,  <a href="../../manual/domains/#JuMP.has_upper_bound-Tuple{AbstractInfiniteDomain}"><code>JuMP.has_upper_bound</code></a>, <a href="../../manual/domains/#JuMP.upper_bound-Tuple{AbstractInfiniteDomain}"><code>JuMP.upper_bound</code></a> to retrieve information  about the interval domain in a more specific way:</p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(x)
true

julia&gt; lower_bound(x)
0.0

julia&gt; has_upper_bound(x)
true

julia&gt; upper_bound(x)
1.0</code></pre><p>A quick way for users to obtain a <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> for a parameter with  a known name would be through <a href="../../manual/parameter/#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel, String}"><code>parameter_by_name</code></a> function. This  function takes an <a href="../../manual/model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> and the parameter name in string,  and returns a <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> for that parameter. For example, </p><pre><code class="language-julia-repl">julia&gt; pref = parameter_by_name(model, &quot;x&quot;)
x</code></pre><p>If there is no parameter associated with that name, the function would return  nothing. Otherwise, if multiple parameters share the same name, the function  would throw an error.</p><p>Now we introduce two additional functions that we can use to access parameter  information for an  <a href="../../manual/model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a>. The function  <a href="../../manual/parameter/#InfiniteOpt.num_parameters"><code>num_parameters</code></a> returns the number of infinite parameters associated  with a model, while <a href="../../manual/parameter/#InfiniteOpt.all_parameters"><code>all_parameters</code></a> returns the list of all infinite  parameter references in the model. For a quick example: </p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, y[1:2] in [0, 5])
2-element Vector{GeneralVariableRef}:
 y[1]
 y[2]

julia&gt; num_parameters(model)
3

julia&gt; all_parameters(model)
3-element Vector{GeneralVariableRef}:
 x   
 y[1]
 y[2]</code></pre><h2 id="Parameter-Modification"><a class="docs-heading-anchor" href="#Parameter-Modification">Parameter Modification</a><a id="Parameter-Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Modification" title="Permalink"></a></h2><p>In this section we introduce a few shortcuts for users to modify defined  infinite parameters.</p><p>First, once an infinite parameter is defined, we can change its name by calling  the [<code>JuMP.set_name</code>] function, which takes the [<code>GeneralVariableRef</code>] of  the parameter that needs a name change and the name string as arguments. For  example, to change the parameter <code>x</code> to <code>t</code> we can do:</p><pre><code class="language-julia-repl">julia&gt; JuMP.set_name(x, &quot;t&quot;)

julia&gt; all_parameters(model)
3-element Vector{GeneralVariableRef}:
 t   
 y[1]
 y[2]</code></pre><p>In a similar way, we can also change the infinite domain that the parameter is in  using the <a href="../../manual/expression/#InfiniteOpt.set_infinite_domain-Tuple{GeneralVariableRef, InfiniteScalarDomain}"><code>set_infinite_domain</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; t = parameter_by_name(model, &quot;t&quot;)
t

julia&gt; set_infinite_domain(t, IntervalDomain(0, 5))

julia&gt; infinite_domain(t)
[0, 5]</code></pre><p>For parameters in an <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a>, we extend  <a href="../../manual/domains/#JuMP.set_lower_bound-Tuple{AbstractInfiniteDomain, Real}"><code>JuMP.set_lower_bound</code></a> and <a href="../../manual/domains/#JuMP.set_upper_bound-Tuple{AbstractInfiniteDomain, Real}"><code>JuMP.set_upper_bound</code></a> functions  for users to modify the lower bounds and upper bounds. For example,</p><pre><code class="language-julia-repl">julia&gt; JuMP.set_lower_bound(t, 1)

julia&gt; JuMP.set_upper_bound(t, 4)

julia&gt; infinite_domain(t)
[1, 4]</code></pre><p>We do not support setting lower bounds and upper bounds for random parameters  in a <a href="../../manual/domains/#InfiniteOpt.UniDistributionDomain"><code>UniDistributionDomain</code></a> and will throw an error if users attempt to do  so. If users want to set lower bound and upper bound for a random infinite  parameter, consider using <code>Distributions.Truncated</code>, which creates a truncated  distribution from a univariate distribution.</p><h2 id="gen_supp_docs"><a class="docs-heading-anchor" href="#gen_supp_docs">Generative Supports</a><a id="gen_supp_docs-1"></a><a class="docs-heading-anchor-permalink" href="#gen_supp_docs" title="Permalink"></a></h2><p>Generative supports denote supports that are generated based on existing supports   (treated as finite elements). These are important for enabling certain measure   and derivative evaluation schemes. Examples of such supports include internal   collocation nodes and quadrature supports generated for quadrature methods that  decompose the infinite domain such that existing supports are incorporated. Users  shouldn&#39;t modify these directly, but extension writers will need to utilize the  generative support API when developing measures and/or derivative evaluation  methods that need to generate supports based on existing ones (e.g., adding  a new orthogonal collocation method). More information about extension writing  for either case is given on the <a href="../../develop/extensions/#Extensions">Extensions</a> page. For enhanced context, we  outline the general API below.</p><p>Information about producing generative supports are stored via concrete subtypes  of <a href="../../manual/parameter/#InfiniteOpt.AbstractGenerativeInfo"><code>AbstractGenerativeInfo</code></a>. Each <code>IndependentParameter</code> stores one of  these objects (the default being <a href="../../manual/parameter/#InfiniteOpt.NoGenerativeSupports"><code>NoGenerativeSupports</code></a>). Hence, a  particular independent parameter can only be associated with 1 generative support  scheme. We currently provide 1 concrete generative subtype of  <code>AbstractGenerativeInfo</code> which is <a href="../../manual/parameter/#InfiniteOpt.UniformGenerativeInfo"><code>UniformGenerativeInfo</code></a>.  <code>UniformGenerativeInfo</code> stores the necessary information to make generative  supports that are uniformly applied to each finite element formed by the existing  supports. For example, let&#39;s say we want to use a generative support scheme that  adds 1 generative support exactly in the middle of each finite element with a  unique support label to we&#39;ll call <code>MyGenLabel</code>:</p><pre><code class="language-julia-repl">julia&gt; struct MyGenLabel &lt;: InfiniteOpt.InternalLabel end;

julia&gt; UniformGenerativeInfo([0.5], MyGenLabel)
UniformGenerativeInfo([0.5], MyGenLabel)</code></pre><p>Users can make other generative support schemes as described on the <a href="../../develop/extensions/#Extensions">Extensions</a>  page. </p><p>These <code>AbstractGenerativeInfo</code> objects are added to parameters as needed via the  addition of measures and/or derivative methods that require generative supports.  We can always check what generative information is currently associated with a  particular parameter via <a href="../../manual/parameter/#InfiniteOpt.generative_support_info-Tuple{IndependentParameterRef}"><code>generative_support_info</code></a>.  The generation of these supports is handled automatically at the appropriate  times via <a href="../../manual/parameter/#InfiniteOpt.add_generative_supports"><code>add_generative_supports</code></a>. We can always check if generative  supports have been created for a particular parameter with  <a href="../../manual/expression/#InfiniteOpt.has_generative_supports-Tuple{GeneralVariableRef}"><code>has_generative_supports</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../domains/">« Infinite Domains</a><a class="docs-footer-nextpage" href="../finite_parameter/">Finite Parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 June 2021 21:04">Wednesday 23 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
