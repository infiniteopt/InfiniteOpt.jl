<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measures · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li class="is-active"><a class="tocitem" href>Measures</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#measure_basic_usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Theoretical-Abstraction"><span>Theoretical Abstraction</span></a></li><li><a class="tocitem" href="#Measure-Data-Generation"><span>Measure Data Generation</span></a></li><li><a class="tocitem" href="#Evaluation-Methods"><span>Evaluation Methods</span></a></li><li><a class="tocitem" href="#Expansion"><span>Expansion</span></a></li></ul></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../manual/optimize/">Optimization</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Measures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/measure.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="measure_docs"><a class="docs-heading-anchor" href="#measure_docs">Measure Operators</a><a id="measure_docs-1"></a><a class="docs-heading-anchor-permalink" href="#measure_docs" title="Permalink"></a></h1><p>A guide for measure operators in <code>InfiniteOpt</code>. See the respective  <a href="../../manual/measure/#measure_manual">technical manual</a> for more details.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Measure operators are objects that capture the evaluation of an expression with respect  to parameters, which is a distinct feature of optimization problems with  infinite decision spaces. In dynamic optimization measures can represent integral  terms such as the total cost over time, and in stochastic optimization measures  can represent integrals over the uncertain parameters, such as expectations. In  <code>InfiniteOpt</code>, measures are general operators that can be uni-variate or   multi-variate. Natively we employ measure abstractions that employ discretization   schemes, which evaluate the expression at a set of points over the parameter space and  approximates the measures based on the expression values at these points. However,  we support the use of alternative measure operator paradigms.</p><h2 id="measure_basic_usage"><a class="docs-heading-anchor" href="#measure_basic_usage">Basic Usage</a><a id="measure_basic_usage-1"></a><a class="docs-heading-anchor-permalink" href="#measure_basic_usage" title="Permalink"></a></h2><p>First, we consider a dynamic optimization problem with the time parameter <code>t</code>  from 0 to 10. We also consider a state variable <code>y(t)</code> and a control variable  <code>u(t)</code> that are parameterized by <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0, 5, 10])
t

julia&gt; @variable(model, y, Infinite(t))
y(t)

julia&gt; @variable(model, u, Infinite(t))
u(t)</code></pre><p>Now suppose we want to evaluate the integral <span>$\int_{2}^{8}y(t)^2 + u(t)^2 dt$</span>.  We can construct a measure to represent this integral using the  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a> function</p><pre><code class="language-julia-repl">julia&gt; mref1 = integral(y^2 + u^2, t, 2, 8)
∫{t ∈ [2, 8]}[y(t)² + u(t)²]</code></pre><p>The four positional arguments of <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a> are the integrand expression,   the parameter of integration, the lower bound, and the upper bound, respectively.  Specifying the integrand expression and the parameter of integration is required.  If the lower and upper bounds are not specified, then the integration will  be over the entire domain, which is <span>$[0, 10]$</span> in this case.</p><p>The <code>integral</code> function uses trapezoid rule as the default discretization scheme  for univariate parameters in finite <code>IntervalDomain</code>s. In addition, the user can also  use quadrature methods for univariate parameters in all <code>IntervalDomain</code>s by setting  the keyword argument <code>eval_method</code> as <code>Quadrature()</code>:</p><pre><code class="language-julia-repl">julia&gt; mref2 = integral(y^2 + u^2, t, eval_method = Quadrature())
∫{t ∈ [0, 10]}[y(t)² + u(t)²]</code></pre><p>The <code>integral</code> function also allows for specifying other keyword arguments that  correspond to the chosen evaluation method. For example, when using  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>FEGaussLobatto</code></a> as the evaluation method we can specify the number of  discretization points per finite element via <code>num_nodes</code>. </p><pre><code class="language-julia-repl">julia&gt; mref3 = ∫(y^2 + u^2, t, eval_method = FEGaussLobatto(), num_nodes = 3)
∫{t ∈ [0, 10]}[y(t)² + u(t)²]</code></pre><p>Notice here how we used <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>∫</code></a> in place of <code>integral</code> as a convenient wrapper.</p><p>Two other explicit measure type methods include <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a> for expectations  and <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.support_sum"><code>support_sum</code></a> for summing an expression over the support points of  selected infinite parameters. The syntax for these is analogous to that of <code>integral</code>  except that there are no lower/upper bounds. For example, we can define the following  expectation of a random expression:</p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel();

julia&gt; @infinite_parameter(m, ξ ~ Normal(), num_supports = 100);

julia&gt; @variable(m, x, Infinite(ξ));

julia&gt; expect_x = expect(x^2, ξ)
𝔼{ξ}[x(ξ)²]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For integrals, expectations, and support sums involving moderate to large  expressions, the macro versions <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a>, <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a>, and  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.@support_sum"><code>@support_sum</code></a> should be used instead of their functional equivalents  for better performance.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For convenience in compact representation we can use <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>∫</code></a>, <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.@∫"><code>@∫</code></a>,  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.𝔼"><code>𝔼</code></a>, and <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.@𝔼"><code>@𝔼</code></a> as wrappers for <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a>,  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a>, <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a>, and <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a>, respectively.</p></div></div><p>Other measure paradigms can be implemented via <a href="../../manual/measure/#InfiniteOpt.measure"><code>measure</code></a> as described in  the sections further below.</p><p>Depending on the type of measures created, support points may be generated  at the time of creating the measures. In these cases, the new support points  will be added to the support list of the integrated parameter.</p><p>Once a measure is created, the evaluation of that measure is stored in a  measure data object. Users can query the measure data object using the  <a href="../../manual/measure/#InfiniteOpt.measure_data"><code>measure_data</code></a> function as follows </p><pre><code class="language-julia-repl">julia&gt; meas_data = measure_data(mref2);</code></pre><p>Natively in <code>InfiniteOpt</code>, two types of measure data objects are used to store the measure  data information depending on the nature of the measures created: <code>DiscreteMeasureData</code> and  <code>FunctionalDiscreteMeasureData</code>. For more details on the measure data object,  refer to <a href="#Measure-Data-Generation">Measure Data Generation</a>.</p><p>Similarly, one can also query the expression the measure operates on using  <a href="../../manual/measure/#InfiniteOpt.measure_function"><code>measure_function</code></a>:</p><pre><code class="language-julia-repl">julia&gt; measure_function(mref3)
y(t)² + u(t)²</code></pre><p>In addition to <code>eval_method</code>, the <code>integral</code> function  also accepts <code>weight_func</code> as keyword argument, which dictates the weight function  of the measure. Now suppose we want to create multiple measures that share the   same keyword argument values that are different from the defaults. We don&#39;t have  to input the keyword argument values every time we construct a new measure.  Instead, we can modify the default values of measure keyword arguments, and  construct measures using the new default values. To do that, we use the functions  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>set_uni_integral_defaults</code></a> and <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>set_multi_integral_defaults</code></a>. We  can in turn reset these via <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults"><code>clear_uni_integral_defaults</code></a> and  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults"><code>clear_multi_integral_defaults</code></a>. Adding new keyword arguments will be  useful if users want to extend the measure functions with their custom  representation/evaluation schemes that need to take additional arguments somehow.  See <a href="../../develop/extensions/#Extensions">Extensions</a> for more details.</p><p>We can also use the <code>pdf</code> keyword argument for [<code>expect</code>] over interval domains  which allows us to specify the density function we would like to use. </p><p>Now we can add measures to the constraints and objective functions in our  model. For more detailed information, please review the information below.</p><h2 id="Theoretical-Abstraction"><a class="docs-heading-anchor" href="#Theoretical-Abstraction">Theoretical Abstraction</a><a id="Theoretical-Abstraction-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Abstraction" title="Permalink"></a></h2><p>In <code>InfiniteOpt</code>, measures denote operators <span>$M_\ell$</span> that operate on some infinite  expression <span>$y$</span> over the infinite domain <span>$\mathcal{D}_\ell$</span> associated with  the infinite parameter <span>$\ell$</span>:</p><p class="math-container">\[M_{\ell}y : \mathcal{D}_{-\ell} \mapsto \mathbb{R}^{n_y}\]</p><p>Such a paradigm can capture a wide variety of mathematical operators commonly  encountered in infinite-dimensional programming such as integrals, expectations,  risk measures, and chance constraints.</p><p>Currently, <code>InfiniteOpt</code> natively contains programmatic objects for measures that  can be represented as integrals of the form:</p><p class="math-container">\[\int_{\tau \in \mathcal{T}} f(\tau)w(\tau) d\tau\]</p><p>where <span>$\tau$</span> is a (possibly multivariate) infinite parameter, <span>$f(\tau)$</span> is an  expression parameterized by <span>$\tau$</span>, <span>$w(\tau)$</span> is a weight function, and  <span>$\mathcal{T}$</span> is a subset of the domain of <span>$\tau$</span>. The measures approximate  the integrals by taking a discretization scheme</p><p class="math-container">\[\int_{\tau \in \mathcal{T}} f(\tau)w(\tau) d\tau \approx \sum_{i=1}^N \alpha_i f(\tau_i) w(\tau_i)\]</p><p>where <span>$\tau_i$</span> are the grid points where the expression <span>$f(\tau)$</span> is  evaluated, and <span>$N$</span> is the total number of points taken.</p><p>This is the abstraction behind both <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> and  <a href="../../manual/measure/#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a> which are the native measure data types  in InfiniteOpt. The <a href="#Measure-Data-Generation">Measure Data Generation</a> section below details how  these can be implemented to enable schemes that fit this mathematical paradigm, but  lie out of the realm of the supported features behind <code>integral</code>, <code>expect</code>, and  <code>support_sum</code>.</p><p>More complex measure paradigms can also be implemented by creating concrete  subtype of <a href="../../manual/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> as detailed in  <a href="../../develop/extensions/#meas_data_ext">Measure Data</a> Section on our extensions page.</p><h2 id="Measure-Data-Generation"><a class="docs-heading-anchor" href="#Measure-Data-Generation">Measure Data Generation</a><a id="Measure-Data-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-Data-Generation" title="Permalink"></a></h2><p>The general <a href="../../manual/measure/#InfiniteOpt.measure"><code>measure</code></a> function takes two arguments: the argument expression and  a measure data object that contains the details of the measure representation.  Measure data objects can be constructed using <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>,  where the parameter of integration, the coefficients <span>$\alpha_i$</span>, and the  support points need to be defined explicitly. For example, if we want to  evaluate a function at each integer time point between 0 and 10, we  can construct the following measure data object to record this discretization  scheme:</p><pre><code class="language-julia-repl">julia&gt; md_t = DiscreteMeasureData(t, ones(10), [i for i in 1:10]);</code></pre><p>The arguments of <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> are parameter, coefficients, and  supports. The default weight function is <span>$w(\tau) = 1$</span> for  any <span>$\tau$</span>, which can be overwritten by the keyword argument <code>weight_function</code>.  The <code>weight_function</code> should take a function that returns a number for any  value that is well defined for the integrated infinite parameter. The data type  is <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, which is a subtype of the abstract data type  <a href="../../manual/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><p>With <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, a measure can be generated in a custom and  quick manner. For example, using the measure data above, we can define a measure  for <span>$y^2$</span> as follows:</p><pre><code class="language-julia-repl">julia&gt; mref = measure(y^2, md_t)
measure{t}[y(t)²]</code></pre><p>In the same way, we can define measure data for multi-variate infinite parameters.  For example, we can define a discretization scheme for a 2D position parameter  <span>$x \in [0, 1] \times [0, 1]$</span> as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:2] in [0, 1])
2-element Vector{GeneralVariableRef}:
 x[1]
 x[2]

julia&gt; md_x = DiscreteMeasureData(x, 0.25 * ones(4), [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]]);</code></pre><p>where <code>md_x</code> cuts the domain into four 0.5-by-0.5 squares, and evaluates the  integrand on the center of these squares. Note that for multivariate parameters,   each support point should be an <code>AbstractArray</code> that stores the value at each dimension. </p><p>In addition to the intuitive [<code>DiscreteMeasureData</code>], another type of measure data   object is <a href="../../manual/measure/#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. This type captures measure data  where the support points are not known at the time of measure data creation. Instead of   storing the specific support and coefficient values, <code>FunctionalDiscreteMeasureData</code>  stores the minimum number of supports required for the measure, and a coefficient function  that maps supports to coefficients. When the measure is built on a <code>FunctionalDiscreteMeasureData</code>   is evaluated (expanded), supports will be generated based on the functions stored in   the data object. The method of support generation is recorded as a <code>label</code> in the  measure object. </p><p>For example, suppose we want to uniformly generate at least 20 Monte Carlo samples   over the interval that <code>t</code> is in. A build-in label <code>UniformGrid</code> can be used to  signify the use of this method. A <code>FunctionalDiscreteMeasureData</code> can be created as follows:</p><pre><code class="language-julia-repl">julia&gt; coeff_f(supports) = [(10 - 0) / length(supports) for i in supports]
coeff_f (generic function with 1 method)

julia&gt; fmd_t = FunctionalDiscreteMeasureData(t, coeff_f, 20, UniformGrid);</code></pre><p>For more details see <a href="../../manual/measure/#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. </p><p>Our higher-level measure methods, such as <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a>, do not require  explicit construction of the measure data object and instead serve as wrappers  that construct the appropriate data object and then call <a href="../../manual/measure/#InfiniteOpt.measure"><code>measure</code></a>.</p><h2 id="Evaluation-Methods"><a class="docs-heading-anchor" href="#Evaluation-Methods">Evaluation Methods</a><a id="Evaluation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Methods" title="Permalink"></a></h2><p>The <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a> function calls <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> under the hood  to construct the measure data object. <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> takes as  positional arguments the integrated parameter, lower bound, upper bound, and method, and returns  a measure data object of type <a href="../../manual/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><p><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> applies multiple dispatch to encode different  support generation methods depending on the input <code>eval_method</code>. Each dispatch is distinguished by  the <code>method</code>, which takes a concrete subtype of <code>AbstractIntegralMethod</code>.  Each dispatch of <code>generate_integral_data</code> implements the specified method and returns  the resulting measure data, which will be used by <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a> to create the measure.  A table of available <code>method</code> options in our package is listed below.  Each method is limited on the dimension of parameter and/or the type of domain  that it can apply for. For the details of what each method type means, refer to the corresponding  docstrings.</p><table><tr><th style="text-align: center">Evaluation Method</th><th style="text-align: center">Uni/Multi-Variate?</th><th style="text-align: center">Weight Function</th><th style="text-align: center">Domain Type</th></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic()</code></a></td><td style="text-align: center">Both</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Any</td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>UniTrapezoid()</code></a></td><td style="text-align: center">Both</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center"><a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>UniIndepMCSampling()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.Quadrature"><code>Quadrature()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center"><a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>GaussLegendre()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussRadau"><code>GaussRadau()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussJacobi"><code>GaussJacobi(α, β)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$(1-x)^\alpha (1+x)^\beta$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>GaussLobatto()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>FEGaussLobatto()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(1)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$\frac{1}{\sqrt{1-x^2}}$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(2)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$\sqrt{1-x^2}$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(3)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$\sqrt{(1+x)/(1-x)}$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(4)</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$\sqrt{(1-x)/(1+x)}$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>GaussLaguerre()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$e^{-x}$</span></td><td style="text-align: center">Semi-infinite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussHermite"><code>GaussHermite()</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><span>$e^{-x^2}$</span></td><td style="text-align: center">Infinite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling()</code></a></td><td style="text-align: center">Multivariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr><tr><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>MultiIndepMCSampling()</code></a></td><td style="text-align: center">Multivariate</td><td style="text-align: center"><span>$1$</span></td><td style="text-align: center">Finite <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a></td></tr></table><p>The eval method <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>FEGaussLobatto</code></a> creates finite elements by decomposing over the  supports that have been added to the integral parameter and then approximates the  integral over each finite element via Lobatto quadrature using num_nodes.  All other Gauss quadrature methods do not incorporate any existing supports nor  do they decompose the integral into finite elements, but instead generate their  quadrature node points over the entire integral domain. See the  <a href="#A-Note-on-Support-Management">A Note on Support Management</a> Section for more information. This method  will take in the user supports, and create generative supports along each interval  and match them with corresponding coefficients. Here is a depiction of such what  <code>FEGaussLobatto</code> does. </p><p><img src="../../assets/fe_lobatto.png" alt="lobatto"/></p><p><span>$\int_{x_1}^{x_3} f(x) dx = \int_{x_1}^{x_2} f(x) dx + \int_{x_2}^{x_3} f(x) dx$</span></p><p><span>$\approx \sum_{i=1}^{n} \alpha_{a,i} f(\tau_{a,i}) + \sum_{i=1}^{n} \alpha_{b,i} f(\tau_{b,i})$</span></p><p><span>$= \sum_{i=1}^{n} (\alpha_{a,i} f(\tau_{a,i}) + \alpha_{b,i} f(\tau_{b,i}))$</span></p><p>where <span>$\tau_{a,i}$</span> and <span>$\tau_{b,i}$</span> are the discrete nodes for the two intervals </p><p>and <span>$\alpha_{a,i}$</span> and <span>$\alpha_{b,i}$</span> are the coefficients.</p><pre><code class="language-julia-repl">julia&gt; mref_lob = integral(y^2 + u^2, t, num_nodes = 3, eval_method = FEGaussLobatto())
∫{t ∈ [0, 10]}[y(t)² + u(t)²]

julia&gt; expand(mref_lob)
0.8333333333333333 y(0)² + 0.8333333333333333 u(0)² + 3.333333333333333 y(2.5)² + 3.333333333333333 u(2.5)² + 1.6666666666666665 y(5)² + 1.6666666666666665 u(5)² + 3.333333333333333 y(7.5)² + 3.333333333333333 u(7.5)² + 0.8333333333333333 y(10)² + 0.8333333333333333 u(10)²
</code></pre><p>We set <code>num_nodes = 3</code> to define the number of nodes (supports) that will be used  at each finite element for the integral approximation. Note that this is inclusive  of the finite element supports, so the number of generative (internal) supports  added to each finite element is <code>num_nodes - 2</code>.  </p><p>In summary, we natively support trapezoid rule, Gaussian quadrature methods for  univariate parameters, and Monte Carlo sampling for both univariate and  multivariate infinite parameters. For extension purposes, users may define their  own <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> to encode custom evaluation methods. See  <a href="../../develop/extensions/#Extensions">Extensions</a> for more details.</p><h3 id="A-Note-on-Support-Management"><a class="docs-heading-anchor" href="#A-Note-on-Support-Management">A Note on Support Management</a><a id="A-Note-on-Support-Management-1"></a><a class="docs-heading-anchor-permalink" href="#A-Note-on-Support-Management" title="Permalink"></a></h3><p>There is a difference in how supports are considered using <code>UniTrapezoid()</code>/<code>FEGaussLobatto()</code> vs. the other schemes. Namely, the other schemes will NOT incorporate other supports  specified elsewhere in the model. Consider the following example with 3 equidistant  supports and an integral objective function that uses <code>UniTrapezoid()</code> (the default):</p><pre><code class="language-julia"># Create a model, with one variable and an infinite parameter with a given number of supports
m = InfiniteModel()
@infinite_parameter(m, t in [0, 2], num_supports = 3)
@variable(m, u, Infinite(t))

# Create an objective function with the default trapezoid integration
@objective(m, Min, integral(u^2, t))

# Get the transcribed model to check how the supports are taken into account
build_optimizer_model!(m)
trans_m = optimizer_model(m);</code></pre><p>If we look at how many supports there are, how the variable <code>u</code> is transcribed,  and how the objective function of the transcribed model looks like, we notice that  the same supports are used in both the objective function and the transcribed  variable:</p><pre><code class="language-julia-repl">julia&gt; supports(t) 
3-element Vector{Float64}:
 0.0
 1.0
 2.0

julia&gt; transcription_variable(u)  
3-element Vector{VariableRef}:
 u(support: 1)
 u(support: 2)
 u(support: 3)

julia&gt; objective_function(trans_m) 
0.5 u(support: 1)² + u(support: 2)² + 0.5 u(support: 3)²</code></pre><p>Thus, the integral incorporates the 3 supports generated outside of the <code>integral</code>  declaration.</p><p>Then we readjust the model to use Gauss-Legendre quadrature via <code>GaussLegendre()</code>  that uses 2 quadrature nodes:</p><pre><code class="language-julia"># Set the new objective and update the TranscriptionModel
set_objective_function(m, integral(u^2, t, eval_method = GaussLegendre(), num_nodes = 2))
build_optimizer_model!(m)
trans_m = optimizer_model(m);</code></pre><p>Now let&#39;s look again at the number of supports, the transcription of <code>u</code>, and the  new objective function:</p><pre><code class="language-julia-repl">julia&gt; supports(t) 
5-element Vector{Float64}:
 0.0
 0.42264973081
 1.0
 1.57735026919
 2.0

julia&gt; transcription_variable(u)  
5-element Vector{VariableRef}:
 u(support: 1)
 u(support: 2)
 u(support: 3)
 u(support: 4)
 u(support: 5)

julia&gt; objective_function(trans_m) 
u(support: 2)² + u(support: 4)²</code></pre><p>The supports used in the objective function are different from the supports used  in the transcription of <code>u</code>. The integral objective function has been transcribed  using the 2 quadrature supports, but does not include the other supports since  they cannot be incorporated into the Gaussian quadrature approximation. Whereas,  <code>u</code> is defined over all the supports and thus certain realizations of <code>u</code> will  excluded from the objective function which will affect the behavior of the  optimization and lead to unexpected results.</p><p>However, this behavior is avoided if we let the integral add the supports and  not add supports elsewhere (for convenience we&#39;ll use <code>set_uni_integral_defaults</code>):</p><pre><code class="language-julia"># Define a new model, parameter, and variable
m = InfiniteModel()
@infinite_parameter(m, t in [0, 2])
@variable(m, u, Infinite(t))

# Update the integral default keyword arguments for convenience 
set_uni_integral_defaults(eval_method = GaussLegendre(), num_nodes = 2)

# Set the objective with our desired integral
@objective(m, Min, integral(u^2, t))

# Build the transcribed model 
build_optimizer_model!(m)
trans_m = optimizer_model(m);</code></pre><p>Then we get the supports are consistent for <code>u</code> and the integral:</p><pre><code class="language-julia-repl">julia&gt; supports(t) 
2-element Vector{Float64}:
 0.42264973081
 1.57735026919

julia&gt; transcription_variable(u)  
2-element Vector{VariableRef}:
 u(support: 1)
 u(support: 2)

julia&gt; objective_function(trans_m) 
u(support: 1)² + u(support: 2)²</code></pre><p>Therefore, using quadratures other than <code>UniTrapezoid()</code> or <code>FEGaussLobatto()</code>  requires careful analysis if there are user-defined supports in the problem. </p><h2 id="Expansion"><a class="docs-heading-anchor" href="#Expansion">Expansion</a><a id="Expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Expansion" title="Permalink"></a></h2><p>In a model, each measure records the integrand expression and an evaluation  scheme that details the discretization scheme to approximate the integral.  The model will not expand the measures until the transcription stage, at which  a <code>JuMP.AbstractJuMPScalar</code> is created for each measure to represent how  the measure is modeled in a transcription model based on the stored  discretization scheme (see <a href="../transcribe/#transcription_docs">Model Transcription</a> for  details on transcription). Additional point variables will be created in the  expansion process if the measure is evaluated at infinite parameter points that  do not have corresponding point variables yet.</p><p>Sometimes for extension purposes, one might want to expand a specific measure  before reaching the transcription stage. Alternatively, one might want to use  custom reformulation instead of the transcription encoded in this package, in  which expanding measures will also be useful. This can be done using the <a href="../../manual/measure/#InfiniteOpt.expand"><code>expand</code></a>  function, which takes a <a href="../../manual/measure/#InfiniteOpt.MeasureRef"><code>MeasureRef</code></a> object and returns a <code>JuMP.AbstractJuMPScalar</code>  based on the <a href="../../manual/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>. For example, suppose we want to  integrate <span>$y^2$</span> in <span>$t$</span>, with two supports <span>$t = 2.5$</span> and <span>$t = 7.5$</span>.  We can set up and expand this measure as follows:</p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [5, 5], [2.5, 7.5]);

julia&gt; mref4 = measure(y^2, tdata)
measure{t}[y(t)²]

julia&gt; expanded_measure = expand(mref4)
5 y(2.5)² + 5 y(7.5)²

julia&gt; typeof(expanded_measure)
GenericQuadExpr{Float64, GeneralVariableRef}</code></pre><p>In the expand call, two point variables, <code>y(2.5)</code> and <code>y(7.5)</code>, are created  because they are not defined in the model before the expand call. One can use  the <a href="../../manual/measure/#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a> function to expand all measures in a model,  which simply applies the <a href="../../manual/measure/#InfiniteOpt.expand"><code>expand</code></a> to all measures stored in the model. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../expression/">« Expressions</a><a class="docs-footer-nextpage" href="../objective/">Objectives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 June 2021 21:04">Wednesday 23 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
