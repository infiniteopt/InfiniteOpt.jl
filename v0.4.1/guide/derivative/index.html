<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Derivatives · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li class="is-active"><a class="tocitem" href>Derivatives</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Advanced-Definition"><span>Advanced Definition</span></a></li><li><a class="tocitem" href="#Derivative-Evaluation"><span>Derivative Evaluation</span></a></li><li><a class="tocitem" href="#Query-Methods"><span>Query Methods</span></a></li><li><a class="tocitem" href="#Modification-Methods"><span>Modification Methods</span></a></li></ul></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../manual/optimize/">Optimization</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Derivatives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Derivatives</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/derivative.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="deriv_docs"><a class="docs-heading-anchor" href="#deriv_docs">Derivative Operators</a><a id="deriv_docs-1"></a><a class="docs-heading-anchor-permalink" href="#deriv_docs" title="Permalink"></a></h1><p>A guide for derivatives in <code>InfiniteOpt</code>. See the respective  <a href="../../manual/derivative/#deriv_manual">technical manual</a> for more details.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Derivative operators commonly arise in many infinite-dimensional problems,  particularly in space-time optimization. <code>InfiniteOpt.jl</code> provides a simple yet  powerful interface to model these objects for derivatives of any order, including  partial derivatives. Derivatives can be used in defining measures and constraints. </p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Derivative operators can defined a few different ways in <code>InfiniteOpt</code>. To motivate  these, let&#39;s first define an <code>InfiniteModel</code> along with some parameters and variables:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, Distributions;

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10], 
                           derivative_method = OrthogonalCollocation(3));

julia&gt; @infinite_parameter(model, ξ ~ Uniform(-1, 1));

julia&gt; @variable(model, y, Infinite(t, ξ));

julia&gt; @variable(model, q, Infinite(t));</code></pre><p>Notice that we used the <code>derivative_method</code> keyword argument to specify which  numerical method will be used to evaluate any derivatives that depend on that  infinite parameter <code>t</code>. In this case we, specified to use orthogonal collocation  over finite elements using 3 nodes. We&#39;ll come back to this just a little further  below to more fully describe the various methods we can use. </p><p>First, let&#39;s discuss how to define derivatives in <code>InfiniteOpt.jl</code>. Principally,  this is accomplished via <a href="../../manual/derivative/#InfiniteOpt.@deriv"><code>@deriv</code></a> which will operate on a particular  <code>InfiniteOpt</code> expression (containing parameters, variables, and/or measures) with  respect to infinite parameters specified with their associated orders. Behind the  scenes all the appropriate calculus will be applied, creating derivative variables  as needed. For example, we can define the following:</p><pre><code class="language-julia-repl">julia&gt; d1 = @deriv(y, t)
∂/∂t[y(t, ξ)]

julia&gt; d2 = @deriv(y, t, ξ)
∂/∂ξ[∂/∂t[y(t, ξ)]]

julia&gt; d3 = @∂(q, t^2)
∂/∂t[∂/∂t[q(t)]]

julia&gt; d_expr = @deriv(y * q - 2t, t)
∂/∂t[y(t, ξ)]*q(t) + ∂/∂t[q(t)]*y(t, ξ) - 2</code></pre><p>Thus, we can define derivatives in a variety of forms according to the problem at  hand. The last example even shows how the product rule is correctly applied. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For convenience in making more compact code we provide <a href="../../manual/derivative/#InfiniteOpt.∂"><code>∂</code></a> and  <a href="../../manual/derivative/#InfiniteOpt.@∂"><code>@∂</code></a> as wrappers for <a href="../../manual/derivative/#InfiniteOpt.deriv"><code>deriv</code></a> and <a href="../../manual/derivative/#InfiniteOpt.@deriv"><code>@deriv</code></a>, respectively.</p></div></div><p>Also, notice that the appropriate analytic calculus is applied to infinite  parameters. For example, we could also compute:</p><pre><code class="language-julia-repl">julia&gt; @deriv(3t^2 - 2t, t)
6 t - 2</code></pre><p>Conveniently, <code>@deriv</code> can be called within any measure and constraint. However,  in certain cases we may need to define an initial guess (initial guess trajectory).  This can be accomplished in 2 ways:</p><ul><li>Call <a href="../../manual/derivative/#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef, Union{Function, Real}}"><code>set_start_value_function</code></a>  using the individual derivative (e.g., <code>d1</code> above)</li><li>Define the derivative using <code>@variable</code> with the <a href="../../manual/derivative/#InfiniteOpt.Deriv"><code>Deriv</code></a> variable type  object and use the <code>start</code> keyword argument.</li></ul><p>In either case, a single value can be given or a start value function that will generate a value in accordance with the support values (i.e., following the same  syntax as infinite variables). For example, we can specify the starting value of  <code>d1</code> to <code>0</code> via the following:</p><pre><code class="language-julia-repl">julia&gt; set_start_value_function(d1, 0)</code></pre><p>Now let&#39;s return to our discussion on derivative evaluation methods. These are the  methods that can/will be invoked to transcript the derivatives when solving the  model. The methods native to <code>InfiniteOpt</code> are described in the table below:</p><table><tr><th style="text-align: center">Method</th><th style="text-align: center">Type</th><th style="text-align: center">Needed Boundary Conditions</th><th style="text-align: center">Creates Supports</th></tr><tr><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.Forward"><code>Forward</code></a></td><td style="text-align: center">Final &amp; optional Initial</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.Central"><code>Central</code></a></td><td style="text-align: center">Initial &amp; Final</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.Backward"><code>Backward</code></a></td><td style="text-align: center">Initial &amp; optional Final</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.OrthogonalCollocation"><code>OrthogonalCollocation</code></a></td><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>GaussLobatto</code></a></td><td style="text-align: center">Initial</td><td style="text-align: center">Yes</td></tr></table><p>Here the default method is backward finite difference. These are enforced on an  infinite parameter basis (i.e., the parameter the differential operator is taken  with respect to). Thus, in the above examples any derivatives taken with respect to  <code>t</code> will use orthogonal collocation on finite elements since that is what we  specified as our derivative method. More information is provided in the  <a href="#Derivative-Methods">Derivative Methods</a> Section below. However, we note here that  <a href="../../manual/derivative/#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef, NonGenerativeDerivativeMethod}"><code>set_derivative_method</code></a> can be invoked anytime after parameter definition  to specify/modify the derivative method used. More conveniently, we can call  <a href="../../manual/derivative/#InfiniteOpt.set_all_derivative_methods"><code>set_all_derivative_methods</code></a>:</p><pre><code class="language-julia-repl">julia&gt; set_all_derivative_methods(model, FiniteDifference(Forward()))
</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>InfiniteOpt</code> does not ensure proper boundary conditions are provided by the  user. Thus, it is imperative that the user ensure these are provided appropriately  with the derivative evaluation method that is used. We recommend specifying  such conditions via a constraint that uses <a href="../variable/#Restricted-Variables">Restricted Variables</a>. For  example:</p><pre><code class="language-julia">@constraint(model, initial_condition, y(0) == 42)</code></pre></div></div><h2 id="Advanced-Definition"><a class="docs-heading-anchor" href="#Advanced-Definition">Advanced Definition</a><a id="Advanced-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Definition" title="Permalink"></a></h2><p>This section will detail the inner-workings and more advanced details behind  defining derivatives in <code>InfiniteOpt</code>.</p><h3 id="Manual-Definition"><a class="docs-heading-anchor" href="#Manual-Definition">Manual Definition</a><a id="Manual-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Definition" title="Permalink"></a></h3><p>The workflow for derivative definition mirrors that of variable definition as  summarized in the following steps:</p><ol><li>Define the variable information via a <code>JuMP.VariableInfo</code>.</li><li>Build the derivative using <a href="../../manual/derivative/#InfiniteOpt.build_derivative"><code>build_derivative</code></a>.</li><li>Add the derivative to the model via <a href="../../manual/derivative/#InfiniteOpt.add_derivative"><code>add_derivative</code></a>.</li></ol><p>To exemplify this process, let&#39;s first define appropriate variable information:</p><pre><code class="language-julia-repl">julia&gt; info = VariableInfo(true, 0., true, 42., false, 0., false, 0., false, false);</code></pre><p>More detailed information on <code>JuMP.VariableInfo</code> is provided in the  <a href="../variable/#Variable-Definition-Methodology">Variable Definition Methodology</a> section. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Instances of <code>JuMP.VariableInfo</code> used to define derivatives should have  <code>info.binary = false</code> and <code>info.integer = false</code>, since most derivative  evaluation methods require that derivatives be continuous.</p></div></div><p>Now that we have our variable information we can make a derivative using  <a href="../../manual/derivative/#InfiniteOpt.build_derivative"><code>build_derivative</code></a>:</p><pre><code class="language-julia-repl">julia&gt; d = build_derivative(error, info, y, ξ);

julia&gt; d isa Derivative
true</code></pre><p>Here the argument variable can be an infinite variable, semi-infinite variable,  derivative, or measure that depends on the infinite parameter provided. This will  error to the contrary.</p><p>Now we can add the derivative to the model via <a href="../../manual/derivative/#InfiniteOpt.add_derivative"><code>add_derivative</code></a> which  will add the <a href="../../manual/derivative/#InfiniteOpt.Derivative"><code>Derivative</code></a> object and return <code>GeneralVariableRef</code> pointing  to it that we can use in <code>InfiniteOpt</code> expressions:</p><pre><code class="language-julia-repl">julia&gt; dref = add_derivative(model, d)
∂/∂ξ[y(t, ξ)]</code></pre><p>This will also create any appropriate information based constraints (e.g., lower  bounds).</p><p>Finally, we note that higher order derivatives are made by simply nesting this  process.</p><h3 id="Macro-Definition"><a class="docs-heading-anchor" href="#Macro-Definition">Macro Definition</a><a id="Macro-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-Definition" title="Permalink"></a></h3><p>There are two macros we provide for defining derivatives:  <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/variables/#JuMP.@variable"><code>@variable</code></a>  that uses the <a href="../../manual/derivative/#InfiniteOpt.Deriv"><code>Deriv</code></a> variable type and <a href="../../manual/derivative/#InfiniteOpt.@deriv"><code>@deriv</code></a>. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>@derivative_variable</code> macro used by previous versions of <code>InfiniteOpt</code>  is now discontinued in favor of using <code>@variable</code> with the <a href="../../manual/derivative/#InfiniteOpt.Deriv"><code>Deriv</code></a>  variable type object.</p></div></div><p>First, <code>@variable</code> simply automates the process described above in a manner  inspired the by the syntax of the variable macros. As such it will support all  the same keywords and constraint syntax used with the variable macros. For  example, we can define the derivative  <span>$\frac{\partial^2 y(t, \xi)}{\partial t^2}$</span> using <code>d1</code> (defined in the  a Basic Usage section) enforcing a lower bound of 1 with an initial guess of 0 and  assign it to an alias <code>GeneralVariableRef</code> called <code>dydt2</code>:</p><pre><code class="language-julia-repl">julia&gt; @variable(model, dydt2 &gt;= 1, Deriv(d1, t), start = 0)
dydt2(t, ξ)</code></pre><p>This will also support anonymous definition and multi-dimensional definition.  Please see <a href="../variable/#Macro-Variable-Definition">Macro Variable Definition</a> for more information.</p><p>Second, for more convenient definition we use <a href="../../manual/derivative/#InfiniteOpt.@deriv"><code>@deriv</code></a> (or <a href="../../manual/derivative/#InfiniteOpt.@∂"><code>@∂</code></a>)  as shown in the Basic Usage section above. Unlike <code>@variable</code> this can handle any  <code>InfiniteOpt</code> expression as the argument input. It also can build derivatives  that depend on multiple infinite parameters and/or are taken to higher orders.  This is accomplished via recursive derivative definition, handling the nesting  as appropriate. For example, we can &quot;define&quot;  <span>$\frac{\partial^2 y(t, \xi)}{\partial t^2}$</span> again:</p><pre><code class="language-julia-repl">julia&gt; @deriv(d1, t)
dydt2(t, ξ)

julia&gt; @deriv(y, t^2)
dydt2(t, ξ)</code></pre><p>Notice that the derivative references all point to the same derivative object we  defined up above with its alias name <code>dydt2</code>. This macro can also tackle complex  expressions using the appropriate calculus such as:</p><pre><code class="language-julia-repl">julia&gt; @deriv(∫(y, ξ) * q, t)
∂/∂t[∫{ξ ∈ [-1, 1]}[y(t, ξ)]]*q(t) + ∂/∂t[q(t)]*∫{ξ ∈ [-1, 1]}[y(t, ξ)]</code></pre><p>Thus, demonstrating the convenience of using <code>@deriv</code>.</p><p>With all this in mind, we recommend using <code>@deriv</code> as the defacto method, but  then using <code>@variable</code> as a convenient way to specify information constraints  and an initial guess value/trajectory. </p><h2 id="Derivative-Evaluation"><a class="docs-heading-anchor" href="#Derivative-Evaluation">Derivative Evaluation</a><a id="Derivative-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Evaluation" title="Permalink"></a></h2><p>In this section, we detail how derivatives are evaluated in <code>InfiniteOpt</code> to then  be used in reformulating the model for solution. </p><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>To motivate the principles behind numerical derivative evaluation/transcription,  let&#39;s first consider the initial value problem:</p><p class="math-container">\[\frac{d y(t)}{dt} = f(t, y(t)), \ \ \ y(t_0) = y_0\]</p><p>With a finite support set <span>$\{t_0, t_1, \dots, t_k\}$</span> we can numerically  approximate the value of <span>$\frac{d y(t_n)}{dt}$</span> at each time point <span>$t_n$</span> via  the Euler method (i.e., forward finite difference). We thus obtain a system of  equations:</p><p class="math-container">\[\begin{aligned}
&amp;&amp;&amp; y(t_{n+1}) = y(t_n) + (t_{n+1} - t_n) \frac{d y(t_n)}{dt}, &amp;&amp; \forall n = 0, \dots, k-1\\
&amp;&amp;&amp; \frac{d y(t_n)}{dt} = f(t_n, y(t_n)), &amp;&amp; \forall n = 0, \dots, k \\ 
&amp;&amp;&amp; y(t_0) = y_0
\end{aligned}\]</p><p>Thus, we obtain 3 sets of equations: </p><ol><li>constraint transcriptions</li><li>auxiliary derivative equations </li><li>boundary conditions. </li></ol><p>In the case above, we could reduce the number of equations by substituting out the  point derivatives in the constraint transcriptions since we have explicit  relationships in the auxiliary equations. However, this is not possible in general,  such as when we encounter more complex partial differential equations. </p><p>Thus, in <code>InfiniteOpt</code> derivatives are treated as variables which can be contained  implicitly in constraints and/or measures. This allows us to support implicit  dependencies and higher order derivatives. This means that when the model is  reformulated, its constraints and measures can be reformulated as normal  (treating any derivative dependencies as variables). We then can apply the  appropriate derivative evaluation technique to derive the necessary set of  auxiliary derivative equations to properly characterize the derivative variables.  This can be formalized as:</p><p class="math-container">\[\begin{aligned}
&amp;&amp;&amp; f_j(y(\lambda), Dy(\lambda)) \leq 0, &amp;&amp; \forall j \in J, \lambda \in \Lambda \\
&amp;&amp;&amp; h_i(y(\lambda), Dy(\lambda)) == 0, &amp;&amp; \forall i \in I, \lambda \in \Lambda \\
&amp;&amp;&amp; g_k(y(\hat{\lambda}), Dy(\hat{\lambda})) == 0, &amp;&amp; \forall k \in K, \hat{\lambda} \in \hat{\Lambda}
\end{aligned}\]</p><p>where <span>$y(\lambda)$</span> and <span>$Dy(\lambda)$</span> denote all the variables and derivatives  in the problem and <span>$\lambda$</span> the denote all the problem&#39;s infinite parameters.  With this let the constraints <span>$f_j$</span> denote the problem constraints which can  contain any variables, parameters, derivatives, and/or measures associated with  the problem. The constraints <span>$h_i$</span> denote the auxiliary derivative equations  formed by the appropriate numerical method to implicitly define the behavior of  the derivative variables present in <span>$f_j$</span>. Finally, the necessary boundary  conditions are provided in the constraints <span>$g_k$</span>.</p><p>Note that this general paradigm captures a wide breadth of problems and  derivative evaluation techniques. Higher order derivatives are dealt with naturally  since such techniques can be applied to nested derivative operators recursively.  For example, consider the second-order partial derivative:</p><p class="math-container">\[\frac{\partial^2 y(t, \xi)}{\partial t^2} = \frac{\partial}{\partial t}\left(\frac{\partial y(t, \xi)}{\partial t}\right)\]</p><p>The 2 forms are equivalent thus when we apply the Euler method we obtain the  following auxiliary equations:</p><p class="math-container">\[\begin{aligned}
&amp;&amp;&amp; y(t_{n+1}, \xi) = y(t_n, \xi) + (t_{n+1} - t_n) \frac{\partial y(t_n, \xi)}{\partial t}, &amp;&amp; \forall \xi \in \mathcal{D}_\xi, n = 0, \dots, k-1\\
&amp;&amp;&amp; \frac{\partial y(t_{n+1}, \xi)}{\partial t} = \frac{\partial y(t_n, \xi)}{\partial t} + (t_{n+1} - t_n) \frac{\partial^2 y(t_n, \xi)}{\partial t^2}, &amp;&amp; \forall \xi \in \mathcal{D}_\xi, n = 0, \dots, k-1\\
\end{aligned}\]</p><p>In the section below we detail the derivative evaluation methods that <code>InfiniteOpt</code>  natively implements.</p><h3 id="Derivative-Methods"><a class="docs-heading-anchor" href="#Derivative-Methods">Derivative Methods</a><a id="Derivative-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Methods" title="Permalink"></a></h3><p>As discussed briefly above in the Basic Usage section, we natively employ 4  derivative methods in <code>InfiniteOpt</code> (see the table in that section for a summary).</p><p>These methods are defined in association with individual infinite parameters and  will be applied to any derivatives that are taken with respect to that parameter.  These methods are specified via the <code>derivative_method</code> keyword argument in the  <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> macro and can also be defined by invoking  <a href="../../manual/derivative/#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef, NonGenerativeDerivativeMethod}"><code>set_derivative_method</code></a> or <a href="../../manual/derivative/#InfiniteOpt.set_all_derivative_methods"><code>set_all_derivative_methods</code></a>:</p><pre><code class="language-julia-repl">julia&gt; set_derivative_method(t, FiniteDifference(Forward()))
</code></pre><p>In this example, we set <code>t</code>&#39;s derivative evaluation method to use forward finite  difference. This will also reset any changes that were made with the old method  (e.g., removing old collocation points). Now let&#39;s describe the ins and outs of  these methods.</p><p>The first class of methods pertain to finite difference techniques. The syntax  for specifying these techniques is described in <a href="../../manual/derivative/#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a> and  exemplified here:</p><pre><code class="language-julia-repl">julia&gt; FiniteDifference(Forward(), true)
FiniteDifference{Forward}(Forward(), true)</code></pre><p>where the first argument indicates the type of finite difference we wish to employ  and the second argument indicates if this method should be enforced on boundary  points. By default, we have <code>FiniteDifference(Backward(), true)</code> which is the default  for all infinite parameters. </p><p>Forward finite difference (i.e., explicit Euler) is exemplified by approximating first  order derivative <span>$\frac{d y(t)}{dt}$</span> via </p><p class="math-container">\[y(t_{n+1}) = y(t_n) + (t_{n+1} - t_{n})\frac{d y(t_n)}{dt}, \ \forall n = 0, 1, \dots, k-1\]</p><p>Note that in this case, the boundary relation corresponds to <span>$n = 0$</span> and would  be included if we set <code>FiniteDifference(Forward(), true)</code> or would excluded if we  let the second argument be <code>false</code>. We recommend, selecting <code>false</code> when an initial  condition is provided. Also, note that a terminal condition should be provided  when using this method since an auxiliary equation for the derivative at the  terminal point cannot be made. Thus, if a terminal condition is not given terminal  point derivative will be a free variable.</p><p>Central finite difference is exemplified by approximating the first order derivative  <span>$\frac{d y(t)}{dt}$</span> via</p><p class="math-container">\[y(t_{n+1}) = y(t_{n-1}) + (t_{n+1} - t_{n-1})\frac{d y(t_n)}{dt}, \ \forall n = 1, 2, \dots, k-1\]</p><p>Note that this form cannot be invoked at <span>$n = 0$</span> or <span>$n = k$</span> and cannot  an equation at either boundary. With this in mind the syntax is <code>FiniteDifference(Central())</code>  where the second argument is omitted since it doesn&#39;t apply to this scheme. As a  result both initial and terminal conditions should be specified otherwise the  derivatives at those points will be free variables.</p><p>Backward finite difference (i.e., implicit euler) is our last (and default)  finite difference method and is exemplified by approximating the first order  derivative <span>$\frac{d y(t)}{dt}$</span> via</p><p class="math-container">\[y(t_{n}) = y(t_{n-1}) + (t_{n} - t_{n-1})\frac{d y(t_{n})}{dt}, \ \forall n = 1, 2, \dots, k\]</p><p>Here the boundary case corresponds to <span>$n = k$</span> and would be included if we set  <code>FiniteDifference(Backward(), true)</code> (the default) or excluded if we set the second  argument to <code>false</code>. We recommend, selecting <code>false</code> when a terminal condition is  provided. Also, note that an initial condition should always be given otherwise  the derivative at the first point will be free.</p><p>Finally, we employ orthogonal collocation on finite elements via the  <a href="../../manual/derivative/#InfiniteOpt.OrthogonalCollocation"><code>OrthogonalCollocation</code></a> object (please refer to it in the manual for  complete syntax details). In general terms, this technique fits an <span>$m$</span> degree  polynomial to each finite element (i.e., sequential support pair) and this fit is  done via <span>$m+1$</span> collocation nodes (supports) which include the finite element  supports along with <span>$m-1$</span> additional internal collocation nodes chosen at  orthogonal points to the polynomial. The typical syntax for specifying this method  is <code>OrthogonalCollocation(num_nodes)</code> where <code>num_nodes</code> indicates the number  collocation nodes to be used for each finite element. For example, we can specify  to use 3 collocation nodes (i.e., 1 internal node per finite element) corresponding  to a 2nd degree polynomial via</p><pre><code class="language-julia-repl">julia&gt; OrthogonalCollocation(3)
OrthogonalCollocation{GaussLobatto}(3, GaussLobatto())</code></pre><p>Notice that the 2nd attribute is <code>GaussLobatto</code> which indicates that we are using  collocation nodes selected via Lobatto quadrature. This is currently the only  supported technique employed by <code>OrthogonalCollocation</code> although more may be added  in future versions. Please note that an initial condition must be provided otherwise  the corresponding derivative will be free variable. For more information on  orthogonal collocation over finite elements, this  <a href="http://apmonitor.com/do/index.php/Main/OrthogonalCollocation">page</a> provides a  good reference.</p><p>Other methods can be employed via user-defined extensions. Please visit our  Extensions page for more information.</p><h3 id="User-Invoked-Evaluation"><a class="docs-heading-anchor" href="#User-Invoked-Evaluation">User-Invoked Evaluation</a><a id="User-Invoked-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#User-Invoked-Evaluation" title="Permalink"></a></h3><p>Typically, derivative evaluation is handled when the model is reformulated in such  a way that the <code>InfiniteModel</code> is unmodified such that modifications and repeated  solutions can be done efficiently and seamlessly. This is also the recommended  workflow. However, we do provide user accessible derivative evaluation methods  that generate the auxiliary derivative equations and add them to the <code>InfiniteModel</code>. This can be useful for visualizing how these techniques work and can be helpful for  user-defined reformulation extensions (i.e., optimizer model extensions).</p><p>We can build these relations for a particular derivative via <a href="../../manual/derivative/#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>evaluate</code></a>.  For example, let&#39;s build evaluation equations for <code>d1</code>:</p><pre><code class="language-julia-repl">julia&gt; d1 
∂/∂t[y(t, ξ)]

julia&gt; fill_in_supports!(t, num_supports = 3) # add supports first

julia&gt; evaluate(d1)

julia&gt; derivative_constraints(d1)
2-element Vector{InfOptConstraintRef}:
 5 ∂/∂t[y(t, ξ)](5, ξ) - y(10, ξ) + y(5, ξ) = 0.0, ∀ ξ ~ Uniform
 5 ∂/∂t[y(t, ξ)](0, ξ) - y(5, ξ) + y(0, ξ) = 0.0, ∀ ξ ~ Uniform</code></pre><p>Note that we made sure <code>t</code> had supports first over which we could carry out the  evaluation, otherwise an error would have been thrown. Moreover, once the  evaluation was completed we were able to access the auxiliary equations via  <a href="../../manual/derivative/#InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}"><code>derivative_constraints</code></a>. </p><p>We can also, add the necessary auxiliary equations for all the derivatives in the  model if we call <a href="../../manual/derivative/#InfiniteOpt.evaluate_all_derivatives!"><code>evaluate_all_derivatives!</code></a>:</p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(ξ, num_supports = 4) # add supports first

julia&gt; evaluate_all_derivatives!(model)

julia&gt; derivative_constraints(dydt2)
2-element Vector{InfOptConstraintRef}:
 5 dydt2(5, ξ) - ∂/∂t[y(t, ξ)](10, ξ) + ∂/∂t[y(t, ξ)](5, ξ) = 0.0, ∀ ξ ~ Uniform
 5 dydt2(0, ξ) - ∂/∂t[y(t, ξ)](5, ξ) + ∂/∂t[y(t, ξ)](0, ξ) = 0.0, ∀ ξ ~ Uniform</code></pre><p>Finally, we note that once derivative constraints have been added to the  <code>InfiniteModel</code> any changes to the respective infinite parameter sets, supports,  or derivative method will necessitate the deletion of these auxiliary constraints  and a warning will be thrown to indicate such:</p><pre><code class="language-julia-repl">julia&gt; derivative_constraints(d1)
2-element Vector{InfOptConstraintRef}:
 5 ∂/∂t[y(t, ξ)](5, ξ) - y(10, ξ) + y(5, ξ) = 0.0, ∀ ξ ~ Uniform
 5 ∂/∂t[y(t, ξ)](0, ξ) - y(5, ξ) + y(0, ξ) = 0.0, ∀ ξ ~ Uniform

julia&gt; add_supports(t, 0.2)
┌ Warning: Support/method changes will invalidate existing derivative evaluation constraints that have been added to the InfiniteModel. Thus, these are being deleted.
└ @ InfiniteOpt ~/build/pulsipher/InfiniteOpt.jl/src/scalar_parameters.jl:781

julia&gt; has_derivative_constraints(d1)
false</code></pre><h2 id="Query-Methods"><a class="docs-heading-anchor" href="#Query-Methods">Query Methods</a><a id="Query-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Methods" title="Permalink"></a></h2><p>Here we describe the various query techniques that we can employ on derivatives  in <code>InfiniteOpt</code>.</p><h3 id="Basic-Queries"><a class="docs-heading-anchor" href="#Basic-Queries">Basic Queries</a><a id="Basic-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Queries" title="Permalink"></a></h3><p>First, let&#39;s overview the basic object inquiries: <a href="../../manual/derivative/#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}"><code>derivative_argument</code></a>,  <a href="../../manual/derivative/#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}"><code>operator_parameter</code></a>, <a href="../../manual/derivative/#InfiniteOpt.derivative_method-Tuple{DerivativeRef}"><code>derivative_method</code></a>, and <a href="../../manual/variable/#JuMP.name-Tuple{DecisionVariableRef}"><code>name</code></a>:</p><pre><code class="language-julia-repl">julia&gt; derivative_argument(dydt2) # get the variable the derivative operates on
∂/∂t[y(t, ξ)]

julia&gt; operator_parameter(dydt2) # get the parameter the operator is taken with respect to
t

julia&gt; derivative_method(dydt2) # get the numerical derivative evaluation method
FiniteDifference{Forward}(Forward(), true)

julia&gt; name(dydt2) # get the name if there is one
&quot;dydt2&quot;</code></pre><p>These all work as exemplified above. We note that <code>derivative_method</code> simply  queries the derivative method associated with the operator parameter.</p><p>Derivatives also inherit all the usage methods employed by infinite variables.  For example:</p><pre><code class="language-julia-repl">julia&gt; is_used(d1)
true

julia&gt; used_by_measure(dydt2)
false

julia&gt; used_by_semi_infinite_variable(d2)
true</code></pre><p>Also, since derivatives are analogous to infinite variables, they inherit many  of the same queries including <a href="../../manual/constraint/#InfiniteOpt.parameter_refs-Tuple{InfOptConstraintRef}"><code>parameter_refs</code></a>:</p><pre><code class="language-julia-repl">julia&gt; parameter_refs(d1)
(t, ξ)

julia&gt; parameter_refs(derivative_argument(d1))
(t, ξ)</code></pre><p>Since derivatives simply inherit their infinite parameter dependencies from the  argument variable, the above lines are equivalent.</p><h3 id="Variable-Information"><a class="docs-heading-anchor" href="#Variable-Information">Variable Information</a><a id="Variable-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Information" title="Permalink"></a></h3><p>Again, since derivatives are essentially a special case of infinite variables, they  inherit all the same methods for querying variable information. For example,  consider the following queries:</p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(dydt2)
true

julia&gt; lower_bound(dydt2)
1.0

julia&gt; LowerBoundRef(dydt2)
dydt2(t, ξ) ≥ 1.0, ∀ t ∈ [0, 10], ξ ~ Uniform

julia&gt; has_upper_bound(dydt2)
false 

julia&gt; func = start_value_function(dydt2);</code></pre><h3 id="Model-Queries"><a class="docs-heading-anchor" href="#Model-Queries">Model Queries</a><a id="Model-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Queries" title="Permalink"></a></h3><p>We can also determine the number of derivatives a model contains and obtain a list  of them via <a href="../../manual/derivative/#InfiniteOpt.num_derivatives"><code>num_derivatives</code></a> and <a href="../../manual/derivative/#InfiniteOpt.all_derivatives"><code>all_derivatives</code></a>, respectively:</p><pre><code class="language-julia-repl">julia&gt; num_derivatives(model)
7

julia&gt; all_derivatives(model)
7-element Vector{GeneralVariableRef}:
 ∂/∂t[y(t, ξ)]
 ∂/∂ξ[∂/∂t[y(t, ξ)]]
 ∂/∂t[q(t)]
 ∂/∂t[∂/∂t[q(t)]]
 ∂/∂ξ[y(t, ξ)]
 dydt2(t, ξ)
 ∂/∂t[∫{ξ ∈ [-1, 1]}[y(t, ξ)]]</code></pre><h2 id="Modification-Methods"><a class="docs-heading-anchor" href="#Modification-Methods">Modification Methods</a><a id="Modification-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Modification-Methods" title="Permalink"></a></h2><p>In this section, we&#39;ll highlight some of the modification methods that can be  used on derivatives in <code>InfiniteOpt</code>.</p><h3 id="Variable-Information-2"><a class="docs-heading-anchor" href="#Variable-Information-2">Variable Information</a><a class="docs-heading-anchor-permalink" href="#Variable-Information-2" title="Permalink"></a></h3><p>As discussed above, derivatives inherit the same variable methods as infinite  variables. Thus we can modify/delete bounds and starting values for derivatives  using the same methods. For example:</p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(dydt2, 0)

julia&gt; lower_bound(dydt2)
0.0

julia&gt; set_upper_bound(dydt2, 2)

julia&gt; upper_bound(dydt2)
2.0

julia&gt; fix(dydt2, 42, force = true)

julia&gt; fix_value(dydt2) 
42.0

julia&gt; set_start_value_function(dydt2, (t, xi) -&gt; t + xi)

julia&gt; unfix(dydt2)
</code></pre><h3 id="Deletion"><a class="docs-heading-anchor" href="#Deletion">Deletion</a><a id="Deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Deletion" title="Permalink"></a></h3><p>Finally, the are 2 deletion methods we can employ apart from deleting variable  information. First, we can employ <a href="../../manual/derivative/#InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}"><code>delete_derivative_constraints</code></a> to  delete any derivative evaluation constraints associated with a particular  derivative:</p><pre><code class="language-julia-repl">julia&gt; delete_derivative_constraints(d2)

julia&gt; has_derivative_constraints(d2)
false</code></pre><p>Lastly, we can employ <code>delete</code> to delete a particular derivative and all its  dependencies:</p><pre><code class="language-julia-repl">julia&gt; delete(model, d2)

julia&gt; is_valid(model, d2)
false</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variable/">« Variables</a><a class="docs-footer-nextpage" href="../expression/">Expressions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 June 2021 21:04">Wednesday 23 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
