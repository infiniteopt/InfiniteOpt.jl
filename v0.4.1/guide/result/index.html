<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Results · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li class="is-active"><a class="tocitem" href>Results</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Termination-Queries"><span>Termination Queries</span></a></li><li><a class="tocitem" href="#Variable-Queries"><span>Variable Queries</span></a></li><li><a class="tocitem" href="#Constraint-Queries"><span>Constraint Queries</span></a></li><li><a class="tocitem" href="#LP-Sensitivity"><span>LP Sensitivity</span></a></li><li><a class="tocitem" href="#Other-Queries"><span>Other Queries</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../manual/optimize/">Optimization</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Results</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Results</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/result.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="result_docs"><a class="docs-heading-anchor" href="#result_docs">Results</a><a id="result_docs-1"></a><a class="docs-heading-anchor-permalink" href="#result_docs" title="Permalink"></a></h1><p>A guide for querying optimized <code>InfiniteOpt</code> models. See the respective  <a href="../../manual/result/#result_manual">technical manual</a> for more details.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>So far we have covered defining, transforming, and optimizing <code>InfiniteModel</code>s.  Now comes the point to extract information from our optimized model. This is done  following extended versions of <code>JuMP</code>s querying functions in combination with  the mapping information stored in the optimizer model. Thus, this page will  walk through the use of these result query functions.</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Let&#39;s revisit the example from the optimization page to get us started:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, Ipopt;

julia&gt; model = InfiniteModel(Ipopt.Optimizer);

julia&gt; set_optimizer_attribute(model, &quot;print_level&quot;, 0);

julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10);

julia&gt; @variable(model, y &gt;= 0, Infinite(t));

julia&gt; @variable(model, z &gt;= 0);

julia&gt; @objective(model, Min, 2z);

julia&gt; @constraint(model, c1, z &gt;= y);

julia&gt; @constraint(model, c2, y(0) == 42);

julia&gt; print(model)
Min 2 z
Subject to
 y(t) ≥ 0.0, ∀ t ∈ [0, 10]
 z ≥ 0.0
 c1 : z - y(t) ≥ 0.0, ∀ t ∈ [0, 10]
 y(0) ≥ 0.0
 c2 : y(0) = 42.0

julia&gt; optimize!(model)
</code></pre><p>Now that the model has been optimized, let&#39;s find out what happened. To determine  why the optimizer stopped, we can use  <a href="../../manual/result/#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a> to report the corresponding <code>MathOptInterface</code>  termination code (possible codes are explained  <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#MathOptInterface.TerminationStatusCode">here</a>.</p><pre><code class="language-julia-repl">julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4</code></pre><p>Here we see that our model was locally solved via Ipopt and that is why it  stopped. Furthermore, we can query the primal and dual problem optimalities via  <a href="../../manual/result/#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a> and  <a href="../../manual/result/#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, respectively.</p><pre><code class="language-julia-repl">julia&gt; primal_status(model)
FEASIBLE_POINT::ResultStatusCode = 1

julia&gt; dual_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre><p>The possible statuses are detailed <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#MathOptInterface.ResultStatusCode">here</a>.  These results are useful in knowing if information can be drawn from the primal  and/or dual and what it means. We can also verify that we indeed have answers  via <a href="../../manual/result/#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a> which indicates if our model has optimized variable  values.</p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre><p>And indeed we do have values.</p><p>Now we can query the objective value via <a href="../../manual/result/#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a> which reports the optimal objective value.</p><pre><code class="language-julia-repl">julia&gt; objective_value(model)
83.99999998250514</code></pre><p>Great now we can inquire about variable values via  <a href="../../manual/result/#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a>. First, let&#39;s retrieve the value of <code>z</code>:</p><pre><code class="language-julia-repl">julia&gt; value(z)
41.99999999125257</code></pre><p>We get a single value since <code>z</code> is a <code>FiniteVariable</code> and therefore finite. Now  let&#39;s retrieve the &quot;value&quot; of <code>y(t)</code> which is infinite with respect to <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; value(y)
10-element Vector{Float64}:
 42.0
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495</code></pre><p>Notice here we obtain an array of values since these correspond to the  transcribed finite (discretized) variables used to solve the problem. We obtain  the corresponding support (discretized <code>t</code>) values via <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; supports(y)
10-element Vector{Tuple}:
 (0.0,)
 (1.11111111111,)
 (2.22222222222,)
 (3.33333333333,)
 (4.44444444444,)
 (5.55555555556,)
 (6.66666666667,)
 (7.77777777778,)
 (8.88888888889,)
 (10.0,)</code></pre><p>There is 1-to-1 correspondence between these supports and the values reported  above. Note that these are stored in tuples to facilitate multiple infinite  parameter dependencies.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The values for an array of variables is obtained via the vectorized call  of <code>value</code> following the syntax:</p><pre><code class="language-julia">value.(::AbstractArray{&lt;:GeneralVariableRef})</code></pre><p>This also holds true for many other methods in <code>InfiniteOpt</code>. For example,  adding the dot also vectorizes <code>dual</code> and <code>set_binary</code>.</p></div></div><p>We can also query the dual of a constraint via  <a href="../../manual/result/#JuMP.dual-Tuple{InfOptConstraintRef}"><code>dual</code></a> if a model has duals available as indicated by <a href="../../manual/result/#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true

julia&gt; dual(c1)
10-element Vector{Float64}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p><code>c1</code> is an infinite constraint and thus we obtain the duals of its transcribed  versions. The underlying infinite parameter(s) and support values are queried  via <code>parameter_refs</code> and <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; parameter_refs(c1)
(t,)

julia&gt; supports(c1)
10-element Vector{Tuple}:
 (0.0,)
 (1.11111111111,)
 (2.22222222222,)
 (3.33333333333,)
 (4.44444444444,)
 (5.55555555556,)
 (6.66666666667,)
 (7.77777777778,)
 (8.88888888889,)
 (10.0,)</code></pre><p>These again all have a 1-to-1 correspondence.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the case that our variables/constraints depend on multiple infinite  parameter it is typically convenient to add the keyword statement  <code>ndarray = true</code> when calling any variable/constraint queries (e.g., <code>value</code>  and <code>dual</code>). This will reformat the output vector into a n-dimensional array  whose dimensions correspond to the supports of the infinite parameters. </p></div></div><h2 id="Termination-Queries"><a class="docs-heading-anchor" href="#Termination-Queries">Termination Queries</a><a id="Termination-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-Queries" title="Permalink"></a></h2><p>Termination queries are those that question about how the infinite model was  solved and what its optimized state entails. Programmatically, such queries on  the <code>InfiniteModel</code> are simply routed to its optimizer model.</p><p>The commonly used queries include <a href="../../manual/result/#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a>,  <a href="../../manual/result/#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a>, <a href="../../manual/result/#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, <a href="../../manual/result/#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a>, <a href="../../manual/result/#JuMP.result_count-Tuple{InfiniteModel}"><code>result_count</code></a>, and <a href="../../manual/result/#JuMP.solve_time-Tuple{InfiniteModel}"><code>solve_time</code></a>. The first four are well  exemplified in the Basic Usage section above and are helpful in quickly  understanding the optimality status of a given model following the many possible  statuses reported by <code>MathOptInterface</code> which are documented  <a href="https://jump.dev/MathOptInterface.jl/v0.9.22/manual/solutions/#Solutions">here</a>.  We use <code>result_count</code> to determine how many solutions are recorded in the  optimizer.</p><pre><code class="language-julia-repl">julia&gt; result_count(model)
1</code></pre><p>This is useful since it informs what results there are which can be specified  via the <code>result</code> keyword argument in many methods such as <code>primal_status</code>,  <code>dual_status</code>, <code>objective_value</code>, <code>value</code>, <code>dual</code>, and more.</p><p>We use <code>solve_time</code> to determine the time in seconds used by the optimizer until  it terminated its search.</p><pre><code class="language-julia-repl">julia&gt; solve_time(model)
0.004999876022338867</code></pre><p>Note that this query might not be supported with all solvers.</p><p>The above status queries are designed to report information in a consistent  format irrespective of the chosen optimizer. However, <a href="../../manual/result/#JuMP.raw_status-Tuple{InfiniteModel}"><code>raw_status</code></a> will  provide the optimality status verbatim as reported by the optimizer. Thus,  following our example with Ipopt we obtain:</p><pre><code class="language-julia-repl">julia&gt; raw_status(model)
&quot;Solve_Succeeded&quot;</code></pre><p>Also, we obtain the best objective bound via <a href="../../manual/result/#JuMP.objective_bound-Tuple{InfiniteModel}"><code>objective_bound</code></a> which  becomes particularly useful solutions that are suboptimal. However, this method  is not supported by all optimizers and in this case Ipopt is one such optimizer.</p><p>Finally, we get the best dual objective value via <a href="../../manual/result/#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>dual_objective_value</code></a>  if the optimizer supplies this information which again Ipopt does not.</p><h2 id="Variable-Queries"><a class="docs-heading-anchor" href="#Variable-Queries">Variable Queries</a><a id="Variable-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Queries" title="Permalink"></a></h2><p>Information about the optimized variables is gathered consistently in comparison  to typical <code>JuMP</code> models. With <code>InfiniteModel</code>s this is done by querying the  optimizer model and using its stored variable mappings to return the correct  information. Thus, here the queries are extended to work with the specifics of  the optimizer model to return the appropriate info.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Like <code>supports</code> the all variable based query methods below also employ the  <code>label::Type{AbstractSupportLabel} = PublicLabel</code> keyword argument that by  default will return the desired information associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via <code>label = All</code>.</li><li>These methods also employ the <code>ndarray::Bool</code> keyword argument that will cause the  output to be formatted as a n-dimensional array where the dimensions  correspond to the infinite parameter dependencies. For example, if we have an  infinite variable <code>y(t, ξ)</code> and we invoke a query method with <code>ndarray = true</code>  then we&#39;ll get a matrix whose dimensions correspond to the supports of <code>t</code> and  <code>ξ</code>, respectively. Also, if <code>ndarray = true</code> then <code>label</code> correspond to the  intersection of supports labels in contrast to its default of invoking the union  of the labels.</li></ol></div></div><p>First, we should verify that the optimized model in fact has variable values  via <a href="../../manual/result/#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a>. In our example, we have:</p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre><p>So we have values readily available to be extracted.</p><p>Now <a href="../../manual/result/#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a> can be used to query the  values as shown above in the Basic Usage section. This works by calling the  appropriate <a href="../../manual/result/#InfiniteOpt.map_value"><code>map_value</code></a> defined by the optimizer  model. By default this, employs the <code>map_value</code> fallback which uses  <code>optimizer_model_variable</code> to do the mapping. Details on how to extend these  methods for user-defined optimizer models is explained on the Extensions page.</p><p>We also, support call to <code>value</code> that use an expression of variables as input.</p><p>Finally, the optimizer index of a variable is queried via  <a href="../../manual/result/#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>optimizer_index</code></a> which  reports back the index of the variable as used in the <code>MathOptInterface</code>  backend:</p><pre><code class="language-julia-repl">julia&gt; optimizer_index(z)
MathOptInterface.VariableIndex(1)

julia&gt; optimizer_index(y)
10-element Vector{MathOptInterface.VariableIndex}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)
 MathOptInterface.VariableIndex(6)
 MathOptInterface.VariableIndex(7)
 MathOptInterface.VariableIndex(8)
 MathOptInterface.VariableIndex(9)
 MathOptInterface.VariableIndex(10)
 MathOptInterface.VariableIndex(11)</code></pre><p>As noted previously, an array is returned for <code>y(t)</code> in accordance with its  transcription variables. In similar manner to <code>value</code>, this is enabled by  appropriate versions of <a href="../../manual/result/#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a>.</p><h2 id="Constraint-Queries"><a class="docs-heading-anchor" href="#Constraint-Queries">Constraint Queries</a><a id="Constraint-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Queries" title="Permalink"></a></h2><p>Like variables, a variety of information can be queried about constraints.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Like <code>supports</code> the all constraint query methods below also employ the  <code>label::Type{AbstractSupportLabel} = PublicLabel</code> keyword argument that by  default will return the desired information associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via <code>label = All</code>.</li><li>These methods also employ the <code>ndarray::Bool</code> keyword argument that will cause the  output to be formatted as a n-dimensional array where the dimensions  correspond to the infinite parameter dependencies. For example, if we have an  infinite constraint that depends on <code>t</code> and <code>ξ)</code> and we invoke a query method  with <code>ndarray = true</code> then we&#39;ll get a matrix whose dimensions correspond to  the supports of <code>t</code> and <code>ξ</code>, respectively. Also, if <code>ndarray = true</code> then  <code>label</code> correspond to the intersection of supports labels in contrast to its  default of invoking the union of the labels.</li></ol></div></div><p>First, recall that constraints are stored in the form <code>function-in-set</code> where  generally <code>function</code> contains the variables and coefficients and the set contains  the relational operator and the constant value. With this understanding, we  query the value of a constraint&#39;s <code>function</code> via  <a href="../../manual/result/#JuMP.value-Tuple{InfOptConstraintRef}"><code>value</code></a>:</p><pre><code class="language-julia-repl">julia&gt; constraint_object(c1).func # show the function expression of c1
z - y(t)

julia&gt; value(c1)
10-element Vector{Float64}:
 -8.747427671096375e-9
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077</code></pre><p>Again, we obtain an array of values since <code>c1</code> is infinite due to its dependence  on <code>x(t)</code>. Behind the scenes this is implemented via the appropriate extensions  of <a href="../../manual/result/#InfiniteOpt.map_value"><code>map_value</code></a>.</p><p>Next the optimizer index(es) of the transcribed constraints in the  <code>MathOptInterface</code> backend provided via  <a href="../../manual/result/#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>optimizer_index</code></a>.</p><pre><code class="language-julia-repl">julia&gt; optimizer_index(c1)
10-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(5)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(6)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(7)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(8)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(9)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(10)</code></pre><p>Here 10 indices are given in accordance with the transcription constraints.  The mapping between these and the original infinite constraints is managed via  the appropriate extensions of <a href="../../manual/result/#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a>.</p><p>We can also query dual information from our constraints if it is available.  First, we should verify that dual information is available via  <a href="../../manual/result/#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true</code></pre><p>Now we can query the duals via <a href="../../manual/result/#JuMP.dual-Tuple{InfOptConstraintRef}"><code>dual</code></a>.</p><pre><code class="language-julia-repl">julia&gt; dual(c1)
10-element Vector{Float64}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p>Here we obtain the optimal dual values for each transcribed version of <code>c1</code>. This  is enabled via the proper extensions of <a href="../../manual/result/#InfiniteOpt.map_dual"><code>map_dual</code></a>.</p><p>Finally, we query the shadow price of a constraint via  <a href="../../manual/result/#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>shadow_price</code></a>. This denotes  the change in the objective value due to an infinitesimal relaxation of the  constraint. For <code>c1</code> we get:</p><pre><code class="language-julia-repl">julia&gt; shadow_price(c1)
10-element Vector{Float64}:
 -1.9999999988666093
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10</code></pre><p>Similarly, the mapping to the transcription constraints is enabled via the  appropriate version of <a href="../../manual/result/#InfiniteOpt.map_shadow_price"><code>map_shadow_price</code></a>.</p><h2 id="LP-Sensitivity"><a class="docs-heading-anchor" href="#LP-Sensitivity">LP Sensitivity</a><a id="LP-Sensitivity-1"></a><a class="docs-heading-anchor-permalink" href="#LP-Sensitivity" title="Permalink"></a></h2><p>We also conduct sensitivity analysis for linear problems using  <a href="../../manual/result/#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}"><code>lp_sensitivity_report</code></a>. This  will generate a <a href="../../manual/result/#InfiniteOpt.InfOptSensitivityReport"><code>InfOptSensitivityReport</code></a> which contains mapping to the  ranges indicating how much a constraint RHS constant or a objective  coefficient can be changed without violating the feasibility of the solution.  This is further explained in the JuMP documentation  <a href="https://jump.dev/JuMP.jl/v0.21.8/manual/solutions/#Sensitivity-analysis-for-LP">here</a>.  Furthermore, these analysis can only be employed for a solver that implements  <code>MOI.ConstraintBasisStatus</code>. In our running example up above, <code>Ipopt.jl</code> does not  support this A solver like <code>Gurobi.jl</code> does.</p><pre><code class="language-julia-repl">julia&gt; report = lp_sensitivity_report(model);

julia&gt; report[c1]
10-element Vector{Tuple{Float64, Float64}}:
 (-42.0, Inf)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)

julia&gt; report[z]
(-2.0, Inf)</code></pre><p>Note that like other query methods, an array of ranges will be provided with testing the sensitivity of an infinite constraint RHS in accordance with the discretization scheme. Also, keyword arguments (like <code>ndarray</code> and <code>label</code>) can  be invoked when indexing the report:</p><pre><code class="language-julia-repl">julia&gt; report[c1, label = All]
10-element Vector{Tuple{Float64, Float64}}:
 (-42.0, Inf)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)</code></pre><h2 id="Other-Queries"><a class="docs-heading-anchor" href="#Other-Queries">Other Queries</a><a id="Other-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Queries" title="Permalink"></a></h2><p>Any other queries supported by <code>JuMP</code> can be accessed by simply interrogating the  optimizer model directly using <a href="../../manual/optimize/#InfiniteOpt.optimizer_model"><code>optimizer_model</code></a> to access it. For  example, we can get the solution summary of the optimizer model:</p><pre><code class="language-julia-repl">julia&gt; solution_summary(optimizer_model(model))
* Solver : Ipopt

* Status
  Termination status : LOCALLY_SOLVED
  Primal status      : FEASIBLE_POINT
  Dual status        : FEASIBLE_POINT
  Message from the solver:
  &quot;Solve_Succeeded&quot;

* Candidate solution
  Objective value      : 83.99999998250514

* Work counters
  Solve time (sec)   : 0.01000</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimize/">« Optimization</a><a class="docs-footer-nextpage" href="../../manual/model/">Infinite Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 June 2021 21:04">Wednesday 23 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
