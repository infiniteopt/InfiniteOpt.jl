<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Derivatives · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../../guide/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../guide/variable/">Variables</a></li><li><a class="tocitem" href="../../guide/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../../guide/measure/">Measures</a></li><li><a class="tocitem" href="../../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../../guide/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li class="is-active"><a class="tocitem" href>Derivatives</a><ul class="internal"><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#Modification"><span>Modification</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li></ul></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Manual</a></li><li class="is-active"><a href>Derivatives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Derivatives</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/manual/derivative.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="deriv_manual"><a class="docs-heading-anchor" href="#deriv_manual">Derivative Operators</a><a id="deriv_manual-1"></a><a class="docs-heading-anchor-permalink" href="#deriv_manual" title="Permalink"></a></h1><p>A technical manual for derivatives in <code>InfiniteOpt</code>. See the respective  <a href="../../guide/derivative/#deriv_docs">guide</a> for more information.</p><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.deriv" href="#InfiniteOpt.deriv"><code>InfiniteOpt.deriv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deriv(expr::JuMP.AbstractJuMPScalar, pref1::GeneralVariableRef[, ....]
      )::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>Apply appropriate calculus methods to define and return the derivative expression of <code>expr</code>  with respect to the infinite parameter(s) <code>pref1</code>, pref2<code>, etc. in that respective  order. This will implicilty build and add individual [</code>Derivative`](@ref)s as  appropriate. Errors if no infinite parameter is given or if the parameters are  not infinite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1])
t

julia&gt; @variable(m, x, Infinite(t))
x(t)

julia&gt; @variable(m, z)
z

julia&gt; deriv_expr = deriv(x^2 + z, t, t)
2 ∂/∂t[∂/∂t[x(t)]]*x(t) + 2 ∂/∂t[x(t)]²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL409-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.∂" href="#InfiniteOpt.∂"><code>InfiniteOpt.∂</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">∂(expr::JuMP.AbstractJuMPScalar, pref1::GeneralVariableRef[, ....]
  )::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>This serves as a convenient unicode wrapper for <a href="#InfiniteOpt.deriv"><code>deriv</code></a>. The <code>∂</code> is  produced via <code>\partial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL500-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@deriv" href="#InfiniteOpt.@deriv"><code>InfiniteOpt.@deriv</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@deriv(expr, pref_expr1[, ...]
       )::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>The macro variant of <a href="#InfiniteOpt.deriv"><code>deriv</code></a> that is more efficient for expression building  and enables symbolic differential operator parameter defintions via <code>pref_expr</code>s.  Like <code>deriv</code> expr can be any InfiniteOpt expression and the appropriate calculus  rules will applied to <code>expr</code> to take its derivative with respect to the indicated  infinite parameters detailed by the <code>pref_expr</code>s. The resulting derivative  expression will contain individual derivatives that were created and added to the  InfiniteModel as needed. Here each <code>pref_expr</code> arugment can be of the form:</p><ul><li><code>pref::GeneralVariableRef</code>: An indiviudal infinite parameter reference</li><li><code>(pref::GeneralVariableRef)^(p::Int)</code>: An infinite parameter applied <code>p</code> times.</li></ul><p>Thus, the syntax <code>@deriv(expr, pref^2)</code> is equivalent to <code>@deriv(expr, pref, pref)</code>. </p><p>This will error if <code>pref_expr</code> is an unrecongnized syntax, no infinite parameter  is given, or if any of the specified parameters are not infinite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1])
t

julia&gt; @variable(m, x, Infinite(t))
x(t)

julia&gt; @variable(m, z)
z

julia&gt; deriv_expr = @deriv(x^2 + z, t^2)
2 ∂/∂t[∂/∂t[x(t)]]*x(t) + 2 ∂/∂t[x(t)]²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL449-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@∂" href="#InfiniteOpt.@∂"><code>InfiniteOpt.@∂</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@∂(expr, pref_expr1[, ...])::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>This serves as a convenient unicode wrapper for <a href="#InfiniteOpt.@deriv"><code>@deriv</code></a>. The <code>∂</code> is  produced via <code>\partial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL514-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Deriv" href="#InfiniteOpt.Deriv"><code>InfiniteOpt.Deriv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Deriv{V, P} &lt;: InfOptVariableType</code></pre><p>A <code>DataType</code> to assist in making derivative variables. This can be passed as an  extra argument to <code>@variable</code> to make such a variable: </p><pre><code class="language-julia">@variable(model, var_expr, Deriv(inf_var, inf_par), kwargs...)</code></pre><p>Here <code>inf_var</code> is the infinite variable that is being operated on and <code>inf_par</code>  is the infinite parameter that the derivative is defined with respect to.</p><p><strong>Fields</strong></p><ul><li><code>argument::V</code>: The infinite variable being operated on.</li><li><code>operator_parameter::P:</code> The infinite parameter that determines the derivative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL223-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function, VariableInfo, Deriv}" href="#JuMP.build_variable-Tuple{Function, VariableInfo, Deriv}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, info::JuMP.VariableInfo, 
                    var_type::Deriv)::InfiniteVariable{GeneralVariableRef}</code></pre><p>Build and return a first order derivative based on <code>info</code> and <code>var_type</code>. Errors  if the information in <code>var_type</code> is invalid. See <a href="#InfiniteOpt.Deriv"><code>Deriv</code></a> for more  information.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);

julia&gt; deriv_var = build_variable(error, info, Deriv(y, t));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL243-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_derivative" href="#InfiniteOpt.build_derivative"><code>InfiniteOpt.build_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_derivative(_error::Function, info::JuMP.VariableInfo, 
                 argument_ref::GeneralVariableRef, 
                 parameter_ref::GeneralVariableRef
                 )::Derivative</code></pre><p>Constructs and returns a <a href="#InfiniteOpt.Derivative"><code>Derivative</code></a> with a differential operator that  depends on <code>parameter_ref</code> and operates on <code>argument_ref</code>. Variable <code>info</code> can also  be provided to associate this derivative with bounds and a starting value function  like that of infinite variables. Errors when <code>argument_ref</code> is not an  infinite/semi-infinite variable or derivative that depends on <code>parameter_ref</code>.</p><p><strong>Example</strong> ```julia-repl  julia&gt; @infinite<em>parameter(m, t in [0, 1]); @infinite</em>variable(m, x(t));</p><p>julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);</p><p>julia&gt; build<em>derivative(error, info, x, t) Derivative{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Function}(false, 0.0, false, 0.0, false, 0.0, false, start</em>func, false, false), true, x(t), t) ````</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL177-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Derivative" href="#InfiniteOpt.Derivative"><code>InfiniteOpt.Derivative</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Derivative{F &lt;: Function, V &lt;: GeneralVariableRef} &lt;: JuMP.AbstractVariable</code></pre><p>A <code>DataType</code> for storing core infinite derivative information. This follows a  derivative of the form: <span>$\frac{\partial x(\alpha, \hdots)}{\partial \alpha}$</span>  where <span>$x(\alpha, \hdots)$</span> is an infinite variable and <span>$\alpha$</span> is an infinite  parameter. Here, both <span>$x$</span> and <span>$\alpha$</span> must be scalars. </p><p>It is important to note that <code>info.start</code> should contain a start value function that generates the start value for a given infinite parameter support. This function should map a support to a start value using user-formatting if <code>is_vector_start = false</code>, otherwise it should do the mapping using a single support vector as input. Also, the variable reference type <code>V</code> must pertain to infinite variables and parameters.</p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{Float64, Float64, Float64, F}</code>: JuMP variable information.</li><li><code>is_vector_start::Bool</code>: Does the start function take support values formatted as vectors?</li><li><code>variable_ref::V</code>: The variable reference of the infinite variable argument.</li><li><code>parameter_ref::V</code>: The variable reference of the infinite parameter the defines the  differential operator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL857-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_derivative" href="#InfiniteOpt.add_derivative"><code>InfiniteOpt.add_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_derivative(model::InfiniteModel, d::Derivative, 
               [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Adds a derivative <code>d</code> to <code>model</code> and returns a <code>GeneralVariableRef</code> that points  to it. Errors if the derivative dependencies do not belong to <code>model</code>. Note that  <code>d</code> should be built using <a href="#InfiniteOpt.build_derivative"><code>build_derivative</code></a> to avoid nuance internal  errors.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1]); @variable(m, x, Infinite(t));

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);

julia&gt; d = build_derivative(error, info, x, t);

julia&gt; dref = add_derivative(m, d)
∂/∂t[x(t)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL284-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DerivativeIndex" href="#InfiniteOpt.DerivativeIndex"><code>InfiniteOpt.DerivativeIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DerivativeIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.Derivative"><code>Derivative</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DerivativeRef" href="#InfiniteOpt.DerivativeRef"><code>InfiniteOpt.DerivativeRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DerivativeRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for untranscripted derivative references.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::DerivativeIndex</code>: Index of the derivative in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL1587-L1595">source</a></section></article><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_argument-Tuple{DerivativeRef}" href="#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_argument</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_argument(dref::DerivativeRef)::GeneralVariableRef</code></pre><p>Returns the infinite variable/derivative reference that is the input the differential operator (i.e., the dependent variable of the derivative).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_argument(dref) 
x(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL49-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.operator_parameter-Tuple{DerivativeRef}" href="#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}"><code>InfiniteOpt.operator_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">operator_parameter(dref::DerivativeRef)::GeneralVariableRef</code></pre><p>Returns the infinite parameter reference that is what the differential operator  is operating with respect to (i.e., the independent  variable of the derivative).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; operator_parameter(dref) 
t</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL65-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_derivatives" href="#InfiniteOpt.num_derivatives"><code>InfiniteOpt.num_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_derivatives(model::InfiniteModel)::Int</code></pre><p>Returns the number of derivatives that have been defined in <code>model</code>. Note that  nested derivatives will be counted in accordance with their components (e.g.,  <span>$\frac{d^2 x(t)}{dt^2} =$</span>\frac{d}{dt}\left(\frac{d x(t)}{dt} \right)``  will count as 2 derivatives.)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_derivatives(model)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL647-L660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_derivatives" href="#InfiniteOpt.all_derivatives"><code>InfiniteOpt.all_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_derivatives(model::InfiniteModel)::Vector{GeneralVariableRef}</code></pre><p>Returns a list of all the individual derivatives stored in <code>model</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; all_derivatives(model)
3-element Array{GeneralVariableRef,1}:
 ∂/∂t[T(x, t)]
 ∂/∂x[T(x, t)]
 ∂/∂x[∂/∂x[T(x, t)]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL665-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{DerivativeRef}" href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(dref::DerivativeRef)::Tuple</code></pre><p>Return the parameter references associated with the infinite derivative <code>dref</code>. This is formatted as a Tuple of containing the parameter references as they inputted to define <code>dref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(deriv)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL539-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{DerivativeRef}" href="#InfiniteOpt.parameter_list-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(dref::DerivativeRef)::Vector{GeneralVariableRef}</code></pre><p>Return a vector of the parameter references that <code>dref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL556-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(dref::DerivativeRef)::VectorTuple</code></pre><p>Return the raw <a href="../variable/#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the  parameter references that <code>dref</code> depends on. This is primarily an internal method  where <a href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>parameter_refs</code></a>  is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL527-L534">source</a></section></article><h2 id="Modification"><a class="docs-heading-anchor" href="#Modification">Modification</a><a id="Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Modification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_start_value_function-Tuple{DerivativeRef, Union{Function, Real}}" href="#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef, Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_start_value_function(dref::DerivativeRef,
                         start::Union{Real, Function})::Nothing</code></pre><p>Set the start value function of <code>dref</code>. If <code>start::Real</code> then a function is generated to such that the start value will be <code>start</code> for the entire infinite domain. If <code>start::Function</code> then this function should map to a scalar start value given a support value arguments matching the format of the parameter elements in <code>parameter_refs(dref)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_start_value_function(dref, 1) # all start values will be 1

julia&gt; set_start_value_function(dref, my_func) # each value will be made via my_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL583-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}" href="#InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}"><code>InfiniteOpt.reset_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_start_value_function(dref::DerivativeRef)::Nothing</code></pre><p>Remove the existing start value function and return to the default. Generally, this is triggered by deleting an infinite parameter that <code>dref</code> depends on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; reset_start_value_function(dref)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL618-L628">source</a></section></article><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractDerivativeMethod" href="#InfiniteOpt.AbstractDerivativeMethod"><code>InfiniteOpt.AbstractDerivativeMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractDerivativeMethod</code></pre><p>An abstract type for storing derivative evaluation data that is pertinent to its  reformation/transcription. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.GenerativeDerivativeMethod" href="#InfiniteOpt.GenerativeDerivativeMethod"><code>InfiniteOpt.GenerativeDerivativeMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GenerativeDerivativeMethod &lt;: AbstractDerivativeMethod</code></pre><p>An abstract type for derivative evaluation method types that will require support  generation when employed (e.g., internal node points associated with orthogonal  collocation). Such methods can be used with derivatives that depend on independent  infinite parameters, but cannot be used for ones that depend on dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL361-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.OrthogonalCollocation" href="#InfiniteOpt.OrthogonalCollocation"><code>InfiniteOpt.OrthogonalCollocation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrthogonalCollocation{Q &lt;: MeasureToolbox.AbstractUnivariateMethod
                      } &lt;: GenerativeDerivativeMethod</code></pre><p>A <code>DataType</code> for storing information about orthogonal collocation over finite  elements to approximate derivatives. The constructor is of the form:</p><pre><code class="nohighlight">    OrthogonalCollocation(num_nodes::Int, 
                          [quad::AbstractUnivariateMethod = GaussLobatto])</code></pre><p><strong>Fields</strong></p><ul><li><code>num_nodes::Int</code>: The number of collocation points (nodes) per finite element.</li><li><code>quadrature_method::Q</code>: The quadrature method uses to choose the collocation points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivative_evaluations.jl#LL4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.NonGenerativeDerivativeMethod" href="#InfiniteOpt.NonGenerativeDerivativeMethod"><code>InfiniteOpt.NonGenerativeDerivativeMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonGenerativeDerivativeMethod &lt;: AbstractDerivativeMethod</code></pre><p>An abstract type for derivative evaluation method types that do not require the  definition of additional support points. Such methods are amendable to any  derivative in InfiniteOpt including those with dependent infinite parameter  dependencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL371-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FiniteDifference" href="#InfiniteOpt.FiniteDifference"><code>InfiniteOpt.FiniteDifference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteDifference{T &lt;: FDTechnique} &lt;: NonGenerativeDerivativeMethod</code></pre><p>A <code>DataType</code> for information about finite difference method applied to  a derivative evaluation. Note that the constructor is of the form:</p><pre><code class="language-julia">    FiniteDifference([technique::FDTechnique = Backward()],
                     [add_boundary_constr::Bool = true])</code></pre><p>where <code>technique</code> is the indicated finite difference method to be applied and  <code>add_boundary_constr</code> indicates if the finite difference equation corresponding to  a boundary support should be included. Thus, for backward difference since corresponds to the terminal point and for forward difference this corresponds to  the initial point. We recommend using <code>add_boundary_constr = false</code> when an final  condition is given with a backward method or when an initial condition is given  with a forward method. Note that this argument is ignored for central finite  difference which cannot include any boundary points.</p><p><strong>Fields</strong> </p><ul><li><code>technique::T</code>: Mathematical technqiue behind finite difference</li><li><code>add_boundary_constraint::Bool</code>: Indicate if the boundary constraint should be  included in the transcription (e.g., the terminal boundary backward equation for  backward difference)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL413-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FDTechnique" href="#InfiniteOpt.FDTechnique"><code>InfiniteOpt.FDTechnique</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FDTechnique</code></pre><p>An abstract data type for labels of specific techniques applied in the finite  difference method in derivative evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL381-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Forward" href="#InfiniteOpt.Forward"><code>InfiniteOpt.Forward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Forward &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a forward  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL389-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Central" href="#InfiniteOpt.Central"><code>InfiniteOpt.Central</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Central &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a central  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL397-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Backward" href="#InfiniteOpt.Backward"><code>InfiniteOpt.Backward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Backward &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a backward  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL405-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_method-Tuple{DerivativeRef}" href="#InfiniteOpt.derivative_method-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_method(dref::DerivativeRef)::AbstractDerivativeMethod</code></pre><p>Returns the evaluation method employed by <code>dref</code> that determines the numerical  computation scheme that will be used to evaluate the derivative. Note that this  is set on by the infinite parameter with respect to which the derivative is  defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_method(dref) 
FiniteDifference(Backward, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL81-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef, NonGenerativeDerivativeMethod}" href="#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef, NonGenerativeDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_derivative_method(pref::IndependentParameterRef, 
                      method::AbstractDerivativeMethod)::Nothing</code></pre><p>Specfies the desired derivative evaluation method <code>method</code> for derivatives that are  taken with respect to <code>pref</code>. Any internal supports exclusively associated with  the previous method will be deleted. Also, if any derivatives were evaluated  manually, the associated derivative evaluation constraints will be deleted. Errors  if new derivative method generates supports that are incompatible with existing  measures.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_derivative_method(d, OrthogonalCollocation(2))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL792-L808">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_derivative_method-Tuple{DependentParameterRef, AbstractDerivativeMethod}" href="#InfiniteOpt.set_derivative_method-Tuple{DependentParameterRef, AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_derivative_method(pref::DependentParameterRef, 
                      method::NonGenerativeDerivativeMethod)::Nothing</code></pre><p>Specfies the desired derivative evaluation method <code>method</code> for derivatives that are  taken with respect to <code>pref</code>. Errors if <code>method</code> is generative (i.e., it requires  the definition of additional supports)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_derivative_method(d, FiniteDifference())
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL598-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_all_derivative_methods" href="#InfiniteOpt.set_all_derivative_methods"><code>InfiniteOpt.set_all_derivative_methods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_all_derivative_methods(model::InfiniteModel, 
                           method::AbstractDerivativeMethod)::Nothing</code></pre><p>Sets the desired evaluation method <code>method</code> for all the derivatives currently added  to <code>model</code>. Note that this is done with respect to the infinite parameters. Errors  if a generative method is specified and the model contains dependent parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_all_derivative_methods(model, OrthogonalCollocation(2))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL627-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate-Tuple{DerivativeRef}" href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>InfiniteOpt.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(dref::DerivativeRef)::Nothing</code></pre><p>Numerically evaluate <code>dref</code> by computing its auxiliary derivative constraints  (e.g., collocation equations) and add them to the model. For normal usage, it is  recommended that this method not be called directly and instead have TranscriptionOpt  handle these equations. Errors if <code>evaluate_derivative</code> is not  defined for the derivative method employed.</p><p>The resulting constraints can be accessed via <code>derivative_constraints</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel(); @infinite_parameter(m, t in [0,2]); @variable(m, T, Infinite(t));

julia&gt; dref = @deriv(T,t)
∂/∂t[T(t)]

julia&gt; add_supports(t, [0, 0.5, 1, 1.5, 2])

julia&gt; evaluate(dref)

julia&gt; derivative_constraints(dref)
Feasibility
4-element Array{InfOptConstraintRef,1}:
 0.5 ∂/∂t[T(t)](0.5) - T(0.5) + T(0) = 0.0
 0.5 ∂/∂t[T(t)](1) - T(1) + T(0.5) = 0.0
 0.5 ∂/∂t[T(t)](1.5) - T(1.5) + T(1) = 0.0
 0.5 ∂/∂t[T(t)](2) - T(2) + T(1.5) = 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivative_evaluations.jl#LL359-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate_all_derivatives!" href="#InfiniteOpt.evaluate_all_derivatives!"><code>InfiniteOpt.evaluate_all_derivatives!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate_all_derivatives!(model::InfiniteModel)::Nothing</code></pre><p>Evaluate all the derivatives in <code>model</code> by adding the corresponding auxiliary  equations to <code>model</code>. See <a href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>evaluate</code></a> for more information.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel();

julia&gt; @infinite_parameter(m, t in [0,2], supports = [0, 1, 2]);

julia&gt; @infinite_parameter(m, x in [0,1], supports = [0, 0.5, 1]);

julia&gt; @variable(m, T, Infinite(x, t));

julia&gt; dref1 = @deriv(T, t); dref2 = @deriv(T, x^2);

julia&gt; evaluate_all_derivatives!(m)

julia&gt; print(m)
Feasibility
Subject to
 ∂/∂t[T(x, t)](x, 1) - T(x, 1) + T(x, 0) = 0.0, ∀ x ∈ [0, 1]
 ∂/∂t[T(x, t)](x, 2) - T(x, 2) + T(x, 1) = 0.0, ∀ x ∈ [0, 1]
 0.5 ∂/∂x[T(x, t)](0.5, t) - T(0.5, t) + T(0, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[T(x, t)](1, t) - T(1, t) + T(0.5, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[∂/∂x[T(x, t)]](0.5, t) - ∂/∂x[T(x, t)](0.5, t) + ∂/∂x[T(x, t)](0, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[∂/∂x[T(x, t)]](1, t) - ∂/∂x[T(x, t)](1, t) + ∂/∂x[T(x, t)](0.5, t) = 0.0, ∀ t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivative_evaluations.jl#LL411-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_derivative_constraints-Tuple{DerivativeRef}" href="#InfiniteOpt.has_derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.has_derivative_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_derivative_constraints(dref::DerivativeRef)::Bool</code></pre><p>Return a <code>Bool</code> whether <code>dref</code> has been evaluated within the <code>InfiniteModel</code> and  has derivative constraints that have been added to the <code>InfiniteModel</code>. Note this  does not indicate if such constraints have been added to the optimizer model. Thus,  with normal usage (i.e., not using <code>evaluate</code>) this should always return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}" href="#InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_constraints(dref::DerivativeRef)::Vector{InfOptConstraintRef}</code></pre><p>Return a list of the derivative evaluation constraints for <code>dref</code> that have been  added directly to the <code>InfiniteModel</code> associated with <code>dref</code>. An empty vector is  returned is there are no such constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL697-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}" href="#InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.delete_derivative_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_derivative_constraints(dref::DerivativeRef)::Nothing</code></pre><p>Delete any derivative constraints of <code>dref</code> that have been directly added to the  <code>InfiniteModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivatives.jl#LL710-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate_derivative" href="#InfiniteOpt.evaluate_derivative"><code>InfiniteOpt.evaluate_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate_derivative(dref::GeneralVariableRef, 
                    method::AbstractDerivativeMethod,
                    write_model::JuMP.AbstractModel)::Vector{JuMP.AbstractJuMPScalar}</code></pre><p>Build expressions for derivative <code>dref</code> evaluated in accordance with <code>method</code>.  The expressions are of the form <code>lhs - rhs</code>, where <code>lhs</code> is a function of derivatives evaluated at some supports for certain infinite parameter, and <code>rhs</code> is a function of the derivative arguments evaluated at some supports for certain infinite parameter. For example, for finite difference methods at point <code>t = 1</code>, <code>lhs</code> is <code>Δt * ∂/∂t[T(1)]</code>, and <code>rhs</code> could be <code>T(1+Δt) - T(1)</code> in case of forward difference mode. This is intended as a helper function for <code>evaluate</code>, which  will take the the expressions generated by this method and generate constraints that approximate the derivative values by setting the expressions as 0. However, one can extend this function  to encode custom methods for approximating derivatives. This should invoke  <code>add_derivative_supports</code> if the method is generative and users will likely find  it convenient to use <code>make_reduced_expr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivative_evaluations.jl#LL193-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generative_support_info-Tuple{AbstractDerivativeMethod}" href="#InfiniteOpt.generative_support_info-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.generative_support_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generative_support_info(method::AbstractDerivativeMethod)::AbstractGenerativeInfo</code></pre><p>Return the <a href="../parameter/#InfiniteOpt.AbstractGenerativeInfo"><code>AbstractGenerativeInfo</code></a> associated with <code>method</code>. This is  intended as an internal method and should be extended for user-defined derivative  methods are <a href="#InfiniteOpt.GenerativeDerivativeMethod"><code>GenerativeDerivativeMethod</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivative_evaluations.jl#LL52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}" href="#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.support_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">support_label(method::GenerativeDerivativeMethod)</code></pre><p>Return the support label associated with <code>method</code> if there is one, errors otherwise.  This depends on <a href="#InfiniteOpt.generative_support_info-Tuple{AbstractDerivativeMethod}"><code>generative_support_info</code></a>  being defined for the type of <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivative_evaluations.jl#LL91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_reduced_expr" href="#InfiniteOpt.make_reduced_expr"><code>InfiniteOpt.make_reduced_expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_reduced_expr(vref::GeneralVariableRef, pref::GeneralVariableRef, 
                  support::Float64, write_model::Union{InfiniteModel, JuMP.Model})</code></pre><p>Given the argument variable <code>vref</code> and the operator parameter <code>pref</code> from a  derivative, build and return the reduced expression in accordance to the support  <code>support</code> with respect to <code>pref</code>. New point/semi-infinite variables will be written to  <code>write_model</code>. This is solely intended as a helper function for derivative  evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/derivative_evaluations.jl#LL108-L117">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variable/">« Variables</a><a class="docs-footer-nextpage" href="../expression/">Expressions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 June 2021 21:04">Wednesday 23 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
