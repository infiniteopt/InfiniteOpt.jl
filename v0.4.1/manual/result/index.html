<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Results · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../../guide/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../guide/variable/">Variables</a></li><li><a class="tocitem" href="../../guide/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../../guide/measure/">Measures</a></li><li><a class="tocitem" href="../../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../../guide/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li class="is-active"><a class="tocitem" href>Results</a><ul class="internal"><li><a class="tocitem" href="#Statuses"><span>Statuses</span></a></li><li><a class="tocitem" href="#General"><span>General</span></a></li><li><a class="tocitem" href="#Objective"><span>Objective</span></a></li><li><a class="tocitem" href="#Variables"><span>Variables</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Expressions"><span>Expressions</span></a></li><li><a class="tocitem" href="#LP-Sensitivity"><span>LP Sensitivity</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Manual</a></li><li class="is-active"><a href>Results</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Results</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/manual/result.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="result_manual"><a class="docs-heading-anchor" href="#result_manual">Results</a><a id="result_manual-1"></a><a class="docs-heading-anchor-permalink" href="#result_manual" title="Permalink"></a></h1><p>A technical manual for querying optimized <code>InfiniteOpt</code> models. See the  respective <a href="#result_manual">guide</a> for more information.</p><h2 id="Statuses"><a class="docs-heading-anchor" href="#Statuses">Statuses</a><a id="Statuses-1"></a><a class="docs-heading-anchor-permalink" href="#Statuses" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.termination_status-Tuple{InfiniteModel}" href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.termination_status(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.termination_status"><code>JuMP.termination_status</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.raw_status-Tuple{InfiniteModel}" href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>JuMP.raw_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.raw_status(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.raw_status"><code>JuMP.raw_status</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.primal_status-Tuple{InfiniteModel}" href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.primal_status(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.primal_status"><code>JuMP.primal_status</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_status-Tuple{InfiniteModel}" href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual_status(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.dual_status"><code>JuMP.dual_status</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL26-L34">source</a></section></article><h2 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.solve_time-Tuple{InfiniteModel}" href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>JuMP.solve_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.solve_time(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.solve_time"><code>JuMP.solve_time</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.simplex_iterations-Tuple{InfiniteModel}" href="#JuMP.simplex_iterations-Tuple{InfiniteModel}"><code>JuMP.simplex_iterations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.simplex_iterations(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.simplex_iterations"><code>JuMP.simplex_iterations</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.barrier_iterations-Tuple{InfiniteModel}" href="#JuMP.barrier_iterations-Tuple{InfiniteModel}"><code>JuMP.barrier_iterations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.barrier_iterations(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.barrier_iterations"><code>JuMP.barrier_iterations</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.node_count-Tuple{InfiniteModel}" href="#JuMP.node_count-Tuple{InfiniteModel}"><code>JuMP.node_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.node_count(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.node_count"><code>JuMP.node_count</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.result_count-Tuple{InfiniteModel}" href="#JuMP.result_count-Tuple{InfiniteModel}"><code>JuMP.result_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.result_count(model::InfiniteModel)</code></pre><p>Extend <code>result_count</code> to return the number of results available to query after a  call to <code>optimize!</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repla">julia&gt; result_count(model)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/optimize.jl#LL437-L448">source</a></section></article><h2 id="Objective"><a class="docs-heading-anchor" href="#Objective">Objective</a><a id="Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Objective" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_bound-Tuple{InfiniteModel}" href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.objective_bound(model::InfiniteModel)</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.objective_bound"><code>JuMP.objective_bound</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model. Errors if such a query is not supported or if the optimizer model  hasn&#39;t be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_value-Tuple{InfiniteModel}" href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.objective_value(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.objective_value"><code>JuMP.objective_value</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_objective_value-Tuple{InfiniteModel}" href="#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>JuMP.dual_objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual_objective_value(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.dual_objective_value"><code>JuMP.dual_objective_value</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL26-L34">source</a></section></article><h2 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_values-Tuple{InfiniteModel}" href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_values(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.has_values"><code>JuMP.has_values</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{GeneralVariableRef}" href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(vref::GeneralVariableRef; [result::Int = 1, 
           label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
           ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.value</code> to return the value(s) of <code>vref</code> in accordance with its  reformulation variable(s) stored in the optimizer model and the result index  <code>result</code> of the most recent solution obtained. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the values associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the values of infinite  variables are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the variable has multiple  infinite parameter dependencies.</p><p>To provide context for the results it may be helpful to also query the variable&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> to retrieve the variables(s) that these values are based on. These functions should  all be called with the same keyword arugments for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(z)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL109-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.reduced_cost-Tuple{GeneralVariableRef}" href="#JuMP.reduced_cost-Tuple{GeneralVariableRef}"><code>JuMP.reduced_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.reduced_cost(vref::GeneralVariableRef)</code></pre><p>Extend <code>JuMP.reduced_cost</code>. This returns the reduced cost(s) of a variable. This  will be a vector of scalar values for an infinite variable or will be a scalar  value for finite variables. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; reduced_cost(x)
12.81</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL284-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{GeneralVariableRef}" href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimizer_index(vref::GeneralVariableRef; 
                     [label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
                     ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.optimizer_index</code> to return the <code>MathOptInterface</code> index(es) of  <code>vref</code> in accordance with its reformulation variable(s) stored in the optimizer  model.</p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the optimizer indices associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the indices of infinite  variables are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the variable has multiple  infinite parameter dependencies.</p><p>It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> to retrieve the variables(s) that these indices are based on. These should use the  same keyword arguments for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a> has been extended for variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_index(x)
4-element Array{MathOptInterface.VariableIndex,1}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL340-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_value" href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_value([ref/expr], key::Val{ext_key_name}, result::Int; kwargs...)</code></pre><p>Map the value(s) of <code>ref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code>, <code>optimizer_model_expression</code>, and/or <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code>, <code>optimizer_model_expression</code>, and <code>optimizer_model_constraint</code> are used to make these mappings by default where <code>kwargs</code> are passed on these functions. Here  <code>result</code> is the result index used in <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL44-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_reduced_cost" href="#InfiniteOpt.map_reduced_cost"><code>InfiniteOpt.map_reduced_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_reduced_cost(vref::GeneralVariableRef, key::Val{ext_key_name}, 
                  result::Int; kwargs...)</code></pre><p>Map the reduced cost(s) of <code>vref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code>. Such as is the case with reformulations  that do not have a direct mapping between variables in the original infinite form. Otherwise, <code>optimizer_model_variable</code>, is used to make these mappings by default where <code>kwargs</code> are passed on these functions. Here  <code>result</code> is the result index used in <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL259-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_optimizer_index" href="#InfiniteOpt.map_optimizer_index"><code>InfiniteOpt.map_optimizer_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_optimizer_index(ref, key::Val{ext_key_name}; kwargs...)</code></pre><p>Map the <code>MathOptInterface</code> index(es) of <code>ref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default where <code>kwargs</code> are passed on as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL305-L317">source</a></section></article><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_duals-Tuple{InfiniteModel}" href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_duals(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="https://jump.dev/JuMP.jl/v0.21.8/reference/solutions/#JuMP.has_duals"><code>JuMP.has_duals</code></a>  for <code>InfiniteModel</code>s in accordance with that reported by its optimizer  model and the result index <code>result</code> of the most recent solution obtained.  Errors if such a query is not supported or if the optimizer model hasn&#39;t  be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{InfOptConstraintRef}" href="#JuMP.value-Tuple{InfOptConstraintRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(cref::InfOptConstraintRef; [result::Int = 1,
           label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
           ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.value</code> to return the value(s) of <code>cref</code> in accordance with its  reformulation constraint(s) stored in the optimizer model and the result index  <code>result</code> of the most recent solution obtained. Use  <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result  exists before asking for values. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the values associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the values of infinite  constraints are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the constraint has multiple  infinite parameter dependencies.</p><p>To provide context for the results it may be helpful to also query the constraint&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these values are based on. By default, only the  values corresponding to public supports are returned. These functions should  all be called with the same keyword arugments for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for constraints. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(c1)
4-element Array{Float64,1}:
 -0.0
 20.9
 20.9
 20.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL150-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{InfOptConstraintRef}" href="#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimizer_index(cref::InfOptConstraintRef; 
                     [label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
                     ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.optimizer_index</code> to return the <code>MathOptInterface</code> index(es) of  <code>cref</code> in accordance with its reformulation constraints(s) stored in the  optimizer model. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the optimizer indices associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the indices of infinite  constraints are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the constraint has multiple  infinite parameter dependencies.</p><p>It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraints(s) that these indices are based on. The same keyword  arguments should be used for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a> has been extended for constraints.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_index(c1)
4-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL381-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual-Tuple{InfOptConstraintRef}" href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>JuMP.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual(cref::InfOptConstraintRef; [result::Int = 1, 
          label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
          ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.dual</code> to return the dual(s) of <code>cref</code> in accordance with its  reformulation constraint(s) stored in the optimizer model and the result index  <code>result</code> of the most recent solution obtained. Use  <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> to check if a result  exists before asking for duals. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the duals associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the duals of infinite  constraints are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the constraint has multiple  infinite parameter dependencies.</p><p>It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these duals are based on. Calling <code>parameter_refs</code> and <code>supports</code> may also be insightful. Be sure to use the same keyword arguments for consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_dual"><code>map_dual</code></a> has been extended for constraints.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dual(c1)
4-element Array{Float64,1}:
 -42.0
 -42.0
 32.3
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL452-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.shadow_price-Tuple{InfOptConstraintRef}" href="#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>JuMP.shadow_price</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.shadow_price(cref::InfOptConstraintRef; 
                  [label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
                  ndarray::Bool = false, kwargs...])</code></pre><p>Extend <code>JuMP.shadow_price</code> to return the shadow price(s) of <code>cref</code> in accordance  with its reformulation constraint(s) stored in the optimizer model. Use  <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> to check if a result  exists before asking for duals. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the shadow prices associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the prices of infinite  constraints are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the constraint has multiple  infinite parameter dependencies.</p><p>It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these shadow prices are based on. Calling <code>parameter_refs</code> and <code>supports</code> may also be insightful. Be sure to use the same keyword arguments for  consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_shadow_price"><code>map_shadow_price</code></a> has been extended for constraints. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; shadow_price(c1)
4-element Array{Float64,1}:
 42.0
 42.0
 -32.3
 -0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL530-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_dual" href="#InfiniteOpt.map_dual"><code>InfiniteOpt.map_dual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_dual(cref::InfOptConstraintRef, key::Val{ext_key_name}, result::Int; 
         kwargs...)</code></pre><p>Map the dual(s) of <code>cref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default where <code>kwargs</code> are also pass on to. Here <code>result</code> is  the result index that is used in <code>dual</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL425-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_shadow_price" href="#InfiniteOpt.map_shadow_price"><code>InfiniteOpt.map_shadow_price</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_shadow_price(cref::InfOptConstraintRef, key::Val{ext_key_name}; 
                 kwargs...)</code></pre><p>Map the shadow price(s) of <code>cref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default where <code>kwargs</code> are passed on to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL504-L517">source</a></section></article><h2 id="Expressions"><a class="docs-heading-anchor" href="#Expressions">Expressions</a><a id="Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{Union{GenericAffExpr{var&quot;#s40&quot;, var&quot;#s39&quot;} where {var&quot;#s40&quot;, var&quot;#s39&quot;&lt;:GeneralVariableRef}, GenericQuadExpr{var&quot;#s38&quot;, var&quot;#s37&quot;} where {var&quot;#s38&quot;, var&quot;#s37&quot;&lt;:GeneralVariableRef}}}" href="#JuMP.value-Tuple{Union{GenericAffExpr{var&quot;#s40&quot;, var&quot;#s39&quot;} where {var&quot;#s40&quot;, var&quot;#s39&quot;&lt;:GeneralVariableRef}, GenericQuadExpr{var&quot;#s38&quot;, var&quot;#s37&quot;} where {var&quot;#s38&quot;, var&quot;#s37&quot;&lt;:GeneralVariableRef}}}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">value(ex::GenericAffExpr, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div></section><section><div><pre><code class="nohighlight">JuMP.value(expr::JuMP.AbstractJuMPScalar; [result::Int = 1, 
           label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
           ndarray::Bool = false, kwargs...])</code></pre><p>Return the value(s) of <code>expr</code> in accordance with the optimized variable values the result index <code>result</code> of the most recent solution obtained. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values. </p><p>The keyword arugments <code>label</code> and <code>ndarray</code> are what <code>TranscriptionOpt</code> employ  and <code>kwargs</code> denote extra ones that user extensions may employ.</p><p>By default only the values associated with public supports are returned, the  full set can be accessed via <code>label = All</code>. Moreover, the values of infinite  expressions are returned as a list. However, a n-dimensional array  can be obtained via <code>ndarray = true</code> which is handy when the expression has multiple  infinite parameter dependencies.</p><p>To provide context for the results it may be helpful to also query the expression&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_expression"><code>optimizer_model_expression</code></a> to retrieve the expression(s) that these values are based on. These should use the same keyword arguments for  consistency.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_expression"><code>optimizer_model_expression</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for expressions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(my_finite_expr)
23.34

julia&gt; value(my_infinite_expr)
4-element Array{Float64,1}:
 -0.0
 20.9
 20.9
 20.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL198-L239">source</a></section></article><h2 id="LP-Sensitivity"><a class="docs-heading-anchor" href="#LP-Sensitivity">LP Sensitivity</a><a id="LP-Sensitivity-1"></a><a class="docs-heading-anchor-permalink" href="#LP-Sensitivity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_sensitivity_report-Tuple{InfiniteModel}" href="#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}"><code>JuMP.lp_sensitivity_report</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lp_sensitivity_report(model::InfiniteModel; 
                           [atol::Float64 = 1e-8])::InfOptSensitivityReport</code></pre><p>Extends <code>JuMP.lp_sensitivity_report</code> to generate and return an LP sensitivity  report in accordance with the optimizer model. See  <a href="#InfiniteOpt.InfOptSensitivityReport"><code>InfOptSensitivityReport</code></a> for syntax details on how to query it. <code>atol</code>  denotes the optimality tolerance and should match that used by the solver to  compute the basis. Please refer to <code>JuMP</code>&#39;s documentation for more technical  information on interpretting the output of the report.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; report = lp_sensitivity_report(model);

julia&gt; report[x]
(0.0, 0.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL623-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptSensitivityReport" href="#InfiniteOpt.InfOptSensitivityReport"><code>InfiniteOpt.InfOptSensitivityReport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfOptSensitivityReport</code></pre><p>A wrapper <code>DataType</code> for <code>JuMP.SensitivityReport</code>s in <code>InfiniteOpt</code>.  These are generated based on the optimizer model and should be made via the use of  <a href="#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}"><code>lp_sensitivity_report</code></a>. Once  made these can be indexed to get the sensitivies with respect to variables and/or  constraints. The indexing syntax for these is: </p><pre><code class="language-julia">report[ref::[GeneralVariableRef/InfOptConstraintRef]; 
       [label::Type{&lt;:AbstractSupportLabel} = PublicLabel,
       ndarray::Bool = false, kwargs...]]</code></pre><p>This is enabled in user-defined optimizer model extensions by appropriately  extending <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> and <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>opt_report::JuMP.SensitivityReport</code>: The LP sensitivity captured from the optimizer model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/results.jl#LL577-L596">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimize/">« Optimization</a><a class="docs-footer-nextpage" href="../../develop/extensions/">Extensions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 June 2021 21:04">Wednesday 23 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
