<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Infinite Parameters · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../../guide/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../guide/variable/">Variables</a></li><li><a class="tocitem" href="../../guide/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../../guide/measure/">Measures</a></li><li><a class="tocitem" href="../../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../../guide/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li class="is-active"><a class="tocitem" href>Infinite Parameters</a><ul class="internal"><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#Modification"><span>Modification</span></a></li><li><a class="tocitem" href="#Generative-Supports"><span>Generative Supports</span></a></li></ul></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Manual</a></li><li class="is-active"><a href>Infinite Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Infinite Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/manual/parameter.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="inf_par_manual"><a class="docs-heading-anchor" href="#inf_par_manual">Infinite Parameters</a><a id="inf_par_manual-1"></a><a class="docs-heading-anchor-permalink" href="#inf_par_manual" title="Permalink"></a></h1><p>A technical manual for infinite parameters in <code>InfiniteOpt</code>. See the respective  <a href="../../guide/parameter/#inf_par_docs">guide</a> for more information.</p><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><h3 id="Macro"><a class="docs-heading-anchor" href="#Macro">Macro</a><a id="Macro-1"></a><a class="docs-heading-anchor-permalink" href="#Macro" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@infinite_parameter" href="#InfiniteOpt.@infinite_parameter"><code>InfiniteOpt.@infinite_parameter</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@infinite_parameter(model::InfiniteModel, kwargs...)</code></pre><p>Add <em>anonymous</em> infinite parameter to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the parameter reference.</p><pre><code class="language-julia">@infinite_parameter(model::InfiniteModel, expr, kwargs...)</code></pre><p>Add an infinite parameter to the model <code>model</code> described by the expression <code>expr</code>, and the keyword arguments <code>kw_args</code>. (Note that in the following the symbol <code>in</code>  can be used instead of <code>∈</code>) The expression <code>expr</code> can be of the form:</p><ul><li><code>paramexpr</code> creating parameters described by <code>paramexpr</code>.</li><li><code>paramexpr ∈ [lb, ub]</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval domain with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ~ dist</code> creating parameters described by <code>paramexpr</code> characterized  by the <code>Distributions.jl</code> distribution object <code>dist</code>.</li><li><code>paramexpr ∈ domain</code> creating parameters described by <code>paramexpr</code> characterized  by the <code>AbstractInfiniteDomain</code> object <code>domain</code>.</li></ul><p>The expression <code>paramexpr</code> can be of the form:</p><ul><li><code>paramname</code> creating a scalar parameter of name <code>paramname</code></li><li><code>paramname[...]</code> or <code>[...]</code> creating a container of parameters</li></ul><p>The recognized keyword arguments in <code>kwargs</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>domain</code>: The <code>InfiniteDomain</code> characterizing the parameters see subtypes of           <a href="../domains/#InfiniteOpt.AbstractInfiniteDomain"><code>AbstractInfiniteDomain</code></a>.</li><li><code>distribution</code>: Sets the <code>Distributions.jl</code> distribution object that   characterizes the parameters (specified instead of a domain).</li><li><code>supports</code>: Sets the support points for the parameters.</li><li><code>num_supports</code>: Specifies the number of supports to be automatically generated.                 Note that <code>supports</code> takes precedence. Defaults to 0.</li><li><code>derivative_method</code>: Specify the numerical method to evaluate derivatives that                       are taken with respect to the parameter.</li><li><code>sig_digits</code>: Specifies the number of significant digits that should be used               in automatic support generation. Defaults to <code>DefaultSigDigits</code>.</li><li><code>independent</code>: Specifies if the each parameter is independent from each other or not. Defaults to false.</li><li><code>container</code>: Specify the container type. Defaults to <code>Auto</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, x in [0, 1])
x

julia&gt; @infinite_parameter(m, y[i = 1:2] ~ MvNormal(ones(2)), num_supports = 10)
2-element Array{GeneralVariableRef,1}:
 y[1]
 y[2]

julia&gt; z = @infinite_parameter(m, [[&quot;a&quot;, &quot;b&quot;]], distribution = Normal(),
                               independent = true)
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, [&quot;a&quot;, &quot;b&quot;]
And data, a 2-element Array{GeneralVariableRef,1}:
 noname[a]
 noname[b]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/macros.jl#LL363-L426">source</a></section></article><h3 id="Independent-Parameters"><a class="docs-heading-anchor" href="#Independent-Parameters">Independent Parameters</a><a id="Independent-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-Parameters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptParameter" href="#InfiniteOpt.InfOptParameter"><code>InfiniteOpt.InfOptParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfOptParameter &lt;: JuMP.AbstractVariable</code></pre><p>An abstract type for all parameters used in InfiniteOpt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL450-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ScalarParameter" href="#InfiniteOpt.ScalarParameter"><code>InfiniteOpt.ScalarParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarParameter &lt;: InfOptParameter</code></pre><p>An abstract type for scalar parameters used in InfiniteOpt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL457-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.IndependentParameter" href="#InfiniteOpt.IndependentParameter"><code>InfiniteOpt.IndependentParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndependentParameter{T &lt;: InfiniteScalarDomain,
                     M &lt;: AbstractDerivativeMethod,
                     I &lt;: AbstractGenerativeInfo} &lt;: ScalarParameter</code></pre><p>A <code>DataType</code> for storing independent scalar infinite parameters.</p><p><strong>Fields</strong></p><ul><li><code>domain::T</code>: The infinite domain that characterizes the parameter.</li><li><code>supports::DataStructures.SortedDict{Float64, Set{DataType}}</code>: The support points  used to discretize the parameter and their associated type labels stored as  <code>DataTypes</code>s which should be a subtype of <a href="../domains/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</li><li><code>sig_digits::Int</code>: The number of significant digits used to round the support values.</li><li><code>derivative_method::M</code>: The derivative evaluation method used for derivatives that  are conducted with respect to this parameter.</li><li><code>gnerative_supp_info::I</code>: The info associated with any generative supports that will   need to be generated for measures and/or derivatives based on existing supports. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL464-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_parameter-Tuple{Function, InfiniteScalarDomain}" href="#InfiniteOpt.build_parameter-Tuple{Function, InfiniteScalarDomain}"><code>InfiniteOpt.build_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_parameter(
    _error::Function, domain::InfiniteScalarDomain;
    [num_supports::Int = 0,
    supports::Union{Real, Vector{&lt;:Real}} = Float64[],
    sig_digits::Int = DefaultSigDigits,
    derivative_method::AbstractDerivativeMethod = DefaultDerivativeMethod]
)::IndependentParameter</code></pre><p>Returns a <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a> given the appropriate information. This is analagous to <code>JuMP.build_variable</code>. Errors if supports violate the bounds associated with <code>domain</code>. This is meant to primarily serve as a helper method for <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. Here <code>derivative_method</code>  specifies the numerical evalution method that will be applied to derivatives that  are taken with respect to this infinite parameter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; param = build_parameter(error, IntervalDomain(0, 3), supports = Vector(0:3));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL147-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_parameter-Tuple{InfiniteModel, IndependentParameter, String}" href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel, IndependentParameter, String}"><code>InfiniteOpt.add_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_parameter(model::InfiniteModel, p::IndependentParameter,
              [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Returns a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> associated with the parameter <code>p</code> that is added  to <code>model</code>. This adds a parameter to the model in a manner similar to  <code>JuMP.add_variable</code>. This is used to add parameters with the use of  <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>.  <a href="#InfiniteOpt.build_parameter-Tuple{Function, InfiniteScalarDomain}"><code>build_parameter</code></a>  should be used to construct <code>p</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; p = build_parameter(error, IntervalDomain(0, 3), supports = Vector(0:3));

julia&gt; param_ref = add_parameter(model, p, &quot;name&quot;)
name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL239-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ScalarParameterData" href="#InfiniteOpt.ScalarParameterData"><code>InfiniteOpt.ScalarParameterData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarParameterData{P &lt;: ScalarParameter} &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing <code>ScalarParameter</code>s and their data.</p><p><strong>Fields</strong></p><ul><li><code>parameter::P</code>: The scalar parameter.</li><li><code>object_num::Int</code>: The location of the corresponding <code>ObjectIndex</code> in   <code>InfiniteModel.param_object_indices</code> (given by <code>InfiniteModel.last_object_num</code>).</li><li><code>parameter_num::Int</code>: Given by <code>InfiniteModel.last_param_num</code> (updated when                       prior parameters are deleted)</li><li><code>name::String</code>: The name used for printing.</li><li><code>parameter_func_indices::Vector{ParameterFunctionIndex}</code>: Indices of dependent  infinite parameter functions.</li><li><code>infinite_var_indices::Vector{InfiniteVariableIndex}</code>: Indices of dependent  infinite variables.</li><li><code>derivative_indices::Vector{DerivativeIndex}</code>: Indices of dependent derivatives.</li><li><code>measure_indices::Vector{MeasureIndex}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{InfOptConstraintIndex}</code>: Indices of dependent constraints.</li><li><code>in_objective::Bool</code>: Is this used in objective? This should be true only for finite parameters.</li><li><code>generative_measures::Vector{MeasureIndex}</code>: Indices of measures that use <code>parameter.generative_supp_info</code>.</li><li><code>has_internal_supports::Bool</code>: Does this parameter have internal supports?</li><li><code>has_generative_supports::Bool</code>: Have any generative supports been added?</li><li><code>has_deriv_constrs::Bool</code>: Have any derivative evaluation constraints been added                             to the infinite model associated with this parameter?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL539-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.IndependentParameterIndex" href="#InfiniteOpt.IndependentParameterIndex"><code>InfiniteOpt.IndependentParameterIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndependentParameterIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.IndependentParameterRef" href="#InfiniteOpt.IndependentParameterRef"><code>InfiniteOpt.IndependentParameterRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndependentParameterRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for independent infinite parameters references that parameterize infinite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::IndependentParameterIndex</code>: Index of the parameter in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL1512-L1521">source</a></section></article><h3 id="Dependent-Parameters"><a class="docs-heading-anchor" href="#Dependent-Parameters">Dependent Parameters</a><a id="Dependent-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Dependent-Parameters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DependentParameters" href="#InfiniteOpt.DependentParameters"><code>InfiniteOpt.DependentParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DependentParameters{T &lt;: InfiniteArrayDomain, 
                    M &lt;: NonGenerativeDerivativeMethod} &lt;: InfOptParameter</code></pre><p>A <code>DataType</code> for storing a collection of dependent infinite parameters.</p><p><strong>Fields</strong></p><ul><li><code>domain::T</code>: The infinite domain that characterizes the parameters.</li><li><code>supports::Dict{Vector{Float64}, Set{DataType}}</code>: Support dictionary where keys             are supports and the values are the set of labels for each support.</li><li><code>sig_digits::Int</code>: The number of significant digits used to round the support values.</li><li><code>derivative_methods::Vector{M}</code>: The derivative evaluation methods associated with  each parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL505-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_parameters" href="#InfiniteOpt.add_parameters"><code>InfiniteOpt.add_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_parameters(model::InfiniteModel,
               params::DependentParameters,
               names::Vector{String}
               )::Vector{GeneralVariableRef}</code></pre><p>Add <code>params</code> to <code>model</code> and return an appropriate container of the dependent infinite parameter references. This is intended as an internal method for use with <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. However, if desired users can use this to add a <code>DependentParameters</code> object to <code>model</code>. Here, <code>names</code> denote the name  of each parameter. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Distributions

julia&gt; dist = MvNormal(ones(3)); # 3 dimensional

julia&gt; domain = MultiDistributionDomain(dist); # 3 dimensional

julia&gt; params = DependentParameters(domain, Dict{Vector{Float64}, Set{DatatType}}(), 10);

julia&gt; prefs = add_parameters(model, params, [&quot;par1&quot;, &quot;par2&quot;, &quot;par3&quot;])
3-element Array{GeneralVariableRef,1}:
 par1
 par2
 par3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL240-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MultiParameterData" href="#InfiniteOpt.MultiParameterData"><code>InfiniteOpt.MultiParameterData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiParameterData{P &lt;: DependentParameters} &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> and their data.</p><p><strong>Fields</strong></p><ul><li><code>parameters::P</code>: The parameter collection.</li><li><code>object_num::Int</code>: The location of the corresponding <code>ObjectIndex</code> in  <code>InfiniteModel.param_object_indices</code> (given by <code>InfiniteModel.last_object_num</code>).</li><li><code>parameter_nums::UnitRange{Int}</code>: Given by <code>InfiniteModel.last_param_num</code>                                   (updated when prior parameters are deleted)</li><li><code>names::Vector{String}</code>: The names used for printing each parameter.</li><li><code>parameter_func_indices::Vector{ParameterFunctionIndex}</code>: Indices of  dependent infinite parameter functions.</li><li><code>infinite_var_indices::Vector{InfiniteVariableIndex}</code>: Indices of  dependent infinite variables.</li><li><code>derivative_indices::Vector{Vector{DerivativeIndex}}</code>: Indices of dependent derivatives.</li><li><code>measure_indices::Vector{Vector{MeasureIndex}}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{Vector{InfOptConstraintIndex}}</code>: Indices of dependent constraints.</li><li><code>has_internal_supports::Bool</code>: Does this parameter have internal supports?</li><li><code>has_deriv_constrs::Bool</code>: Have any derivative evaluation constraints been added                             to the infinite model associated with this parameter?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL595-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DependentParametersIndex" href="#InfiniteOpt.DependentParametersIndex"><code>InfiniteOpt.DependentParametersIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DependentParametersIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DependentParameterIndex" href="#InfiniteOpt.DependentParameterIndex"><code>InfiniteOpt.DependentParameterIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DependentParameterIndex &lt;: AbstractInfOptIndex</code></pre><p>A <code>DataType</code> for storing the index of an indiviudal parameter in a <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object.</p><p><strong>Fields</strong></p><ul><li><code>object_index::DependentParametersIndex</code>: The index of the parameter collection.</li><li><code>param_index::Int</code>: The index of the individual parameter in the above object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL42-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DependentParameterRef" href="#InfiniteOpt.DependentParameterRef"><code>InfiniteOpt.DependentParameterRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DependentParameterRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for dependent infinite parameter references that parameterize infinite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::DependentParameterIndex</code>: Index of the dependent parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL1527-L1536">source</a></section></article><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><h3 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_by_name-Tuple{InfiniteModel, String}" href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel, String}"><code>InfiniteOpt.parameter_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_by_name(model::InfiniteModel,
                  name::String)::Union{GeneralVariableRef, Nothing}</code></pre><p>Return the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_by_name(model, &quot;t&quot;)
t</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL561-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_parameters" href="#InfiniteOpt.num_parameters"><code>InfiniteOpt.num_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_parameters(model::InfiniteModel,
               [type::Type{InfOptParameter} = InfOptParameter])::Int</code></pre><p>Return the number of <code>InfiniteOpt</code> parameters assigned to <code>model</code>. By default, the total number of infinite and finite parameters is returned. The amount of a particular type is obtained by specifying the concrete parameter type of <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> via <code>type</code>. Type options include:</p><ul><li><code>InfOptParameter</code>: all parameters</li><li><code>ScalarParameter</code>: all scalar parameters</li><li><code>InfiniteParameter</code>: all infinite parameters</li><li><code>FiniteParameter</code>: all finite parameters</li><li><code>IndependentParameter</code>: all independent infinite parameters</li><li><code>DependentParameters</code>: all dependent infinite parameters</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_parameters(model)
3

julia&gt; num_parameters(model, IndependentParameter)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1517-L1540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_parameters" href="#InfiniteOpt.all_parameters"><code>InfiniteOpt.all_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_parameters(model::InfiniteModel,
               type::Type{InfOptParameter} = InfOptParameter
               )::Vector{GeneralVariableRef}</code></pre><p>Return a list of all the <code>InfiniteOpt</code> parameters assigned to <code>model</code>. By default, all of the infinite and finite parameters is returned. The search is reduced to a particular type is obtained by specifying the concrete parameter type of <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> via <code>type</code>. Type options include:</p><ul><li><code>InfOptParameter</code>: all parameters</li><li><code>ScalarParameter</code>: all scalar parameters</li><li><code>InfiniteParameter</code>: all infinite parameters</li><li><code>FiniteParameter</code>: all finite parameters</li><li><code>IndependentParameter</code>: all independent infinite parameters</li><li><code>DependentParameters</code>: all dependent infinite parameters</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all_parameters(model)
4-element Array{GeneralVariableRef,1}:
 t
 x[1]
 x[2]
 alpha

julia&gt; all_parameters(model, FiniteParameter)
1-element Array{GeneralVariableRef,1}:
 alpha</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1591-L1620">source</a></section></article><h3 id="Independent-Parameters-2"><a class="docs-heading-anchor" href="#Independent-Parameters-2">Independent Parameters</a><a class="docs-heading-anchor-permalink" href="#Independent-Parameters-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{ScalarParameterRef}" href="#JuMP.name-Tuple{ScalarParameterRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(pref::Union{IndependentParameterRef, FiniteParameterRef})::String</code></pre><p>Extend the <code>JuMP.name</code> function to accomodate infinite parameters. Returns the  name string associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(t)
&quot;t&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL464-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_domain-Tuple{IndependentParameterRef}" href="#InfiniteOpt.infinite_domain-Tuple{IndependentParameterRef}"><code>InfiniteOpt.infinite_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_domain(pref::IndependentParameterRef)::InfiniteScalarDomain</code></pre><p>Return the infinite domain associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_domain(t)
[0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL881-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{IndependentParameterRef}" href="#JuMP.has_lower_bound-Tuple{IndependentParameterRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(pref::IndependentParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_lower_bound</code> function to accomodate infinite parameters. Return true if the domain associated with <code>pref</code> has a defined lower bound or if a lower bound can be found. Extensions with user-defined infinite domain types should extend <code>JuMP.has_lower_bound(domain::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL924-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{IndependentParameterRef}" href="#JuMP.lower_bound-Tuple{IndependentParameterRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(pref::IndependentParameterRef)::Real</code></pre><p>Extend the <code>JuMP.lower_bound</code> function to accomodate infinite parameters. Returns the lower bound associated with the infinite domain. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(t)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL943-L955">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{IndependentParameterRef}" href="#JuMP.has_upper_bound-Tuple{IndependentParameterRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(pref::IndependentParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_upper_bound</code> function to accomodate infinite parameters. Return true if the domain associated with <code>pref</code> has a defined upper bound or if a upper bound can be found. Extensions with user-defined domains should extend <code>JuMP.has_upper_bound(domain::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL987-L1000">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{IndependentParameterRef}" href="#JuMP.upper_bound-Tuple{IndependentParameterRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(pref::IndependentParameterRef)::Real</code></pre><p>Extend the <code>JuMP.upper_bound</code> function to accomodate infinite parameters. Returns the upper bound associated with the infinite domain. Errors if such a bound is not well-defined. Extensions with user-defined domain types should extend <code>JuMP.has_upper_bound(domain::NewType)</code> and <code>JuMP.upper_bound(domain::NewType)</code> if appropriate.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(t)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1006-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.has_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.has_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_supports(pref::IndependentParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> has supports or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_supports(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1139-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.num_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(pref::IndependentParameterRef; 
             [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Int</code></pre><p>Return the number of support points associated with <code>pref</code>. By default, only the  number of public supports are counted. The full amount can be determined by setting  <code>label = All</code>. Moreover, the amount of labels that satisfy <code>label</code> is obtained  using an <a href="../domains/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_supports(t)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1114-L1128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(pref::IndependentParameterRef; 
         [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Vector{Float64}</code></pre><p>Return the support points associated with <code>pref</code>. Errors if there are no supports. Users can query just support points generated by a certain method using the keyword argument <code>label</code>. By default, the function returns all public support points regardless of the associated label. The full collection is given by setting  <code>label = All</code>. Moreover, the amount of labels that satisfy <code>label</code> is obtained  using an <a href="../domains/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(t)
2-element Array{Float64,1}:
 0.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1152-L1170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_internal_supports-Tuple{Union{DependentParameterRef, IndependentParameterRef}}" href="#InfiniteOpt.has_internal_supports-Tuple{Union{DependentParameterRef, IndependentParameterRef}}"><code>InfiniteOpt.has_internal_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_internal_supports(pref::Union{IndependentParameterRef, DependentParameterRef})::Bool</code></pre><p>Indicate if <code>pref</code> has internal supports that will be hidden from the user by  default. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1078-L1083">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.significant_digits-Tuple{IndependentParameterRef}" href="#InfiniteOpt.significant_digits-Tuple{IndependentParameterRef}"><code>InfiniteOpt.significant_digits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">significant_digits(pref::IndependentParameterRef)::Int</code></pre><p>Return the number of significant digits enforced on the supports of <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; significant_digits(t)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1099-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_method-Tuple{IndependentParameterRef}" href="#InfiniteOpt.derivative_method-Tuple{IndependentParameterRef}"><code>InfiniteOpt.derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_method(pref::IndependentParameterRef)::AbstractDerivativeMethod</code></pre><p>Returns the numerical derivative evaluation method employed with <code>pref</code> when it  is used as an operator parameter in a derivative.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_method(pref) 
FiniteDifference(Backward, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL761-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{ScalarParameterRef}" href="#InfiniteOpt.is_used-Tuple{ScalarParameterRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool</code></pre><p>Return true if <code>pref</code> is used in the model or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL443-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_infinite_variable-Tuple{IndependentParameterRef}" href="#InfiniteOpt.used_by_infinite_variable-Tuple{IndependentParameterRef}"><code>InfiniteOpt.used_by_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_infinite_variable(pref::IndependentParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by an infinite variable or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_infinite_variable(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL343-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_parameter_function-Tuple{IndependentParameterRef}" href="#InfiniteOpt.used_by_parameter_function-Tuple{IndependentParameterRef}"><code>InfiniteOpt.used_by_parameter_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_parameter_function(pref::IndependentParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by an infinite parameter function or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_parameter_function(t)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL361-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{ScalarParameterRef}" href="#InfiniteOpt.used_by_measure-Tuple{ScalarParameterRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool</code></pre><p>Return true if <code>pref</code> is used by a measure or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(t)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL379-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{ScalarParameterRef}" href="#InfiniteOpt.used_by_constraint-Tuple{ScalarParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool</code></pre><p>Return true if <code>pref</code> is used by a constraint or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL394-L404">source</a></section></article><h3 id="Dependent-Parameters-2"><a class="docs-heading-anchor" href="#Dependent-Parameters-2">Dependent Parameters</a><a class="docs-heading-anchor-permalink" href="#Dependent-Parameters-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{DependentParameterRef}" href="#JuMP.name-Tuple{DependentParameterRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(pref::DependentParameterRef)::String</code></pre><p>Extend <a href="../constraint/#JuMP.name-Tuple{InfOptConstraintRef}"><code>JuMP.name</code></a> to return the names of infinite dependent parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(pref)
&quot;par_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL300-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_domain-Tuple{DependentParameterRef}" href="#InfiniteOpt.infinite_domain-Tuple{DependentParameterRef}"><code>InfiniteOpt.infinite_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_domain(pref::DependentParameterRef)::InfiniteScalarDomain</code></pre><p>Return the infinite domain associated with the particular infinite dependent parameter <code>pref</code> if valid. Errors if the underlying <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object does not use a <a href="../domains/#InfiniteOpt.CollectionDomain"><code>CollectionDomain</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_domain(x[1])
[-1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL673-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_domain-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}" href="#InfiniteOpt.infinite_domain-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}"><code>InfiniteOpt.infinite_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_domain(prefs::AbstractArray{&lt;:DependentParameterRef})::InfiniteArrayDomain</code></pre><p>Return the infinite domain associated with the container of infinite dependent parameters <code>prefs</code>. Errors if the container <code>prefs</code> is incomplete.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_domain(x)
ZeroMeanDiagNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 1.0]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL701-L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{DependentParameterRef}" href="#JuMP.has_lower_bound-Tuple{DependentParameterRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(pref::DependentParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_lower_bound</code> function to accomodate a single dependent infinite parameter. Return true if the domain associated with <code>pref</code> has a defined lower bound or if a lower bound can be found. Extensions with user-defined scalar infinite domain types should extend <code>JuMP.has_lower_bound(domain::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(x[1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL805-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{DependentParameterRef}" href="#JuMP.lower_bound-Tuple{DependentParameterRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(pref::DependentParameterRef)::Number</code></pre><p>Extend the <code>JuMP.lower_bound</code> function to accomodate a single dependent infinite parameter. Returns the lower bound associated with the infinite domain. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(x[1])
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL829-L841">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{DependentParameterRef}" href="#JuMP.has_upper_bound-Tuple{DependentParameterRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(pref::DependentParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_upper_bound</code> function to accomodate a single dependent infinite parameter. Return true if the domain associated with <code>pref</code> has a defined upper bound or if a upper bound can be found. Extensions with user-defined scalar infinite domain types should extend <code>JuMP.has_upper_bound(domain::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(x[1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL874-L888">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{DependentParameterRef}" href="#JuMP.upper_bound-Tuple{DependentParameterRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(pref::DependentParameterRef)::Number</code></pre><p>Extend the <code>JuMP.upper_bound</code> function to accomodate a single dependent infinite parameter. Returns the upper bound associated with the infinite domain. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(x[1])
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL898-L910">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_supports-Tuple{DependentParameterRef}" href="#InfiniteOpt.has_supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.has_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_supports(pref::DependentParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> has supports or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_supports(x[1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1018-L1028">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}" href="#InfiniteOpt.has_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}"><code>InfiniteOpt.has_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_supports(prefs::AbstractArray{&lt;:DependentParameterRef})::Bool</code></pre><p>Return true if <code>prefs</code> have supports or false otherwise. Errors if not all of the infinite dependent parameters are from the same object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_supports(x)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1031-L1042">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{DependentParameterRef}" href="#InfiniteOpt.num_supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(pref::DependentParameterRef; 
             [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Int</code></pre><p>Return the number of support points associated with a single dependent infinite parameter <code>pref</code>. Specify a subset of supports via <code>label</code> to only count the supports with <code>label</code>. By default only the amount of public supports are given, but  the full amount is obtained via <code>label == All</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_supports(x[1])
2

julia&gt; num_supports(x[1], label = MCSample)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL967-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}" href="#InfiniteOpt.num_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(prefs::AbstractArray{&lt;:DependentParameterRef};
             [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Int</code></pre><p>Return the number of support points associated with dependent infinite parameters <code>prefs</code>. Errors if not all from the same underlying object. Specify a subset of supports via <code>label</code> to only count the supports with <code>label</code>. By default only the amount of public supports are given, but the full amount is  obtained via <code>label == All</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_supports(x)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL995-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{DependentParameterRef}" href="#InfiniteOpt.supports-Tuple{DependentParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(pref::DependentParameterRef; 
         [label::Type{&lt;:AbstractSupportLabel} = PublicLabel])::Vector{Float64}</code></pre><p>Return the support points associated with <code>pref</code>. A subset of supports can be returned via <code>label</code> to return just the supports associated with <code>label</code>. By  default only the public supports are given, but the full set is  obtained via <code>label == All</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(x[1])
2-element Array{Float64,1}:
 0.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1048-L1064">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}" href="#InfiniteOpt.supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(prefs::AbstractArray{&lt;:DependentParameterRef};
         [label::Type{&lt;:AbstractSupportLabel} = PublicLabel]
         )::Union{Vector{&lt;:AbstractArray{&lt;:Real}}, Array{Float64, 2}}</code></pre><p>Return the support points associated with <code>prefs</code>. Errors if not all of the infinite dependent parameters are from the same object. This will return a matrix if <code>prefs</code> is <code>Vector</code>, otherwise a vector of arrays is returned where each  array is a support point matching the format of <code>prefs</code>. A subset of supports can be returned via <code>label</code> to return just the supports associated with <code>label</code>. By  default only the public supports are given, but the full set is  obtained via  <code>label == All</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(x) # columns are supports
2×2 Array{Float64,2}:
 0.0  1.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1077-L1097">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.significant_digits-Tuple{DependentParameterRef}" href="#InfiniteOpt.significant_digits-Tuple{DependentParameterRef}"><code>InfiniteOpt.significant_digits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">significant_digits(pref::DependentParameterRef)::Int</code></pre><p>Return the number of significant digits enforced on the supports of <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; significant_digits(x[1])
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL952-L962">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_method-Tuple{DependentParameterRef}" href="#InfiniteOpt.derivative_method-Tuple{DependentParameterRef}"><code>InfiniteOpt.derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_method(pref::DependentParameterRef)::NonGenerativeDerivativeMethod</code></pre><p>Returns the numerical derivative evaluation method employed with <code>pref</code> when it  is used as an operator parameter in a derivative.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_method(pref) 
FiniteDifference</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL559-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{DependentParameterRef}" href="#InfiniteOpt.is_used-Tuple{DependentParameterRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(pref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL453-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_infinite_variable-Tuple{DependentParameterRef}" href="#InfiniteOpt.used_by_infinite_variable-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_infinite_variable(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used by an infinite variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_infinite_variable(pref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL370-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_parameter_function-Tuple{DependentParameterRef}" href="#InfiniteOpt.used_by_parameter_function-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_parameter_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_parameter_function(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used by an infinite parameter function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_parameter_function(pref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL386-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{DependentParameterRef}" href="#InfiniteOpt.used_by_measure-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(pref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL402-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{DependentParameterRef}" href="#InfiniteOpt.used_by_constraint-Tuple{DependentParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(pref::DependentParameterRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the dependent infinite parameter <code>pref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(pref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL418-L429">source</a></section></article><h2 id="Modification"><a class="docs-heading-anchor" href="#Modification">Modification</a><a id="Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Modification" title="Permalink"></a></h2><h3 id="General-2"><a class="docs-heading-anchor" href="#General-2">General</a><a class="docs-heading-anchor-permalink" href="#General-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}" href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>InfiniteOpt.fill_in_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_in_supports!(model::InfiniteModel; [num_supports::Int = DefaultNumSupports,
                  modify::Bool = true])::Nothing</code></pre><p>Automatically generate support points for all infinite parameters in model. This calls <code>fill_in_supports!</code> for each parameter in the model. See <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a> for more information. Errors if one of the infinite domain types is unrecognized. Note that no supports will be added to a particular parameter if it already has some and <code>modify = false</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(model, num_supports = 4)

julia&gt; supports(t)
4-element Array{Float64,1}:
 0.0
 0.333
 0.667
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1472-L1494">source</a></section></article><h3 id="Independent-Parameters-3"><a class="docs-heading-anchor" href="#Independent-Parameters-3">Independent Parameters</a><a class="docs-heading-anchor-permalink" href="#Independent-Parameters-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{ScalarParameterRef, String}" href="#JuMP.set_name-Tuple{ScalarParameterRef, String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(pref::ScalarParameterRef, name::String)</code></pre><p>Extend the <code>JuMP.set_name</code> function to accomodate infinite parameters. Set a new  base name to be associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(t, &quot;time&quot;)

julia&gt; name(t)
&quot;time&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL481-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_infinite_domain-Tuple{IndependentParameterRef, InfiniteScalarDomain}" href="#InfiniteOpt.set_infinite_domain-Tuple{IndependentParameterRef, InfiniteScalarDomain}"><code>InfiniteOpt.set_infinite_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_infinite_domain(pref::IndependentParameterRef,
                 domain::InfiniteScalarDomain)::Nothing</code></pre><p>Reset the infinite domain of <code>pref</code> with another <code>InfiniteScalarDomain</code>. An error will  be thrown if <code>pref</code> is being used by some measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_infinite_domain(t, IntervalDomain(0, 2))

julia&gt; infinite_domain(t)
[0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL896-L910">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{IndependentParameterRef, Real}" href="#JuMP.set_lower_bound-Tuple{IndependentParameterRef, Real}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_lower_bound(pref::IndependentParameterRef, lower::Real)::Nothing</code></pre><p>Extend the <code>JuMP.set_lower_bound</code> function to accomodate infinite parameters. Updates the infinite domain lower bound if such an operation is supported. Set extensions that seek to employ this should extend <code>JuMP.set_lower_bound(domain::NewType, lower::Number)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(t, -1)

julia&gt; lower_bound(t)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL964-L979">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{IndependentParameterRef, Real}" href="#JuMP.set_upper_bound-Tuple{IndependentParameterRef, Real}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_upper_bound(pref::IndependentParameterRef, lower::Real)::Nothing</code></pre><p>Extend the <code>JuMP.set_upper_bound</code> function to accomodate infinite parameters. Updates the infinite domain upper bound if and only if it is an IntervalDomain. Errors otherwise. Extensions with user-defined infinite domains should extend <code>JuMP.set_upper_bound(domain::NewType, upper::Number)</code> if appropriate.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_upper_bound(t, 2)

julia&gt; upper_bound(t)
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1029-L1044">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_supports-Tuple{IndependentParameterRef, Union{Real, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}}" href="#InfiniteOpt.add_supports-Tuple{IndependentParameterRef, Union{Real, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}}"><code>InfiniteOpt.add_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_supports(pref::IndependentParameterRef,
             supports::Union{Real, Vector{&lt;:Real}};
             [label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Add additional support points for <code>pref</code> with identifying label <code>label</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; add_supports(t, 0.5)

julia&gt; supports(t)
3-element Array{Float64,1}:
 0.0
 0.5
 1.0

julia&gt; add_supports(t, [0.25, 1])

julia&gt; supports(t)
4-element Array{Float64,1}:
 0.0
 0.25
 0.5
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1254-L1280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_supports-Tuple{IndependentParameterRef, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}" href="#InfiniteOpt.set_supports-Tuple{IndependentParameterRef, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real}"><code>InfiniteOpt.set_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_supports(pref::IndependentParameterRef, supports::Vector{&lt;:Real};
             [force::Bool = false,
             label::Type{&lt;:AbstractSupportLabel} = UserDefined]
             )::Nothing</code></pre><p>Specify the support points for <code>pref</code>. Errors if the supports violate the bounds associated with the infinite domain. Warns if the points are not unique. If <code>force</code> this will overwrite exisiting supports otherwise it will error if there are existing supports.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_supports(t, [0, 1])

julia&gt; supports(t)
2-element Array{Int64,1}:
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1211-L1231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.delete_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.delete_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_supports(pref::IndependentParameterRef; 
                [label::Type{&lt;:AbstractSupportLabel} = All])::Nothing</code></pre><p>Delete the support points for <code>pref</code>. If <code>label != All</code> then delete <code>label</code> and  any supports that solely depend on it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_supports(t)

julia&gt; supports(t)
ERROR: Parameter t does not have supports.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1307-L1321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef, AbstractInfiniteDomain}" href="#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef, AbstractInfiniteDomain}"><code>InfiniteOpt.generate_and_add_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_and_add_supports!(pref::IndependentParameterRef,
                           domain::AbstractInfiniteDomain,
                           [method::Type{&lt;:AbstractSupportLabel}];
                           [num_supports::Int = DefaultNumSupports])::Nothing</code></pre><p>Generate supports for independent parameter <code>pref</code> via <a href="../domains/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> and add them to <code>pref</code>. This is intended as an extendable internal method for <a href="#InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}"><code>fill_in_supports!</code></a>. Most extensions that empoy user-defined infinite domains can typically enable this by extending <a href="../domains/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a>. Errors if the infinite domain type is not recognized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1444-L1456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}" href="#InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}"><code>InfiniteOpt.fill_in_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_in_supports!(pref::IndependentParameterRef;
                  [num_supports::Int = DefaultNumSupports])::Nothing</code></pre><p>Automatically generate support points for a particular independent parameter <code>pref</code>. Generating <code>num_supports</code> for the parameter. The supports are generated uniformly if the underlying infinite domain is an <code>IntervalDomain</code> or they are generating randomly accordingly to the distribution if the domain is a <code>UniDistributionDomain</code>. Will add nothing if there are supports and <code>modify = false</code>. Extensions that use user defined domain types should extend <a href="#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef, AbstractInfiniteDomain}"><code>generate_and_add_supports!</code></a> and/or <a href="../domains/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> as needed. Errors if the infinite domain type is not recognized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(x, num_supports = 4)

julia&gt; supports(x)
4-element Array{Number,1}:
 0.0
 0.333
 0.667
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1405-L1430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel, IndependentParameterRef}" href="#JuMP.delete-Tuple{InfiniteModel, IndependentParameterRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, pref::ScalarParameterRef)::Nothing</code></pre><p>Extend <code>JuMP.delete</code> to delete scalar parameters and their dependencies. All variables, constraints, and measure functions that depend on <code>pref</code> are updated to exclude it. Errors if the parameter is used by an infinite variable or if it is contained in an  <code>AbstractMeasureData</code> DataType that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that <a href="../measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>parameter_refs</code></a> needs to be extended to allow deletion of parameters when custom <code>AbstractMeasureData</code> datatypes are used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete(model, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL1601-L1619">source</a></section></article><h3 id="Dependent-Parameters-3"><a class="docs-heading-anchor" href="#Dependent-Parameters-3">Dependent Parameters</a><a class="docs-heading-anchor-permalink" href="#Dependent-Parameters-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{DependentParameterRef, String}" href="#JuMP.set_name-Tuple{DependentParameterRef, String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(pref::DependentParameterRef, name::String)::Nothing</code></pre><p>Extend <a href="../constraint/#JuMP.set_name-Tuple{InfOptConstraintRef, String}"><code>JuMP.set_name</code></a> to set names of dependent infinite parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(vref, &quot;par_name&quot;)

julia&gt; name(vref)
&quot;para_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL317-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_infinite_domain-Tuple{DependentParameterRef, InfiniteScalarDomain}" href="#InfiniteOpt.set_infinite_domain-Tuple{DependentParameterRef, InfiniteScalarDomain}"><code>InfiniteOpt.set_infinite_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_infinite_domain(pref::DependentParameterRef,
                 domain::InfiniteScalarDomain)::Nothing</code></pre><p>Specify the scalar infinite domain of the dependent infinite parameter <code>pref</code> to <code>domain</code> if <code>pref</code> is part of a <a href="../domains/#InfiniteOpt.CollectionDomain"><code>CollectionDomain</code></a>, otherwise an error is thrown. Note this will reset/delete all the supports contained in the underlying <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object. Also, errors if <code>pref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_infinite_domain(x[1], IntervalDomain(0, 2))

julia&gt; infinite_domain(x[1])
[0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL744-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_infinite_domain-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}, InfiniteArrayDomain}" href="#InfiniteOpt.set_infinite_domain-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}, InfiniteArrayDomain}"><code>InfiniteOpt.set_infinite_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_infinite_domain(prefs::AbstractArray{&lt;:DependentParameterRef},
                 domain::InfiniteArrayDomain)::Nothing</code></pre><p>Specify the multi-dimensional infinite domain of the dependent infinite parameters <code>prefs</code> to <code>domain</code>. Note this will reset/delete all the supports contained in the underlying <a href="#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a> object. This will error if the not all of the dependent infinite parameters are included, if any of them are used by measures.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_infinite_domain(x, CollectionDomain([IntervalDomain(0, 1), IntervalDomain(0, 2)]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL779-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{DependentParameterRef, Real}" href="#JuMP.set_lower_bound-Tuple{DependentParameterRef, Real}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_lower_bound(pref::DependentParameterRef, lower::Real)::Nothing</code></pre><p>Extend the <code>JuMP.set_lower_bound</code> function to accomodate a single dependent infinite parameter. Updates the infinite domain lower bound if such an operation is supported. Infinite scalar domain extensions that seek to employ this should extend <code>JuMP.set_lower_bound(domain::NewType, lower::Number)</code>. This will call <a href="../expression/#InfiniteOpt.set_infinite_domain-Tuple{GeneralVariableRef, InfiniteScalarDomain}"><code>set_infinite_domain</code></a> and will error if this is not well-defined. Note that existing supports will be deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(t, -1)

julia&gt; lower_bound(t)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL849-L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{DependentParameterRef, Real}" href="#JuMP.set_upper_bound-Tuple{DependentParameterRef, Real}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_upper_bound(pref::DependentParameterRef, upper::Real)::Nothing</code></pre><p>Extend the <code>JuMP.set_upper_bound</code> function to accomodate a single dependent infinite parameter. Updates the infinite domain upper bound if such an operation is supported. Infinite scalar domain extensions that seek to employ this should extend <code>JuMP.set_upper_bound(domain::NewType, upper::Number)</code>. This will call <a href="../expression/#InfiniteOpt.set_infinite_domain-Tuple{GeneralVariableRef, InfiniteScalarDomain}"><code>set_infinite_domain</code></a> and will error if this is not well-defined. Note that existing supports will be deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_upper_bound(t, -1)

julia&gt; upper_bound(t)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL918-L935">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}, Vector{var&quot;#s39&quot;} where var&quot;#s39&quot;&lt;:(AbstractArray{var&quot;#s38&quot;, N} where {var&quot;#s38&quot;&lt;:Real, N})}" href="#InfiniteOpt.add_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}, Vector{var&quot;#s39&quot;} where var&quot;#s39&quot;&lt;:(AbstractArray{var&quot;#s38&quot;, N} where {var&quot;#s38&quot;&lt;:Real, N})}"><code>InfiniteOpt.add_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_supports(prefs::AbstractArray{&lt;:DependentParameterRef},
             supports::Vector{&lt;:AbstractArray{&lt;:Real}};
             [label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Add additional support points for <code>prefs</code>. Errors if the supports violate the domain of the infinite domain, if the dimensions don&#39;t match up properly, if <code>prefs</code> and <code>supports</code> have different indices, or not all of the <code>prefs</code> are from the same dependent infinite parameter container.</p><pre><code class="language-julia">    add_supports(prefs::Vector{DependentParameterRef},
                 supports::Array{&lt;:Real, 2};
                 [label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Specify the supports for a vector <code>prefs</code> of dependent infinite parameters. Here rows of <code>supports</code> correspond to <code>prefs</code> and the columns correspond to the supports. This is more efficient than the above method and will error for the same reasons.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; add_supports(x, [[1], [1]])

julia&gt; supports(x)
2×2 Array{Float64,2}:
 0.0  1.0
 0.0  1.0

julia&gt; add_supports(x, ones(2, 1) * 0.5)

julia&gt; supports(t)
2×3 Array{Float64,2}:
 0.0  1.0  0.5
 0.0  1.0  0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1247-L1283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}, Vector{var&quot;#s39&quot;} where var&quot;#s39&quot;&lt;:(AbstractArray{var&quot;#s38&quot;, N} where {var&quot;#s38&quot;&lt;:Real, N})}" href="#InfiniteOpt.set_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}, Vector{var&quot;#s39&quot;} where var&quot;#s39&quot;&lt;:(AbstractArray{var&quot;#s38&quot;, N} where {var&quot;#s38&quot;&lt;:Real, N})}"><code>InfiniteOpt.set_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_supports(prefs::AbstractArray{&lt;:DependentParameterRef},
             supports::Vector{&lt;:AbstractArray{&lt;:Real}};
             [force::Bool = false,
             label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Specify the support points for <code>prefs</code>. Errors if the supports violate the domain of the infinite domain, if the dimensions don&#39;t match up properly, if <code>prefs</code> and <code>supports</code> have different indices, not all of the <code>prefs</code> are from the same dependent infinite parameter container, there are existing supports and <code>force = false</code>. Note that it is strongly preferred to use <code>add_supports</code> if possible to avoid destroying measure dependencies.</p><pre><code class="language-julia">    set_supports(prefs::Vector{DependentParameterRef},
                 supports::Array{&lt;:Real, 2};
                 [force::Bool = false,
                 label::Type{&lt;:AbstractSupportLabel} = UserDefined])::Nothing</code></pre><p>Specify the supports for a vector <code>prefs</code> of dependent infinite parameters. Here rows of <code>supports</code> correspond to <code>prefs</code> and the columns correspond to the supports. This is more efficient than the above method and will error for the same reasons.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_supports(y, [[0, 1], [0, 1]])

julia&gt; set_supports(x, [0 1; 0 1])

julia&gt; supports(x)
2×2 Array{Float64,2}:
 0.0  1.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1173-L1208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}" href="#InfiniteOpt.delete_supports-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}"><code>InfiniteOpt.delete_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_supports(prefs::AbstractArray{&lt;:DependentParameterRef};
                [label::Type{&lt;:AbstractSupportLabel} = All])::Nothing</code></pre><p>Delete the support points for <code>prefs</code>. Errors if any of the parameters are used by a measure or if not all belong to the same set of dependent parameters. If <code>label != All</code> then that label is removed along with any supports that solely  contain that label.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_supports(w)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1335-L1349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generate_and_add_supports!-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}, InfiniteArrayDomain}" href="#InfiniteOpt.generate_and_add_supports!-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}, InfiniteArrayDomain}"><code>InfiniteOpt.generate_and_add_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_and_add_supports!(prefs::AbstractArray{&lt;:DependentParameterRef},
                           domain::InfiniteArrayDomain,
                           [method::Type{&lt;:AbstractSupportLabel}];
                           [num_supports::Int = DefaultNumSupports])::Nothing</code></pre><p>Generate supports for <code>prefs</code> via <a href="../domains/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> and add them to <code>pref</code>. This is intended as an extendable internal method for <a href="#InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}"><code>fill_in_supports!</code></a>. Most extensions that employ user-defined infinite domains can typically enable this by extending <a href="../domains/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a>. However, in some cases it may be necessary to extend this when more complex operations need to take place then just adding supports to a set of infinite parameters. Errors if the infinite domain type is not recognized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1387-L1401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}" href="#InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}"><code>InfiniteOpt.fill_in_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_in_supports!(prefs::AbstractArray{&lt;:DependentParameterRef};
                  [num_supports::Int = DefaultNumSupports,
                   modify::Bool = true])::Nothing</code></pre><p>Automatically generate support points for a container of dependent infinite parameters <code>prefs</code>. Generating up to <code>num_supports</code> for the parameters in accordance with <code>generate_and_add_supports!</code>. Will add nothing if there are supports and <code>modify = false</code>. Extensions that use user defined domain types should extend <a href="#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef, AbstractInfiniteDomain}"><code>generate_and_add_supports!</code></a> and/or <a href="../domains/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> as needed. Errors if the infinite domain type is not recognized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(x, num_supports = 4)

julia&gt; supports(x)
2×4 Array{Float64,2}:
 0.0  0.333  0.667  1.0
 0.0  0.333  0.667  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1430-L1452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel, AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}" href="#JuMP.delete-Tuple{InfiniteModel, AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:DependentParameterRef, N}}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel,
            prefs::AbstractArray{&lt;:DependentParameterRef})::Nothing</code></pre><p>Extend <code>JuMP.delete</code> to delete dependent infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on <code>prefs</code> are updated to exclude them. Errors if the parameters are contained in an <code>AbstractMeasureData</code> datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that <a href="../measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>parameter_refs</code></a> needs to be extended to allow deletion of parameters when custom <code>AbstractMeasureData</code> datatypes are used. Note that any dependent infinite variables will have their start values reset to the default via <a href="../derivative/#InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}"><code>reset_start_value_function</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t, x)*t + x) + z
Subject to
 z ≥ 0.0
 g(t, x) + z ≥ 42.0, ∀ t ∈ [0, 6], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]
 g(0.5, x) = 0, x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]

julia&gt; delete(model, x)

julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/array_parameters.jl#LL1683-L1715">source</a></section></article><h2 id="Generative-Supports"><a class="docs-heading-anchor" href="#Generative-Supports">Generative Supports</a><a id="Generative-Supports-1"></a><a class="docs-heading-anchor-permalink" href="#Generative-Supports" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractGenerativeInfo" href="#InfiniteOpt.AbstractGenerativeInfo"><code>InfiniteOpt.AbstractGenerativeInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGenerativeInfo</code></pre><p>An abstract type for storing information about generating supports that are made  based on existing supports as required by certain measures and/or derivatives  that depend on a certain independent infinite parameter. Such as the case with  internal collocation supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL296-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.NoGenerativeSupports" href="#InfiniteOpt.NoGenerativeSupports"><code>InfiniteOpt.NoGenerativeSupports</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoGenerativeSupports &lt;: AbstractGenerativeInfo</code></pre><p>A <code>DataType</code> to signify that no generative supports will be generated for the  measures and/or the derivatives. Has no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL306-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.UniformGenerativeInfo" href="#InfiniteOpt.UniformGenerativeInfo"><code>InfiniteOpt.UniformGenerativeInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniformGenerativeInfo &lt;: AbstractGenerativeInfo</code></pre><p>A <code>DataType</code> for generative supports that will be generated in a uniform manner  over finite elements (i.e., in between the existing supports). These generative  supports are described by the <code>support_basis</code> which lie in a nominal domain [0, 1].  The constructor is of the form:</p><pre><code class="nohighlight">    UniformGenerativeInfo(support_basis::Vector{&lt;:Real}, label::DataType, 
                          [lb::Real = 0, ub::Real = 1])</code></pre><p>where the <code>support_basis</code> is defined over [<code>lb</code>, <code>ub</code>].</p><p><strong>Fields</strong></p><ul><li><code>support_basis::Vector{Float64}</code>: The basis of generative supports defined in   [0, 1] that will be transformed for each finite element.</li><li><code>label::DataType</code>: The unique label to be given to each generative support.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/datatypes.jl#LL314-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_generative_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.has_generative_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.has_generative_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_generative_supports(pref::IndependentParameterRef)::Bool</code></pre><p>Return whether generative supports have been added to <code>pref</code> in accordance  with its generative support info.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL636-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_label-Tuple{AbstractGenerativeInfo}" href="#InfiniteOpt.support_label-Tuple{AbstractGenerativeInfo}"><code>InfiniteOpt.support_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">support_label(info::AbstractGenerativeInfo)::DataType</code></pre><p>Return the support label to be associated with generative supports produced in  accordance with <code>info</code>. This is intended an internal method that should be  extended for user defined types of <a href="#InfiniteOpt.AbstractGenerativeInfo"><code>AbstractGenerativeInfo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL605-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generative_support_info-Tuple{IndependentParameterRef}" href="#InfiniteOpt.generative_support_info-Tuple{IndependentParameterRef}"><code>InfiniteOpt.generative_support_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generative_support_info(pref::IndependentParameterRef)::AbstractGenerativeInfo</code></pre><p>Return the generative support information associated with <code>pref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL627-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_generative_supports" href="#InfiniteOpt.make_generative_supports"><code>InfiniteOpt.make_generative_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_generative_supports(info::AbstractGenerativeInfo,
                         pref::IndependentParameterRef,
                         existing_supps::Vector{Float64}
                         )::Vector{Float64}</code></pre><p>Generate the generative supports for <code>pref</code> in accordance with <code>info</code> and the  <code>existing_supps</code> that <code>pref</code> has. The returned supports should not include  <code>existing_supps</code>. This is intended as internal method to enable  <a href="#InfiniteOpt.add_generative_supports"><code>add_generative_supports</code></a> and should be extended for any user defined  <code>info</code> types that are created to enable new measure and/or derivative evaluation  techniques that require the creation of generative supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL678-L690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_generative_supports" href="#InfiniteOpt.add_generative_supports"><code>InfiniteOpt.add_generative_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_generative_supports(pref::IndependentParameterRef)::Nothing</code></pre><p>Create generative supports for <code>pref</code> if needed in accordance with its  generative support info using <a href="#InfiniteOpt.make_generative_supports"><code>make_generative_supports</code></a> and add them to  <code>pref</code>. This is intended as an internal function, but can be useful user defined  optimizer model extensions that utlize our support system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/scalar_parameters.jl#LL732-L739">source</a></section><section><div><pre><code class="language-julia">add_generative_supports(prefs; [kwargs...])</code></pre><p>Define <code>add_generative_supports</code> for general variable references. It relies on <code>add_generative_supports</code> being defined for the underlying <code>DispatchVariableRef</code>, otherwise an <code>ArgumentError</code> is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use <code>kwargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/33c5643917f11bcee2864bb3da4f58d729953764/src/general_variables.jl#LL479-L487">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../domains/">« Infinite Domains</a><a class="docs-footer-nextpage" href="../finite_parameter/">Finite Parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 June 2021 21:04">Wednesday 23 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
