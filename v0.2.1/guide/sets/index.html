<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Infinite Sets · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li class="is-active"><a class="tocitem" href>Infinite Sets</a><ul class="internal"><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Infinite-Set-Classes"><span>Infinite Set Classes</span></a></li><li><a class="tocitem" href="#Bound-Query/Modification-Methods-for-Infinite-Sets"><span>Bound Query/Modification Methods for Infinite Sets</span></a></li><li><a class="tocitem" href="#Support-Generation-for-Infinite-Sets"><span>Support Generation for Infinite Sets</span></a></li><li><a class="tocitem" href="#User-Defined-Sets"><span>User Defined Sets</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Infinite Sets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Infinite Sets</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/sets.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="infinite_sets_normal"><a class="docs-heading-anchor" href="#infinite_sets_normal">Infinite Sets</a><a id="infinite_sets_normal-1"></a><a class="docs-heading-anchor-permalink" href="#infinite_sets_normal" title="Permalink"></a></h1><p>A guide and manual to the definition and use of infinite sets in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Interval sets are what characterize the behavior of infinite parameters in <code>InfiniteOpt</code>, since they comprise the domains of infinite parameters. However, most users will not need to work directly with infinite sets and can instead focus on the use of infinite parameters as defined via <a href="../parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> and as discussed on the <a href="../parameter/#inf_par_page">Infinite Parameters</a> page.</p><p>However, for convenience below we summary the infinite sets associated with <code>InfiniteOpt</code>:</p><table><tr><th style="text-align: center">Set Type</th><th style="text-align: center">Domain</th><th style="text-align: center">Type</th></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td><td style="text-align: center"><span>$[lb, ub]$</span></td><td style="text-align: center"><a href="#InfiniteOpt.InfiniteScalarSet"><code>InfiniteScalarSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.UniDistributionSet"><code>UniDistributionSet</code></a></td><td style="text-align: center"><span>$\sim \mathcal{D} \subseteq \mathbb{R}$</span></td><td style="text-align: center"><a href="#InfiniteOpt.InfiniteScalarSet"><code>InfiniteScalarSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MultiDistributionSet"><code>MultiDistributionSet</code></a></td><td style="text-align: center"><span>$\sim \mathcal{D} \subseteq \mathbb{R}^n$</span></td><td style="text-align: center"><a href="#InfiniteOpt.InfiniteArraySet"><code>InfiniteArraySet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.CollectionSet"><code>CollectionSet</code></a></td><td style="text-align: center">Combination of Univariate Domains</td><td style="text-align: center"><a href="#InfiniteOpt.InfiniteArraySet"><code>InfiniteArraySet</code></a></td></tr></table><h2 id="Infinite-Set-Classes"><a class="docs-heading-anchor" href="#Infinite-Set-Classes">Infinite Set Classes</a><a id="Infinite-Set-Classes-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-Set-Classes" title="Permalink"></a></h2><p>The domain of a given infinite parameter(s) is described by an infinite set inherited from <a href="#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a>. <code>InfiniteOpt</code> natively supports two set sub-groups, namely <a href="#InfiniteOpt.InfiniteScalarSet"><code>InfiniteScalarSet</code></a>s and <a href="#InfiniteOpt.InfiniteArraySet"><code>InfiniteArraySet</code></a>s.  These correspond to a single independent infinite parameter and a dependent multi-dimensional  group of infinite parameters, respectively. We describe each group&#39;s natively  supported sets below.</p><h3 id="Univariate-Sets"><a class="docs-heading-anchor" href="#Univariate-Sets">Univariate Sets</a><a id="Univariate-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Sets" title="Permalink"></a></h3><p>Univariate infinite sets (i.e., <a href="#InfiniteOpt.InfiniteScalarSet"><code>InfiniteScalarSet</code></a>s) are one-dimensional  domains (<span>$\subseteq \mathbb{R}$</span>) that describe the behavior of one single independent  infinite parameter (i.e., infinite parameters made using <code>independent = true</code>). The  two natively supported concrete types are <a href="#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>s and <a href="#InfiniteOpt.UniDistributionSet"><code>UniDistributionSet</code></a>s.</p><p><a href="#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>s describe a continuous interval from some lower bound up to  some upper bound. Where the range is inclusive of the bounds. Such sets often  arise for parameters that pertain to time and/or spatial position. For example,  to define a position interval <span>$[-2, 2]$</span> we would use:</p><pre><code class="language-julia-repl">julia&gt; set = IntervalSet(-2, 2)
[-2, 2]</code></pre><p>Note that (semi-)infinite bounds are acceptable, as shown in the following example:</p><pre><code class="language-julia-repl">julia&gt; infinite_set = IntervalSet(-Inf, Inf)
[-Inf, Inf]</code></pre><p><a href="#InfiniteOpt.UniDistributionSet"><code>UniDistributionSet</code></a>s pertain to the co-domain of a univariate distribution.  In other words, these correspond to the underlying distributions that characterize  uncertain scalar parameters. These sets are compatible with any univariate  distribution native to <a href="https://github.com/JuliaStats/Distributions.jl"><code>Distributions.jl</code></a>. For example, let&#39;s make a <code>UniDistributionSet</code> that depends on a Beta distribution:</p><pre><code class="language-julia-repl">julia&gt; using Distributions;

julia&gt; set = UniDistributionSet(Beta(2,2))
Beta{Float64}(α=2.0, β=2.0)</code></pre><p>User-defined distributions are also permissible so long as they are created in accordance with <code>Distributions.jl</code>.</p><h3 id="Multivariate-Sets"><a class="docs-heading-anchor" href="#Multivariate-Sets">Multivariate Sets</a><a id="Multivariate-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Sets" title="Permalink"></a></h3><p>Multivariate infinite sets (i.e., [<code>InfiniteArraySet</code>])(@ref)s are multi-dimensional  domains that define the behavior of a group of dependent infinite parameters  (i.e., an array of infinite parameters where <code>independent = false</code>). This is a  unique feature to <code>InfiniteOpt</code> that enables a much richer set of possibilities  for modeling infinite domain. Natively two set types are supported:  <a href="#InfiniteOpt.MultiDistributionSet"><code>MultiDistributionSet</code></a>s and <a href="#InfiniteOpt.CollectionSet"><code>CollectionSet</code></a>s. </p><p><a href="#InfiniteOpt.MultiDistributionSet"><code>MultiDistributionSet</code></a>s correspond to the co-domain of a multi-variate  (or matrix-variate) distribution which characterizes the behavior of multi-dimensional  uncertain parameters. Again, these correspond to any appropriate distribution  defined in <code>Distributions.jl</code>. For example, we can make a <code>MultiDistributionSet</code>  that depends on a 2-D normal distribution as follows:</p><pre><code class="language-julia-repl">julia&gt; using Distributions;

julia&gt; dist = MvNormal([0., 0.], [1. 0.; 0. 2.]);

julia&gt; set = MultiDistributionSet(dist)
FullNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 2.0]
)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The dimensions (shape) of a chosen distribution used in an <code>MultiDistriubtionSet</code>  must match those of the corresponding infinite parameter array.</p></div></div><p>Finally, <a href="#InfiniteOpt.CollectionSet"><code>CollectionSet</code></a>s are a dependent collection of <a href="#InfiniteOpt.InfiniteScalarSet"><code>InfiniteScalarSet</code></a>s that correspond to a group of infinite parameters that are treated dependently.  This can be useful when the user wishes to have complete control over how the  supports are generated for a group independent parameters where the default  combinatorial approach in not wanted. For example, let&#39;s make a set of <code>IntervalSet</code>s:</p><pre><code class="language-julia-repl">julia&gt; set = CollectionSet([IntervalSet(-2, 2), IntervalSet(-1, 4)])
CollectionSet with 2 sets:
 [-2, 2]
 [-1, 4]</code></pre><p>Now we could use this set in define a two-dimensional infinite parameter of which  we can have the freedom to define a non-combinatorial support grid.</p><h2 id="Bound-Query/Modification-Methods-for-Infinite-Sets"><a class="docs-heading-anchor" href="#Bound-Query/Modification-Methods-for-Infinite-Sets">Bound Query/Modification Methods for Infinite Sets</a><a id="Bound-Query/Modification-Methods-for-Infinite-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Bound-Query/Modification-Methods-for-Infinite-Sets" title="Permalink"></a></h2><p>Once an infinite set is created, one can query the lower bound and upper bound of the set  similar to how one queries the bounds of a <code>JuMP</code> variable. Thus, the functions  <a href="../../JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a>, <a href="../../JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a>, <a href="../../JuMP/#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a>, <a href="../../JuMP/#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a>  are all applicable to infinite sets mentioned above. For example, for an <code>IntervalSet</code> <code>[-2, 2]</code> we can query the bound information as follows:</p><pre><code class="language-julia-repl">julia&gt; set = IntervalSet(-2, 2);

julia&gt; has_lower_bound(set)
true

julia&gt; has_upper_bound(set)
true

julia&gt; lower_bound(set)
-2.0

julia&gt; upper_bound(set)
2.0</code></pre><p>In addition, we can also apply <a href="../../JuMP/#JuMP.set_lower_bound-Tuple{VariableRef,Number}"><code>JuMP.set_lower_bound</code></a> and <a href="../../JuMP/#JuMP.set_upper_bound-Tuple{VariableRef,Number}"><code>JuMP.set_upper_bound</code></a>  to <code>IntervalSet</code>s to generate a new set with updated bounds. Note that this will not modify the original set. For example, we can change the bounds of the set <code>[-2, 2]</code> as follows:</p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(set, -1)
[-1, 2]

julia&gt; set_upper_bound(set, 1)
[-2, 1]</code></pre><h2 id="Support-Generation-for-Infinite-Sets"><a class="docs-heading-anchor" href="#Support-Generation-for-Infinite-Sets">Support Generation for Infinite Sets</a><a id="Support-Generation-for-Infinite-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Support-Generation-for-Infinite-Sets" title="Permalink"></a></h2><p><code>InfiniteOpt</code> provides a systematic interface to generate support points for infinite sets. This is crucial as support generation decides how each infinite-dimensional parameter, which is subject to certain infinite set, is discretized later in the transcription stage. The interface will allow users to automatically generate support points using our default methods. Later we will also show that users can  also input support points manually for an infinite parameter. Please note that these  methods are called by the <a href="../parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> macro when the <code>num_supports</code>  keyword is used. Thus, users typically will not need to use this interface directly.</p><p>In <code>InfiniteOpt</code> supports can be generated via <a href="#InfiniteOpt.generate_supports"><code>generate_supports</code></a> function. For example, let&#39;s  generate 5 equidistant support points for the <code>IntervalSet</code> [-2, 2]:</p><pre><code class="language-julia-repl">julia&gt; supps, label = generate_supports(set, num_supports = 5)
([-2.0, -1.0, 0.0, 1.0, 2.0], :uniform_grid)

julia&gt; supps
5-element Array{Float64,1}:
 -2.0
 -1.0
  0.0
  1.0
  2.0

julia&gt; label
:uniform_grid</code></pre><p>Note that the number of supports generated is specified via <code>num_supports</code> keyword argument, which will take a default value of 10 if not specified.  The function <code>generate_supports</code> returns a vector of the supports generated, and a label that symbolizes the underlying method. In this case the label returned is <code>UniformGrid</code>, which is the default  support generation method for <code>IntervalSet</code>s. Another support generation method implemented for <code>IntervalSet</code>s is <code>MCSample</code>, which is to sample from a uniform distribution over the interval. To use this mehtod, users need to specify a second positional argument, as shown in the following example:</p><pre><code class="language-julia-repl">julia&gt; generate_supports(set, MCSample, num_supports = 5)
([1.29459, 1.64143, -1.34174, -1.29068, -0.88448], :mc_sample)</code></pre><p>In this case, the returned label is <code>MCSample</code>, instead of <code>UniformGrid</code>.</p><p><code>generate_supports</code> can also be applied to <code>DistributionSets</code>. The default (and currently only) method implemented for <code>DistributionSets</code> is <code>WeightedSample</code>, which generates Monte Carlo samples that are  weighted based on the underlying probability density function of the distribution.  For example, a set of support points for a 2-D normal distribution can be generated as follows:</p><pre><code class="language-setup">julia&gt; dist = MvNormal([0., 0.], [1. 0.;0. 2.]);

julia&gt; set = MultiDistributionSet(dist);

julia&gt; supps, label = generate_supports(set, num_supports = 3)
([0.679107426036 -0.353007400301 0.586617074633; 1.17155358277 -0.190712174623 0.420496392851], :weighted_sample)

julia&gt; supps
2×3 Array{Float64,2}:
 0.679107  -0.353007  0.586617
 1.17155   -0.190712  0.420496</code></pre><p>For those who are interested in coding up their own support generation functions, <a href="#InfiniteOpt.generate_supports"><code>generate_supports</code></a> is an inteface that calls the proper <a href="#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> function based on the type of set and value of method. Therefore, to use custom support generation methods, users can implement extensions for <a href="#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a>  with a different method label from the existing methods. See <a href="../../extensions/#Extensions">Extensions</a> for full details.</p><h2 id="User-Defined-Sets"><a class="docs-heading-anchor" href="#User-Defined-Sets">User Defined Sets</a><a id="User-Defined-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#User-Defined-Sets" title="Permalink"></a></h2><p>Furthermore, custom infinite sets that inherit <code>AbstractInfiniteSet</code> can also be defined. See <a href="../../extensions/#Extensions">Extensions</a> for more information.</p><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.AbstractInfiniteSet"><code>InfiniteOpt.AbstractInfiniteSet</code></a></li><li><a href="#InfiniteOpt.CollectionSet"><code>InfiniteOpt.CollectionSet</code></a></li><li><a href="#InfiniteOpt.InfiniteArraySet"><code>InfiniteOpt.InfiniteArraySet</code></a></li><li><a href="#InfiniteOpt.InfiniteScalarSet"><code>InfiniteOpt.InfiniteScalarSet</code></a></li><li><a href="#InfiniteOpt.IntervalSet"><code>InfiniteOpt.IntervalSet</code></a></li><li><a href="#InfiniteOpt.MultiDistributionSet"><code>InfiniteOpt.MultiDistributionSet</code></a></li><li><a href="#InfiniteOpt.UniDistributionSet"><code>InfiniteOpt.UniDistributionSet</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractInfiniteSet" href="#InfiniteOpt.AbstractInfiniteSet"><code>InfiniteOpt.AbstractInfiniteSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractInfiniteSet</code></pre><p>An abstract type for sets that characterize infinite parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/datatypes.jl#LL170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteScalarSet" href="#InfiniteOpt.InfiniteScalarSet"><code>InfiniteOpt.InfiniteScalarSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteScalarSet &lt;: AbstractInfiniteSet</code></pre><p>An abstract type for infinite sets that are one-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/datatypes.jl#LL177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.IntervalSet" href="#InfiniteOpt.IntervalSet"><code>InfiniteOpt.IntervalSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IntervalSet &lt;: InfiniteScalarSet</code></pre><p>A <code>DataType</code> that stores the lower and upper interval bounds for infinite parameters that are continuous over a certain that interval. This is for use with a <a href="../parameter/#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>lower_bound::Float64</code> Lower bound of the infinite parameter.</li><li><code>upper_bound::Float64</code> Upper bound of the infinite parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/datatypes.jl#LL184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.UniDistributionSet" href="#InfiniteOpt.UniDistributionSet"><code>InfiniteOpt.UniDistributionSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniDistributionSet{T &lt;: Distributions.UnivariateDistribution} &lt;: InfiniteScalarSet</code></pre><p>A <code>DataType</code> that stores the distribution characterizing an infinite parameter that is random. This is for use with a <a href="../parameter/#InfiniteOpt.IndependentParameter"><code>IndependentParameter</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>distribution::T</code> Distribution of the random parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/datatypes.jl#LL207-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteArraySet" href="#InfiniteOpt.InfiniteArraySet"><code>InfiniteOpt.InfiniteArraySet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteArraySet &lt;: AbstractInfiniteSet</code></pre><p>An abstract type for multi-dimensional infinite sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/datatypes.jl#LL220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MultiDistributionSet" href="#InfiniteOpt.MultiDistributionSet"><code>InfiniteOpt.MultiDistributionSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiDistributionSet{T &lt;: NonUnivariateDistribution} &lt;: InfiniteArraySet</code></pre><p>A <code>DataType</code> that stores the distribution characterizing a collection of infinite parameters that follows its form. This is for use with <a href="../parameter/#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>distribution::T</code> Distribution of the random parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/datatypes.jl#LL231-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.CollectionSet" href="#InfiniteOpt.CollectionSet"><code>InfiniteOpt.CollectionSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CollectionSet{T &lt;: InfiniteScalarSet} &lt;: InfiniteArraySet</code></pre><p>A <code>DataType</code> that stores a collection of <code>InfiniteScalarSet</code>s characterizing a collection of infinite parameters that follows its form. This is for use with <a href="../parameter/#InfiniteOpt.DependentParameters"><code>DependentParameters</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>sets::Array{T}</code> The collection of scalar sets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/datatypes.jl#LL248-L257">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.collection_sets"><code>InfiniteOpt.collection_sets</code></a></li><li><a href="#InfiniteOpt.generate_support_values"><code>InfiniteOpt.generate_support_values</code></a></li><li><a href="#InfiniteOpt.generate_supports"><code>InfiniteOpt.generate_supports</code></a></li><li><a href="#InfiniteOpt.supports_in_set"><code>InfiniteOpt.supports_in_set</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.lower_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.set_lower_bound-Tuple{AbstractInfiniteSet,Real}"><code>JuMP.set_lower_bound</code></a></li><li><a href="#JuMP.set_upper_bound-Tuple{AbstractInfiniteSet,Real}"><code>JuMP.set_upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.upper_bound</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.collection_sets" href="#InfiniteOpt.collection_sets"><code>InfiniteOpt.collection_sets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collection_sets(set::AbstractInfiniteSet)</code></pre><p>Return the array of sets associated with a <code>CollectionSet</code>. Error if the input set is not a <code>CollectionSet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{AbstractInfiniteSet}" href="#JuMP.has_lower_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(set::AbstractInfiniteSet)::Bool</code></pre><p>Return <code>Bool</code> indicating if <code>set</code> has a lower bound that can be determined. This should be extended for user-defined infinite sets. It defaults to <code>false</code> for unrecognized set types.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set = InfiniteSet(0, 1);

julia&gt; has_lower_bound(set)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL92-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{AbstractInfiniteSet}" href="#JuMP.lower_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(set::AbstractInfiniteSet)::Union{Real, Vector{&lt;:Real}}</code></pre><p>Return the lower bound of <code>set</code> if one exists. This should be extended for user-defined infinite sets if appropriate. Errors if <code>JuMP.has_lower_bound</code> returns <code>false</code>. Extensions are enabled by <code>JuMP.has_lower_bound(set)</code> and <code>JuMP.lower_bound(set)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set = InfiniteSet(0, 1);

julia&gt; lower_bound(set)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL127-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{AbstractInfiniteSet,Real}" href="#JuMP.set_lower_bound-Tuple{AbstractInfiniteSet,Real}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_lower_bound(set::AbstractInfiniteSet,
                     lower::Union{Real, Vector{&lt;:Real}})::AbstractInfiniteSet</code></pre><p>Set and return the lower bound of <code>set</code> if such an operation makes sense. Errors if the type of <code>set</code> does not support this operation or has not been extended. User-defined set types should extend this if appropriate.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set = InfiniteSet(0, 1);

julia&gt; set_lower_bound(set, 0.5)
[0.5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL161-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{AbstractInfiniteSet}" href="#JuMP.has_upper_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(set::AbstractInfiniteSet)::Bool</code></pre><p>Return <code>Bool</code> indicating if <code>set</code> has a upper bound that can be determined. This should be extended for user-defined infinite sets. It defaults to <code>false</code> for unrecognized set types.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set = InfiniteSet(0, 1);

julia&gt; has_upper_bound(set)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL206-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{AbstractInfiniteSet}" href="#JuMP.upper_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(set::AbstractInfiniteSet)::Union{Real, Vector{&lt;:Real}}</code></pre><p>Return the upper bound of <code>set</code> if one exists. This should be extended for user-defined infinite sets if appropriate. Errors if <code>JuMP.has_upper_bound</code> returns <code>false</code>. Extensions are enabled by <code>JuMP.has_upper_bound(set)</code> and <code>JuMP.upper_bound(set)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set = InfiniteSet(0, 1);

julia&gt; upper_bound(set)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL241-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{AbstractInfiniteSet,Real}" href="#JuMP.set_upper_bound-Tuple{AbstractInfiniteSet,Real}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_upper_bound(set::AbstractInfiniteSet,
                     upper::Real)::AbstractInfiniteSet</code></pre><p>Set and return the upper bound of <code>set</code> if such an aoperation makes sense. Errors if the type of <code>set</code> does not support this operation or has not been extended. User-defined set types should extend this if appropriate.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set = InfiniteSet(0, 1);

julia&gt; set_upper_bound(set, 0.5)
[0, 0.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL276-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports_in_set" href="#InfiniteOpt.supports_in_set"><code>InfiniteOpt.supports_in_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_in_set(supports::Union{Real, Vector{&lt;:Real}, Array{&lt;:Real, 2}},
                set::AbstractInfiniteSet)::Bool</code></pre><p>Used to check if <code>supports</code> are in the domain of <code>set</code>. Returns <code>true</code> if <code>supports</code> are in domain of <code>set</code> and returns <code>false</code> otherwise. This is primarily an internal method for performing checks but can be extended for user-defined set types. Extending this is optional, but recommended where possible. Note by fallback, this returns <code>true</code> for unrecognized set types such that an error won&#39;t be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generate_supports" href="#InfiniteOpt.generate_supports"><code>InfiniteOpt.generate_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_supports(set::AbstractInfiniteSet
                  method::Union{Symbol, Nothing} = Nothing;
                  [num_supports::Int = DefaultNumSupports,
                  sig_digits::Int = DefaultSigDigits]
                  )::Tuple{Array{&lt;:Real}, Symbol}</code></pre><p>Generate <code>num_supports</code> support values with <code>sig_digits</code> significant digits in accordance with <code>set</code> and return them along with the correct generation label(s). <code>IntervalSet</code>s generate supports uniformly with label <code>UniformGrid</code> and distribution sets generate them randomly accordingly to the underlying distribution. Moreover, <code>method</code> indicates the generation method that should be used. These <code>methods</code> correspond to parameter support labels. Current labels that can be used as generation methods include (but may not be defined for certain set types):</p><ul><li><code>MCSample</code>: Uniformly distributed Monte Carlo samples.</li><li><code>WeightedSample</code>: Monte Carlo samples that are weighted by an underlying PDF.</li><li><code>UniformGrid</code>: Samples that are generated uniformly over the set domain.</li></ul><p>Extensions that employ user-defined infinite set types and/or methods should extend <a href="#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> to enable this. Errors if the <code>set</code> type and /or methods are unrecognized. This is intended as an internal method to be used by methods such as <a href="../parameter/#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef,AbstractInfiniteSet,Union{Nothing, Symbol}}"><code>generate_and_add_supports!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL332-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generate_support_values" href="#InfiniteOpt.generate_support_values"><code>InfiniteOpt.generate_support_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_support_values(set::AbstractInfiniteSet,
                        [method::Val{:MyMethod} = Val(:MyMethod)];
                        num_supports::Int = DefaultNumSupports,
                        sig_digits::Int = DefaultSigDigits,
                        )::Tuple{Array{&lt;:Real}, Symbol}</code></pre><p>A multiple dispatch method for <a href="#InfiniteOpt.generate_supports"><code>generate_supports</code></a>. This will return a tuple where the first element are the supports and the second is their label. This can be extended for user-defined infinite sets and/or generation methods. When defining a new set type the default method dispatch should make <code>method</code> an optional argument (making it the default). Otherwise, other method dispatches for a given set must ensure that <code>method</code> is positional argument without a default value (contrary to the definition above).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/c3c9f59b20a0ab5c0b73945731349d4655d11c1b/src/infinite_sets.jl#LL372-L386">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model/">« Infinite Models</a><a class="docs-footer-nextpage" href="../parameter/">Infinite Parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 21 September 2020 21:37">Monday 21 September 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
