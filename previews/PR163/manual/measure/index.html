<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measures · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../../guide/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../guide/variable/">Variables</a></li><li><a class="tocitem" href="../../guide/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../../guide/measure/">Measures</a></li><li><a class="tocitem" href="../../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../../guide/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li class="is-active"><a class="tocitem" href>Measures</a><ul class="internal"><li><a class="tocitem" href="#Measure-Data"><span>Measure Data</span></a></li><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#Modification"><span>Modification</span></a></li><li><a class="tocitem" href="#Expansion"><span>Expansion</span></a></li></ul></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Manual</a></li><li class="is-active"><a href>Measures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/manual/measure.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="measure_manual"><a class="docs-heading-anchor" href="#measure_manual">Measure Operators</a><a id="measure_manual-1"></a><a class="docs-heading-anchor-permalink" href="#measure_manual" title="Permalink"></a></h1><p>A technical manual for measures in <code>InfiniteOpt</code>. See the respective  <a href="../../guide/measure/#measure_docs">guide</a> for more information.</p><h2 id="Measure-Data"><a class="docs-heading-anchor" href="#Measure-Data">Measure Data</a><a id="Measure-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-Data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractMeasureData" href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMeasureData</code></pre><p>An abstract type to define data for measures to define the behavior of <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/datatypes.jl#LL889-L894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real, Vector{var&quot;#s39&quot;} where var&quot;#s39&quot;&lt;:Real}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real, Vector{var&quot;#s39&quot;} where var&quot;#s39&quot;&lt;:Real}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteMeasureData(pref::GeneralVariableRef,
    coefficients::Vector{&lt;:Real},
    supports::Vector{&lt;:Real};
    [label::Type{&lt;:AbstractSupportLabel} = generate_unique_label(),
    weight_function::Function = [`default_weight`](@ref),
    lower_bound::Real = NaN,
    upper_bound::Real = NaN,
    is_expect::Bool = false]
    )::DiscreteMeasureData</code></pre><p>Returns a 1-dimensional <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds or an unequal number of supports and coefficients are given. Note that by default a unique <code>label</code> is generated via <code>generate_unique_label</code> to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL144-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef, N} where N, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real, Vector{var&quot;#s39&quot;} where var&quot;#s39&quot;&lt;:(AbstractArray{var&quot;#s38&quot;, N} where {var&quot;#s38&quot;&lt;:Real, N})}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef, N} where N, Vector{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:Real, Vector{var&quot;#s39&quot;} where var&quot;#s39&quot;&lt;:(AbstractArray{var&quot;#s38&quot;, N} where {var&quot;#s38&quot;&lt;:Real, N})}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteMeasureData(prefs::AbstractArray{GeneralVariableRef},
    coefficients::Vector{&lt;:Real},
    supports::Vector{&lt;:AbstractArray{&lt;:Real}};
    label::Type{&lt;:AbstractSupportLabel} = generate_unique_label(),
    weight_function::Function = [`default_weight`](@ref),
    lower_bounds::AbstractArray{&lt;:Real} = [NaN...],
    upper_bounds::AbstractArray{&lt;:Real} = [NaN...],
    is_expect::Bool = false
    )::DiscreteMeasureData</code></pre><p>Returns a <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for <code>parameter_refs</code>. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or if mixed infinite parameter types are given. Note that by default a unique <code>label</code> is generated via <code>generate_unique_label</code> to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL262-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData" href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiscreteMeasureData{P &lt;: Union{JuMP.AbstractVariableRef,
                    Vector{&lt;:JuMP.AbstractVariableRef}},
                    N, B &lt;: Union{Float64, Vector{Float64}},
                    F &lt;: Function
                    } &lt;: AbstractMeasureData</code></pre><p>A DataType for immutable measure abstraction data where the abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>. The supports and coefficients are immutable (i.e., they will not change even if supports are changed for the underlying infinite parameter.) This type can be used for both 1-dimensional and multi-dimensional measures.</p><p><strong>Fields</strong></p><ul><li><code>parameter_refs::P</code>: The infinite parameter(s) over which the integration occurs.                      These can be comprised of multiple independent parameters,                      but dependent parameters cannot be mixed with other types.</li><li><code>coefficients::Vector{Float64}</code>: Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Array{Float64, N}</code>: Supports points <span>$\tau_i$</span>. This is a <code>Vector</code>                                if only one parameter is given, otherwise it is                                a <code>Matrix</code> where the supports are stored column-wise.</li><li><code>label::DataType</code>: Label for the support points <span>$\tau_i$</span> when stored in the                  infinite parameter(s), stemming from <a href="../domains/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</li><li><code>weight_function::F</code>: Weighting function <span>$w$</span> must map an individual                              support value to a <code>Real</code> scalar value.</li><li><code>lower_bounds::B</code>: Lower bound in accordance with <span>$T$</span>, this denotes the                   intended interval of the measure and should be <code>NaN</code> if ignored</li><li><code>upper_bounds::B</code>: Same as above but the upper bound.</li><li><code>is_expect::Bool</code>: Is this data associated with an expectation call?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/datatypes.jl#LL897-L928">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef, Function, Int64, Type{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:AbstractSupportLabel}" href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef, Function, Int64, Type{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:AbstractSupportLabel}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FunctionalDiscreteMeasureData(pref::GeneralVariableRef,
    coeff_func::Function,
    min_num_supports::Int,
    label::Type{&lt;:AbstractSupportLabel};
    [weight_function::Function = [`default_weight`](@ref),
    lower_bound::Real = NaN,
    upper_bound::Real = NaN,
    is_expect::Bool = false,
    generative_support_info::AbstractGenerativeInfo = NoGenerativeSupports()]
    )::FunctionalDiscreteMeasureData</code></pre><p>Returns a 1-dimensional <code>FunctionalDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Errors if <code>pref</code> is not an infinite parameter. Built-in choices for <code>label</code> include:</p><ul><li><code>All</code>: Use all of the supports stored in <code>pref</code></li><li><code>MCSample</code>: Use Monte Carlo samples associated with <code>pref</code></li><li><code>WeightedSample</code>: Use weighted Monte Carlo samples associated with <code>pref</code></li><li><code>UniformGrid</code>: Use uniform grid points associated with <code>pref</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = FunctionalDiscreteMeasureData(pref, my_func, 20, UniformGrid);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL320-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef, N} where N, Function, Int64, Type{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:AbstractSupportLabel}" href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef, N} where N, Function, Int64, Type{var&quot;#s40&quot;} where var&quot;#s40&quot;&lt;:AbstractSupportLabel}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FunctionalDiscreteMeasureData(prefs::AbstractArray{GeneralVariableRef},
    coeff_func::Function,
    min_num_supports::Int,
    label::Type{&lt;:AbstractSupportLabel};
    [weight_function::Function = [`default_weight`](@ref),
    lower_bounds::AbstractArray{&lt;:Real} = [NaN...],
    upper_bounds::AbstractArray{&lt;:Real} = [NaN...],
    is_expect::Bool = false]
    )::FunctionalDiscreteMeasureData</code></pre><p>Returns a multi-dimensional <code>FunctionalDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for an array of infinite parameters. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Errors if <code>prefs</code> are not infinite parameters or if the mixed parameter types are provided. Built-in choices for <code>label</code> include:</p><ul><li><code>All</code>: Use all of the supports stored in <code>prefs</code></li><li><code>MCSample</code>: Use Monte Carlo samples associated with <code>prefs</code></li><li><code>WeightedSample</code>: Use weighted Monte Carlo samples associated with <code>prefs</code></li><li><code>UniformGrid</code>: Use uniform grid points associated with <code>prefs</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = FunctionalDiscreteMeasureData(prefs, my_func, 20, MCSample);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL395-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData" href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FunctionalDiscreteMeasureData{P &lt;: Union{JuMP.AbstractVariableRef,
                              Vector{&lt;:JuMP.AbstractVariableRef}},
                              B &lt;: Union{Float64, Vector{Float64}},
                              I &lt;: AbstractGenerativeInfo,
                              F1 &lt;: Function,
                              F2 &lt;: Function
                              } &lt;: AbstractMeasureData</code></pre><p>A DataType for mutable measure abstraction data where the abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>. This abstraction is equivalent to that of <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, but the difference is that the supports are not fully known at the time of measure creation. Thus, functions are stored that will be used to generate the concrete support points <span>$\tau_i$</span> and their coefficients <span>$\alpha_i$</span> when the measure is evaluated (expanded). These supports are identified/generated in accordance with the <code>label</code> with a gaurantee that at least <code>num_supports</code> are generated. For example, if <code>label = MCSample</code> and <code>num_supports = 100</code> then the measure will use all of the supports stored in the <code>parameter_refs</code> with the label <code>MCSample</code> and will ensure there are at least 100 are generated. This type can be used for both 1-dimensional and multi-dimensional measures.</p><p>For 1-dimensional measures over independent infinite parameters, the  <code>generative_supp_info</code> specifies the info needed to make generative supports based  on those with that exist with <code>label</code>. Note that only 1 kind of generative  supports are allowed for each infinite parameter.</p><p><strong>Fields</strong></p><ul><li><code>parameter_refs::P</code>: The infinite parameter(s) over which the integration occurs.                    These can be comprised of multiple independent parameters,                    but dependent parameters cannot be mixed with other types.</li><li><code>coeff_function::F1</code>: Coefficient generation function making <span>$\alpha_i$</span>                             for the above measure abstraction. It should take                             all the supports as input (formatted as an Array)                             and return the corresponding vector of coefficients.</li><li><code>min_num_supports::Int</code>: Specifies the minimum number of supports <span>$\tau_i$</span>                      desired in association with <code>parameter_refs</code> and <code>label</code>.</li><li><code>label::DataType</code>: Label for the support points <span>$\tau_i$</span> which are/will be                  stored in the infinite parameter(s), stemming from <a href="../domains/#InfiniteOpt.AbstractSupportLabel"><code>AbstractSupportLabel</code></a>.</li><li><code>generative_supp_info::I</code>: Information needed to generate supports based on other   existing ones.</li><li><code>weight_function::F2</code>: Weighting function <span>$w$</span> must map an individual                             support value to a <code>Real</code> scalar value.</li><li><code>lower_bounds::B</code>: Lower bounds in accordance with <span>$T$</span>, this denotes the                 intended interval of the measure and should be <code>NaN</code> if ignored</li><li><code>upper_bounds::B</code>: Same as above but the upper bounds.</li><li><code>is_expect::Bool</code>: Is this data associated with an expectation call?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/datatypes.jl#LL972-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}" href="#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter_refs(data::AbstractMeasureData)::Union{GeneralVariableRef,
                                                 AbstractArray{GeneralVariableRef}}</code></pre><p>Return the infinite parameter reference(s) in <code>data</code>. This is intended as an internal function to be used with measure addition. User-defined measure data types will need to extend this function otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL450-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_label-Tuple{AbstractMeasureData}" href="#InfiniteOpt.support_label-Tuple{AbstractMeasureData}"><code>InfiniteOpt.support_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">support_label(data::AbstractMeasureData)::Type{&lt;:AbstractSupportLabel}</code></pre><p>Return the label stored in <code>data</code> associated with its supports. This is intended as en internal method for measure creation and ensures any new supports are added to parameters with such a label. User-defined measure data types should extend this functionif supports are used, otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL472-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generative_support_info-Tuple{AbstractMeasureData}" href="#InfiniteOpt.generative_support_info-Tuple{AbstractMeasureData}"><code>InfiniteOpt.generative_support_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generative_support_info(data::AbstractMeasureData)::AbstractGenerativeInfo</code></pre><p>Return the generative support creation info that corresponds to <code>data</code>. This is  intended as an internal method and only needs to be extended for user-defined  measure data types that use generative supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL540-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{AbstractMeasureData}" href="#JuMP.lower_bound-Tuple{AbstractMeasureData}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JuMP.lower_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}</code></pre><p>Return the lower bound associated with <code>data</code> that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise <code>NaN</code> is returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL492-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{AbstractMeasureData}" href="#JuMP.upper_bound-Tuple{AbstractMeasureData}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JuMP.upper_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}</code></pre><p>Return the lower bound associated with <code>data</code> that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise <code>NaN</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL510-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">supports(data::AbstractMeasureData)::Array{Float64}</code></pre><p>Return the supports associated with <code>data</code> and its infinite parameters. This is intended as en internal method for measure creation and ensures any new supports are added to parameters. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL556-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_supports(data::AbstractMeasureData)::Int</code></pre><p>Return the number supports associated with <code>data</code> and its infinite parameters. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise 0 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL646-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.min_num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_num_supports(data::AbstractMeasureData)::Int</code></pre><p>Return the minimum number of supports associated with <code>data</code>. By fallback, this will just return <code>num_supports(data)</code>. This is primarily intended for internal queries of <code>FunctionalDiscreteMeasureData</code>, but can be extended for other measure data types if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL664-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}" href="#InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficient_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coefficient_function(data::AbstractMeasureData)::Function</code></pre><p>Return the coefficient function stored in <code>data</code> associated with its expansion abstraction is there is such a function. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown for unsupported types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL681-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.coefficients-Tuple{AbstractMeasureData}" href="#InfiniteOpt.coefficients-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coefficients(data::AbstractMeasureData)::Vector{&lt;:Real}</code></pre><p>Return the coefficients associated with <code>data</code> associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL702-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.weight_function-Tuple{AbstractMeasureData}" href="#InfiniteOpt.weight_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.weight_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight_function(data::AbstractMeasureData)::Function</code></pre><p>Return the weight function stored in <code>data</code> associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL724-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.default_weight" href="#InfiniteOpt.default_weight"><code>InfiniteOpt.default_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_weight(t) = 1</code></pre><p>Default weight function for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> and <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Returns 1 regardless of the input value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL128-L133">source</a></section></article><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><h3 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure" href="#InfiniteOpt.measure"><code>InfiniteOpt.measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure(expr::JuMP.AbstractJuMPScalar,
        data::AbstractMeasureData;
        [name::String = &quot;measure&quot;])::GeneralVariableRef</code></pre><p>Return a measure reference that evaluates <code>expr</code> using according to <code>data</code>. The measure data <code>data</code> determines how the measure is to be evaluated. Typically, the <code>DiscreteMeasureData</code> and the <code>FunctionalDiscreteMeasureData</code> constructors can be used to for <code>data</code>. The variable expression <code>expr</code> can contain <code>InfiniteOpt</code> variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Typically, this is called inside of <code>JuMP.@expression</code>, <code>JuMP.@objective</code>, and <code>JuMP.@constraint</code> in a manner similar  to <code>sum</code>. Note measures are not explicitly evaluated until  <a href="../optimize/#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> is called or unless they are expanded via  <a href="#InfiniteOpt.expand"><code>expand</code></a> or <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2]);

julia&gt; xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]]);

julia&gt; constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)
measure{t}[g(t) - s + 2] + s²

julia&gt; @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))
measure{xs}[g(t) - 1 + measure{xs}[T(t, x)]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1149-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@measure" href="#InfiniteOpt.@measure"><code>InfiniteOpt.@measure</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@measure(expr::JuMP.AbstractJuMPScalar,
         data::AbstractMeasureData;
         [name::String = &quot;measure&quot;])::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.measure"><code>measure</code></a>, please see its doc string for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1191-L1198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_measure" href="#InfiniteOpt.build_measure"><code>InfiniteOpt.build_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_measure(expr::JuMP.AbstractJuMPScalar,
              data::AbstractMeasureData)::Measure</code></pre><p>Build and return a <a href="#InfiniteOpt.Measure"><code>Measure</code></a> given the expression to be measured <code>expr</code> using measure data <code>data</code>. This principally serves as an internal method for measure definition. Errors if the supports associated with <code>data</code> violate an finite variable parameter bounds of finite variables that are included in the measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL746-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Measure" href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Measure{T &lt;: JuMP.AbstractJuMPScalar, V &lt;: AbstractMeasureData}</code></pre><p>A <code>DataType</code> for measure abstractions. The abstraction is determined by <code>data</code> and is enacted on <code>func</code> when the measure is evaluated (expended).</p><p><strong>Fields</strong></p><ul><li><code>func::T</code> The <code>InfiniteOpt</code> expression to be measured.</li><li><code>data::V</code> Data of the abstraction as described in a <code>AbstractMeasureData</code>           concrete subtype.</li><li><code>object_nums::Vector{Int}</code>: The parameter object numbers of the evaluated                             measure expression (i.e., the object numbers of                             <code>func</code> excluding those that belong to <code>data</code>).</li><li><code>parameter_nums::Vector{Int}</code>: The parameter numbers that parameterize the                                evaluated measure expression. (i.e., the                                parameter numbers of <code>func</code> excluding those                                that belong to <code>data</code>).</li><li><code>constant_func::Bool</code>: Indicates if <code>func</code> is not parameterized by the infinite                        parameters in <code>data</code>. (i.e., do the object numbers of                        <code>func</code> and <code>data</code> have no intersection?) This is useful                        to enable analytic evaluations if possible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/datatypes.jl#LL1088-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure" href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_measure(model::InfiniteModel, meas::Measure,
            name::String = &quot;measure&quot;)::GeneralVariableRef</code></pre><p>Add a measure to <code>model</code> and return the corresponding measure reference. This operates in a manner similar to <code>JuMP.add_variable</code>. Note this intended as an internal method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1004-L1011">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}" href="#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}"><code>InfiniteOpt.add_supports_to_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_supports_to_parameters(data::AbstractMeasureData)::Nothing</code></pre><p>Add supports as appropriate with <code>data</code> to the underlying infinite parameters. This is an internal method with by <a href="#InfiniteOpt.add_measure"><code>add_measure</code></a> and should be defined for user-defined measure data types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL857-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureIndex" href="#InfiniteOpt.MeasureIndex"><code>InfiniteOpt.MeasureIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeasureIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/datatypes.jl#LL148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureData" href="#InfiniteOpt.MeasureData"><code>InfiniteOpt.MeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeasureData{M &lt;: Measure} &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing <a href="#InfiniteOpt.Measure"><code>Measure</code></a>s and their data.</p><p><strong>Fields</strong></p><ul><li><code>measure::M</code>: The measure structure.</li><li><code>name::String</code>: The base name used for printing <code>name(meas_expr d(par))</code>.</li><li><code>measure_indices::Vector{MeasureIndex}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{InfOptConstraintIndex}</code>: Indices of dependent constraints.</li><li><code>derivative_indices::Vector{DerivativeIndex}</code>: Indices of dependent derivatives.</li><li><code>in_objective::Bool</code>: Is this used in objective?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/datatypes.jl#LL1118-L1130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureRef" href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeasureRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for referring to measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::MeasureIndex</code>: Index of the measure in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/datatypes.jl#LL1601-L1609">source</a></section></article><h3 id="Integrals"><a class="docs-heading-anchor" href="#Integrals">Integrals</a><a id="Integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Integrals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}" href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>InfiniteOpt.MeasureToolbox.integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integral(expr::JuMP.AbstractJuMPScalar,
         pref::GeneralVariableRef,
         [lower_bound::Real = lower_bound(pref),
         upper_bound::Real = upper_bound(pref);
         kwargs...])::GeneralVariableRef</code></pre><p>Returns a measure reference that evaluates the integral of <code>expr</code> with respect to infinite parameter <code>pref</code> from <code>lower_bound</code> to <code>upper_bound</code>. This thus considers integrals of the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter and <span>$w$</span> is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> via <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> in accordance with the keyword arugment <code>eval_method</code> that is then used with <a href="#InfiniteOpt.measure"><code>measure</code></a>. Note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a> when <code>expr</code> is not just a single variable reference. Errors for bad bound input.</p><p>The keyword arguments are as follows:</p><ul><li><code>eval_method::AbstractUnivariateMethod</code>: Used to determine the   numerical evaluation scheme. Possible choices include:<ul><li><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>UniTrapezoid()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>UniIndepMCSampling()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>Quadrature()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>GaussHermite()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>GaussLegendre()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>FEGaussLobatto()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>GaussLageurre()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>GaussLobatto()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>GaussChebyshev(order)</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussRadau"><code>GaussRadau()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussJacobi"><code>GaussJacobi(α, β)</code></a></li></ul></li><li><code>num_supports</code>: The minimum number of supports to be generated (if used by   <code>eval_method</code>)</li><li><code>weight_func</code>: <span>$w(p)$</span> above with parameter value inputs and scalar output</li></ul><p>See <a href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>set_uni_integral_defaults</code></a> to update the default keyword argument values for all one-dimensional integral calls.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, x in [0, 1])
x

julia&gt; @variable(model, f, Infinite(x))
f(x)

julia&gt; int = integral(f, x)
∫{x ∈ [0, 1]}[f(x)]

julia&gt; expand(int)
0.2 f(0.8236475079774124) + 0.2 f(0.9103565379264364) + 0.2 f(0.16456579813368521) + 0.2 f(0.17732884646626457) + 0.2 f(0.278880109331201)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL747-L801">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}" href="#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>InfiniteOpt.MeasureToolbox.∫</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∫(expr::JuMP.AbstractJuMPScalar,
  pref::GeneralVariableRef,
  [lower_bound::Real = NaN,
  upper_bound::Real = NaN;
  kwargs...])::GeneralVariableRef</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a>. The <code>∫</code> unicode symbol is produced  via <code>\int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL834-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.uni_integral_defaults" href="#InfiniteOpt.MeasureToolbox.uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.uni_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uni_integral_defaults()::Dict{Symbol, Any}</code></pre><p>Get the default keyword argument values for defining one-dimensional integrals.</p><pre><code class="language-julia-repl hljs">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL677-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.set_uni_integral_defaults" href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_uni_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_uni_integral_defaults(; kwargs...)::Nothing</code></pre><p>Set the default keyword argument settings for one-dimensional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a> with a single infinite parameter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()


julia&gt; set_uni_integral_defaults(num_supports = 5, eval_method = Quadrature(),
                                 new_kwarg = true)

julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Quadrature()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL690-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults" href="#InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clear_uni_integral_defaults()::Nothing</code></pre><p>Clears and resets the keyword argument defaults for univariate integrals to their  default state. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Quadrature()

julia&gt; clear_uni_integral_defaults()

julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL721-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, AbstractArray{GeneralVariableRef, N} where N, Union{Real, AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:Real, N}}, Union{Real, AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:Real, N}}}" href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, AbstractArray{GeneralVariableRef, N} where N, Union{Real, AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:Real, N}}, Union{Real, AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:Real, N}}}"><code>InfiniteOpt.MeasureToolbox.integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integral(expr::JuMP.AbstractJuMPScalar,
         prefs::AbstractArray{GeneralVariableRef},
         [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = [lower_bound(pref)...],
         upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = [upper_bound(pref)...];
         kwargs...])::GeneralVariableRef</code></pre><p>Returns a measure reference that evaluates the integral of <code>expr</code> with respect to infinite parameters <code>prefs</code> from <code>lower_bounds</code> to <code>upper_bounds</code>. This thus considers integrals of the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter and <span>$w$</span> is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> via <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> in accordance with the keyword arugment <code>eval_method</code> that is then used with <a href="#InfiniteOpt.measure"><code>measure</code></a>. Note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a> when <code>expr</code> is not just a single variable reference. Errors when the container types and dimensions do not match or the bounds are invalid.</p><p>The keyword arguments are as follows:</p><ul><li><code>eval_method::AbstractMultivariateMethod</code>: Used to determine the   numerical evaluation scheme. Possible choices include:<ul><li><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling()</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>MultiIndepMCSampling()</code></a></li></ul></li><li><code>num_supports</code>: The minimum number of supports to be generated (if used by   <code>eval_method</code>)</li><li><code>weight_func</code>: <span>$w(p)$</span> above with parameter value inputs and scalar output</li></ul><p>See <a href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>set_multi_integral_defaults</code></a> to update the default keyword argument values for all multi-dimensional integral calls.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, x[1:2] in [0, 1], independent = true);

julia&gt; @variable(model, f, Infinite(x));

julia&gt; int = integral(f, x)
∫{x ∈ [0, 1]^2}[f(x)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL930-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar, AbstractArray{GeneralVariableRef, N} where N, Union{Real, AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:Real, N}}, Union{Real, AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:Real, N}}}" href="#InfiniteOpt.MeasureToolbox.∫-Tuple{AbstractJuMPScalar, AbstractArray{GeneralVariableRef, N} where N, Union{Real, AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:Real, N}}, Union{Real, AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:Real, N}}}"><code>InfiniteOpt.MeasureToolbox.∫</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∫(expr::JuMP.AbstractJuMPScalar,
  prefs::AbstractArray{GeneralVariableRef},
  [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = NaN,
  upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = NaN;
  kwargs...])::GeneralVariableRef</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a>. The unicode symbol <code>∫</code> is produced  via <code>\int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL1021-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.multi_integral_defaults" href="#InfiniteOpt.MeasureToolbox.multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.multi_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">multi_integral_defaults()::Dict{Symbol, Any}</code></pre><p>Get the default keyword argument values for defining multi-dimensional integrals.</p><pre><code class="language-julia-repl hljs">julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL860-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.set_multi_integral_defaults" href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_multi_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_multi_integral_defaults(; kwargs...)::Nothing</code></pre><p>Set the default keyword argument settings for multi-dimesnional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, AbstractArray{GeneralVariableRef, N} where N, Union{Real, AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:Real, N}}, Union{Real, AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:Real, N}}}"><code>integral</code></a> with an array of infinite parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()

julia&gt; set_multi_integral_defaults(num_supports = 5, new_kwarg = true)

julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL873-L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults" href="#InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clear_multi_integral_defaults()::Nothing</code></pre><p>Clears and resets the keyword argument defaults for multivariate integrals to their  default state. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Automatic()

julia&gt; clear_multi_integral_defaults()

julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 1 entry:
  :eval_method =&gt; Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL902-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@integral" href="#InfiniteOpt.MeasureToolbox.@integral"><code>InfiniteOpt.MeasureToolbox.@integral</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@integral(expr::JuMP.AbstractJuMPScalar,
          prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}},
          [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds,
          upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds;
          kwargs...])::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a> and <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, AbstractArray{GeneralVariableRef, N} where N, Union{Real, AbstractArray{var&quot;#s40&quot;, N} where {var&quot;#s40&quot;&lt;:Real, N}}, Union{Real, AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:Real, N}}}"><code>integral</code></a>. Please see the above doc strings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL1039-L1049">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@∫" href="#InfiniteOpt.MeasureToolbox.@∫"><code>InfiniteOpt.MeasureToolbox.@∫</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@∫(expr::JuMP.AbstractJuMPScalar,
   prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}},
   [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds,
   upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds;
   kwargs...])::GeneralVariableRef</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a>. The unicode symbol <code>∫</code> is produced  via <code>\int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL1063-L1072">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractIntegralMethod" href="#InfiniteOpt.MeasureToolbox.AbstractIntegralMethod"><code>InfiniteOpt.MeasureToolbox.AbstractIntegralMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods use in combination with <code>integral</code> and <code>generate_integral_data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.Automatic" href="#InfiniteOpt.MeasureToolbox.Automatic"><code>InfiniteOpt.MeasureToolbox.Automatic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Automatic &lt;: AbstractIntegralMethod</code></pre><p>An integral evaluation type for automically selecting an appropriate integral evaluation method. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod" href="#InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractUnivariateMethod &lt;: AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods for 1-dimensional integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniTrapezoid" href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>InfiniteOpt.MeasureToolbox.UniTrapezoid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniTrapezoid &lt;: AbstractUnivariateMethod</code></pre><p>An integral evalution method that uses the trapezoid rule to in combination with all parameter supports available when the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this method will ignore the <code>num_supports</code> keyword argument. The upper and lower bounds of the integral  will automatically be added as supports. Note this is valid only for finite integral domains. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL34-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniMCSampling" href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>InfiniteOpt.MeasureToolbox.UniMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniMCSampling &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy <code>num_supports</code> and it will include all supports with the <code>MCSample</code> label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL46-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniIndepMCSampling" href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.UniIndepMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniIndepMCSampling &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to <a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling</code></a>. However, this variant will generate its own set of supports and ignore all other supports with the <code>MCSample</code> label. Note this is valid only for finite integral domains. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.Quadrature" href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>InfiniteOpt.MeasureToolbox.Quadrature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Quadrature &lt;: AbstractUnivariateMethod</code></pre><p>A general integral evaluation method that will automatically select the appropriate quadrature method to approximate the integral. Please note that this will generate a unique set of parameter supports and will ignore existing supports when the integral is evaluated and thus should be used with caution. However, this method is able to handle infinite and semi-infinite integral domains. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL69-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussHermite" href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>InfiniteOpt.MeasureToolbox.GaussHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussHermite &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaulation method that uses Gauss-Hermite quadrature to evaluate integrals. This is valid for infinite integral domains.  It will take this form:</p><p><span>$\int_{-∞}^{∞} f(x) e^{-x^2} \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p><p>Using the weight function: <span>$w(x)$</span> = <span>$e^{-x^2}$</span></p><p>Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL215-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussLegendre" href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>InfiniteOpt.MeasureToolbox.GaussLegendre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussLegendre &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Legendre quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL98-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussRadau" href="#InfiniteOpt.MeasureToolbox.GaussRadau"><code>InfiniteOpt.MeasureToolbox.GaussRadau</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussRadau &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Radau quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussLobatto" href="#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>InfiniteOpt.MeasureToolbox.GaussLobatto</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussLobatto &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Lobatto quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussJacobi" href="#InfiniteOpt.MeasureToolbox.GaussJacobi"><code>InfiniteOpt.MeasureToolbox.GaussJacobi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussJacobi &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Jacobi quadrature to evaluate integrals. It will take this form:</p><p><span>$\int_{-1}^{1} f(x) (1-x)^\alpha (1+x)^\beta dx \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p><p>Where, </p><p><span>$(1-x)^\alpha (1+x)^\beta$</span> </p><p>is the weight function. This is valid for finite integral domains. This requires the user to input the alpha and beta shape parameters for their function. This will then generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. If α or β is &lt; -1, an error will be returned.  </p><p><strong>Fields</strong></p><ul><li><code>α::Float64</code>: Shape parameter that must be &gt; -1</li><li><code>β::Float64</code>: Shape parameter that must be &gt; -1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL128-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.FEGaussLobatto" href="#InfiniteOpt.MeasureToolbox.FEGaussLobatto"><code>InfiniteOpt.MeasureToolbox.FEGaussLobatto</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FEGaussLobatto &lt;: AbstractUnivariateMethod</code></pre><p>Integral evaluation method that allows for the user to specify supports to be included in quadrature evaluation. The upper and lower bounds of the integral will automatically  be added as supports. This method uses Gauss Lobatto quadrature to decompose the overall Integral into smaller integrals that span the user defined supports as follows:</p><p><span>$\int_{x_1}^{x_3} f(x) dx = \int_{x_1}^{x_2} f(x) dx + \int_{x_2}^{x_3} f(x) dx$</span></p><p>where the integrals are evaluated using Gauss Lobatto quadrature:</p><p><span>$\int f(x) dx \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL81-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussChebyshev" href="#InfiniteOpt.MeasureToolbox.GaussChebyshev"><code>InfiniteOpt.MeasureToolbox.GaussChebyshev</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussChebyshev &lt;: FiniteGaussQuad</code></pre><p>An integral evaulation method that uses Gauss-Chebyshev quadrature to evaluate integrals. This is valid for finite integral domains. This requires the user to input the order of Guass-Chebyshev Quadrature they want to use.  If the order is not between 1 and 4 an error will be returned.  The integral evaluated is as follows:</p><p><span>$\int_{-1}^{1} f(x) w(x) \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p><p>The weight functions are as follows: </p><ul><li>1st order: <span>$w(x)  =  \frac{1}{\sqrt{1-x^2}}$</span></li><li>2nd order: <span>$w(x) = {\sqrt{1-x^2}}$</span></li><li>3rd order: <span>$w(x) = \sqrt{(1+x)/(1-x)}$</span></li><li>4th order: <span>$w(x) = \sqrt{(1-x)/(1+x)}$</span></li></ul><p>This will then generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p><p><strong>Fields</strong></p><ul><li><code>order::Int</code>: Specifies the order of Gauss-Chebyshev Quadrature. Must be between 1 and 4.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL162-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussLaguerre" href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>InfiniteOpt.MeasureToolbox.GaussLaguerre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussLaguerre &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaulation method that uses Gauss-Laguerre quadrature to evaluate integrals. This is valid for semi-infinite integral domains. </p><p>This method evaluates the following integral:</p><p><span>$\int_{0}^{+∞} f(x) e^{-x} \approx \sum_{i=1}^{n} \alpha_i f(x_i)$</span></p><p>Using the weight function:</p><p><span>$w(x) = e^{-x}$</span></p><p>Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL196-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod" href="#InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMultivariateMethod &lt;: AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods for multi-dimensional integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.MultiMCSampling" href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiMCSampling &lt;: AbstractMultivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy <code>num_supports</code> and it will include all supports with the <code>MCSample</code> label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains. If an array of independent infinite parameters is specified, they must use the same amount of supports. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL239-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.MultiIndepMCSampling" href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiIndepMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiIndepMCSampling &lt;: AbstractMultivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to <a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling</code></a>. However, this variant will generate its own set of supports and ignore all other supports with the <code>MCSample</code> label. Note this is valid only for finite integral domains. Contains no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL252-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.generate_integral_data" href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>InfiniteOpt.MeasureToolbox.generate_integral_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_integral_data(
    prefs::Union{InfiniteOpt.GeneralVariableRef, Vector{InfiniteOpt.GeneralVariableRef}},
    lower_bounds::Union{Real, Vector{&lt;:Real}},
    upper_bounds::Union{Real, Vector{&lt;:Real}},
    method::V; [num_supports::Int = InfiniteOpt.DefaultNumSupports,
    weight_func::Function = InfiniteOpt.default_weight,
    extra_kwargs...]
    )::InfiniteOpt.AbstractMeasureData where {V &lt;: AbstractIntegralMethod}</code></pre><p>Generate the appropriate concrete realization of <code>AbstractMeasureData</code> using <code>method</code>. Here <code>prefs</code>, <code>lower_bounds</code>, and <code>upper_bounds</code> will always have a 1 to 1 correspondence when this is called from <code>integral</code>. Please refer to the method docstrings for an explanation of each one.</p><p>User-defined method extensions should first define a concrete <code>method</code> type inheriting from <code>AbstractUnivariateMethod</code> or <code>AbstractMultivariateMethod</code> as appropriate and then implement extend this method using that type for <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/integrals.jl#LL278-L297">source</a></section></article><h3 id="Expectations"><a class="docs-heading-anchor" href="#Expectations">Expectations</a><a id="Expectations-1"></a><a class="docs-heading-anchor-permalink" href="#Expectations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.expect" href="#InfiniteOpt.MeasureToolbox.expect"><code>InfiniteOpt.MeasureToolbox.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expect(expr::JuMP.AbstractJuMPScalar,
       prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};
       [num_supports::Int = DefaultNumSupports])::GeneralVariableRef</code></pre><p>Makes a measure for <code>expr</code> based on its expectation with respect to <code>prefs</code>. For  <code>prefs</code> with distribution domains this is essentially equivalent to </p><pre><code class="language-julia hljs">1/total_num_supports * support_sum(expr, prefs, label = WeightedSample)</code></pre><p>Thus, for these domain types it only considers supports that are added to <code>prefs</code>  via generation on creation (i.e., specifying the <code>num_supports</code> keyword when  creating <code>prefs</code>). For incorporating other supports consider  calling <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a> and using the <code>weight_func</code> argument to specify the  probability density function.</p><p>For a single infinite parameter defined over a bounded interval domain the syntax  becomes:</p><pre><code class="language-julia hljs">    expect(expr::JuMP.AbstractJuMPScalar,
           prefs::GeneralVariableRef;
           [num_supports::Int = DefaultNumSupports,
           pdf::Function = (supp) -&gt; 1 / (ub - lb)])::GeneralVariableRef</code></pre><p>The behavior with the default <code>pdf</code> is equivalent to evaluating the mean value  theorem for integrals for <code>expr</code> with respect to <code>pref</code> using  <a href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>UniTrapezoid</code></a>. Other density functions can be given via <code>pdf</code>. Errors  if the interval domain is not bounded.</p><p>Note that num_supports should be 0 if a single dependent parameter is given. Also, note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a> when <code>expr</code> is not just a single variable reference.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, x ~ Normal(), num_supports = 2)
x

julia&gt; @variable(model, f, Infinite(x))
f(x)

julia&gt; meas = expect(f, x)
𝔼{x}[f(x)]

julia&gt; expand(meas)
0.5 f(0.6791074260357777) + 0.5 f(0.8284134829000359)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/expectations.jl#LL133-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@expect" href="#InfiniteOpt.MeasureToolbox.@expect"><code>InfiniteOpt.MeasureToolbox.@expect</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@expect(expr::JuMP.AbstractJuMPScalar,
        prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};
        [num_supports::Int = DefaultNumSupports, 
        kwargs...]
        )::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a>. Please see its doc string more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/expectations.jl#LL205-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.𝔼" href="#InfiniteOpt.MeasureToolbox.𝔼"><code>InfiniteOpt.MeasureToolbox.𝔼</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">𝔼(expr::JuMP.AbstractJuMPScalar,
  prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}};
  [num_supports::Int = DefaultNumSupports, 
  kwargs...]
  )::GeneralVariableRef)</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a>. The unicode symbol <code>𝔼</code> is produced by  <code>\bbE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/expectations.jl#LL228-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@𝔼" href="#InfiniteOpt.MeasureToolbox.@𝔼"><code>InfiniteOpt.MeasureToolbox.@𝔼</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@𝔼(expr::JuMP.AbstractJuMPScalar,
   prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};
   [num_supports::Int = DefaultNumSupports],
   kwargs...)::GeneralVariableRef</code></pre><p>A convenient wrapper for <a href="#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a>. The unicode symbol <code>𝔼</code> is produced by  <code>\bbE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/expectations.jl#LL245-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.generate_expect_data" href="#InfiniteOpt.MeasureToolbox.generate_expect_data"><code>InfiniteOpt.MeasureToolbox.generate_expect_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_expect_data(domain::AbstractInfiniteDomain, 
                     prefs::Union{GeneralVariableRef, Vector{GeneralVariableRef}}, 
                     num_supports::Int; 
                     [kwargs...])::AbstractMeasureData</code></pre><p>Generate a concrete instance of <code>AbstractMeasureData</code> in accordance with the  <code>domain</code> and infinite parameter(s) <code>prefs</code> given for computing the expectation.  This is intended as an internal method, but should be extended for user defined  infinite domain types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/expectations.jl#LL4-L14">source</a></section></article><h3 id="Support-Sum"><a class="docs-heading-anchor" href="#Support-Sum">Support Sum</a><a id="Support-Sum-1"></a><a class="docs-heading-anchor-permalink" href="#Support-Sum" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@support_sum" href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>InfiniteOpt.MeasureToolbox.@support_sum</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@support_sum(expr::JuMP.AbstractJuMPScalar,
             prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}};
             label = All
             )::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.support_sum"><code>support_sum</code></a> please see its doc string for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/support_sums.jl#LL50-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.support_sum" href="#InfiniteOpt.MeasureToolbox.support_sum"><code>InfiniteOpt.MeasureToolbox.support_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">support_sum(expr::JuMP.AbstractJuMPScalar,
            params::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}};
            label = All
            )::GeneralVariableRef</code></pre><p>Creates a measure that represents the sum of the expression over a parameter(s) using all of its supports corresponding to <code>label</code>. Also, note that it is  preferred to call <a href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>@support_sum</code></a> when <code>expr</code> is not just a  single variable reference.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, x in [0, 1], supports = [0.3, 0.7])
x

julia&gt; @variable(model, f, Infinite(x))
f(x)

julia&gt; meas = support_sum(f, x)
support_sum{x}[f(x)]

julia&gt; expand(meas)
f(0.3) + f(0.7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/MeasureToolbox/support_sums.jl#LL7-L32">source</a></section></article><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{MeasureRef}" href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JuMP.name(mref::MeasureRef)::String</code></pre><p>Extend <code>JuMP.name</code> to return the name associated with a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1218-L1223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_measures" href="#InfiniteOpt.num_measures"><code>InfiniteOpt.num_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_measures(model::InfiniteModel)::Int</code></pre><p>Return the number of measures defined in <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; num_measures(model)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1321-L1331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_measures" href="#InfiniteOpt.all_measures"><code>InfiniteOpt.all_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_measures(model::InfiniteModel)::Vector{GeneralVariableRef}</code></pre><p>Return the list of all measures added to <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; all_measures(model)
2-element Array{GeneralVariableRef,1}:
 ∫{t ∈ [0, 6]}[w(t, x)]
 𝔼{x}[w(t, x)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1336-L1348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_function" href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return the function associated with <code>mref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; measure_function(meas)
y(x, t) + 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1047-L1057">source</a></section><section><div><pre><code class="language-julia hljs">measure_function(mref::GeneralVariableRef)</code></pre><p>Define <code>measure_function</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/general_variables.jl#LL766-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_data" href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure_data(mref::MeasureRef)::AbstractMeasureData</code></pre><p>Return the measure data associated with <code>mref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = measure_data(meas);

julia&gt; typeof(data)
FunctionalDiscreteMeasureData{Vector{GeneralVariableRef},Vector{Float64}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1062-L1074">source</a></section><section><div><pre><code class="language-julia hljs">measure_data(mref::GeneralVariableRef)</code></pre><p>Define <code>measure_data</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/general_variables.jl#LL766-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_analytic" href="#InfiniteOpt.is_analytic"><code>InfiniteOpt.is_analytic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_analytic(mref::MeasureRef)::Bool</code></pre><p>Return if <code>mref</code> is evaluated analytically.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_analytic(meas)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1079-L1089">source</a></section><section><div><pre><code class="language-julia hljs">is_analytic(mref::GeneralVariableRef)</code></pre><p>Define <code>is_analytic</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/general_variables.jl#LL766-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{MeasureRef}" href="#InfiniteOpt.parameter_refs-Tuple{MeasureRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter_refs(mref::MeasureRef)::Tuple</code></pre><p>Return the tuple of infinite parameters that the measured expression associated <code>mref</code> depends on once the measure has been evaluated. Note that this will correspond to the parameter dependencies of the measure function excluding those included in the measure data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parameter_refs(meas)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1117-L1130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{MeasureRef}" href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_used(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_used(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1302-L1312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">used_by_constraint(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; used_by_constraint(mref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1257-L1267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">used_by_measure(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; used_by_measure(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1242-L1252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">used_by_objective(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; used_by_objective(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1272-L1282">source</a></section></article><h2 id="Modification"><a class="docs-heading-anchor" href="#Modification">Modification</a><a id="Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Modification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{MeasureRef, String}" href="#JuMP.set_name-Tuple{MeasureRef, String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JuMP.set_name(mref::MeasureRef, name::String)::Nothing</code></pre><p>Extend <code>JuMP.set_name</code> to specify the name of a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1229-L1233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel, MeasureRef}" href="#JuMP.delete-Tuple{InfiniteModel, MeasureRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JuMP.delete(model::InfiniteModel, mref::MeasureRef)::Nothing</code></pre><p>Extend <code>JuMP.delete</code> to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; print(model)
Min ∫{t ∈ [0, 6]}[g(t)] + z
Subject to
 z ≥ 0.0
 ∫{t ∈ [0, 6]}[g(t)] = 0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0

julia&gt; delete(model, meas)

julia&gt; print(model)
Min z
Subject to
 z ≥ 0.0
 0 = 0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measures.jl#LL1360-L1386">source</a></section></article><h2 id="Expansion"><a class="docs-heading-anchor" href="#Expansion">Expansion</a><a id="Expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Expansion" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand" href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return a JuMP scalar function containing the explicit expansion of the measure <code>mref</code>. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and semi-infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with <a href="#InfiniteOpt.measure"><code>measure</code></a> to expand measures on the fly.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. Optionally, <a href="#InfiniteOpt.analytic_expansion"><code>analytic_expansion</code></a> can also be extended which is triggered by <a href="#InfiniteOpt.is_analytic"><code>is_analytic</code></a> for such types if analytic expansion is possible in certain cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])

julia&gt; expr = expand(measure(g + z + T - h - 2, tdata))
0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL698-L723">source</a></section><section><div><pre><code class="nohighlight hljs">expand(mref::GeneralVariableRef)</code></pre><p>Define <code>expand</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/general_variables.jl#LL766-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_all_measures!" href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand_all_measures!(model::InfiniteModel)::Nothing</code></pre><p>Expand all of the measures used in the objective and/or constraints of <code>model</code>. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and semi-infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before <code>model</code> is translated into the new model. This method can also be extended to handle custom measure data types by extending <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. Note that this method leverages <code>expand_measure</code> via <a href="#InfiniteOpt.expand_measures"><code>expand_measures</code></a>. Optionally, <a href="#InfiniteOpt.analytic_expansion"><code>analytic_expansion</code></a> can also be extended which is triggered by <a href="#InfiniteOpt.is_analytic"><code>is_analytic</code></a> for such types if analytic expansion is possible in certain cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; print(model)
Min integral{t ∈ [0, 6]}[g(t)*t] + z
Subject to
 T(t, x) ≥ 0.0, ∀ t ∈ [0, 6], xi ∈ [-1, 1]
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 integral{t ∈ [0, 6]}[T(t, x)] ≥ 0.0, ∀ x ∈ [-1, 1]

julia&gt; expand_all_measures!(model)

julia&gt; print(model)
Min 3 g(6) + z
Subject to
 T(t, x) ≥ 0.0, ∀ t ∈ [0, 6], xi ∈ [-1, 1]
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 0.5 T(0, x) + 0.5 T(6, xi) ≥ 0.0, ∀ x ∈ [-1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL807-L844">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_measure" href="#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand_measure(expr, data::AbstractMeasureData,
               write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Return the finite reformulation of a measure containing a variable/parameter expression <code>expr</code> with measure data <code>data</code>. Here <code>write_model</code> is the target model where this expanded expression will be used. Thus, any variables that need to be created will be added to <code>write_model</code>. The methods <a href="#InfiniteOpt.make_point_variable_ref"><code>make_point_variable_ref</code></a> and <a href="#InfiniteOpt.make_semi_infinite_variable_ref"><code>make_semi_infinite_variable_ref</code></a> should be used as appropriate to create these variables. Note this is intended as an internal function, but will need to be extended for unsupported <code>expr</code> types and for user-defined measure data types. Principally, this is leveraged to enable the user methods <a href="#InfiniteOpt.expand"><code>expand</code></a> and <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL182-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.analytic_expansion" href="#InfiniteOpt.analytic_expansion"><code>InfiniteOpt.analytic_expansion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">analytic_expansion(expr, data::AbstractMeasureData,
                   write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Analytically, evaluate measure in the simple case where the measure expression <code>expr</code> doesn&#39;t depend on <code>data</code> and thus <code>expr</code> can be treated as a constant in conjunction with an analytic result of the <code>data</code>. This is intended as an internal method that is used by <a href="#InfiniteOpt.expand"><code>expand</code></a> and <a href="#InfiniteOpt.expand_measures"><code>expand_measures</code></a>. For unrecognized <code>data</code> types, <code>expand_measure</code> is called instead. User defined measure data type may choose to extend this method if desired. This is triggered when <code>is_analytic(mref) = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL626-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_measures" href="#InfiniteOpt.expand_measures"><code>InfiniteOpt.expand_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand_measures(expr, write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Expand all <code>MeasureRef</code>s in <code>expr</code> in-place via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a> and return the expanded expression. This is an internal method used by <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a> and <code>TranscriptionOpt</code> but can be useful for user-defined optimizer model extensions that add implement <a href="#InfiniteOpt.add_point_variable-Tuple{Model, Any, Any, Any}"><code>add_point_variable</code></a>/<a href="#InfiniteOpt.add_semi_infinite_variable-Tuple{Model, Any, Any}"><code>add_semi_infinite_variable</code></a> in combination  with <code>expand_measure</code>. <code>write_model</code> is the model that the measure variables are  added to as described in <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL735-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_point_variable_ref" href="#InfiniteOpt.make_point_variable_ref"><code>InfiniteOpt.make_point_variable_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_point_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},
                        ivref::GeneralVariableRef,
                        support::Vector{Float64}
                        )::GeneralVariableRef</code></pre><p>Make a point variable for infinite variable/derivative <code>ivref</code> at <code>support</code>, add it to the <code>write_model</code>, and return the <code>GeneralVariableRef</code>. This is an internal method for point variables produced by expanding measures via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the <code>InfiniteModel</code>. In such cases, <code>write_model</code> should be the optimizer model and  <a href="#InfiniteOpt.add_point_variable-Tuple{Model, Any, Any, Any}"><code>add_point_variable</code></a>  should be extended appropriately for point variables. Errors if <code>write_model</code> is an optimizer model and <code>add_point_variable</code> is not properly extended. </p><p>Note this is also accomodates infinite parameter functions, in which case the  infinite parameter function is called with the support as input. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_semi_infinite_variable_ref" href="#InfiniteOpt.make_semi_infinite_variable_ref"><code>InfiniteOpt.make_semi_infinite_variable_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_semi_infinite_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},
                                ivref::GeneralVariableRef,
                                indices::Vector{Int},
                                values::Vector{Float64}
                                )::GeneralVariableRef</code></pre><p>Make a semi-infinite variable for infinite variable/derivative/parameter  function <code>ivref</code> at <code>support</code>, add it to the <code>write_model</code>, and return the  <code>GeneralVariableRef</code>. This is an internal method for semi-infinite variables  produced by expanding measures via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. This is also useful  for those writing extension optimizer models and wish to expand measures without  modifiying the <code>InfiniteModel</code>. In such cases, <code>write_model</code> should be the  optimizer model and  <a href="#InfiniteOpt.add_semi_infinite_variable-Tuple{Model, Any, Any}"><code>add_semi_infinite_variable</code></a>  should be extended appropriately for semi-infinite variables. Errors if  <code>write_model</code> is an optimizer model and <code>add_semi_infinite_variable</code> is not  properly extended. Note this is only intended for optimizer models that are  currently stored in <code>InfiniteModel.optimizer_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL110-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_point_variable-Tuple{Model, Any, Any, Any}" href="#InfiniteOpt.add_point_variable-Tuple{Model, Any, Any, Any}"><code>InfiniteOpt.add_point_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_point_variable(model::JuMP.Model, ivref::GeneralVariableRef, 
                   support::Vector{Float64}, key::Val{:ext_key_name}
                   )::GeneralVariableRef</code></pre><p>Add a point variable (defined by restricting <code>ivref</code> to <code>support</code>) to the  optimizer model <code>model</code> (with <code>key</code>) and return the correct <code>InfiniteOpt</code>  variable reference. This is an internal method used by  <a href="#InfiniteOpt.make_point_variable_ref"><code>make_point_variable_ref</code></a> to make point variables when the <code>write_model</code>  is an optimizer model. This is useful for extensions that wish to expand  measures, but without changing the original <code>InfiniteModel</code>. An error is thrown  for unextended optimizer model types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL67-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_semi_infinite_variable-Tuple{Model, Any, Any}" href="#InfiniteOpt.add_semi_infinite_variable-Tuple{Model, Any, Any}"><code>InfiniteOpt.add_semi_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_semi_infinite_variable(model::JuMP.Model, var::SemiInfiniteVariable, 
                           key::Val{:ext_key_name})::GeneralVariableRef</code></pre><p>Add a semi-infinite variable <code>var</code> to the optimizer model <code>model</code> (with <code>key</code>)  and return the correct <code>InfiniteOpt</code> variable reference. This is an internal  method used by <a href="#InfiniteOpt.make_semi_infinite_variable_ref"><code>make_semi_infinite_variable_ref</code></a> to make semi-infinite  variables when the <code>write_model</code> is an optimizer model. This is useful for  extensions that wish to expand measures, but without changing the original  <code>InfiniteModel</code>. An error is thrown for optimizer model types. Note if this is  extended, than <a href="#InfiniteOpt.internal_semi_infinite_variable"><code>internal_semi_infinite_variable</code></a> should also be extended  in order to direct semi-infinite variables references to the underlying  <a href="../variable/#InfiniteOpt.SemiInfiniteVariable"><code>SemiInfiniteVariable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/measure_expansions.jl#LL146-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.internal_semi_infinite_variable" href="#InfiniteOpt.internal_semi_infinite_variable"><code>InfiniteOpt.internal_semi_infinite_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">internal_semi_infinite_variable(vref::SemiInfiniteVariableRef,
                                key::Val{:my_ext_key})::SemiInfiniteVariable</code></pre><p>Return the semi-infinite variable object of <code>vref</code> assuming it is an internal variable made during measure expansion within an optimizer model. This will apply to optimizer model extensions that utilize <code>add_measure_variable</code> in combination with <code>expand_measure</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/931568214cde4f2e46d73f59b35ea1787c843b1b/src/semi_infinite_variables.jl#LL46-L54">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../expression/">« Expressions</a><a class="docs-footer-nextpage" href="../objective/">Objectives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Tuesday 21 September 2021 00:32">Tuesday 21 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
