<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Transcription · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../../guide/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../guide/variable/">Variables</a></li><li><a class="tocitem" href="../../guide/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../../guide/measure/">Measures</a></li><li><a class="tocitem" href="../../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../../guide/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li class="is-active"><a class="tocitem" href>Model Transcription</a><ul class="internal"><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Manual</a></li><li class="is-active"><a href>Model Transcription</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Transcription</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/manual/transcribe.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="transcription_manual"><a class="docs-heading-anchor" href="#transcription_manual">Model Transcription</a><a id="transcription_manual-1"></a><a class="docs-heading-anchor-permalink" href="#transcription_manual" title="Permalink"></a></h1><p>A technical manual for <code>InfiniteOpt.TranscriptionOpt</code>. See the respective  <a href="../../guide/transcribe/#transcription_docs">guide</a> for more information.</p><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.TranscriptionModel" href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">TranscriptionModel([optimizer_constructor;
                   caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,
                   bridge_constraints::Bool = true])::JuMP.Model</code></pre><p>Return a <code>JuMP.Model</code> with <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>TranscriptionData</code></a> included in the <code>ext</code> data field. Accepts the same arguments as a typical JuMP <code>Model</code>. More detailed variable and constraint naming can be enabled via <code>verbose_naming</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; TranscriptionModel()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL109-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.TranscriptionData" href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>InfiniteOpt.TranscriptionOpt.TranscriptionData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TranscriptionData</code></pre><p>A DataType for storing the data mapping an <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteOpt.InfiniteModel</code></a> that has been transcribed to a regular <code>JuMP.Model</code> that contains the transcribed variables. This is stored in the <code>ext</code> field of a <code>JuMP.Model</code> to make what is called a <code>TranscriptionModel</code> via the <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel"><code>TranscriptionModel</code></a> constructor.</p><p><strong>Fields</strong></p><ul><li><code>infvar_lookup::Dict{InfiniteOpt.GeneralVariableRef, Dict{Vector{Float64}, Int}}</code>:  A lookup table of infinite variable transcriptions via support value.</li><li><code>infvar_mappings::Dict{InfiniteOpt.GeneralVariableRef, Vector{JuMP.VariableRef}}</code>:  Map infinite variables to their transcription variables.</li><li><code>infvar_supports::Dict{InfiniteOpt.GeneralVariableRef, Vector{Tuple}}</code>:  Map infinite variables to their support values.</li><li><code>infvar_support_labels::Dict{InfiniteOpt.GeneralVariableRef, Vector{Set{DataType}}}</code>:   Map the infinite variables to their support labels.</li><li><code>finvar_mappings::Dict{InfiniteOpt.GeneralVariableRef, JuMP.VariableRef}</code>:  Map finite variables to their transcription variables.</li><li><code>semi_infinite_vars::Vector{InfiniteOpt.SemiInfiniteVariable{InfiniteOpt.GeneralVariableRef}}</code>:  Store the core semi-infinite variable objects of semi-infinite variables formed on transcription.</li><li><code>semi_lookup::Dict{Tuple{InfiniteOpt.GeneralVariableRef, Dict{Int, Float64}}, InfiniteOpt.GeneralVariableRef}</code>:  Lookup which semi-infinite variables have already been added.</li><li><code>last_point_index::Int</code>: The last internal point variable index added.</li><li><code>point_lookup::Dict{Tuple{InfiniteOpt.GeneralVariableRef, Vector{Float64}}, InfiniteOpt.GeneralVariableRef}</code>:  Lookup which point variables have already been created internally.</li><li><code>measure_lookup::Dict{InfiniteOpt.GeneralVariableRef, Dict{Vector{Float64}, Int}}</code>:  A lookup table of measure transcriptions via support value.</li><li><code>measure_mappings::Dict{InfiniteOpt.GeneralVariableRef, Vector{JuMP.AbstractJuMPScalar}}</code>:  Map measures to transcription expressions.</li><li><code>measure_supports::Dict{InfiniteOpt.GeneralVariableRef, Vector{Tuple}}</code>:  Map measures to their supports values (if the transcribed measure is still infinite).</li><li><code>measure_support_labels::Dict{InfiniteOpt.GeneralVariableRef, Vector{Set{DataType}}}</code>:   Map measures to their support labels if they have any.</li><li><code>constr_mappings::Dict{InfiniteOpt.InfOptConstraintRef, Vector{JuMP.ConstraintRef}}</code>:  Map constraints to their transcriptions.</li><li><code>constr_supports::Dict{InfiniteOpt.InfOptConstraintRef, Vector{Tuple}}</code>:  Map constraints to their support values.</li><li><code>constr_support_labels::Dict{InfiniteOpt.InfOptConstraintRef, Vector{Set{DataType}}}</code>:   Map constraints to their support labels.</li><li><code>supports::Tuple</code>: Store the collected parameter supports here.</li><li><code>support_labels::Tuple</code>: Store the collected parameter labels here.</li><li><code>has_internal_supports::Bool</code>: Where any internal supports collected?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL4-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.set_parameter_supports" href="#InfiniteOpt.TranscriptionOpt.set_parameter_supports"><code>InfiniteOpt.TranscriptionOpt.set_parameter_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_parameter_supports(trans_model::JuMP.Model,
                       inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Collect the infinite parameter supports stored in their respective dictionaries form <code>inf_model</code> and process them into a tuple of vectors where each vector contains the collected supports of a particular infinite parameter. These support collections are ordered in accordance with the definition order of the parameters (i.e., their object numbers). A support collection assocciated with an independent will be a <code>Vector{Float64}</code> and a support collection associated with a group of dependent parameters will be a <code>Vector{Vector{Float64}}</code>. Note that each collection vector will include an extra final placeholder element comprised of <code>NaN</code>s for convenience in generating support indices via <a href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>support_index_iterator</code></a>. This also gathers the associated support labels. </p><p>Before this is all done, <code>InfiniteOpt.add_generative_supports</code> is invoked as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_finite_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_finite_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_finite_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_finite_variables!(trans_model::JuMP.Model,
                           inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Create a transcription variable (i.e., a JuMP variable) for each <code>FiniteVariable</code> stored in <code>inf_model</code> and add it to <code>trans_model</code>. The variable mapping is also stored in <code>TranscriptionData.finvar_mappings</code> which enables <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model, GeneralVariableRef, Vector{T} where T}"><code>lookup_by_support</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_infinite_variables!(trans_model::JuMP.Model,
                               inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Create transcription variables (i.e., JuMP variables) for each <code>InfiniteVariable</code> stored in <code>inf_model</code> and add them to <code>trans_model</code>. The variable mappings are also stored in <code>TranscriptionData.infvar_mappings</code> in accordance with <code>TranscriptionData.infvar_lookup</code> which enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model, GeneralVariableRef, Vector{T} where T}"><code>lookup_by_support</code></a>. Note that the supports will not be generated until <code>InfiniteOpt.variable_supports</code> is invoked via <code>InfiniteOpt.supports</code>.  Note that <code>TranscriptionData.infvar_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL127-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_derivative_variables!(trans_model::JuMP.Model,
                                 inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Create transcription variables (i.e., JuMP variables) for each <code>Derivative</code> stored in <code>inf_model</code> and add them to <code>trans_model</code>. The variable mappings are also stored in <code>TranscriptionData.infvar_mappings</code> in accordance with <code>TranscriptionData.infvar_lookup</code> which enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model, GeneralVariableRef, Vector{T} where T}"><code>lookup_by_support</code></a>. Note that the supports will not be generated until <code>InfiniteOpt.variable_supports</code> is invoked via <code>InfiniteOpt.supports</code>. The  futher derivative evaluation constraints are added when  <code>transcribe_derivative_evaluations!</code> is invoked. Note that  <code>TranscriptionData.infvar_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL193-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_semi_infinite_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_semi_infinite_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_semi_infinite_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_semi_infinite_variables!(trans_model::JuMP.Model,
                              inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Map each <code>SemiInfiniteVariable</code> in <code>inf_model</code> to transcription variables stored in <code>trans_model</code>. The variable mappings are also stored in <code>TranscriptionData.infvar_mappings</code> in accordance with <code>TranscriptionData.infvar_lookup</code> which enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model, GeneralVariableRef, Vector{T} where T}"><code>lookup_by_support</code></a>. Note that <a href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>transcribe_infinite_variables!</code></a> must be called first. Note that the supports will not be generated until <code>InfiniteOpt.variable_supports</code> is invoked via <code>InfiniteOpt.supports</code>.  Note that <code>TranscriptionData.infvar_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL299-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_point_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_point_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_point_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_point_variables!(trans_model::JuMP.Model,
                           inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Map each <code>PointVariable</code> in <code>inf_model</code> to a transcription variable stored in <code>trans_model</code>. The variable mapping is also stored in <code>TranscriptionData.finvar_mappings</code> which enables <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model, GeneralVariableRef, Vector{T} where T}"><code>lookup_by_support</code></a>. Note that <a href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>transcribe_infinite_variables!</code></a> must be called first and that the info constraints associated with the transcription variable will be updated in accordance with the point variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL366-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_expression" href="#InfiniteOpt.TranscriptionOpt.transcription_expression"><code>InfiniteOpt.TranscriptionOpt.transcription_expression</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcription_expression(
    model::JuMP.Model,
    expr::JuMP.AbstractJuMPScalar;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the transcribed expression(s) corresponding to <code>expr</code>. Errors if <code>expr</code> cannot be transcribed. Also can query via the syntax:</p><pre><code class="language-julia hljs">transcription_expression(expr::JuMP.AbstractJuMPScalar;
                         [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
                         ndarray::Bool = false])</code></pre><p>If the infinite model contains a built transcription model. By default, this method returns only transcribed expressions associated with public supports. All the  expressions can be returned by setting <code>label = All</code>.</p><p>If <code>expr</code> is infinite and <code>ndarray = true</code> then an n-dimensional array will be  returned in accordance with the infinite parameters that have unique object  numbers. In this case, <code>label</code> will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transcription_expression(trans_model, my_expr)
x(support: 1) - y

julia&gt; transcription_expression(my_expr)
x(support: 1) - y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL606-L638">source</a></section><section><div><pre><code class="nohighlight hljs">transcription_expression(trans_model::JuMP.Model, expr, support::Vector{Float64})</code></pre><p>Given the <code>expr</code> from an <code>InfiniteModel</code>, form its transcripted version in accordance with the variable mappings available in <code>trans_model</code> defined at <code>support</code>. This should only be used once all variables and measures have been transcribed (e.g., via <a href="#InfiniteOpt.TranscriptionOpt.transcribe_finite_variables!"><code>transcribe_finite_variables!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL400-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_measures!" href="#InfiniteOpt.TranscriptionOpt.transcribe_measures!"><code>InfiniteOpt.TranscriptionOpt.transcribe_measures!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_measures!(trans_model::JuMP.Model,
                     inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>For each <code>Measure</code> in <code>inf_model</code> expand it via <code>InfiniteOpt.expand_measure</code> or <code>analytic_expansion</code> as appropriate and transcribe the expanded expression via <a href="#InfiniteOpt.TranscriptionOpt.transcription_expression"><code>transcription_expression</code></a>. Then store the measure to transcripted expression mappings in <code>TranscriptionData.measure_mappings</code> and <code>TranscriptionData.measure_lookup</code> to enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model, GeneralVariableRef, Vector{T} where T}"><code>lookup_by_support</code></a>. Note that the supports will not be generated until <code>InfiniteOpt.variable_supports</code> is invoked via <code>InfiniteOpt.supports</code>.  Note that <code>TranscriptionData.measure_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL526-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_objective!" href="#InfiniteOpt.TranscriptionOpt.transcribe_objective!"><code>InfiniteOpt.TranscriptionOpt.transcribe_objective!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_objective!(trans_model::JuMP.Model,
                      inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Form the transcripted version of the objective stored in <code>inf_model</code> and add it to <code>trans_model</code>. Note that all the variables and measures in <code>inf_model</code> must by transcripted first (e.g., via <a href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>transcribe_infinite_variables!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL590-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_constraints!" href="#InfiniteOpt.TranscriptionOpt.transcribe_constraints!"><code>InfiniteOpt.TranscriptionOpt.transcribe_constraints!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_constraints!(trans_model::JuMP.Model,
                        inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>For each constraint in <code>inf_model</code> form its transcripted version(s) and add them to <code>trans_model</code>. The mappings are stored in <code>TranscriptionData.constr_mappings</code> and the associated supports are stored in <code>TranscriptionData.constr_supports</code> to enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model, InfOptConstraintRef}"><code>transcription_constraint</code></a> and <code>InfiniteOpt.constraint_supports</code>. Note that variable info constraints are simply mapped to the existing info constraints already generated along with the transcription variables. Note that the variables and measures must all first be transcripted (e.g., via <a href="#InfiniteOpt.TranscriptionOpt.transcribe_measures!"><code>transcribe_measures!</code></a>). Note that  <code>TranscriptionData.constr_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL774-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!" href="#InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!"><code>InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcribe_derivative_evaluations!(trans_model::JuMP.Model, 
                                   inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Generate the auxiliary derivative evaluation equations and transcribe them  appropriately for all the derivatives in <code>inf_model</code>. These are in turn added to  <code>trans_model</code>. Note that no mapping information is recorded since the InfiniteModel  won&#39;t have any constraints that correspond to these equations. Also Note that the variables and measures must all first be transcripted (e.g., via <a href="#InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!"><code>transcribe_derivative_variables!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL861-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.build_transcription_model!" href="#InfiniteOpt.TranscriptionOpt.build_transcription_model!"><code>InfiniteOpt.TranscriptionOpt.build_transcription_model!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_transcription_model!(trans_model::JuMP.Model,
                           inf_model::InfiniteOpt.InfiniteModel;
                           [check_support_dims::Bool = true])::Nothing</code></pre><p>Given an empty <code>trans_model</code> build it using the information stored in <code>inf_model</code>. This is intended for a <code>TranscriptionModel</code> that serves as a internal optimizer model of <code>inf_model</code>. This detail is important to correctly enable internally generated semi-infinite variables during the transcription process such that <code>inf_model</code> is not modified. Note that this will add supports to <code>inf_model</code> via <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>InfiniteOpt.fill_in_supports!</code></a> for infinite parameters that contain no supports. Also a warning is thrown when the transcription model contains more than 15,000 support points to alert users when they may naively have a few independent supports whose product quickly yields a very large grid. For example having 3 independent parameters with 100 supports each would result in 1,000,000 supports if all three are together in at least 1 constraint. This  behavior can be overcome using dependent parameters. The warning can be turned off  via <code>check_support_dims = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/transcribe.jl#LL907-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_point_variable-Tuple{Model, GeneralVariableRef, Vector{Float64}, Val{:TransData}}" href="#InfiniteOpt.add_point_variable-Tuple{Model, GeneralVariableRef, Vector{Float64}, Val{:TransData}}"><code>InfiniteOpt.add_point_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.add_point_variable(model::JuMP.Model,
                               var::InfiniteOpt.PointVariable,
                               key::Val{:TransData}
                               )::InfiniteOpt.GeneralVariableRef</code></pre><p>Make a <code>PointVariableRef</code> and map it to the appropriate transcription variable and return the <code>GeneralVariableRef</code>. This is an extension of <a href="../measure/#InfiniteOpt.add_point_variable-Tuple{Model, Any, Any, Any}"><code>add_point_variable</code></a> for <code>TranscriptionOpt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/measures.jl#LL1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_semi_infinite_variable-Tuple{Model, SemiInfiniteVariable, Val{:TransData}}" href="#InfiniteOpt.add_semi_infinite_variable-Tuple{Model, SemiInfiniteVariable, Val{:TransData}}"><code>InfiniteOpt.add_semi_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.add_semi_infinite_variable(model::JuMP.Model,
                                 var::InfiniteOpt.SemiInfiniteVariable,
                                 key::Val{:TransData}
                                 )::InfiniteOpt.GeneralVariableRef</code></pre><p>Make a <code>SemiInfiniteVariableRef</code> and add <code>var</code> to the transcription data  and return the <code>GeneralVariableRef</code>. This is an extension of  <a href="../measure/#InfiniteOpt.add_semi_infinite_variable-Tuple{Model, Any, Any}"><code>add_semi_infinite_variable</code></a>  for <code>TranscriptionOpt</code>. Note that <code>internal_semi_infinite_variable</code> is also  extended to be able to access the <code>var</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/measures.jl#LL42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel, Val{:TransData}}" href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel, Val{:TransData}}"><code>InfiniteOpt.build_optimizer_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.build_optimizer_model!(model::InfiniteOpt.InfiniteModel,
                                   key::Val{:TransData};
                                   check_support_dims::Bool = true)::Nothing</code></pre><p>Transcribe <code>model</code> and store it as a <code>TranscriptionModel</code> in the <code>model.optimizer_model</code> field which can be accessed with <code>transcription_model</code>. Ths clears the existing <code>TranscriptionModel</code> via <a href="../optimize/#InfiniteOpt.clear_optimizer_model_build!-Tuple{InfiniteModel}"><code>InfiniteOpt.clear_optimizer_model_build!</code></a> and then builds a new one using <a href="#InfiniteOpt.TranscriptionOpt.build_transcription_model!"><code>build_transcription_model!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/optimize.jl#LL15-L25">source</a></section></article><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.is_transcription_model" href="#InfiniteOpt.TranscriptionOpt.is_transcription_model"><code>InfiniteOpt.TranscriptionOpt.is_transcription_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_transcription_model(model::JuMP.Model)::Bool</code></pre><p>Return true if <code>model</code> is a <code>TranscriptionModel</code> or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; is_transcription_model(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL145-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_data" href="#InfiniteOpt.TranscriptionOpt.transcription_data"><code>InfiniteOpt.TranscriptionOpt.transcription_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcription_data(model::JuMP.Model)::TranscriptionData</code></pre><p>Return the <code>TranscriptionData</code> from a <code>TranscriptionModel</code>. Errors if it is not a <code>TranscriptionModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.has_internal_supports" href="#InfiniteOpt.TranscriptionOpt.has_internal_supports"><code>InfiniteOpt.TranscriptionOpt.has_internal_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_internal_supports(model::JuMP.Model)::Bool</code></pre><p>Return a <code>Bool</code> whether <code>model</code> has any internal supports that were collected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_model" href="#InfiniteOpt.TranscriptionOpt.transcription_model"><code>InfiniteOpt.TranscriptionOpt.transcription_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcription_model(model::InfiniteOpt.InfiniteModel)::JuMP.Model</code></pre><p>Return the transcription model stored in <code>model</code> if that is what is stored in <code>model.optimizer_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/optimize.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}" href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}"><code>InfiniteOpt.TranscriptionOpt.transcription_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transcription_variable(model::JuMP.Model,
    vref::InfiniteOpt.GeneralVariableRef;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
     ndarray::Bool = false])</code></pre><p>Return the transcribed variable reference(s) corresponding to <code>vref</code>. Errors if no transcription variable is found. Also can query via the syntax:</p><pre><code class="language-julia hljs">transcription_variable(vref::InfiniteOpt.GeneralVariableRef; 
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
     ndarray::Bool = false])</code></pre><p>If the infinite model contains a built transcription model. By default, this method returns only transcribed variables associated with public supports. All the  variables can be returned by setting <code>label = All</code>. </p><p>If <code>vref</code> is infinite and <code>ndarray = true</code> then an n-dimensional array will be  returned in accordance with the infinite parameters that have unique object  numbers. In this case, <code>label</code> will be used to search the intersection of variable  supports that use the label. This is defers from the default behavior which  considers the union.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transcription_variable(trans_model, infvar)
2-element Array{VariableRef,1}:
 infvar(support: 1)
 infvar(support: 2)

julia&gt; transcription_variable(trans_model, hdvar)
hdvar

julia&gt; transcription_variable(infvar)
2-element Array{VariableRef,1}:
 infvar(support: 1)
 infvar(support: 2)

julia&gt; transcription_variable(hdvar)
hdvar</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL193-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_variable-Tuple{GeneralVariableRef, Val{:TransData}}" href="#InfiniteOpt.optimizer_model_variable-Tuple{GeneralVariableRef, Val{:TransData}}"><code>InfiniteOpt.optimizer_model_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.optimizer_model_variable(vref::InfiniteOpt.GeneralVariableRef,
    ::Val{:TransData};
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Proper extension of <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>InfiniteOpt.optimizer_model_variable</code></a> for <code>TranscriptionModel</code>s. This simply dispatches to <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model, GeneralVariableRef}"><code>transcription_variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL343-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.variable_supports-Tuple{Model, Union{InfiniteVariableRef, SemiInfiniteVariableRef}, Val{:TransData}}" href="#InfiniteOpt.variable_supports-Tuple{Model, Union{InfiniteVariableRef, SemiInfiniteVariableRef}, Val{:TransData}}"><code>InfiniteOpt.variable_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.variable_supports(model::JuMP.Model,
    vref::InfiniteOpt.DecisionVariableRef,
    key::Val{:TransData} = Val(:TransData);
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the support alias mapping associated with <code>vref</code> in the transcription model. Errors if <code>vref</code> does not have transcripted variables. See <code>transcription_variable</code>  for an explanation of <code>ndarray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL361-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model, GeneralVariableRef, Vector{T} where T}" href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model, GeneralVariableRef, Vector{T} where T}"><code>InfiniteOpt.TranscriptionOpt.lookup_by_support</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup_by_support(model::JuMP.Model,
                  vref::InfiniteOpt.GeneralVariableRef,
                  support::Vector)</code></pre><p>Return the transcription expression of <code>vref</code> defined at its <code>support</code>. This is intended as a helper method for automated transcription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL435-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.internal_semi_infinite_variable-Tuple{SemiInfiniteVariableRef, Val{:TransData}}" href="#InfiniteOpt.internal_semi_infinite_variable-Tuple{SemiInfiniteVariableRef, Val{:TransData}}"><code>InfiniteOpt.internal_semi_infinite_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.internal_semi_infinite_variable(
    vref::InfiniteOpt.SemiInfiniteVariableRef,
    ::Val{:TransData}
    )::InfiniteOpt.SemiInfiniteVariable{InfiniteOpt.GeneralVariableRef}</code></pre><p>Return the internal semi-infinite variable associated with <code>vref</code>, assuming it was added internally during measure expansion at the transcription step. This extends <a href="../measure/#InfiniteOpt.internal_semi_infinite_variable"><code>InfiniteOpt.internal_semi_infinite_variable</code></a> as described in its docstring. Errors, if no such variable can be found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL499-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_expression-Tuple{Model, Union{GenericAffExpr, GenericQuadExpr}}" href="#InfiniteOpt.TranscriptionOpt.transcription_expression-Tuple{Model, Union{GenericAffExpr, GenericQuadExpr}}"><code>InfiniteOpt.TranscriptionOpt.transcription_expression</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transcription_expression(
    model::JuMP.Model,
    expr::JuMP.AbstractJuMPScalar;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the transcribed expression(s) corresponding to <code>expr</code>. Errors if <code>expr</code> cannot be transcribed. Also can query via the syntax:</p><pre><code class="language-julia hljs">transcription_expression(expr::JuMP.AbstractJuMPScalar;
                         [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
                         ndarray::Bool = false])</code></pre><p>If the infinite model contains a built transcription model. By default, this method returns only transcribed expressions associated with public supports. All the  expressions can be returned by setting <code>label = All</code>.</p><p>If <code>expr</code> is infinite and <code>ndarray = true</code> then an n-dimensional array will be  returned in accordance with the infinite parameters that have unique object  numbers. In this case, <code>label</code> will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transcription_expression(trans_model, my_expr)
x(support: 1) - y

julia&gt; transcription_expression(my_expr)
x(support: 1) - y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL606-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_expression-Tuple{Union{GenericAffExpr, GenericQuadExpr}, Val{:TransData}}" href="#InfiniteOpt.optimizer_model_expression-Tuple{Union{GenericAffExpr, GenericQuadExpr}, Val{:TransData}}"><code>InfiniteOpt.optimizer_model_expression</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.optimizer_model_expression(expr::JuMP.AbstractJuMPScalar,
    ::Val{:TransData};
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Proper extension of <a href="../optimize/#InfiniteOpt.optimizer_model_expression"><code>InfiniteOpt.optimizer_model_expression</code></a> for <code>TranscriptionModel</code>s. This simply dispatches to <a href="#InfiniteOpt.TranscriptionOpt.transcription_expression"><code>transcription_expression</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL693-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expression_supports-Tuple{Model, Union{GenericAffExpr, GenericQuadExpr}, Val{:TransData}}" href="#InfiniteOpt.expression_supports-Tuple{Model, Union{GenericAffExpr, GenericQuadExpr}, Val{:TransData}}"><code>InfiniteOpt.expression_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.expression_supports(model::JuMP.Model,
    expr::JuMP.AbstractJuMPScalar,
    key::Val{:TransData} = Val(:TransData);
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the support alias mappings associated with <code>expr</code>. Errors if <code>expr</code> cannot be transcribed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL710-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model, InfOptConstraintRef}" href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model, InfOptConstraintRef}"><code>InfiniteOpt.TranscriptionOpt.transcription_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transcription_constraint(model::JuMP.Model,
    cref::InfiniteOpt.InfOptConstraintRef;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the transcribed constraint reference(s) corresponding to <code>cref</code>. Errors if <code>cref</code> has not been transcribed. Also can query via the syntax:</p><pre><code class="language-julia hljs">transcription_constraint(cref::InfiniteOpt.InfOptConstraintRef;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>If the infinite model contains a built transcription model. By default, this method returns only transcribed constraints associated with public supports. All the  constraints can be returned by setting <code>label = All</code>.</p><p>If <code>cref</code> is infinite and <code>ndarray = true</code> then an n-dimensional array will be  returned in accordance with the infinite parameters that have unique object  numbers. In this case, <code>label</code> will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transcription_constraint(trans_model, fin_con)
fin_con : x(support: 1) - y &lt;= 3.0

julia&gt; transcription_constraint(fin_con)
fin_con : x(support: 1) - y &lt;= 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL753-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_constraint-Tuple{InfOptConstraintRef, Val{:TransData}}" href="#InfiniteOpt.optimizer_model_constraint-Tuple{InfOptConstraintRef, Val{:TransData}}"><code>InfiniteOpt.optimizer_model_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.optimizer_model_constraint(
    cref::InfiniteOpt.InfOptConstraintRef,
    ::Val{:TransData};
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel
    ndarray::Bool = false])</code></pre><p>Proper extension of <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>InfiniteOpt.optimizer_model_constraint</code></a> for <code>TranscriptionModel</code>s. This simply dispatches to <a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model, InfOptConstraintRef}"><code>transcription_constraint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL819-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.constraint_supports-Tuple{Model, InfOptConstraintRef, Val{:TransData}}" href="#InfiniteOpt.constraint_supports-Tuple{Model, InfOptConstraintRef, Val{:TransData}}"><code>InfiniteOpt.constraint_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteOpt.constraint_supports(model::JuMP.Model,
    cref::InfiniteOpt.InfOptConstraintRef,
    key::Val{:TransData} = Val(:TransData);
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the support alias mappings associated with <code>cref</code>. Errors if <code>cref</code> is not transcribed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL838-L847">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.parameter_supports-Tuple{Model}" href="#InfiniteOpt.TranscriptionOpt.parameter_supports-Tuple{Model}"><code>InfiniteOpt.TranscriptionOpt.parameter_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter_supports(model::JuMP.Model)::Tuple</code></pre><p>Return the collected parameter support tuple that is stored in <code>TranscriptionData.supports</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL875-L880">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.support_index_iterator" href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>InfiniteOpt.TranscriptionOpt.support_index_iterator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">support_index_iterator(model::JuMP.Model, [obj_nums::Vector{Int}])::CartesianIndices</code></pre><p>Return the <code>CartesianIndices</code> that determine the indices of the unique combinations of <code>TranscriptionData.supports</code> stored in <code>model</code>. If <code>obj_nums</code> is specified, then the indices will only include the tuple elements uses indices are included in the object numbers <code>obj_nums</code> and all others will be assigned the last index which should correspond to an appropriately sized placeholder comprised of <code>NaN</code>s. Note this method assumes that <a href="#InfiniteOpt.TranscriptionOpt.set_parameter_supports"><code>set_parameter_supports</code></a> has already been called and that the last elements of each support vector contains a placeholder value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL885-L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.index_to_support" href="#InfiniteOpt.TranscriptionOpt.index_to_support"><code>InfiniteOpt.TranscriptionOpt.index_to_support</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">index_to_support(model::JuMP.Model, index::CartesianIndex)::Vector{Float64}</code></pre><p>Given a particular support <code>index</code> generated via <a href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>support_index_iterator</code></a> using <code>model</code>, return the corresponding support from <code>TranscriptionData.supports</code> using placeholder <code>NaN</code>s as appropriate for tuple elements that are unneeded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL915-L921">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.index_to_labels" href="#InfiniteOpt.TranscriptionOpt.index_to_labels"><code>InfiniteOpt.TranscriptionOpt.index_to_labels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">index_to_labels(model::JuMP.Model, index::CartesianIndex)::Set{DataType}</code></pre><p>Given a particular support <code>index</code> generated via <a href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>support_index_iterator</code></a> using <code>model</code>, return the corresponding support label set from <code>TranscriptionData.support_labels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL930-L935">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.make_ndarray" href="#InfiniteOpt.TranscriptionOpt.make_ndarray"><code>InfiniteOpt.TranscriptionOpt.make_ndarray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_narray(model::JuMP.Model, 
            ref::Union{JuMP.AbstractJuMPScalar, InfiniteOpt.InfOptConstraintRef}, 
            info::Vector, 
            label::Type{&lt;:InfiniteOpt.AbstractSupportLabel})::Array</code></pre><p>Take the results<code>info</code> associated with <code>ref</code> and rearrange them into an  n-dimensional array where the axes correspond to the infinite parameter dependencies  in accordance with their creation. Note that this works by querying the object  numbers. Thus, independent infinite parameters will each get their own dimension  (even if they are defined at the same time in an array) and each dependent infinite  parameter group will have its own dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/5a954db6d9edfb2e4eae1b8f469bfff95678472f/src/TranscriptionOpt/model.jl#LL969-L981">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constraint/">« Constraints</a><a class="docs-footer-nextpage" href="../optimize/">Optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 3 December 2021 17:13">Friday 3 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
