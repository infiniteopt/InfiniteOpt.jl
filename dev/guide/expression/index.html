<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Expressions · InfiniteOpt.jl</title><meta name="title" content="Expressions · InfiniteOpt.jl"/><meta property="og:title" content="Expressions · InfiniteOpt.jl"/><meta property="twitter:title" content="Expressions · InfiniteOpt.jl"/><meta name="description" content="Documentation for InfiniteOpt.jl."/><meta property="og:description" content="Documentation for InfiniteOpt.jl."/><meta property="twitter:description" content="Documentation for InfiniteOpt.jl."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/Fishing/">Fishing Optimal Control</a></li><li><a class="tocitem" href="../../examples/Optimal Control/Hanging Chain/">Hanging Chain Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/Jennings/">Minimizing Final Time (Jennings Problem)</a></li><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li class="is-active"><a class="tocitem" href>Expressions</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#par_func_docs"><span>Parameter Functions</span></a></li><li><a class="tocitem" href="#Variable-Hierarchy"><span>Variable Hierarchy</span></a></li><li><a class="tocitem" href="#Affine-Expressions"><span>Affine Expressions</span></a></li><li><a class="tocitem" href="#Quadratic-Expressions"><span>Quadratic Expressions</span></a></li><li><a class="tocitem" href="#nlp_guide"><span>Nonlinear Expressions</span></a></li></ul></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/backend/">Backends</a></li><li><a class="tocitem" href="../../manual/transcribe/">TranscriptionOpt</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li><li><a class="tocitem" href="../../manual/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Expressions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Expressions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/infiniteopt/InfiniteOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/docs/src/guide/expression.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="expr_docs"><a class="docs-heading-anchor" href="#expr_docs">Expressions</a><a id="expr_docs-1"></a><a class="docs-heading-anchor-permalink" href="#expr_docs" title="Permalink"></a></h1><p>A guide for the defining and understanding the variable expressions used in <code>InfiniteOpt</code>. See the <a href="../../manual/expression/#expr_manual">technical manual</a> for more details.</p><div class="admonition is-info" id="Note-989cf2c84cdcc560"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-989cf2c84cdcc560" title="Permalink"></a></header><div class="admonition-body"><p>Nonlinear modeling is now handled in <code>InfiniteOpt</code> via <code>JuMP</code>&#39;s new nonlinear interface. See <a href="#nlp_guide">Nonlinear Expressions</a> for more information.</p></div></div><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Expressions in <code>InfiniteOpt</code> (also called functions) refer to mathematical statements involving variables and numbers. Thus, these comprise the mathematical expressions used that are used in measures, objectives, and constraints. Programmatically, <code>InfiniteOpt</code> simply extends <code>JuMP</code> expression types and methods.</p><h2 id="par_func_docs"><a class="docs-heading-anchor" href="#par_func_docs">Parameter Functions</a><a id="par_func_docs-1"></a><a class="docs-heading-anchor-permalink" href="#par_func_docs" title="Permalink"></a></h2><p>Rather than construct an explicit symbolic expression, we might want to provide a more complex function of infinite parameter(s) (e.g., nonlinear setpoint tracking). Thus, we provide parameter function objects that wrap arbitrary Julia functions that take infinite parameters as input and output  a scalar value. Mathematically, these can can be interpreted infinite variables constrained to a particular known function. These are created via <a href="../../manual/expression/#InfiniteOpt.@parameter_function"><code>@parameter_function</code></a> or <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a> and is exemplified below by defining a parameter function <code>f(t)</code> that uses <code>sin(t)</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using InfiniteOpt;

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @parameter_function(model, f == sin(t))
f(t)</code></pre><p>Here, we created a parameter function object, added it to <code>model</code>, and then created a Julia variable <code>f</code> that serves as a <code>GeneralVariableRef</code> that points to it. From here we can treat <code>f</code> as a normal infinite variable and use it with measures, and constraints. For example, we can do the following:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, y, Infinite(t));

julia&gt; f(0)
f(0)

julia&gt; meas = integral(y - f, t)
∫{t ∈ [0, 10]}[y(t) - f(t)]

julia&gt; @constraint(model, y - f &lt;= 0)
y(t) - f(t) ≤ 0, ∀ t ∈ [0, 10]</code></pre><p>We can also define parameter functions that depend on multiple infinite parameters and even use an anonymous Julia function if desired:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, x[1:2] in [-1, 1]);

julia&gt; @parameter_function(model, myname == (t, x) -&gt; t + sum(x))
myname(t, x)</code></pre><p>In many applications, we may also desire to define an array of parameter functions that each use a different realization of some parent function by varying some additional positional/keyword arguments. We readily support this behavior since parameter functions can be defined with additional known arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; @parameter_function(model, pfunc_alt[i = 1:3] == t -&gt; mysin(t, as[i], b = 0))
3-element Vector{GeneralVariableRef}:
 pfunc_alt[1](t)
 pfunc_alt[2](t)
 pfunc_alt[3](t)</code></pre><p>The use of <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a> is convenient for enabling do-block syntax which  often handy. For instance, when defining a time-varied setpoint for optimal control:</p><pre><code class="language-julia-repl hljs">julia&gt; setpoint = parameter_function(t, name = &quot;setpoint&quot;) do t_supp
                    if t_supp &lt;= 5
                        return 2.0
                    else
                        return 10.2
                    end
                 end
setpoint(t)</code></pre><p>Please consult the following links for more information about defining parameter functions: <a href="../../manual/expression/#InfiniteOpt.@parameter_function"><code>@parameter_function</code></a> and <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a>.</p><p>We can also update the underlying function as often required for repeated solves. This is accomplished via  <a href="../../manual/expression/#JuMP.set_parameter_value-Tuple{ParameterFunctionRef, Function}"><code>set_parameter_value</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; set_parameter_value(setpoint, t -&gt; 5)
</code></pre><p>Beyond this, there are a number of query and modification methods that can be employed for parameter functions and these are detailed in the <a href="../../manual/expression/#par_func_manual">technical manual</a>.</p><h2 id="Variable-Hierarchy"><a class="docs-heading-anchor" href="#Variable-Hierarchy">Variable Hierarchy</a><a id="Variable-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Hierarchy" title="Permalink"></a></h2><p>Expressions employ variable reference types inherited from <code>JuMP.AbstractVariableRef</code> to form expression objects. <code>InfiniteOpt</code> uses a hierarchy of such types to organize the complexities associated with modeling infinite dimensional programs. The figure below summarizes this hierarchy of variable reference types where the abstract types are depicted in green and the concrete types are shown blue.</p><p><img src="../../assets/variable_tree.png" alt="tree"/></p><p>In consistently with <code>JuMP</code> expression support, <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> exists as a variable reference type that is able to represent any of the above concrete subtypes of <a href="../../manual/expression/#InfiniteOpt.DispatchVariableRef"><code>DispatchVariableRef</code></a>. This allows the expression containers to be homogeneous in variable type which provides improved performance.</p><p>However, the variable hierarchy is used for variable methods. To accomplish this, appropriate <code>GeneralVariableRef</code> dispatch methods are implemented (which are detailed in User Methods section at the bottom of this page) that utilize <a href="../../manual/expression/#InfiniteOpt.dispatch_variable_ref"><code>dispatch_variable_ref</code></a> to create the appropriate concrete subtype of <code>DispatchVariableRef</code> and call the appropriate underlying method. These dispatch methods have been implemented for all public methods and the underlying methods are what are documented in the method manuals throughout the User Guide pages.</p><h2 id="Affine-Expressions"><a class="docs-heading-anchor" href="#Affine-Expressions">Affine Expressions</a><a id="Affine-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-Expressions" title="Permalink"></a></h2><p>An affine expression pertains to a mathematical function of the form:</p><p class="math-container">\[f_a(x) = a_1x_1 + ... + a_nx_n + b\]</p><p>where <span>$x \in \mathbb{R}^n$</span> denote variables, <span>$a \in \mathbb{R}^n$</span> denote coefficients, and <span>$b \in \mathbb{R}$</span> denotes a constant value. Such expressions, are prevalent in any problem than involves linear constraints and/or objectives.</p><p>In <code>InfiniteOpt</code>, affine expressions can be defined directly using <code>Julia</code>&#39;s arithmetic operators (i.e., <code>+</code>, <code>-</code>, <code>*</code>, etc.) or using <code>@expression</code>.  For example, let&#39;s define the expression <span>$2y(t) + z - 3t$</span> noting that the following methods are equivalent:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @variable(model, y, Infinite(t))
y(t)

julia&gt; @variable(model, z)
z

julia&gt; expr = 2y + z - 3t
2 y(t) + z - 3 t

julia&gt; expr = 2 * y + z - 3 * t
2 y(t) + z - 3 t

julia&gt; expr = @expression(model, 2y + z - 3t)
2 y(t) + z - 3 t

julia&gt; typeof(expr)
GenericAffExpr{Float64, GeneralVariableRef}</code></pre><p>Notice that coefficients to variables can simply be put alongside variables without having to use the <code>*</code> operator. Also, note that all of these expressions are stored in a container referred to as a <code>GenericAffExpr</code> which is a <code>JuMP</code> object for storing affine expressions.</p><div class="admonition is-info" id="Note-390644f054aee47"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-390644f054aee47" title="Permalink"></a></header><div class="admonition-body"><p>Where possible, it is preferable to use <a href="https://jump.dev/JuMP.jl/v1/api/JuMP/#JuMP.@expression"><code>@expression</code></a> for defining expressions as it is much more efficient than explicitly using the standard operators.</p></div></div><p><code>GenericAffExpr</code> objects contain 2 fields which are:</p><ul><li><code>constant::CoefType</code> The constant value of the affine expression.</li><li><code>terms::OrderDict{VarType, CoefType}</code> A dictionary mapping variables to coefficients.</li></ul><p>For example, let&#39;s see what these fields look like in the above example:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.terms
OrderedCollections.OrderedDict{GeneralVariableRef, Float64} with 3 entries:
  y(t) =&gt; 2.0
  z    =&gt; 1.0
  t    =&gt; -3.0

julia&gt; expr.constant
0.0</code></pre><p>Notice that the ordered dictionary preserves the order in which the variables appear in the expression.</p><p>More information can be found in the documentation for affine expressions in <a href="https://jump.dev/JuMP.jl/v1/api/JuMP/#JuMP.GenericAffExpr"><code>JuMP</code></a>.</p><h2 id="Quadratic-Expressions"><a class="docs-heading-anchor" href="#Quadratic-Expressions">Quadratic Expressions</a><a id="Quadratic-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Expressions" title="Permalink"></a></h2><p>A quadratic function pertains to a mathematical function of the form:</p><p class="math-container">\[f_q(x) = a_1x_1^2 + a_2 x_1 x_2 + ... + a_m x_n^2 + f_a(x)\]</p><p>where <span>$x \in \mathbb{R}^n$</span> are the variables, <span>$f_a(x): \mathbb{R}^n \mapsto \mathbb{R}$</span> is an affine function, and <span>$m = n(n+1)/2$</span> is the number of unique combinations of variables <span>$x$</span>. Like affine expressions, quadratic expressions can be defined via <code>Julia</code>&#39;s arithmetic operators or via <code>@expression</code>. For example, let&#39;s define <span>$2y^2(t) - zy(t) + 42t - 3$</span> using the following equivalent methods:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = 2y^2 - z * y + 42t - 3
2 y(t)² - z*y(t) + 42 t - 3

julia&gt; expr = @expression(model, 2y^2 - z * y + 42t - 3)
2 y(t)² - z*y(t) + 42 t - 3

julia&gt; typeof(expr)
GenericQuadExpr{Float64, GeneralVariableRef}</code></pre><p>Again, notice that coefficients need not employ <code>*</code>. Also, the object used to store the expression is a <code>GenericQuadExpr</code> which is a <code>JuMP</code> object used for storing quadratic expressions.</p><p><code>GenericQuadExpr</code> object contains 2 data fields which are:</p><ul><li><code>aff::GenericAffExpr{CoefType,VarType}</code> An affine expression</li><li><code>terms::OrderedDict{UnorderedPair{VarType}, CoefType}</code> A dictionary mapping quadratic variable pairs to coefficients.</li></ul><p>Here the <code>UnorderedPair</code> type is unique to <code>JuMP</code> and contains the fields:</p><ul><li><code>a::AbstractVariableRef</code> One variable in a quadratic pair</li><li><code>b::AbstractVariableRef</code> The other variable in a quadratic pair.</li></ul><p>Thus, this form can be used to store arbitrary quadratic expressions. For example, let&#39;s look at what these fields look like in the above example:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.aff
42 t - 3

julia&gt; typeof(expr.aff)
GenericAffExpr{Float64, GeneralVariableRef}

julia&gt; expr.terms
OrderedCollections.OrderedDict{UnorderedPair{GeneralVariableRef}, Float64} with 2 entries:
  UnorderedPair{GeneralVariableRef}(y(t), y(t)) =&gt; 2.0
  UnorderedPair{GeneralVariableRef}(z, y(t))    =&gt; -1.0</code></pre><p>Notice again that the ordered dictionary preserves the order.</p><p>More information can be found in the documentation for quadratic expressions in <a href="https://jump.dev/JuMP.jl/v1/api/JuMP/#JuMP.GenericQuadExpr"><code>JuMP</code></a>.</p><h2 id="nlp_guide"><a class="docs-heading-anchor" href="#nlp_guide">Nonlinear Expressions</a><a id="nlp_guide-1"></a><a class="docs-heading-anchor-permalink" href="#nlp_guide" title="Permalink"></a></h2><p>In this section, we walk you through the ins and out of working with general nonlinear (i.e., not affine or quadratic) expressions in <code>InfiniteOpt</code>.</p><div class="admonition is-info" id="Info-14c2e8f5a418c2d7"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-14c2e8f5a418c2d7" title="Permalink"></a></header><div class="admonition-body"><p>Our previous <code>InfiniteOpt</code> specific nonlinear API as been removed in favor of <code>JuMP</code>&#39;s new and improved nonlinear interface. Thus, <code>InfiniteOpt</code> now strictly uses the same expression structures as <code>JuMP</code>.</p></div></div><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><p>We can define nonlinear expressions in similar manner to how affine/quadratic expressions are made in <code>JuMP</code>. For instance, we can make an expression using normal Julia code outside a macro:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, t ∈ [0, 1]); @variable(model, y, Infinite(t));

julia&gt; expr = exp(y^2.3) * y - 42
(exp(y(t) ^ 2.3) * y(t)) - 42.0

julia&gt; typeof(expr)
GenericNonlinearExpr{GeneralVariableRef}</code></pre><p>Thus, the nonlinear expression <code>expr</code> of type <a href="https://jump.dev/JuMP.jl/v1/api/JuMP/#GenericNonlinearExpr"><code>GenericNonlinearExpr</code></a> is created and can be readily incorporated into other expressions, the objective, and/or constraints. For macro-based definition, we simply use the <code>@expression</code>, <code>@objective</code>, and <code>@constraint</code> macros as normal:</p><pre><code class="language-julia-repl hljs">julia&gt; @expression(model, expr, exp(y^2.3) * y - 42)
(exp(y(t) ^ 2.3) * y(t)) - 42.0

julia&gt; @objective(model, Min, ∫(0.3^cos(y^2), t))
∫{t ∈ [0, 1]}[0.3 ^ cos(y(t)²)]


julia&gt; @constraint(model, constr, y^y * sin(y) + sum(y^i for i in 3:4) == 3)
constr : (((y(t) ^ y(t)) * sin(y(t))) + (y(t) ^ 3) + (y(t) ^ 4)) - 3.0 = 0, ∀ t ∈ [0, 1]</code></pre><div class="admonition is-info" id="Note-633cbe3f4159ff49"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-633cbe3f4159ff49" title="Permalink"></a></header><div class="admonition-body"><p>The legacy <code>@NLexpression</code>, <code>@NLobjective</code>, and <code>@NLconstraint</code> macros in <code>JuMP</code> are not supported by <code>InfiniteOpt</code>.</p></div></div><p>Natively, we support all the same nonlinear operators that <code>JuMP</code> does. See <a href="https://jump.dev/JuMP.jl/v1/manual/nonlinear/#Supported-operators">JuMP&#39;s documentation</a> for more information.</p><p>We can interrogate which nonlinear operators our model currently supports by invoking <a href="../../manual/expression/#InfiniteOpt.all_nonlinear_operators"><code>all_nonlinear_operators</code></a>. Moreover, we can add additional operators (see <a href="#Adding-Nonlinear-Operators">Adding Nonlinear Operators</a> for more details).</p><p>Finally, we highlight that nonlinear expressions in <code>InfiniteOpt</code> support the same linear algebra operations as affine/quadratic expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, v[1:2]); @variable(model, Q[1:2, 1:2]);

julia&gt; @expression(model, v&#39; * Q * v)
0.0 + ((Q[1,2]*v[1] + Q[2,2]*v[2]) * v[2]) + ((Q[1,1]*v[1] + Q[2,1]*v[2]) * v[1])</code></pre><h3 id="Function-Tracing"><a class="docs-heading-anchor" href="#Function-Tracing">Function Tracing</a><a id="Function-Tracing-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Tracing" title="Permalink"></a></h3><p>In similar manner to <code>Symbolics.jl</code>, we support function tracing. This means that we can create nonlinear modeling expression using Julia functions that satisfy certain criteria. For instance:</p><pre><code class="language-julia-repl hljs">julia&gt; myfunc(x) = sin(x^3) / tan(2^x);

julia&gt; expr = myfunc(y)
sin(y(t) ^ 3) / tan(2.0 ^ y(t))</code></pre><p>However, there are certain limitations as to what internal code these functions can contain. The following CANNOT be used:</p><ul><li>loops (unless it only uses very simple operations)</li><li>if-statements (see workaround below)</li><li>unrecognized operators (if they cannot be traced).</li></ul><div class="admonition is-success" id="Tip-62adb42e74d342d7"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-62adb42e74d342d7" title="Permalink"></a></header><div class="admonition-body"><p>If a particular function is not amendable for tracing, try adding it as a new nonlinear operator instead. See <a href="#Adding-Nonlinear-Operators">Adding Nonlinear Operators</a> for details.</p></div></div><p>We can readily work around the if-statement limitation using <code>op_ifelse</code> which is a nonlinear operator version of <code>Base.ifelse</code> and follows the same syntax. For example, the function:</p><pre><code class="language-julia hljs">function mylogicfunc(x)
    if x &gt;= 0
        return x^3
    else
        return 0
    end
end</code></pre><p>is not amendable for function tracing, but we can rewrite it as:</p><pre><code class="language-julia-repl hljs">julia&gt; function mylogicfunc(x)
          return op_ifelse(op_greater_than_or_equal_to(x, 0), x^3, 0)
       end
mylogicfunc (generic function with 1 method)

julia&gt; mylogicfunc(y)
ifelse(y(t) &gt;= 0, y(t) ^ 3, 0)</code></pre><p>which is amendable for function tracing. Note that the basic logic operators (e.g., <code>&lt;=</code>) have special nonlinear operator analogues when used outside of a macro. See <a href="https://jump.dev/JuMP.jl/v1/manual/nonlinear/#Limitations">JuMP&#39;s documentation</a> for more details.</p><h3 id="Linear-Algebra"><a class="docs-heading-anchor" href="#Linear-Algebra">Linear Algebra</a><a id="Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra" title="Permalink"></a></h3><p>As described above in the Basic Usage Section, we support basic linear algebra operations with nonlinear expressions! This relies on our basic extensions of <a href="https://github.com/jump-dev/MutableArithmetics.jl"><code>MutableArithmetics</code></a>, but admittedly this implementation is not perfect in terms of efficiency.</p><div class="admonition is-success" id="Tip-3464761d9b1cb117"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-3464761d9b1cb117" title="Permalink"></a></header><div class="admonition-body"><p>Using linear algebra operations with nonlinear expression provides user convenience, but is less efficient than using <code>sum</code>s. Thus, <code>sum</code> should be used instead when efficiency is critical.</p><pre><code class="language-julia-repl hljs">julia&gt; v&#39; * Q * v # convenient linear algebra syntax
(+(0.0) + ((Q[1,1]*v[1] + Q[2,1]*v[2]) * v[1])) + ((Q[1,2]*v[1] + Q[2,2]*v[2]) * v[2])

julia&gt; sum(v[i] * Q[i, j] * v[j] for i in 1:2, j in 1:2) # more efficient
((((v[1]*Q[1,1]) * v[1]) + ((v[2]*Q[2,1]) * v[1])) + ((v[1]*Q[1,2]) * v[2])) + ((v[2]*Q[2,2]) * v[2])</code></pre></div></div><p>We can also set vectorized constraints using the <code>.==</code>, <code>.&lt;=</code>, and <code>.&gt;=</code> operators:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, W[1:2, 1:2]);

julia&gt; @constraint(model, W * Q * v .== 0)
2-element Vector{InfOptConstraintRef}:
 ((+(0.0) + ((W[1,1]*Q[1,1] + W[1,2]*Q[2,1]) * v[1])) + ((W[1,1]*Q[1,2] + W[1,2]*Q[2,2]) * v[2])) - 0.0 = 0
 ((+(0.0) + ((W[2,1]*Q[1,1] + W[2,2]*Q[2,1]) * v[1])) + ((W[2,1]*Q[1,2] + W[2,2]*Q[2,2]) * v[2])) - 0.0 = 0</code></pre><h3 id="Adding-Nonlinear-Operators"><a class="docs-heading-anchor" href="#Adding-Nonlinear-Operators">Adding Nonlinear Operators</a><a id="Adding-Nonlinear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Nonlinear-Operators" title="Permalink"></a></h3><p>In a similar spirit to <code>JuMP</code> and <code>Symbolics</code>, we can add nonlinear operators such that they can be directly incorporated into nonlinear expressions as atoms (they will not be traced). This is done via the <a href="https://jump.dev/JuMP.jl/v1/api/JuMP/#@operator"><code>@operator</code></a> macro. We can register any operator that takes scalar arguments (which can accept inputs of type <code>Real</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; h(a, b) = a * b^2; # an overly simple example operator

julia&gt; @operator(model, op_h, 2, h);

julia&gt; op_h(y, 42)
op_h(y(t), 42)</code></pre><div class="admonition is-success" id="Tip-6735eacf06035b50"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-6735eacf06035b50" title="Permalink"></a></header><div class="admonition-body"><p>Where possible it is preferred to use function tracing instead. This improves performance and can prevent unintentional errors. See <a href="#Function-Tracing">Function Tracing</a> for more details.</p></div></div><p>To highlight the difference between function tracing and operator definition consider the following example:</p><pre><code class="language-julia-repl hljs">julia&gt; f(a) = a^3;

julia&gt; f(y) # user-function gets traced
y(t) ^ 3

julia&gt; @operator(model, op_f, 1, f) # create nonlinear operator
NonlinearOperator(f, :op_f)

julia&gt; op_f(y) # function is no longer traced
op_f(y(t))</code></pre><p>Thus, nonlinear operators are incorporated directly. This means that their gradients and hessians will need to determined as well (typically occurs behind the scenes via auto-differentiation with the selected optimizer model backend). However, again please note that in this case tracing is preferred since <code>f</code> can be traced.</p><p>Let&#39;s consider a more realistic example where the function is not amenable to tracing:</p><pre><code class="language-julia-repl hljs">julia&gt; function g(a)
          v = 0
          for i in 1:4
              v *= v^a
              if v &gt;= 1
                 return v
              end
          end
          return a
       end;

julia&gt; @operator(model, op_g, 1, g);

julia&gt; op_g(y)
op_g(y(t))</code></pre><p>Notice this example is a little contrived still, highlighting that in most cases we can avoid adding operators. However, one exception to this trend, are functions from other packages that we might want to use. For example, perhaps we would like to use the <code>eta</code> function from <code>SpecialFunctions.jl</code> which is not natively supported:</p><pre><code class="language-julia-repl hljs">julia&gt; using SpecialFunctions

julia&gt; @operator(model, op_eta, 1, eta)
NonlinearOperator(eta, :op_eta)

julia&gt; op_eta(y)
op_eta(y(t))</code></pre><p>Now in some cases we might wish to specify the gradient and hessian of a univariate operator to avoid the need for auto-differentiation. We can do this, simply by adding them as additional arguments in <code>@operator</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; my_squared(a) = a^2; gradient(a) = 2 * a; hessian(a) = 2;

julia&gt; @operator(model, op_square, 1, my_squared, gradient, hessian);

julia&gt; op_square(y)
op_square(y(t))</code></pre><p>Note the specification of the hessian is optional (it can separately be computed via auto-differentiation if need be).</p><p>For multivariate functions, we can specify the gradient following the same gradient function structure that <code>JuMP</code> uses:</p><pre><code class="language-julia-repl hljs">julia&gt; w(a, b) = a * b^2;

julia&gt; function wg(v, a, b)
          v[1] = b^2
          v[2] = 2 * a * b
          return
       end;

julia&gt; @operator(model, op_w, 2, w, wg)
NonlinearOperator(w, :op_w)

julia&gt; op_w(42, y)
op_w(42, y(t))</code></pre><p>Note that the first argument of the gradient needs to accept an <code>AbstractVector{Real}</code> that is then filled in place.</p><div class="admonition is-info" id="Note-13dc3b015b302ada"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-13dc3b015b302ada" title="Permalink"></a></header><div class="admonition-body"><p>We do not currently support vector inputs or vector valued functions directly, since typically <code>JuMP</code> optimizer model backends don&#39;t support them.</p></div></div><h3 id="More-Details"><a class="docs-heading-anchor" href="#More-Details">More Details</a><a id="More-Details-1"></a><a class="docs-heading-anchor-permalink" href="#More-Details" title="Permalink"></a></h3><p>For more details, please consult <a href="https://jump.dev/JuMP.jl/v1/manual/nonlinear/">JuMP&#39;s Documentation</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../derivative/">« Derivatives</a><a class="docs-footer-nextpage" href="../measure/">Measures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 7 November 2025 01:58">Friday 7 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
