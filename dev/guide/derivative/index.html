<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Derivatives · InfiniteOpt.jl</title><meta name="title" content="Derivatives · InfiniteOpt.jl"/><meta property="og:title" content="Derivatives · InfiniteOpt.jl"/><meta property="twitter:title" content="Derivatives · InfiniteOpt.jl"/><meta name="description" content="Documentation for InfiniteOpt.jl."/><meta property="og:description" content="Documentation for InfiniteOpt.jl."/><meta property="twitter:description" content="Documentation for InfiniteOpt.jl."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/Fishing/">Fishing Optimal Control</a></li><li><a class="tocitem" href="../../examples/Optimal Control/Hanging Chain/">Hanging Chain Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/Jennings/">Minimizing Final Time (Jennings Problem)</a></li><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li class="is-active"><a class="tocitem" href>Derivatives</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Advanced-Definition"><span>Advanced Definition</span></a></li><li><a class="tocitem" href="#Derivative-Evaluation"><span>Derivative Evaluation</span></a></li><li><a class="tocitem" href="#Query-Methods"><span>Query Methods</span></a></li><li><a class="tocitem" href="#Modification-Methods"><span>Modification Methods</span></a></li></ul></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/backend/">Backends</a></li><li><a class="tocitem" href="../../manual/transcribe/">TranscriptionOpt</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li><li><a class="tocitem" href="../../manual/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Derivatives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Derivatives</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/infiniteopt/InfiniteOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/docs/src/guide/derivative.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="deriv_docs"><a class="docs-heading-anchor" href="#deriv_docs">Derivative Operators</a><a id="deriv_docs-1"></a><a class="docs-heading-anchor-permalink" href="#deriv_docs" title="Permalink"></a></h1><p>A guide for derivatives in <code>InfiniteOpt</code>. See the respective  <a href="../../manual/derivative/#deriv_manual">technical manual</a> for more details.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Derivative operators commonly arise in many infinite-dimensional problems,  particularly in dynamic and PDE-constrained optimization. <code>InfiniteOpt.jl</code> provides  a simple yet powerful interface to model these objects for derivatives of any order,  including partial derivatives. Derivatives can be used in defining measures and  constraints. </p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Derivative operators can be defined a few different ways in <code>InfiniteOpt</code>. To motivate  these, let&#39;s first define an <code>InfiniteModel</code> along with some parameters and variables:</p><pre><code class="language-julia-repl hljs">julia&gt; using InfiniteOpt, Distributions;

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10], 
                           derivative_method = OrthogonalCollocation(3));

julia&gt; @infinite_parameter(model, ξ ~ Uniform(-1, 1));

julia&gt; @infinite_parameter(model, x in [-1, 1]);

julia&gt; @variable(model, y, Infinite(t, x, ξ));

julia&gt; @variable(model, q, Infinite(t));</code></pre><p>Notice that we used the <code>derivative_method</code> keyword argument to specify which  numerical method will be used to evaluate any derivatives that depend on that  infinite parameter <code>t</code>. In this case we, specified to use orthogonal collocation  over finite elements using 3 nodes. We&#39;ll come back to this just a little further  below to more fully describe the various methods we can use. </p><p>First, let&#39;s discuss how to define derivatives in <code>InfiniteOpt.jl</code>. Principally,  this is accomplished via <a href="../../manual/derivative/#InfiniteOpt.deriv"><code>deriv</code></a> which will operate on a particular  <code>InfiniteOpt</code> expression (containing parameters, variables, and/or measures) with  respect to infinite parameters specified with their associated orders. Behind the  scenes all the appropriate calculus will be applied, creating derivative variables  as needed. For example, we can define the following:</p><pre><code class="language-julia-repl hljs">julia&gt; d1 = deriv(y, t)
∂/∂t[y(t, x, ξ)]

julia&gt; d2 = ∂(y, t, x)
∂/∂x[∂/∂t[y(t, x, ξ)]]

julia&gt; d3 = @∂(q, t^2) # the macro version allows the `t^2` syntax
d²/dt²[q(t)]

julia&gt; d_expr = deriv(y * q - 2t, t)
∂/∂t[y(t, x, ξ)]*q(t) + d/dt[q(t)]*y(t, x, ξ) - 2</code></pre><p>Thus, we can define derivatives in a variety of forms according to the problem at  hand. The last example even shows how the product rule is correctly applied.</p><div class="admonition is-info" id="Note-3f14a70487b24876"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3f14a70487b24876" title="Permalink"></a></header><div class="admonition-body"><p>For convenience in making more compact code we provide <a href="../../manual/derivative/#InfiniteOpt.∂"><code>∂</code></a>  as an alias for <a href="../../manual/derivative/#InfiniteOpt.deriv"><code>deriv</code></a>.</p></div></div><div class="admonition is-info" id="Note-2925ec29d46650e9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2925ec29d46650e9" title="Permalink"></a></header><div class="admonition-body"><p>Derivatives taken with respect to dependent infinite parameters are not supported.</p></div></div><p>Also, notice that the appropriate symbolic calculus is applied to infinite  parameters. For example, we could also compute:</p><pre><code class="language-julia-repl hljs">julia&gt; deriv(3t^2 - 2t, t)
6 t - 2</code></pre><p>Conveniently, <code>@deriv</code> can be called within any measure and constraint. However,  in certain cases we may need to define an initial guess (initial guess trajectory).  This can be accomplished in 2 ways:</p><ul><li>Call <a href="../../manual/derivative/#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef, Union{Function, Real}}"><code>set_start_value_function</code></a>  using the individual derivative (e.g., <code>d1</code> above)</li><li>Define the derivative using <code>@variable</code> with the <a href="../../manual/derivative/#InfiniteOpt.Deriv"><code>Deriv</code></a> variable type  object and use the <code>start</code> keyword argument.</li></ul><p>In either case, a single value can be given or a start value function that will generate a value in accordance with the support values (i.e., following the same  syntax as infinite variables). For example, we can specify the starting value of  <code>d1</code> to <code>0</code> via the following:</p><pre><code class="language-julia-repl hljs">julia&gt; set_start_value_function(d1, 0)</code></pre><p>Now let&#39;s return to our discussion on derivative evaluation methods. These are the  methods that can/will be invoked to transcript (i.e., discretize) the derivatives  when solving the model. The methods native to <code>InfiniteOpt</code> are described in the  table below:</p><table><tr><th style="text-align: center">Method</th><th style="text-align: center">Type</th><th style="text-align: center">Needed Boundary Conditions</th><th style="text-align: center">Creates Supports</th><th style="text-align: center">Derivative Orders</th></tr><tr><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.Forward"><code>Forward</code></a></td><td style="text-align: center">Final &amp; optional Initial</td><td style="text-align: center">No</td><td style="text-align: center">Any</td></tr><tr><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.Central"><code>Central</code></a></td><td style="text-align: center">Initial &amp; Final</td><td style="text-align: center">No</td><td style="text-align: center">1, 2, 4, 6, ...</td></tr><tr><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.Backward"><code>Backward</code></a></td><td style="text-align: center">Initial &amp; optional Final</td><td style="text-align: center">No</td><td style="text-align: center">Any</td></tr><tr><td style="text-align: center"><a href="../../manual/derivative/#InfiniteOpt.OrthogonalCollocation"><code>OrthogonalCollocation</code></a></td><td style="text-align: center"><a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.GaussLobatto"><code>GaussLobatto</code></a></td><td style="text-align: center">Initial</td><td style="text-align: center">Yes</td><td style="text-align: center">1</td></tr></table><p>Here, the default method is backward finite difference. These are enforced on an  infinite parameter basis (i.e., the parameter the differential operator is taken  with respect to). Unlike, <code>FiniteDifference</code> which directly handles derivatives of  any order, <code>OrthogonalCollocation</code> is limited to 1st order derivatives and higher  order derivatives are automatically reformulated into a system of 1st order derivatives. In the above examples, any derivatives taken with respect to <code>t</code> will use orthogonal collocation on  finite elements since that is what we specified as our derivative method. More  information is provided in the <a href="#Derivative-Methods">Derivative Methods</a> Section below. However, we  note here that <a href="../../manual/derivative/#InfiniteOpt.set_derivative_method"><code>set_derivative_method</code></a> can be invoked anytime after parameter  definition to specify/modify the derivative method used. More conveniently, we can call  <a href="../../manual/derivative/#InfiniteOpt.set_all_derivative_methods"><code>set_all_derivative_methods</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; set_all_derivative_methods(model, FiniteDifference(Forward()))
</code></pre><div class="admonition is-info" id="Note-513c9a2c3cbb89a3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-513c9a2c3cbb89a3" title="Permalink"></a></header><div class="admonition-body"><p>When <a href="../../manual/derivative/#InfiniteOpt.OrthogonalCollocation"><code>OrthogonalCollocation</code></a> is used, additional degrees of freedom can be  artificially introduced to infinite variables that share the same infinite parameter.  For instance, this occurs with control variables in optimal control problems. To address  this, <a href="../../manual/variable/#InfiniteOpt.constant_over_collocation-Tuple{InfiniteVariableRef, GeneralVariableRef}"><code>constant_over_collocation</code></a>  should be called on the appropriate variables. For example:</p><pre><code class="language-julia hljs">@infinite_parameter(model, t in [0, 1], derivative_method = OrthogonalCollocation(3))
@variable(model, y_state, Infinite(t))
@variable(model, y_control, Infinite(t))
@constraint(model, ∂(y_state, t) == y_state^2)
@constraint(model, y_state(0) == 0)
constant_over_collocation(y_control, t)

# output
</code></pre><p>where we use <code>constant_over_collocation</code> to hold <code>y_control</code> constant over each finite  element (i.e., constant for each internal collocation point). </p></div></div><div class="admonition is-warning" id="Warning-e8e09fd3a5c2d20d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-e8e09fd3a5c2d20d" title="Permalink"></a></header><div class="admonition-body"><p><code>InfiniteOpt</code> does not ensure proper boundary conditions are provided by the  user. Thus, it is imperative that the user ensure these are provided appropriately  with the derivative evaluation method that is used. We recommend specifying  such conditions via a constraint that uses <a href="../variable/#Restricted-Variables">Restricted Variables</a>. For  example:</p><pre><code class="language-julia hljs">@constraint(model, initial_condition, y(0) == 42)</code></pre></div></div><h2 id="Advanced-Definition"><a class="docs-heading-anchor" href="#Advanced-Definition">Advanced Definition</a><a id="Advanced-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Definition" title="Permalink"></a></h2><p>This section will detail the inner-workings and more advanced details behind  defining derivatives in <code>InfiniteOpt</code>.</p><h3 id="Manual-Definition"><a class="docs-heading-anchor" href="#Manual-Definition">Manual Definition</a><a id="Manual-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Definition" title="Permalink"></a></h3><p>The workflow for derivative definition mirrors that of variable definition as  summarized in the following steps:</p><ol><li>Define the variable information via a <code>JuMP.VariableInfo</code>.</li><li>Build the derivative using <a href="../../manual/derivative/#InfiniteOpt.build_derivative"><code>build_derivative</code></a>.</li><li>Add the derivative to the model via <a href="../../manual/derivative/#InfiniteOpt.add_derivative"><code>add_derivative</code></a>.</li></ol><p>To exemplify this process, let&#39;s first define appropriate variable information:</p><pre><code class="language-julia-repl hljs">julia&gt; info = VariableInfo(true, 0., true, 42., false, 0., false, 0., false, false);</code></pre><p>More detailed information on <code>JuMP.VariableInfo</code> is provided in the  <a href="../variable/#Variable-Definition-Methodology">Variable Definition Methodology</a> section. </p><div class="admonition is-warning" id="Warning-8cb787087fa731c5"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-8cb787087fa731c5" title="Permalink"></a></header><div class="admonition-body"><p>Instances of <code>JuMP.VariableInfo</code> used to define derivatives should have  <code>info.binary = false</code> and <code>info.integer = false</code>, since most derivative  evaluation methods require that derivatives be continuous.</p></div></div><p>Now that we have our variable information we can make a derivative using  <a href="../../manual/derivative/#InfiniteOpt.build_derivative"><code>build_derivative</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; d = build_derivative(error, info, y, x, 1);

julia&gt; d isa Derivative
true</code></pre><p>Here the argument variable can be an infinite variable, semi-infinite variable,  derivative, or measure that depends on the infinite parameter provided. This will  error to the contrary.</p><p>Now we can add the derivative to the model via <a href="../../manual/derivative/#InfiniteOpt.add_derivative"><code>add_derivative</code></a> which  will add the <a href="../../manual/derivative/#InfiniteOpt.Derivative"><code>Derivative</code></a> object and return <code>GeneralVariableRef</code> pointing  to it that we can use in <code>InfiniteOpt</code> expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; dref = add_derivative(model, d)
∂/∂x[y(t, x, ξ)]</code></pre><p>This will also create any appropriate information based constraints (e.g., lower  bounds).</p><p>Finally, we note that higher order derivatives by changing the order argument:</p><pre><code class="language-julia-repl hljs">julia&gt; d = build_derivative(error, info, y, x, 3); # 3rd order derivative</code></pre><h3 id="Macro-Definition"><a class="docs-heading-anchor" href="#Macro-Definition">Macro Definition</a><a id="Macro-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-Definition" title="Permalink"></a></h3><p>There are two macros we provide for defining derivatives:  <a href="https://jump.dev/JuMP.jl/v1/api/JuMP/#JuMP.@variable"><code>@variable</code></a>  that uses the <a href="../../manual/derivative/#InfiniteOpt.Deriv"><code>Deriv</code></a> variable type and <a href="../../manual/derivative/#InfiniteOpt.@deriv"><code>@deriv</code></a>. </p><p>First, <code>@variable</code> simply automates the process described above in a manner  inspired the by the syntax of the variable macros. As such it will support all  the same keywords and constraint syntax used with the variable macros. For  example, we can define the derivative  <span>$\frac{\partial^2 y(t, \xi)}{\partial t^2}$</span> while enforcing a lower bound  of 1 with an initial guess of 0 and assign it to an alias  <code>GeneralVariableRef</code> called <code>dydt2</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, dydt2 &gt;= 1, Deriv(y, t, 2), start = 0)
dydt2(t, x, ξ)</code></pre><p>This will also support anonymous definition and multi-dimensional definition.  Please see <a href="../variable/#Macro-Variable-Definition">Macro Variable Definition</a> for more information.</p><div class="admonition is-warning" id="Warning-f2dc399a7bbfee4"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-f2dc399a7bbfee4" title="Permalink"></a></header><div class="admonition-body"><p>The same derivative should not be redefined with multiple <code>@variable</code> calls  and using <code>@variable</code> to define derivatives should be avoided on derivatives  that were already defined. This is because the latest <code>@variable</code> call will  overwrite any existing properties a derivative might already have. </p></div></div><p>Second, for more convenient definition we use <a href="../../manual/derivative/#InfiniteOpt.@deriv"><code>@deriv</code></a> (or <a href="../../manual/derivative/#InfiniteOpt.@∂"><code>@∂</code></a>)  as shown in the Basic Usage section above. Unlike <code>@variable</code> this can handle any  <code>InfiniteOpt</code> expression as the argument input (except for general nonlinear  expressions). It also can build derivatives that depend on multiple infinite  parameters and/or are taken to higher orders. This is accomplished via recursive  derivative definition, handling the nesting as appropriate. For example, we can  &quot;define&quot; <span>$\frac{\partial^2 y(t, \xi)}{\partial t^2}$</span> again:</p><pre><code class="language-julia-repl hljs">julia&gt; @deriv(d1, t) # recall `d1 = deriv(y, t)`
dydt2(t, x, ξ)

julia&gt; @deriv(y, t^2)
dydt2(t, x, ξ)</code></pre><p>Notice that the derivative references all point to the same derivative object we  defined up above with its alias name <code>dydt2</code>. This macro can also tackle complex  expressions using the appropriate calculus such as:</p><pre><code class="language-julia-repl hljs">julia&gt; @deriv(∫(y, ξ) * q, t)
d/dt[∫{ξ ∈ [-1, 1]}[y(t, x, ξ)]]*q(t) + d/dt[q(t)]*∫{ξ ∈ [-1, 1]}[y(t, x, ξ)]</code></pre><p>Thus, demonstrating the convenience of using <code>@deriv</code>.</p><p>With all this in mind, we recommend using <code>@deriv</code> as the defacto method, but  then using <code>@variable</code> as a convenient way to specify bounds and an initial guess  value/trajectory. </p><h2 id="Derivative-Evaluation"><a class="docs-heading-anchor" href="#Derivative-Evaluation">Derivative Evaluation</a><a id="Derivative-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Evaluation" title="Permalink"></a></h2><p>In this section, we detail how derivatives are evaluated in <code>InfiniteOpt</code> to then  be used in reformulating the model for solution. </p><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>To motivate the principles behind numerical derivative evaluation/transcription,  let&#39;s first consider the initial value problem:</p><p class="math-container">\[\frac{d y(t)}{dt} = f(t, y(t)), \ \ \ y(t_0) = y_0\]</p><p>With a finite support set <span>$\{t_0, t_1, \dots, t_k\}$</span> we can numerically  approximate the value of <span>$\frac{d y(t_n)}{dt}$</span> at each time point <span>$t_n$</span> via  the Euler method (i.e., forward finite difference). We thus obtain a system of  equations:</p><p class="math-container">\[\begin{aligned}
&amp;&amp;&amp; y(t_{n+1}) = y(t_n) + (t_{n+1} - t_n) \frac{d y(t_n)}{dt}, &amp;&amp; \forall n = 0, \dots, k-1\\
&amp;&amp;&amp; \frac{d y(t_n)}{dt} = f(t_n, y(t_n)), &amp;&amp; \forall n = 0, \dots, k \\ 
&amp;&amp;&amp; y(t_0) = y_0
\end{aligned}\]</p><p>Thus, we obtain 3 sets of equations: </p><ol><li>constraint transcriptions</li><li>auxiliary derivative equations </li><li>boundary conditions. </li></ol><p>In the case above, we could reduce the number of equations by substituting out the  point derivatives in the constraint transcriptions since we have explicit  relationships in the auxiliary equations. However, this is not possible in general,  such as when we encounter more complex partial differential equations. </p><p>Thus, in <code>InfiniteOpt</code> derivatives are treated as variables which can be contained  implicitly in constraints and/or measures. This allows us to support implicit  dependencies and higher order derivatives. This means that when the model is  reformulated, its constraints and measures can be reformulated as normal  (treating any derivative dependencies as variables). We then can apply the  appropriate derivative evaluation technique to derive the necessary set of  auxiliary derivative equations to properly characterize the derivative variables.  This can be formalized as:</p><p class="math-container">\[\begin{aligned}
&amp;&amp;&amp; f_j(y(\lambda), Dy(\lambda)) \leq 0, &amp;&amp; \forall j \in J, \lambda \in \Lambda \\
&amp;&amp;&amp; h_i(y(\lambda), Dy(\lambda)) = 0, &amp;&amp; \forall i \in I, \lambda \in \Lambda \\
&amp;&amp;&amp; g_k(y(\hat{\lambda}), Dy(\hat{\lambda})) = 0, &amp;&amp; \forall k \in K, \hat{\lambda} \in \hat{\Lambda}
\end{aligned}\]</p><p>where <span>$y(\lambda)$</span> and <span>$Dy(\lambda)$</span> denote all the variables and derivatives  in the problem and <span>$\lambda$</span> denote all the problem&#39;s infinite parameters.  With this let the constraints <span>$f_j$</span> denote the problem constraints which can  contain any variables, parameters, derivatives, and/or measures associated with  the problem. The constraints <span>$h_i$</span> denote the auxiliary derivative equations  formed by the appropriate numerical method to implicitly define the behavior of  the derivative variables present in <span>$f_j$</span>. Finally, the necessary boundary  conditions are provided in the constraints <span>$g_k$</span>.</p><p>Note that this general paradigm captures a wide breadth of problems and  derivative evaluation techniques. Higher order derivatives are dealt with in one of  two ways:</p><ol><li>Auxiliary equations are derived directly if the selected derivative method  supports higher orders.</li><li>They are reformulated into a system of 1st order derivatives and then auxiliary  equations are derived for each 1st order derivative. </li></ol><p>For example, consider the second-order partial derivative:</p><p class="math-container">\[\frac{\partial^2 y(t, x)}{\partial x^2}\]</p><p>We can directly derive auxiliary equations using 2nd order central finite difference:</p><p class="math-container">\[\frac{\partial^2 y(t, x_n)}{\partial x^2} = \frac{y(t, x_{n+1}) - 2y(t, x_n) + y(t, x_{n-1})}{(x_{n+1} - x_{n})(x_n - x_{n-1})}, \ \forall t \in \mathcal{D}_t, n = 1, \dots, k-1\]</p><p>Where possible, InfiniteOpt favors this approach. For derivative methods that do not support higher orders, we can reformulate the derivative into nested 1st derivatives:</p><p class="math-container">\[\frac{\partial^2 y(t, x)}{\partial x^2} = \frac{\partial }{\partial x}\left(\frac{\partial y(t, x)}{\partial x}\right)\]</p><p>Then we can obtain auxiliary equations for each derivative, let&#39;s use forward finite difference for the sake of variety:</p><p class="math-container">\[\begin{aligned}
&amp;&amp;&amp; y(t, x_{n+1}) = y(t, x_n) + (x_{n+1} - x_n) \frac{\partial y(t, x_n)}{\partial x}, &amp;&amp; \forall x \in \mathcal{D}_x, n = 0, \dots, k-1\\
&amp;&amp;&amp; \frac{\partial y(t, x_{n+1})}{\partial x} = \frac{\partial y(t, x_n)}{\partial x} + (x_{n+1} - x_n) \frac{\partial^2 y(t, x_n)}{\partial x^2}, &amp;&amp; \forall x \in \mathcal{D}_x, n = 0, \dots, k-1\\
\end{aligned}\]</p><p>In the section below we detail the derivative evaluation methods that <code>InfiniteOpt</code>  natively implements.</p><h3 id="Derivative-Methods"><a class="docs-heading-anchor" href="#Derivative-Methods">Derivative Methods</a><a id="Derivative-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Methods" title="Permalink"></a></h3><p>As discussed briefly above in the Basic Usage section, we natively employ 4  derivative methods in <code>InfiniteOpt</code> (see the table in that section for a summary).</p><p>These methods are defined in association with individual infinite parameters and  will be applied to any derivatives that are taken with respect to that parameter.  These methods are specified via the <code>derivative_method</code> keyword argument in the  <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> macro and can also be defined by invoking  <a href="../../manual/derivative/#InfiniteOpt.set_derivative_method"><code>set_derivative_method</code></a> or <a href="../../manual/derivative/#InfiniteOpt.set_all_derivative_methods"><code>set_all_derivative_methods</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; set_derivative_method(t, FiniteDifference(Forward()))
</code></pre><p>In this example, we set <code>t</code>&#39;s derivative evaluation method to use central finite  difference. This will also reset any changes that were made with the old method  (e.g., removing old collocation points). Now let&#39;s describe the ins and outs of  these methods.</p><p>The first class of methods pertain to finite difference techniques. The syntax  for specifying these techniques is described in <a href="../../manual/derivative/#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a> and  exemplified here:</p><pre><code class="language-julia-repl hljs">julia&gt; FiniteDifference(Forward(), true)
FiniteDifference{Forward}(Forward(), true)</code></pre><p>where the first argument indicates the type of finite difference we wish to employ  and the second argument indicates if this method should be enforced on boundary  points. By default, we have <code>FiniteDifference(Backward(), true)</code> which is the default  for all infinite parameters. </p><p>Forward finite difference (i.e., explicit Euler) is exemplified by approximating first  order derivative <span>$\frac{d y(t)}{dt}$</span> via </p><p class="math-container">\[y(t_{n+1}) = y(t_n) + (t_{n+1} - t_{n})\frac{d y(t_n)}{dt}, \ \forall n = 0, 1, \dots, k-1\]</p><p>Note that in this case, the boundary relation corresponds to <span>$n = 0$</span> and would  be included if we set <code>FiniteDifference(Forward(), true)</code> or would be excluded if we  let the second argument be <code>false</code>. We recommend, selecting <code>false</code> when an initial  condition is provided. Also, note that a terminal condition should be provided  when using this method since an auxiliary equation for the derivative at the  terminal point cannot be made. Thus, if a terminal condition is not given terminal  point derivative will be a free variable.</p><p>Central finite difference is exemplified by approximating the first order derivative  <span>$\frac{d y(t)}{dt}$</span> via</p><p class="math-container">\[y(t_{n+1}) = y(t_{n-1}) + (t_{n+1} - t_{n-1})\frac{d y(t_n)}{dt}, \ \forall n = 1, 2, \dots, k-1\]</p><p>Note that this form cannot be invoked at <span>$n = 0$</span> or <span>$n = k$</span> and cannot have an equation at either boundary. With this in mind the syntax is <code>FiniteDifference(Central())</code>  where the second argument is omitted since it doesn&#39;t apply to this scheme. As a  result both initial and terminal conditions should be specified otherwise the  derivatives at those points will be free variables.</p><p>Backward finite difference (i.e., implicit Euler) is our last (and default)  finite difference method and is exemplified by approximating the first order  derivative <span>$\frac{d y(t)}{dt}$</span> via</p><p class="math-container">\[y(t_{n}) = y(t_{n-1}) + (t_{n} - t_{n-1})\frac{d y(t_{n})}{dt}, \ \forall n = 1, 2, \dots, k\]</p><p>Here the boundary case corresponds to <span>$n = k$</span> and would be included if we set  <code>FiniteDifference(Backward(), true)</code> (the default) or excluded if we set the second  argument to <code>false</code>. We recommend, selecting <code>false</code> when a terminal condition is  provided. Also, note that an initial condition should always be given otherwise  the derivative at the first point will be free.</p><p>All the above explanations highlight using finite difference on 1st order  derivatives, but  <a href="https://en.wikipedia.org/wiki/Finite_difference#Higher-order_differences">higher orders are also supported</a>.  <a href="../../manual/derivative/#InfiniteOpt.Forward"><code>Forward</code></a> and <a href="../../manual/derivative/#InfiniteOpt.Backward"><code>Backward</code></a> approaches can directly handle derivatives  of arbitrary order. Whereas, <a href="../../manual/derivative/#InfiniteOpt.Central"><code>Central</code></a> 1st order derivatives and higher  <strong>even</strong> orders (i.e., odd orders greater than 1 are not supported). When using  higher order derivatives, it is important to include the necessary boundary  conditions which often involve lower order derivatives.</p><p>Finally, we employ orthogonal collocation on finite elements via the  <a href="../../manual/derivative/#InfiniteOpt.OrthogonalCollocation"><code>OrthogonalCollocation</code></a> object (please refer to it in the manual for  complete syntax details). In general terms, this technique fits an <span>$m$</span> degree  polynomial to each finite element (i.e., sequential support pair) and this fit is  done via <span>$m+1$</span> collocation nodes (supports) which include the finite element  supports along with <span>$m-1$</span> additional internal collocation nodes chosen at  orthogonal points to the polynomial. The typical syntax for specifying this method  is <code>OrthogonalCollocation(num_nodes)</code> where <code>num_nodes</code> indicates the number  collocation nodes to be used for each finite element. For example, we can specify  to use 3 collocation nodes (i.e., 1 internal node per finite element) corresponding  to a 2nd degree polynomial via</p><pre><code class="language-julia-repl hljs">julia&gt; OrthogonalCollocation(3)
OrthogonalCollocation{GaussLobatto}(3, GaussLobatto())</code></pre><p>Notice that the 2nd attribute is <code>GaussLobatto</code> which indicates that we are using  collocation nodes selected via Lobatto quadrature. This is currently the only  supported technique employed by <code>OrthogonalCollocation</code> although more may be added  in future versions. Please note that an initial condition must be provided otherwise  the corresponding derivative will be free variable. For more information on  orthogonal collocation over finite elements, this  <a href="http://apmonitor.com/do/index.php/Main/OrthogonalCollocation">page</a> provides a  good reference.</p><div class="admonition is-info" id="Note-838b19c1985565c9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-838b19c1985565c9" title="Permalink"></a></header><div class="admonition-body"><p><code>OrthogonalCollocation</code> only provides direct support for 1st order  derivatives. Higher order derivatives are reformulated by nesting 1st order  derivatives that are each reformulated using orthogonal collocation.</p></div></div><p>The addition of internal collocation supports by <code>OrthogonalCollocation</code> will increase  the degrees of freedom for infinite variables that are not used by derivatives (e.g.,  control variables). To prevent this, we use <a href="../../manual/expression/#InfiniteOpt.constant_over_collocation-Tuple{GeneralVariableRef, GeneralVariableRef}"><code>constant_over_collocation</code></a> on any  such infinite variables to hold them constant over internal collocation nodes. </p><p>Other methods can be employed via user-defined extensions. Please visit our  Extensions page for more information.</p><h3 id="User-Invoked-Evaluation"><a class="docs-heading-anchor" href="#User-Invoked-Evaluation">User-Invoked Evaluation</a><a id="User-Invoked-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#User-Invoked-Evaluation" title="Permalink"></a></h3><p>Typically, derivative evaluation is handled when the model is reformulated in such  a way that the <code>InfiniteModel</code> is unmodified such that modifications and repeated  solutions can be done efficiently and seamlessly. This is also the recommended  workflow. However, we do provide user accessible derivative evaluation methods  that generate the auxiliary derivative equations and add them to the <code>InfiniteModel</code>. This can be useful for visualizing how these techniques work and can be helpful for  user-defined reformulation extensions (i.e., transformation backend extensions).</p><p>We can build these relations for a particular derivative via <a href="../../manual/derivative/#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>evaluate</code></a>.  For example, let&#39;s build evaluation equations for <code>d1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; d1 
∂/∂t[y(t, x, ξ)]

julia&gt; fill_in_supports!(t, num_supports = 5) # add supports first

julia&gt; evaluate(d1)

julia&gt; derivative_constraints(d1)
4-element Vector{InfOptConstraintRef}:
 2.5 ∂/∂t[y(t, x, ξ)](0, x, ξ) + y(0, x, ξ) - y(2.5, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]
 2.5 ∂/∂t[y(t, x, ξ)](2.5, x, ξ) + y(2.5, x, ξ) - y(5, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]
 2.5 ∂/∂t[y(t, x, ξ)](5, x, ξ) + y(5, x, ξ) - y(7.5, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]
 2.5 ∂/∂t[y(t, x, ξ)](7.5, x, ξ) + y(7.5, x, ξ) - y(10, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]</code></pre><p>Note that we made sure <code>t</code> had supports first over which we could carry out the  evaluation, otherwise an error would have been thrown. Moreover, once the  evaluation was completed we were able to access the auxiliary equations via  <a href="../../manual/derivative/#InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}"><code>derivative_constraints</code></a>. </p><p>We can also, add the necessary auxiliary equations for all the derivatives in the  model if we call <a href="../../manual/derivative/#InfiniteOpt.evaluate_all_derivatives!"><code>evaluate_all_derivatives!</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; fill_in_supports!(x, num_supports = 4) # add supports first

julia&gt; evaluate_all_derivatives!(model)

julia&gt; derivative_constraints(dydt2)
3-element Vector{InfOptConstraintRef}:
 6.25 dydt2(0, x, ξ) - y(0, x, ξ) + 2 y(2.5, x, ξ) - y(5, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]
 6.25 dydt2(2.5, x, ξ) - y(2.5, x, ξ) + 2 y(5, x, ξ) - y(7.5, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]
 6.25 dydt2(5, x, ξ) - y(5, x, ξ) + 2 y(7.5, x, ξ) - y(10, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]</code></pre><p>Finally, we note that once derivative constraints have been added to the  <code>InfiniteModel</code> any changes to the respective infinite parameter sets, supports,  or derivative method will necessitate the deletion of these auxiliary constraints  and a warning will be thrown to indicate such:</p><pre><code class="language-julia-repl hljs">julia&gt; derivative_constraints(d1)
4-element Vector{InfOptConstraintRef}:
 2.5 ∂/∂t[y(t, x, ξ)](0, x, ξ) + y(0, x, ξ) - y(2.5, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]
 2.5 ∂/∂t[y(t, x, ξ)](2.5, x, ξ) + y(2.5, x, ξ) - y(5, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]
 2.5 ∂/∂t[y(t, x, ξ)](5, x, ξ) + y(5, x, ξ) - y(7.5, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]
 2.5 ∂/∂t[y(t, x, ξ)](7.5, x, ξ) + y(7.5, x, ξ) - y(10, x, ξ) = 0, ∀ ξ ~ Uniform, x ∈ [-1, 1]

julia&gt; add_supports(t, 0.2)
┌ Warning: Support/method changes will invalidate existing derivative evaluation constraints that have been added to the InfiniteModel. Thus, these are being deleted.
└ @ InfiniteOpt ~/work/infiniteopt/InfiniteOpt.jl/src/scalar_parameters.jl:813

julia&gt; has_derivative_constraints(d1)
false</code></pre><h2 id="Query-Methods"><a class="docs-heading-anchor" href="#Query-Methods">Query Methods</a><a id="Query-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Methods" title="Permalink"></a></h2><p>Here we describe the various query techniques that we can employ on derivatives  in <code>InfiniteOpt</code>.</p><h3 id="Basic-Queries"><a class="docs-heading-anchor" href="#Basic-Queries">Basic Queries</a><a id="Basic-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Queries" title="Permalink"></a></h3><p>First, let&#39;s overview the basic object inquiries: <a href="../../manual/derivative/#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}"><code>derivative_argument</code></a>,  <a href="../../manual/derivative/#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}"><code>operator_parameter</code></a>, <a href="../../manual/derivative/#InfiniteOpt.derivative_order-Tuple{DerivativeRef}"><code>derivative_order</code></a>,  <a href="../../manual/derivative/#InfiniteOpt.derivative_method-Tuple{DerivativeRef}"><code>derivative_method</code></a>, and <a href="../../manual/variable/#JuMP.name-Tuple{DecisionVariableRef}"><code>name</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; derivative_argument(dydt2) # get the variable the derivative operates on
y(t, x, ξ)

julia&gt; operator_parameter(dydt2) # get the parameter the operator is taken with respect to
t

julia&gt; derivative_order(dydt2) # get the order of the derivative
2

julia&gt; derivative_method(dydt2) # get the numerical derivative evaluation method
FiniteDifference{Forward}(Forward(), true)

julia&gt; name(dydt2) # get the name if there is one
&quot;dydt2&quot;</code></pre><p>These all work as exemplified above. We note that <code>derivative_method</code> simply  queries the derivative method associated with the operator parameter.</p><p>Derivatives also inherit all the usage methods employed by infinite variables.  For example:</p><pre><code class="language-julia-repl hljs">julia&gt; is_used(d1)
true

julia&gt; used_by_measure(dydt2)
false

julia&gt; used_by_semi_infinite_variable(d2)
true</code></pre><p>Also, since derivatives are analogous to infinite variables, they inherit many  of the same queries including <a href="../../manual/constraint/#InfiniteOpt.parameter_refs-Tuple{InfOptConstraintRef}"><code>parameter_refs</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; parameter_refs(d1)
(t, x, ξ)

julia&gt; parameter_refs(derivative_argument(d1))
(t, x, ξ)</code></pre><p>Since derivatives simply inherit their infinite parameter dependencies from the  argument variable, the above lines are equivalent.</p><h3 id="Variable-Information"><a class="docs-heading-anchor" href="#Variable-Information">Variable Information</a><a id="Variable-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Information" title="Permalink"></a></h3><p>Again, since derivatives are essentially a special case of infinite variables, they  inherit all the same methods for querying variable information. For example,  consider the following queries:</p><pre><code class="language-julia-repl hljs">julia&gt; has_lower_bound(dydt2)
true

julia&gt; lower_bound(dydt2)
1.0

julia&gt; LowerBoundRef(dydt2)
dydt2(t, x, ξ) ≥ 1, ∀ t ∈ [0, 10], ξ ~ Uniform, x ∈ [-1, 1]

julia&gt; has_upper_bound(dydt2)
false 

julia&gt; func = start_value_function(dydt2);</code></pre><h3 id="Model-Queries"><a class="docs-heading-anchor" href="#Model-Queries">Model Queries</a><a id="Model-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Queries" title="Permalink"></a></h3><p>We can also determine the number of derivatives a model contains and obtain a list  of them via <a href="../../manual/derivative/#InfiniteOpt.num_derivatives"><code>num_derivatives</code></a> and <a href="../../manual/derivative/#InfiniteOpt.all_derivatives"><code>all_derivatives</code></a>, respectively:</p><pre><code class="language-julia-repl hljs">julia&gt; num_derivatives(model)
7

julia&gt; all_derivatives(model)
7-element Vector{GeneralVariableRef}:
 ∂/∂t[y(t, x, ξ)]
 ∂/∂x[∂/∂t[y(t, x, ξ)]]
 d²/dt²[q(t)]
 d/dt[q(t)]
 ∂/∂x[y(t, x, ξ)]
 dydt2(t, x, ξ)
 ∂/∂t[∫{ξ ∈ [-1, 1]}[y(t, x, ξ)]]</code></pre><h2 id="Modification-Methods"><a class="docs-heading-anchor" href="#Modification-Methods">Modification Methods</a><a id="Modification-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Modification-Methods" title="Permalink"></a></h2><p>In this section, we&#39;ll highlight some of the modification methods that can be  used on derivatives in <code>InfiniteOpt</code>.</p><h3 id="Variable-Information-2"><a class="docs-heading-anchor" href="#Variable-Information-2">Variable Information</a><a class="docs-heading-anchor-permalink" href="#Variable-Information-2" title="Permalink"></a></h3><p>As discussed above, derivatives inherit the same variable methods as infinite  variables. Thus, we can modify/delete bounds and starting values for derivatives  using the same methods. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; set_lower_bound(dydt2, 0)

julia&gt; lower_bound(dydt2)
0.0

julia&gt; set_upper_bound(dydt2, 2)

julia&gt; upper_bound(dydt2)
2.0

julia&gt; fix(dydt2, 42, force = true)

julia&gt; fix_value(dydt2) 
42.0

julia&gt; set_start_value_function(dydt2, (t, x, xi) -&gt; t + x+ xi)

julia&gt; unfix(dydt2)
</code></pre><h3 id="Deletion"><a class="docs-heading-anchor" href="#Deletion">Deletion</a><a id="Deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Deletion" title="Permalink"></a></h3><p>Finally, there are 2 deletion methods we can employ apart from deleting variable  information. First, we can employ <a href="../../manual/derivative/#InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}"><code>delete_derivative_constraints</code></a> to  delete any derivative evaluation constraints associated with a particular  derivative:</p><pre><code class="language-julia-repl hljs">julia&gt; delete_derivative_constraints(d2)

julia&gt; has_derivative_constraints(d2)
false</code></pre><p>Lastly, we can employ <code>delete</code> to delete a particular derivative and all its  dependencies:</p><pre><code class="language-julia-repl hljs">julia&gt; delete(model, d2)

julia&gt; is_valid(model, d2)
false</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variable/">« Variables</a><a class="docs-footer-nextpage" href="../expression/">Expressions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 15 October 2025 03:13">Wednesday 15 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
