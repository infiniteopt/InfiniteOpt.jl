<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extensions · InfiniteOpt.jl</title><meta name="title" content="Extensions · InfiniteOpt.jl"/><meta property="og:title" content="Extensions · InfiniteOpt.jl"/><meta property="twitter:title" content="Extensions · InfiniteOpt.jl"/><meta name="description" content="Documentation for InfiniteOpt.jl."/><meta property="og:description" content="Documentation for InfiniteOpt.jl."/><meta property="twitter:description" content="Documentation for InfiniteOpt.jl."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/Fishing/">Fishing Optimal Control</a></li><li><a class="tocitem" href="../../examples/Optimal Control/Hanging Chain/">Hanging Chain Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/Jennings/">Minimizing Final Time (Jennings Problem)</a></li><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../../guide/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../guide/variable/">Variables</a></li><li><a class="tocitem" href="../../guide/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../../guide/measure/">Measures</a></li><li><a class="tocitem" href="../../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../../guide/result/">Results</a></li><li><a class="tocitem" href="../../guide/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/backend/">Backends</a></li><li><a class="tocitem" href="../../manual/transcribe/">TranscriptionOpt</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li><li><a class="tocitem" href="../../manual/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Extensions</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Infinite-Domains"><span>Infinite Domains</span></a></li><li><a class="tocitem" href="#Derivative-Evaluation-Methods"><span>Derivative Evaluation Methods</span></a></li><li><a class="tocitem" href="#Measure-Evaluation-Techniques"><span>Measure Evaluation Techniques</span></a></li><li><a class="tocitem" href="#meas_data_ext"><span>Measure Data</span></a></li><li><a class="tocitem" href="#Generative-Support-Information"><span>Generative Support Information</span></a></li><li><a class="tocitem" href="#extend_backends"><span>Transformation Backends</span></a></li><li><a class="tocitem" href="#Wrapper-Packages"><span>Wrapper Packages</span></a></li></ul></li><li><a class="tocitem" href="../start_guide/">Getting Started</a></li><li><a class="tocitem" href="../style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Development</a></li><li class="is-active"><a href>Extensions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extensions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/infiniteopt/InfiniteOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/docs/src/develop/extensions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Extensions"><a class="docs-heading-anchor" href="#Extensions">Extensions</a><a id="Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Extensions" title="Permalink"></a></h1><p>Here we provide guidance to various ways <code>InfiniteOpt</code> can be extended.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Extendibility is one of the core ideas of <code>InfiniteOpt</code> so that it can serve as a  convenient tool for those developing and implementing advanced techniques for  infinite dimensional optimization problems. Thus, <code>InfiniteOpt</code> is developed in  a modular manner to readily accommodate user-defined functionality and/or to  serve as useful base in writing a <code>JuMP</code> extension. Admittedly, this modularity  is not perfect and comments/suggestions are welcomed to help us improve this.</p><h2 id="Infinite-Domains"><a class="docs-heading-anchor" href="#Infinite-Domains">Infinite Domains</a><a id="Infinite-Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-Domains" title="Permalink"></a></h2><p>Infinite domains are used to characterize the behavior of infinite parameters and  used to govern the behavior of supports in <code>InfiniteOpt</code>. Here we walk through  how user-defined domains can be added to various degrees of functionality. A  template is provided in  <a href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/test/extensions/infinite_domain.jl"><code>./test/extensions/infinite_domain.jl</code></a>.  The extension steps employed are:</p><ol><li>Define the new <code>struct</code> infinite domain type (only thing required as bare minimum)</li><li>Extend<a href="../../manual/domains/#InfiniteOpt.round_domain"><code>InfiniteOpt.round_domain</code></a> (enables safe use of significant digit rounding)</li><li>Extend <a href="../../manual/domains/#InfiniteOpt.supports_in_domain"><code>InfiniteOpt.supports_in_domain</code></a> (enables error checking of supports)</li><li>Extend <a href="../../manual/domains/#InfiniteOpt.generate_support_values"><code>InfiniteOpt.generate_support_values</code></a> (enables support generation via <code>num_supports</code> keyword arguments)</li><li>If a lower bound and upper bound can be reported, extend <code>JuMP</code> lower bound and upper bound methods (enables automatic bound detection in <code>integral</code>)</li><li>Extend <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_expect_data"><code>InfiniteOpt.MeasureToolbox.generate_expect_data</code></a> (enables the use of <code>expect</code>) </li></ol><p>As an example, let&#39;s create a univariate disjoint interval domain as an infinite  domain type. This corresponds to the domain <span>$[lb_1, ub_1] \cup [lb_2, ub_2]$</span>  where <span>$ub_1 \leq lb_2$</span>. First, we need to create the <code>DataType</code> with  inheritance from <a href="../../manual/domains/#InfiniteOpt.InfiniteScalarDomain"><code>InfiniteScalarDomain</code></a>:</p><pre><code class="language-julia hljs">using InfiniteOpt

struct DisjointDomain &lt;: InfiniteOpt.InfiniteScalarDomain
    lb1::Float64
    ub1::Float64
    lb2::Float64
    ub2::Float64
    # constructor
    function DisjointDomain(lb1::Number, ub1::Number, lb2::Number, ub2::Number)
        if lb1 &gt; ub1 || lb2 &gt; ub2 || ub1 &gt; lb2
            error(&quot;Invalid bounds&quot;)
        end
        return new(convert(Float64, lb1), convert(Float64, ub1),
                   convert(Float64, lb2), convert(Float64, ub2))
    end
end</code></pre><p>Notice that we also define the constructor function to error check and convert as  needed (this is recommended, but not required). For basic functionality this is  all we have to do to add a domain in <code>InfiniteOpt</code>.</p><p>We can now define infinite parameters using this domain via  <a href="../../manual/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> both anonymously and explicitly:</p><pre><code class="language-julia-repl hljs">julia&gt; model = InfiniteModel();

julia&gt; t = @infinite_parameter(model, domain = DisjointDomain(0, 1, 3, 4), base_name = &quot;t&quot;)
t

julia&gt; @infinite_parameter(model, t in DisjointDomain(0, 1, 3, 4))
t</code></pre><p>Once defined (without further extension), these parameters can be used as normal  with the following limitations:</p><ul><li>Supports must be specified manually (<code>num_supports</code> is not enabled)</li><li>Supports will not be checked if they are in the domain of the infinite domain</li><li>Domain bounds cannot be queried.</li><li>The <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> or <a href="../../manual/measure/#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>  must be provided explicitly to evaluate measures</li></ul><p>However, all of these limitations except for the last one can be eliminated by  extending a few functions as outlined above. To address the last one, we need  to extend <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a>. See [<code>Measure Evaluation Techniques</code>]  for details. </p><p>To enable support domain checking which is useful to avoid strange bugs, we will  extend <a href="../../manual/domains/#InfiniteOpt.round_domain"><code>InfiniteOpt.round_domain</code></a> which rounds the domain to use proper  significant digits and <a href="../../manual/domains/#InfiniteOpt.supports_in_domain"><code>InfiniteOpt.supports_in_domain</code></a> which returns a  <code>Bool</code> whether a vector of supports is in the domain:</p><pre><code class="language-julia hljs">function InfiniteOpt.round_domain(
    domain::DisjointDomain,
    sig_digits::Int
    )
    lb1 = round(domain.lb1, sigdigits = sig_digits)
    ub1 = round(domain.ub1, sigdigits = sig_digits)
    lb2 = round(domain.lb2, sigdigits = sig_digits)
    ub2 = round(domain.ub2, sigdigits = sig_digits)
    return DisjointDomain(lb1, ub1, lb2, ub2)
end

function InfiniteOpt.supports_in_domain(
    supports::Union{Number, Vector{&lt;:Number}},
    domain::DisjointDomain
    )
    return all((domain.lb1 .&lt;= supports .&lt;= domain.ub1) .| (domain.lb2 .&lt;= supports .&lt;= domain.ub2))
end</code></pre><p>Now the checks are enabled, so the following would yield an error because the  support is not in the domain:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, domain = DisjointDomain(0, 1, 3, 4), supports = 2)
ERROR: At none:1: `@infinite_parameter(model, domain = DisjointDomain(0, 1, 3, 4), supports = 2)`: Supports violate the domain bounds.</code></pre><p>To enable automatic support generation via the <code>num_supports</code> keyword and with  functions such as <a href="../../manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>fill_in_supports!</code></a>, we will extend  <a href="../../manual/domains/#InfiniteOpt.generate_support_values"><code>InfiniteOpt.generate_support_values</code></a>:</p><pre><code class="language-julia hljs">struct DisjointGrid &lt;: InfiniteOpt.PublicLabel end

function InfiniteOpt.generate_support_values(
    domain::DisjointDomain;
    num_supports::Int = InfiniteOpt.DefaultNumSupports,
    sig_digits::Int = InfiniteOpt.DefaultSigDigits
    )
    length_ratio = (domain.ub1 - domain.lb1) / (domain.ub1 - domain.lb1 + domain.ub2 - domain.lb2)
    num_supports1 = Int64(ceil(length_ratio * num_supports))
    num_supports2 = num_supports - num_supports1
    supports1 = collect(range(domain.lb1, stop = domain.ub1, length = num_supports1))
    supports2 = collect(range(domain.lb2, stop = domain.ub2, length = num_supports2))
    return round.([supports1; supports2], sigdigits = sig_digits), DisjointGrid
end</code></pre><p>Now automatic support generation is enabled, for example:</p><pre><code class="language-julia-repl hljs">julia&gt; par = @infinite_parameter(model, domain = DisjointDomain(0, 2, 3, 4), num_supports = 10)
noname

julia&gt; supports(par)
10-element Vector{Float64}:
 0.0
 0.333333333333
 0.666666666667
 1.0
 1.33333333333
 1.66666666667
 2.0
 3.0
 3.5
 4.0</code></pre><p>We can extend the appropriate <code>JuMP</code> upper and lower bound functions  if desired which are:</p><ul><li><a href="../../manual/domains/#JuMP.has_lower_bound-Tuple{AbstractInfiniteDomain}"><code>JuMP.has_lower_bound</code></a></li><li><a href="../../manual/domains/#JuMP.lower_bound-Tuple{AbstractInfiniteDomain}"><code>JuMP.lower_bound</code></a></li><li><a href="../../manual/domains/#JuMP.set_lower_bound-Tuple{AbstractInfiniteDomain, Real}"><code>JuMP.set_lower_bound</code></a></li><li><a href="../../manual/domains/#JuMP.has_upper_bound-Tuple{AbstractInfiniteDomain}"><code>JuMP.has_upper_bound</code></a></li><li><a href="../../manual/domains/#JuMP.upper_bound-Tuple{AbstractInfiniteDomain}"><code>JuMP.upper_bound</code></a></li><li><a href="../../manual/domains/#JuMP.set_upper_bound-Tuple{AbstractInfiniteDomain, Real}"><code>JuMP.set_upper_bound</code></a></li></ul><p>However, if we want <code>has_lower_bound = false</code> and <code>has_upper_bound = false</code> then  no extension is needed. For our current example we won&#39;t do this since lower  and upper bounds aren&#39;t exactly clear for a disjoint interval. Please refer to  the template in <code>./InfiniteOpt/test/extensions/infinite_domain.jl</code> to see how  this is done.</p><p>Finally, we can optionally enable the use of <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a> taken with respect  to infinite parameters with this new domain type by extending  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_expect_data"><code>InfiniteOpt.MeasureToolbox.generate_expect_data</code></a>:</p><pre><code class="language-julia hljs">function InfiniteOpt.MeasureToolbox.generate_expect_data(domain::DisjointDomain, 
    pref::GeneralVariableRef, 
    num_supports::Int; 
    kwargs...
    )
    for (k, _) in kwargs
        error(&quot;Keyword argument `$k` not supported for expectations over &quot;,
              &quot;disjoint domains.&quot;)
    end
    coeff_func = (supps) -&gt; ones(size(supps)[end]) ./ size(supps)[end] 
    return InfiniteOpt.FunctionalDiscreteMeasureData(pref, coeff_func, 0, All)
end</code></pre><p>The above implementation simply sums over all the supports associated with <code>pref</code>  and divides by the total number. Now we can use <code>expect</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, y, Infinite(t))
y(t)

julia&gt; expect(y, t)
𝔼{t}[y(t)]</code></pre><h2 id="Derivative-Evaluation-Methods"><a class="docs-heading-anchor" href="#Derivative-Evaluation-Methods">Derivative Evaluation Methods</a><a id="Derivative-Evaluation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Evaluation-Methods" title="Permalink"></a></h2><p>Derivative evaluation methods are used to dictate how we form the auxiliary  derivative evaluation equations (derivative constraints) when we evaluate  derivatives in InfiniteOpt. Users may wish to implement their own methods beyond  the finite difference and orthogonal collocation ones we natively provide. Thus,  we provide an API to do just this. A complete template is provided in  <a href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/test/extensions/derivative_method.jl"><code>./test/extensions/derivative_method.jl</code></a>  to help streamline this process. The extension steps are:</p><ol><li>Define the new method <code>struct</code> that inherits from the correct  <a href="../../manual/derivative/#InfiniteOpt.AbstractDerivativeMethod"><code>AbstractDerivativeMethod</code></a> subtype</li><li>Extend <a href="../../manual/derivative/#InfiniteOpt.allows_high_order_derivatives"><code>InfiniteOpt.allows_high_order_derivatives</code></a></li><li>Extend <a href="../../manual/derivative/#InfiniteOpt.generative_support_info-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.generative_support_info</code></a>  if the method is a <a href="../../manual/derivative/#InfiniteOpt.GenerativeDerivativeMethod"><code>GenerativeDerivativeMethod</code></a></li><li>Extend <a href="../../manual/derivative/#InfiniteOpt.derivative_expr_data"><code>InfiniteOpt.derivative_expr_data</code></a></li><li>Extend <a href="../../manual/derivative/#InfiniteOpt.make_indexed_derivative_expr"><code>InfiniteOpt.make_indexed_derivative_expr</code></a>.</li></ol><p>To exemplify this process let&#39;s implement 1st order explicit Euler which is already  implemented via <code>FiniteDifference(Forward())</code>, but let&#39;s make our own anyway for  the sake of example. For a first order derivative <span>$\frac{d y(t)}{dt}$</span> explicit  Euler is expressed:</p><p class="math-container">\[y(t_{n+1}) = y(t_n) + (t_{n+1} - t_{n})\frac{d y(t_n)}{dt}, \ \forall n = 0, 1, \dots, k-1\]</p><p>Let&#39;s get started with step 1 and define our new method struct:</p><pre><code class="language-julia hljs">using InfiniteOpt

struct ExplicitEuler &lt;: NonGenerativeDerivativeMethod end</code></pre><p>Notice that our method <code>ExplicitEuler</code> inherits from  <a href="../../manual/derivative/#InfiniteOpt.NonGenerativeDerivativeMethod"><code>NonGenerativeDerivativeMethod</code></a> since explicit Euler uses the existing  support scheme without adding any additional supports. If our desired method  needed to add additional supports (e.g., orthogonal collocation over finite  elements) then we would need to have used <a href="../../manual/derivative/#InfiniteOpt.GenerativeDerivativeMethod"><code>GenerativeDerivativeMethod</code></a>.</p><p>Now we need to decide if this method will directly support higher order derivatives.  In this case, let&#39;s say it won&#39;t and define:</p><pre><code class="language-julia hljs">InfiniteOpt.allows_high_order_derivatives(::ExplicitEuler) = false</code></pre><p>Conversely, we could set the output to <code>true</code> if we wanted to directly support higher  order derivatives. In which case, we would need to take the order into account in steps 4 and 5.</p><p>Since, this is a <code>NonGenerativeDerivativeMethod</code> we skip step 3. This is  however exemplified in the extension template.</p><p>For step 4, we extend <a href="../../manual/derivative/#InfiniteOpt.derivative_expr_data"><code>InfiniteOpt.derivative_expr_data</code></a>.  This function generates all the needed data to make the expressions necessary to build the derivative evaluation equations (derivative  constraints). We assume these relations to be of the form <span>$h = 0$</span> where <span>$h$</span>  is a vector of expressions. Thus, mathematically <span>$h$</span> should be of the form:</p><p class="math-container">\[\begin{aligned}
&amp;&amp;&amp; y(t_{2}) - y(t_{1}) - (t_{2} - t_{1})\frac{d y(t_1)}{dt} \\
&amp;&amp;&amp; \vdots \\
&amp;&amp;&amp; y(t_{n+1}) - y(t_n) - (t_{n+1} - t_{n})\frac{d y(t_n)}{dt} \\
\end{aligned}\]</p><p>The required data must include the support indices used for each derivative  variable and then any other constants needed. In this case, we will need the indices <span>$\{1, \dots, n\}$</span> and no additional data (additional data is exemplified  in the extension template). With this in mind let&#39;s now extend  <code>InfiniteOpt.derivative_expr_data</code>:</p><pre><code class="language-julia hljs">function InfiniteOpt.derivative_expr_data(
    dref::GeneralVariableRef, 
    order::Int,
    supps::Vector{Float64},
    method::ExplicitEuler
    )
    # generate the support indices to be used for each call of `make_indexed_derivative_expr`
    idxs = 1:length(supps)-1
    # return the indexes and the other iterators
    return (idxs, ) # output must be a tuple
end</code></pre><p>Finally, we just need to extend <a href="../../manual/derivative/#InfiniteOpt.make_indexed_derivative_expr"><code>InfiniteOpt.make_indexed_derivative_expr</code></a>. This will be used to create derivative expressions for each index determined (and additional datum) produced by <code>derivative_expr_data</code>.</p><pre><code class="language-julia hljs">function InfiniteOpt.make_indexed_derivative_expr(
    dref::GeneralVariableRef,
    vref::GeneralVariableRef,
    pref::GeneralVariableRef,
    order::Int,
    idx,
    supps::Vector{Float64}, # ordered
    write_model::Union{InfiniteModel, AbstractTransformationBackend},
    ::ExplicitEuler,
    # put extra data args here (none in this case)
    )
    # generate the derivative expression h corresponding to the equation of 
    # the form h = 0
    d = InfiniteOpt.make_reduced_expr(dref, pref, supps[idx], write_model)
    v1 = InfiniteOpt.make_reduced_expr(vref, pref, supps[idx], write_model)
    v2 = InfiniteOpt.make_reduced_expr(vref, pref, supps[idx + 1], write_model)
    return JuMP.@expression(write_model, -(supps[idx+1] - supps[idx]) * d + v2 - v1)
end</code></pre><p>We used <a href="../../manual/derivative/#InfiniteOpt.make_reduced_expr"><code>InfiniteOpt.make_reduced_expr</code></a> as a convenient helper function  to generate the semi-infinite variables/expressions we need to generate at each  support point.</p><div class="admonition is-info" id="Note-30fcbc778a1dba54"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-30fcbc778a1dba54" title="Permalink"></a></header><div class="admonition-body"><p>If your new derivative method is not compatible can not be broken  up into the <code>derivative_expr_data</code>-<code>make_indexed_derivative_expr</code>  workflow, then you can instead extend <a href="../../manual/derivative/#InfiniteOpt.evaluate_derivative"><code>InfiniteOpt.evaluate_derivative</code></a>. This is discouraged where possible since it may make your method incompatible  with backends that depend on the preferred workflow.</p></div></div><p>Now that we have completed all the necessary steps, let&#39;s try it out! </p><pre><code class="language-julia-repl hljs">julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 3, 
                           derivative_method = ExplicitEuler());

julia&gt; @variable(model, y, Infinite(t));

julia&gt; dy = deriv(y, t);

julia&gt; evaluate(dy)

julia&gt; derivative_constraints(dy)
2-element Vector{InfOptConstraintRef}:
 -5 d/dt[y(t)](0) + y(5) - y(0) = 0
 -5 d/dt[y(t)](5) + y(10) - y(5) = 0</code></pre><p>We implemented explicit Euler and it works! Now go and extend away!</p><h2 id="Measure-Evaluation-Techniques"><a class="docs-heading-anchor" href="#Measure-Evaluation-Techniques">Measure Evaluation Techniques</a><a id="Measure-Evaluation-Techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-Evaluation-Techniques" title="Permalink"></a></h2><p>Measure evaluation methods are used to dictate how to evaluate measures. Users  may wish to apply evaluation methods other than Monte Carlo sampling and/or  Gaussian quadrature methods. To create multiple measures using the same new  evaluation methods, users may want to embed the new evaluation method under the  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a> function that does not require explicit construction of  <a href="../../manual/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><h3 id="Creating-a-DiscreteMeasureData-Object"><a class="docs-heading-anchor" href="#Creating-a-DiscreteMeasureData-Object">Creating a DiscreteMeasureData Object</a><a id="Creating-a-DiscreteMeasureData-Object-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-DiscreteMeasureData-Object" title="Permalink"></a></h3><p>The basic way to do that is to write a function that creates  <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> object and pass the object to <a href="../../manual/measure/#InfiniteOpt.measure"><code>measure</code></a>.  This considers a measure approximation of the form:</p><p class="math-container">\[\sum_{i \in I} \alpha_i f(\tau_i) w(\tau_i)\]</p><p>where <span>$\alpha_i$</span> are coefficients, <span>$f(\cdot)$</span> is the expression being measured,  <span>$w(\cdot)$</span> is a weighting function, and <span>$i \in I$</span> indexes the support points.  Let&#39;s consider defining a function that enables the definition of a  uniform grid for a univariate infinite parameter in <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a>.  This example approximation uses a uniformly spaced supports <span>$\tau_i$</span> with  <span>$\alpha_i = \frac{ub - lb}{|I|}$</span>:</p><pre><code class="language-julia hljs">function uniform_grid(param, num_supports)
    lb = lower_bound(param)
    ub = upper_bound(param)
    supps = collect(LinRange(lb, ub, num_supports))
    coeffs = ones(num_supports) / num_supports * (ub - lb)
    return DiscreteMeasureData(param, coeffs, supps, lower_bound = lb, upper_bound = ub)
end</code></pre><p>It is necessary to pass the infinite parameter reference since the  construction of measure data object needs parameter information. Now let&#39;s  apply the new <code>uniform_grid</code> function to infinite parameters in  intervals. We consider a time parameter <code>t</code> and 2D spatial parameter <code>x</code>, and  two variables <code>f(t)</code> and <code>g(x)</code> parameterized by <code>t</code> and <code>x</code>, respectively:</p><pre><code class="language-julia-repl hljs">julia&gt; m = InfiniteModel();

julia&gt; @infinite_parameter(m, t in [0, 5]);

julia&gt; @variable(m, y, Infinite(t));</code></pre><p>Now we can use <code>uniform_grid</code> to construct a <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> and  create a measure using the measure data, as shown below:</p><pre><code class="language-julia-repl hljs">julia&gt; tdata = uniform_grid(t, 6);

julia&gt; y_meas = measure(y, tdata)
measure{t ∈ [0, 5]}[y(t)]

julia&gt; expand(y_meas)
0.8333333333333333 y(0) + 0.8333333333333333 y(1) + 0.8333333333333333 y(2) + 0.8333333333333333 y(3) + 0.8333333333333333 y(4) + 0.8333333333333333 y(5)</code></pre><h3 id="Integral-Evaluation-Methods"><a class="docs-heading-anchor" href="#Integral-Evaluation-Methods">Integral Evaluation Methods</a><a id="Integral-Evaluation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-Evaluation-Methods" title="Permalink"></a></h3><p>For integrals, we can implement a new approximation method via the extension of  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>InfiniteOpt.MeasureToolbox.generate_integral_data</code></a>. This will  allow users to use their custom measure evaluation methods in the  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}"><code>integral</code></a> function that does not explicitly require a measure data  object. A template for how such an extension is accomplished is provided in  <a href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/test/extensions/measure_eval.jl"><code>./test/extensions/measure_eval.jl</code></a>. In general, such an extension can be created as follows: </p><ol><li>Define a new empty <code>struct</code> (e.g. <code>my_new_fn</code>) that dispatches your function</li><li>Extend <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>InfiniteOpt.MeasureToolbox.generate_integral_data</code></a>,  where <code>method</code> is of the type <code>my_new_fn</code>, and <code>domain</code> needs to be a subtype  of <a href="../../manual/domains/#InfiniteOpt.AbstractInfiniteDomain"><code>AbstractInfiniteDomain</code></a> that you wish to apply the new evaluation  method to.</li></ol><p>Note that this procedure can be used to generate new measure evaluation methods  not only for existing infinite domains, but also for user-defined infinite  domains. </p><p>For example, an extension of  <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>InfiniteOpt.MeasureToolbox.generate_integral_data</code></a> that implements  uniform grid for univariate and multivariate parameters in  <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a> can be created as follows:</p><pre><code class="language-julia hljs">struct UnifGrid &lt;: InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod end

function InfiniteOpt.MeasureToolbox.generate_integral_data(
    pref::InfiniteOpt.GeneralVariableRef,
    lower_bound::Real,
    upper_bound::Real,
    method::UnifGrid;
    num_supports::Int = InfiniteOpt.DefaultNumSupports,
    weight_func::Function = InfiniteOpt.default_weight
    )
    increment = (upper_bound - lower_bound) / (num_supports - 1)
    supports = [lower_bound + (i - 1) * increment for i in 1:num_supports]
    coeffs = ones(num_supports) / num_supports * (upper_bound - lower_bound)
    return InfiniteOpt.DiscreteMeasureData(
        pref, coeffs, supports,
        weight_function = weight_func,
        lower_bound = lower_bound, 
        upper_bound = upper_bound)
end</code></pre><p>Also notice that users are free to pass keyword arguments for their new  functions in addition to the required positional arguments. This might be needed  in case if the new evaluation method requires additional information not  captured in the default positional arguments. For example, the multivariate  parameter version above needs to know if the multivariate parameter is  independent in order to throw a warning when needed.</p><p>We create measure for <code>y</code> using the <code>uniform_grid</code> method:</p><pre><code class="language-julia-repl hljs">julia&gt; y_int = integral(y, t, num_supports = 6, eval_method = UnifGrid())
∫{t ∈ [0, 5]}[y(t)]

julia&gt; expand(y_int)
0.8333333333333333 y(0) + 0.8333333333333333 y(1) + 0.8333333333333333 y(2) + 0.8333333333333333 y(3) + 0.8333333333333333 y(4) + 0.8333333333333333 y(5)</code></pre><p>Here we go! We can freely use <code>UnifGrid</code> for infinite parameters residing in  <a href="../../manual/domains/#InfiniteOpt.IntervalDomain"><code>IntervalDomain</code></a>s now.</p><h2 id="meas_data_ext"><a class="docs-heading-anchor" href="#meas_data_ext">Measure Data</a><a id="meas_data_ext-1"></a><a class="docs-heading-anchor-permalink" href="#meas_data_ext" title="Permalink"></a></h2><p>Measures are used to evaluate over infinite domains. Users may wish to employ  measure abstractions that cannot be readily represented with coefficients and  discretized supports, and thus may wish to extend <code>InfiniteOpt</code>&#39;s  measure framework to accommodate other paradigms. This can be accomplished by   implementing a user-defined measure data structure that inherits from  <a href="../../manual/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>. A template for how such an extension is  accomplished is provided in  <a href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/test/extensions/measure_data.jl"><code>./test/extensions/measure_data.jl</code></a>.  The extension steps employed are:</p><ol><li>Define the new data struct inheriting from <a href="../../manual/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> (required)</li><li>Extend <a href="../../manual/measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a> (required)</li><li>Extend <a href="../../manual/measure/#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a> (required)</li><li>Extend <a href="../../manual/measure/#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a> (required if parameter supports are employed in any way)</li><li>Extend <a href="../../manual/measure/#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}"><code>InfiniteOpt.add_supports_to_parameters</code></a> (required if parameter supports are employed in measure evaluation)</li><li>Extend <a href="../../manual/measure/#InfiniteOpt.coefficients-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficients</code></a> (useful getter method if applicable)</li><li>Extend <a href="../../manual/measure/#InfiniteOpt.weight_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.weight_function</code></a> (useful getter method if applicable)</li><li>Extend <a href="../../manual/derivative/#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.support_label</code></a> (needed to enable deletion if supports are added.)</li><li>Extend <a href="../../manual/derivative/#InfiniteOpt.generative_support_info-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.generative_support_info</code></a> (Needed if the measure will cause the creation of generative supports)</li><li>Make simple measure constructor wrapper of <a href="../../manual/measure/#InfiniteOpt.measure"><code>measure</code></a> to ease definition.</li></ol><p>To illustrate how this process can be done, let&#39;s consider extending <code>InfiniteOpt</code>  to include measure support for assessing the variance of random expressions. The  variance of an expression <span>$f(x, \xi)$</span> where <span>$x \in \mathbb{R}^n$</span> are finite  variables and <span>$\xi \in \mathbb{R}^m$</span> are random infinite parameters is defined:</p><p class="math-container">\[\mathbb{V}[f(x, \xi)] = \mathbb{E}\left[(f(x, \xi) - \mathbb{E}[f(x, \xi)])^2 \right].\]</p><p>Note, we could just accomplish this by nested use of <a href="../../manual/measure/#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a>, but we  implement this example to illustrate the mechanics of extension.</p><p>First, let&#39;s define our new <code>struct</code> inheriting from <code>AbstractMeasureData</code>:</p><pre><code class="language-julia hljs">using InfiniteOpt, Distributions

struct DiscreteVarianceData &lt;: AbstractMeasureData
    parameter_refs::Union{GeneralVariableRef, Vector{GeneralVariableRef}}
    supports::Vector
    label::DataType
    # constructor
    function DiscreteVarianceData(
        parameter_refs::Union{GeneralVariableRef, Array{&lt;:GeneralVariableRef}},
        supports::Vector,
        label::DataType = InfiniteOpt.generate_unique_label()
        )
        # convert input as necessary to proper array format
        if parameter_refs isa Array
            parameter_refs = convert(Vector, parameter_refs)
            supports = [convert(Vector, arr) for arr in supports]
        end
        return new(parameter_refs, supports, label)
    end
end</code></pre><p>We have defined our data type, so let&#39;s extend the measure data query  methods to enable its definition. These include:</p><ul><li><a href="../../manual/measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>parameter_refs</code></a></li><li><a href="../../manual/measure/#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>supports</code></a></li><li><a href="../../manual/measure/#InfiniteOpt.support_label-Tuple{AbstractMeasureData}"><code>support_label</code></a></li></ul><pre><code class="language-julia hljs">function InfiniteOpt.parameter_refs(data::DiscreteVarianceData)
    return data.parameter_refs
end

function InfiniteOpt.supports(data::DiscreteVarianceData)
    return data.supports
end

function InfiniteOpt.support_label(data::DiscreteVarianceData)
    return data.label
end</code></pre><p>We also need to extend <a href="../../manual/measure/#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}"><code>InfiniteOpt.add_supports_to_parameters</code></a>  since support points will be used for measure evaluation later:</p><pre><code class="language-julia hljs">function InfiniteOpt.add_supports_to_parameters(data::DiscreteVarianceData)
    pref = parameter_refs(data)
    supps = supports(data)
    label = support_label(data)
    add_supports(pref, supps, label = label)
    return
end</code></pre><p>Note that extending <code>supports</code> is not needed for abstractions that don&#39;t involve  discretization of the infinite parameter(s), such as the case for certain  outer approximation techniques. Our extension is now sufficiently constructed to  allow us to define out the new variance measure via <a href="../../manual/measure/#InfiniteOpt.measure"><code>measure</code></a>. For  example:</p><pre><code class="language-julia hljs"># Setup the infinite model
model = InfiniteModel()
@infinite_parameter(model, xi ~ Normal(), num_supports = 2) # few for simplicity
@variable(model, y, Infinite(xi))
@variable(model, z)

# Define out new variance measure
data = DiscreteVarianceData(xi, supports(xi))
mref = measure(2y + z, data, name = &quot;Var&quot;)

# output
Var{xi}[2 y(xi) + z]</code></pre><p>Thus, we can define measure references that employ this our new data type.</p><p>We can define variance measures now, but now let&#39;s extend  <a href="../../manual/measure/#InfiniteOpt.expand_measure"><code>expand_measure</code></a> so that they can be expanded into finite expressions:</p><pre><code class="language-julia hljs">function InfiniteOpt.expand_measure(
    expr::JuMP.AbstractJuMPScalar,
    data::DiscreteVarianceData,
    write_model::Union{InfiniteModel, AbstractTransformationBackend}
    )
    # define the expectation data
    expect_data = DiscreteMeasureData(
                      data.parameter_refs,
                      1 / length(data.supports) * ones(length(data.supports)),
                      data.supports, is_expect = true, label = data.label)
    # define the mean
    mean = measure(expr, expect_data)
    # return the expansion of the variance using the data mean
    return expand_measure((copy(expr) - mean)^2, expect_data, write_model)
end</code></pre><p>Notice that we reformulated our abstraction in terms of measures with  <a href="../../manual/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> so that we could leverage the existing  <a href="../../manual/measure/#InfiniteOpt.expand_measure"><code>expand_measure</code></a> library. Now, new the measure type can be expanded and  moreover infinite models using this new type can be optimized. Let&#39;s try  expanding the measure we already defined:</p><pre><code class="language-julia-repl hljs">julia&gt; expand(mref)
y(-0.556026876146)² + 0 z*y(-0.556026876146) - 2 y(-0.44438335711)*y(-0.556026876146) + 0 z² + 0 z*y(-0.44438335711) + y(-0.44438335711)²</code></pre><p>Finally, as per recommendation let&#39;s make a wrapper method to make defining  variance measures more convenient:</p><pre><code class="language-julia hljs">function variance(
    expr::Union{JuMP.GenericAffExpr, GeneralVariableRef},
    params::Union{GeneralVariableRef, Array{GeneralVariableRef}};
    name::String = &quot;Var&quot;, 
    num_supports::Int = 10,
    use_existing::Bool = false
    )
    # get the supports
    if use_existing
        supps = supports.(params)
    else
        supps = generate_support_values(infinite_domain(first(params)),
                                        num_supports = num_supports)
    end
    # make the data
    data = DiscreteVarianceData(params, supps)
    # built the measure
    return measure(expr, data, name = name)
end</code></pre><p>Notice in this case that we only permit linear expressions for <code>expr</code> since  it will be squared by our new measure and we currently only support quadratic  expressions. (This could be overcome by defining a place holder variable  for <code>expr</code>.</p><p>Now let&#39;s use our constructor to repeat the above measure example:</p><pre><code class="language-julia-repl hljs">julia&gt; expand(variance(2y + z, xi, use_existing = true))
y(-0.556026876146)² + 0 z*y(-0.556026876146) - 2 y(-0.44438335711)*y(-0.556026876146) + 0 z² + 0 z*y(-0.44438335711) + y(-0.44438335711)²</code></pre><p>We have done it! Now go and extend away!</p><h2 id="Generative-Support-Information"><a class="docs-heading-anchor" href="#Generative-Support-Information">Generative Support Information</a><a id="Generative-Support-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Generative-Support-Information" title="Permalink"></a></h2><p>As discussed in the <a href="../../guide/parameter/#gen_supp_docs">Generative Supports</a> section, generative  supports help enable measure and/or derivative evaluation techniques that require  the creation of generative supports (e.g., orthogonal collocation). Natively, we  provide <a href="../../manual/parameter/#InfiniteOpt.UniformGenerativeInfo"><code>UniformGenerativeInfo</code></a> to help accomplish this which works for  creating generative supports uniformly over finite elements as is the case for  orthogonal collocation (note this includes scaling them as need to the size of  each finite element). However, more complex generative support schemes can be  enabled by defining a new concrete <a href="../../manual/parameter/#InfiniteOpt.AbstractGenerativeInfo"><code>AbstractGenerativeInfo</code></a> subtype. This  section will detail how this can be accomplished in <code>InfiniteOpt</code>. A template for  implementing this is provided in  <a href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/test/extensions/generative_info.jl"><code>./test/extensions/generative_info.jl</code></a>.</p><p>A new generative support information type can be created via the following:</p><ol><li>Define a concrete subtype of <a href="../../manual/parameter/#InfiniteOpt.AbstractGenerativeInfo"><code>AbstractGenerativeInfo</code></a> (required)</li><li>Make a unique support label that inherits <a href="../../manual/domains/#InfiniteOpt.InternalLabel"><code>InternalLabel</code></a> (recommended)</li><li>Extend <a href="../../manual/derivative/#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.support_label</code></a> (required)</li><li>Extend <a href="../../manual/parameter/#InfiniteOpt.make_generative_supports"><code>InfiniteOpt.make_generative_supports</code></a> (required).</li></ol><p>For the sake of example, let&#39;s suppose we want to make a method that generates a  certain amount of random supports for each finite element. First, let&#39;s define  our struct <code>RandomGenerativeInfo</code>:</p><pre><code class="language-julia hljs">using InfiniteOpt, Random

struct RandomGenerativeInfo &lt;: InfiniteOpt.AbstractGenerativeInfo
    amount::Int # amount of random supports per finite element
end</code></pre><p>With that done, let&#39;s define a unique support label <code>RandomInternal</code> for these  types of supports and extend <code>support_label</code>:</p><pre><code class="language-julia hljs">struct RandomInternal &lt;: InternalLabel end

function InfiniteOpt.support_label(info::RandomGenerativeInfo)
    return RandomInternal
end</code></pre><p>Finally, let&#39;s extend <code>make_generative_supports</code> to create a vector of the  generative supports based on a <code>RandomGenerativeInfo</code> and the existing model  supports which are passed in the function as input:</p><pre><code class="language-julia hljs">function InfiniteOpt.make_generative_supports(info::RandomGenerativeInfo, pref, supps)
    num_existing = length(supps)
    num_existing &lt;= 1 &amp;&amp; error(&quot;`$pref` doesn&#39;t have enough supports.&quot;)
    num_internal = info.attr
    gen_supps = Float64[]
    for i = 1:num_existing-1 
        lb = supps[i]
        ub = supps[i+1]
        append!(gen_supps, rand(num_internal) * (ub - lb) .+ lb)
    end
    return gen_supps
end</code></pre><p>Our extension is done and now <code>RandomGenerativeInfo</code> can be incorporated by a  <code>GenerativeDerivativeMethod</code> we create or an <code>AbstractMeasureData</code> object of our  choice like <code>FunctionalDiscreteMeasureData</code>. </p><h2 id="extend_backends"><a class="docs-heading-anchor" href="#extend_backends">Transformation Backends</a><a id="extend_backends-1"></a><a class="docs-heading-anchor-permalink" href="#extend_backends" title="Permalink"></a></h2><p><code>InfiniteOpt</code> provides a convenient interface and abstraction for modeling  infinite-dimensional optimization problems. By default, <code>InfiniteModel</code>s are  reformulated into a solvable <code>JuMP.Model</code> via <code>TranscriptionOpt.TranscriptionBackend</code>  which discretizes the model in accordance with the infinite parameter supports.  However, users may wish to employ some other transformation method to produce  the transformation backend. This section will explain how this can be done in  <code>InfiniteOpt</code>. A template for implementing this extension is provided in  <a href="https://github.com/infiniteopt/InfiniteOpt.jl/blob/master/test/extensions/backend.jl"><code>./test/extensions/backend.jl</code></a>.  Our default sub-module <code>InfiniteOpt.TranscriptionOpt</code> also serves as a good  example.</p><p>A new transformation approach and its corresponding transformation backend can be  extended using the following steps:</p><ol><li>Define a <code>mutable struct</code> for variable/constraint mappings and other needed info (required)</li><li>Define an <a href="../../manual/backend/#InfiniteOpt.AbstractTransformationBackend"><code>AbstractTransformationBackend</code></a> (required)</li><li>Extend <a href="../../manual/backend/#Base.empty!-Tuple{AbstractTransformationBackend}"><code>Base.empty!</code></a> for the backend (required)</li><li>Extend <a href="../../manual/backend/#InfiniteOpt.build_transformation_backend!-Tuple{InfiniteModel, AbstractTransformationBackend}"><code>build_transformation_backend!</code></a> (required)</li><li>If appropriate and NOT a <a href="../../manual/backend/#InfiniteOpt.JuMPBackend"><code>JuMPBackend</code></a>, extend the following:<ul><li><a href="../../manual/backend/#InfiniteOpt.transformation_model-Tuple{AbstractTransformationBackend}"><code>transformation_model</code></a></li><li><a href="../../manual/backend/#InfiniteOpt.transformation_data-Tuple{AbstractTransformationBackend}"><code>transformation_data</code></a></li><li><a href="../../manual/backend/#JuMP.set_attribute-Tuple{AbstractTransformationBackend, Any, Any}"><code>JuMP.set_attribute</code></a> (including the suggested attributes)</li><li><a href="../../manual/backend/#JuMP.get_attribute-Tuple{AbstractTransformationBackend, Any}"><code>JuMP.get_attribute</code></a> (including the suggested attributes)</li><li><a href="../../manual/backend/#JuMP.optimize!-Tuple{AbstractTransformationBackend}"><code>JuMP.optimize!</code></a></li><li><a href="../../manual/backend/#JuMP.set_optimizer-Tuple{AbstractTransformationBackend, Any}"><code>JuMP.set_optimizer</code></a></li><li><a href="../../manual/backend/#JuMP.bridge_constraints-Tuple{AbstractTransformationBackend}"><code>JuMP.bridge_constraints</code></a></li><li><a href="../../manual/backend/#JuMP.add_bridge-Tuple{AbstractTransformationBackend, Any}"><code>JuMP.add_bridge</code></a></li><li><a href="../../manual/backend/#JuMP.print_active_bridges-Tuple{IO, AbstractTransformationBackend, Vararg{Any}}"><code>JuMP.print_active_bridges</code></a></li><li><a href="../../manual/backend/#JuMP.print_active_bridges-Tuple{IO, AbstractTransformationBackend, Vararg{Any}}"><code>JuMP.print_active_bridges</code></a></li><li><a href="../../manual/backend/#JuMP.compute_conflict!-Tuple{AbstractTransformationBackend}"><code>JuMP.compute_conflict!</code></a></li><li><a href="../../manual/backend/#JuMP.copy_conflict-Tuple{AbstractTransformationBackend}"><code>JuMP.copy_conflict</code></a></li><li><a href="../../manual/backend/#JuMP.mode-Tuple{AbstractTransformationBackend}"><code>JuMP.mode</code></a></li><li><a href="../../manual/backend/#JuMP.backend-Tuple{AbstractTransformationBackend}"><code>JuMP.backend</code></a></li><li><a href="../../manual/backend/#JuMP.unsafe_backend-Tuple{AbstractTransformationBackend}"><code>JuMP.unsafe_backend</code></a></li></ul></li><li>Extend the following, if possible (also enables result queries for <code>JuMPBackend</code>s):<ul><li><a href="../../manual/backend/#InfiniteOpt.transformation_variable-Tuple{GeneralVariableRef, AbstractTransformationBackend}"><code>transformation_variable</code></a></li><li><a href="../../manual/backend/#InfiniteOpt.transformation_expression-Tuple{Any, AbstractTransformationBackend}"><code>transformation_expression</code></a></li><li><a href="../../manual/backend/#InfiniteOpt.transformation_constraint-Tuple{InfOptConstraintRef, AbstractTransformationBackend}"><code>transformation_constraint</code></a></li></ul></li><li>Extend the following, if appropriate:<ul><li><a href="../../manual/backend/#InfiniteOpt.variable_supports-Tuple{Any, AbstractTransformationBackend}"><code>InfiniteOpt.variable_supports</code></a></li><li><a href="../../manual/backend/#InfiniteOpt.expression_supports-Tuple{Any, AbstractTransformationBackend}"><code>InfiniteOpt.expression_supports</code></a></li><li><a href="../../manual/backend/#InfiniteOpt.constraint_supports-Tuple{InfOptConstraintRef, AbstractTransformationBackend}"><code>InfiniteOpt.constraint_supports</code></a></li></ul></li><li>As appropriate and if NOT a <code>JuMPBackend</code>, extend the following:<ul><li>The remaining result related attributes listed in <a href="../../manual/backend/#JuMP.get_attribute-Tuple{AbstractTransformationBackend, Any}"><code>JuMP.get_attribute</code></a></li><li><a href="../../manual/result/#JuMP.lp_sensitivity_report-Tuple{AbstractTransformationBackend}"><code>JuMP.lp_sensitivity_report</code></a></li><li><a href="../../manual/backend/#InfiniteOpt.warmstart_backend_start_values-Tuple{AbstractTransformationBackend}"><code>InfiniteOpt.warmstart_backend_start_values</code></a> to enable automated warmstarts</li></ul></li><li>If Step 6 was skipped and/or the backend is NOT a <code>JuMPBackend</code> then extend the following:<ul><li><a href="../../manual/result/#InfiniteOpt.map_value-Tuple{Any, AbstractTransformationBackend}"><code>InfiniteOpt.map_value</code></a> (enables <code>JuMP.value</code>)</li><li><a href="../../manual/result/#InfiniteOpt.map_infinite_parameter_value"><code>InfiniteOpt.map_infinite_parameter_value</code></a> (enables <code>JuMP.value</code> for infinite parameters)</li><li><a href="../../manual/result/#InfiniteOpt.map_optimizer_index-Tuple{GeneralVariableRef, AbstractTransformationBackend}"><code>InfiniteOpt.map_optimizer_index</code></a> (enables <code>JuMP.optimizer_index</code>)</li><li><a href="../../manual/result/#InfiniteOpt.map_reduced_cost-Tuple{GeneralVariableRef, AbstractTransformationBackend}"><code>InfiniteOpt.map_reduced_cost</code></a> (enables <code>JuMP.reduced_cost</code>)</li><li><a href="../../manual/result/#InfiniteOpt.map_shadow_price-Tuple{InfOptConstraintRef, AbstractTransformationBackend}"><code>InfiniteOpt.map_shadow_price</code></a> (enables <code>JuMP.shadow_cost</code>)</li><li><a href="../../manual/result/#InfiniteOpt.map_dual-Tuple{InfOptConstraintRef, AbstractTransformationBackend}"><code>InfiniteOpt.map_dual</code></a> (enables <code>JuMP.dual</code>)</li></ul></li><li>Extend <a href="../../manual/measure/#InfiniteOpt.add_point_variable-Tuple{AbstractTransformationBackend, Any, Any}"><code>InfiniteOpt.add_point_variable</code></a> and   <a href="../../manual/measure/#InfiniteOpt.add_semi_infinite_variable-Tuple{AbstractTransformationBackend, Any}"><code>InfiniteOpt.add_semi_infinite_variable</code></a> to use   <a href="../../manual/measure/#InfiniteOpt.expand_measure"><code>expand_measure</code></a> without modifying the infinite model.</li><li>Extend <a href="../../manual/backend/#InfiniteOpt.update_parameter_value-Tuple{AbstractTransformationBackend, Any, Any}"><code>InfiniteOpt.update_parameter_value</code></a> to enable incremental parameter updates.</li></ol><p>This may seem like a lot a work, but the majority of the above steps can be skipped for <a href="../../manual/backend/#InfiniteOpt.JuMPBackend"><code>JuMPBackend</code></a>s as exemplified below. A complete extension, showing all the above is provided in the extension template file.</p><p>For the sake of example, let&#39;s suppose we want to define a reformulation method  for <code>InfiniteModel</code>s that are 2-stage stochastic programs (i.e., only  <code>DistributionDomain</code>s are used, infinite variables are random 2nd stage variables,  and finite variables are 1st stage variables). In particular, let&#39;s make a simple  method that replaces the infinite parameters with their mean values, giving us  the deterministic mean-valued problem.</p><p>First, let&#39;s define the (potentially mutable) <code>struct</code> that will be used to store  our variable and constraint mappings. This case it is quite simple since our  deterministic model will have a 1-to-1 mapping:</p><pre><code class="language-julia hljs">using InfiniteOpt, Distributions

struct DeterministicData
    # variable and constraint mapping
    infvar_to_detvar::Dict{GeneralVariableRef, VariableRef}
    infconstr_to_detconstr::Dict{InfOptConstraintRef, ConstraintRef}
    # constructor
    function DeterministicData()
        return new(Dict{GeneralVariableRef, VariableRef}(),
                   Dict{InfOptConstraintRef, ConstraintRef}())
    end
end</code></pre><p>Now let&#39;s define the transformation backend based on <a href="../../manual/backend/#InfiniteOpt.JuMPBackend"><code>JuMPBackend</code></a> that will use a tag <code>Deterministic</code>:</p><pre><code class="language-julia hljs">struct Deterministic &lt;: AbstractJuMPTag end

const DeterministicBackend = JuMPBackend{Deterministic, Float64, DeterministicData}

# Constructor
function DeterministicBackend(; kwargs...)
    return JuMPBackend{Deterministic}(Model(; kwargs...), DeterministicData())
end
function DeterministicBackend(optimizer_constructor; kwargs...)
    backend = DeterministicBackend(; kwargs...)
    set_optimizer(backend.model, optimizer_constructor)
    return backend
end</code></pre><p>With the constructor we can now specify that a given <code>InfiniteModel</code> uses a  <code>DeterministicBackend</code> instead of a <code>TranscriptionBackend</code> or via  <a href="../../manual/backend/#InfiniteOpt.set_transformation_backend"><code>set_transformation_backend</code></a>:</p><pre><code class="language-julia hljs">using Ipopt

# Make model using Ipopt and DeterministicModels
dbackend = DeterministicBackend(optimizer_with_attributes(Ipopt.Optimizer, &quot;print_level&quot; =&gt; 0))
model = InfiniteModel(dbackend)

# Or equivalently
model = InfiniteModel()
set_transformation_backend(model, DeterministicBackend())
set_optimizer(model, optimizer_with_attributes(Ipopt.Optimizer, &quot;print_level&quot; =&gt; 0))</code></pre><p>Now <code>model</code> uses a <code>DeterministicBackend</code> as its transformation backend! With that we can build our <code>InfiniteModel</code> as normal, for example:</p><pre><code class="language-julia hljs">@infinite_parameter(model, ξ ~ Uniform())
@variable(model, y[1:2] &gt;= 0, Infinite(ξ))
@variable(model, z)
@objective(model, Min, z + expect(y[1] + y[2], ξ))
@constraint(model, 2y[1] - z &lt;= 42)
@constraint(model, y[2]^2 + ξ == 2)
@constraint(model, sin(z) &gt;= -1)
print(model)

# output
Min z + 𝔼{ξ}[y[1](ξ) + y[2](ξ)]
Subject to
 y[1](ξ) ≥ 0.0, ∀ ξ ~ Uniform
 y[2](ξ) ≥ 0.0, ∀ ξ ~ Uniform
 2 y[1](ξ) - z ≤ 42.0, ∀ ξ ~ Uniform
 y[2](ξ)² + ξ = 2.0, ∀ ξ ~ Uniform
 sin(z) - -1 ≥ 0.0</code></pre><p>We have defined our <code>InfiniteModel</code>, but now we need to specify how to  reformulate it into a <code>DeterministicBackend</code>. This is accomplished by extending  <a href="../../manual/backend/#InfiniteOpt.build_transformation_backend!-Tuple{InfiniteModel, AbstractTransformationBackend}"><code>build_transformation_backend!</code></a> which will enable the use of <code>optimize!</code>. A necessary preliminary step though, is to define <code>Base.empty!</code> for <code>DeterministicData</code>:</p><pre><code class="language-julia hljs">function Base.empty!(data::DeterministicData)
    empty!(data.infvar_to_detvar)
    empty!(data.infconstr_to_detconstr)
    return data
end</code></pre><p>This enables the backend to be cleared out before it is rebuilt which is necessary to allow for modifications to the model. Now, let&#39;s define an internal function <code>_make_expression</code> that will use dispatch to  convert an <code>InfiniteOpt</code> expression into a <code>JuMP</code> expression using the mappings  stored in <code>backend</code>&#39;s <code>DeterministicData</code>:</p><pre><code class="language-julia hljs">## Make dispatch methods for converting InfiniteOpt expressions
# GeneralVariableRef
function _make_expression(backend::DeterministicBackend, expr::GeneralVariableRef)
    return _make_expression(backend, expr, index(expr))
end
# IndependentParameterRef
function _make_expression(
    backend::DeterministicBackend, 
    expr::GeneralVariableRef, 
    ::IndependentParameterIndex
    )
    return mean(infinite_domain(expr).distribution) # assuming univariate
end
# FiniteParameterRef
function _make_expression(
    backend::DeterministicBackend, 
    expr::GeneralVariableRef, 
    ::FiniteParameterIndex
    )
    return parameter_value(expr)
end
# DependentParameterRef
function _make_expression(
    backend::DeterministicBackend, 
    expr::GeneralVariableRef, 
    ::DependentParameterIndex
    )
    return mean(infinite_domain(expr).distribution) # assuming valid distribution
end
# DecisionVariableRef
function _make_expression(
    backend::DeterministicBackend, 
    expr::GeneralVariableRef, 
    ::Union{InfiniteVariableIndex, FiniteVariableIndex}
    )
    return backend.data.infvar_to_detvar[expr]
end
# MeasureRef --&gt; assume is expectation
function _make_expression(
    backend::DeterministicBackend, 
    expr::GeneralVariableRef,
    ::MeasureIndex
    )
    return _make_expression(backend, measure_function(expr))
end
# AffExpr/QuadExpr/NonlinearExpr
function _make_expression(backend::DeterministicBackend, expr::Union{GenericAffExpr, GenericQuadExpr, GenericNonlinearExpr})
    return map_expression(v -&gt; _make_expression(backend, v), expr)
end</code></pre><p>For simplicity in example, above we assume that only <code>DistributionDomain</code>s are  used, there are not any <code>PointVariableRef</code>s, and all <code>MeasureRef</code>s correspond to  expectations. Naturally, a full extension should include checks to enforce that  such assumptions hold. Notice that <a href="../../manual/expression/#InfiniteOpt.map_expression"><code>map_expression</code></a> is useful for  converting expressions.</p><p>Now let&#39;s extend <a href="../../manual/backend/#InfiniteOpt.build_transformation_backend!-Tuple{InfiniteModel, AbstractTransformationBackend}"><code>build_transformation_backend!</code></a> for <code>DeterministicBackend</code>s. This should build out the backend in-place and thus we should also be sure to have it clear out any previous builds with <code>Base.empty!</code>:</p><pre><code class="language-julia hljs">function InfiniteOpt.build_transformation_backend!(
    model::InfiniteModel,
    backend::DeterministicBackend
    )
    # TODO check that `model` is a stochastic model
    # empty the model for a build/rebuild
    empty!(backend)
    backend.model.operator_counter = 0 # clears out any previous user defined operators

    # add user-defined nonlinear operators if there are any
    add_operators_to_jump(backend.model, model)

    # add variables
    for vref in all_variables(model)
        if index(vref) isa InfiniteVariableIndex
            start = NaN # simple hack for sake of example
        else
            start = start_value(vref)
            start = isnothing(start) ? NaN : start
        end
        lb = has_lower_bound(vref) ? lower_bound(vref) : NaN
        ub = has_upper_bound(vref) ? upper_bound(vref) : NaN
        if is_fixed(vref)
            lb = fix_value(vref)
        end
        info = VariableInfo(!isnan(lb), lb, !isnan(ub), ub, is_fixed(vref), lb, 
                            !isnan(start), start, is_binary(vref), is_integer(vref))
        new_vref = add_variable(backend.model, ScalarVariable(info), name(vref))
        backend.data.infvar_to_detvar[vref] = new_vref
    end

    # add the objective
    obj_func = _make_expression(backend, objective_function(model))
    set_objective(backend.model, objective_sense(model), obj_func)

    # add the constraints
    for cref in all_constraints(model, Union{GenericAffExpr, GenericQuadExpr, GenericNonlinearExpr})
        constr = constraint_object(cref)
        new_func = _make_expression(backend, constr.func)
        new_constr = build_constraint(error, new_func, constr.set)
        new_cref = add_constraint(backend.model, new_constr, name(cref))
        backend.data.infconstr_to_detconstr[cref] = new_cref
    end
    return
end</code></pre><p>Note that Step 5 can be skipped since we are using the <code>JuMPBackend</code> API which inherits  all the needed methods. Now we can build our backend automatically and enable the use of  <code>optimize!</code>:</p><pre><code class="language-julia hljs">optimize!(model)
print(transformation_model(model))

# output
Min z + y[1] + y[2]
Subject to
 sin(z) - -1.0 ≥ 0
 2 y[1] - z ≤ 42
 y[2]² = 1.5
 y[1] ≥ 0
 y[2] ≥ 0</code></pre><p>Note that better variable naming could be used with the reformulated infinite  variables. Moreover, in general extensions of <a href="../../manual/backend/#InfiniteOpt.build_transformation_backend!-Tuple{InfiniteModel}"><code>build_transformation_backend!</code></a>  should account for the possibility that <code>InfiniteModel</code> contains constraints with  <a href="../../manual/constraint/#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> as accessed via <a href="../../manual/constraint/#InfiniteOpt.domain_restrictions"><code>domain_restrictions</code></a>.</p><p>Now that we have optimized our <code>InfiniteModel</code> via the use the of a  <code>DeterministicBackend</code>, we probably want to access the results. All queries  are enabled via Step 6 where we extend:</p><ul><li><a href="../../manual/backend/#InfiniteOpt.transformation_variable-Tuple{GeneralVariableRef, AbstractTransformationBackend}"><code>transformation_variable</code></a></li><li><a href="../../manual/backend/#InfiniteOpt.transformation_expression-Tuple{Any, AbstractTransformationBackend}"><code>transformation_expression</code></a></li><li><a href="../../manual/backend/#InfiniteOpt.transformation_constraint-Tuple{InfOptConstraintRef, AbstractTransformationBackend}"><code>transformation_constraint</code></a></li></ul><p>to return the variable(s)/expression(s)/constraint(s) in the backend. These will use the <code>DeterministicData</code> and should error if no mapping can be  found.</p><pre><code class="language-julia hljs">function InfiniteOpt.transformation_variable(
    vref::GeneralVariableRef,
    backend::DeterministicBackend
    )
    map_dict = backend.data.infvar_to_detvar
    haskey(map_dict, vref) || error(&quot;Variable $vref not used in the transformation backend.&quot;)
    return map_dict[vref]
end

function InfiniteOpt.transformation_expression(
    expr::JuMP.AbstractJuMPScalar,
    backend::DeterministicBackend
    )
    return _make_expression(backend, expr)
end

function InfiniteOpt.transformation_constraint(
    cref::InfOptConstraintRef,
    backend::DeterministicBackend
    )
    map_dict = backend.data.infconstr_to_detconstr
    haskey(map_dict, cref) || error(&quot;Constraint $cref not used in the transformation backend.&quot;)
    return map_dict[cref]
end</code></pre><p>With these extensions we can now access all the result queries (skipping Steps 8-9). For example:</p><pre><code class="language-julia-repl hljs">julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4

julia&gt; result_count(model)
1

julia&gt; value.(y)
2-element Vector{Float64}:
 -9.164638781941642e-9
  1.224744871391589

julia&gt; optimizer_index(z)
MathOptInterface.VariableIndex(3)</code></pre><p>We also skip steps 7 and 10 since these are not applicable to this particular  example.</p><p>That&#39;s it!</p><h2 id="Wrapper-Packages"><a class="docs-heading-anchor" href="#Wrapper-Packages">Wrapper Packages</a><a id="Wrapper-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-Packages" title="Permalink"></a></h2><p><code>InfiniteOpt</code> provides a convenient modular interface for defining infinite  dimensional optimization problems, implementing many tedious <code>JuMP</code> extensions  such as facilitating mixed variable expressions. Thus, <code>InfiniteOpt</code> can serve  as a base package for specific types of infinite dimensional problems and/or  solution techniques. These extension packages can implement any of the extensions  shown above and likely will want to introduce wrapper functions and macros to  use package specific terminology (e.g., using random variables instead of  infinite variables).</p><p>Please reach out to us via the  <a href="https://github.com/infiniteopt/InfiniteOpt.jl/discussions">discussion forum</a> to  discuss your plans before starting this on your own.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../manual/extensions/">« Extensions</a><a class="docs-footer-nextpage" href="../start_guide/">Getting Started »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 23 October 2025 16:55">Thursday 23 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
