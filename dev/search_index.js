var documenterSearchIndex = {"docs":
[{"location":"tutorials/quick_start/#Quick-Start-Guide","page":"Quick Start","title":"Quick Start Guide","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Below we exemplify and briefly explain the very basics behind defining and solving  an infinite-dimensional optimization problem in InfiniteOpt. Please refer to the  Guide on our subsequent pages for more complete information. The Basic Usage sections  on each guide page are good places to start from. Also, the syntax of InfiniteOpt  is inspired by JuMP thus we recommend new users that haven't used JuMP, first  consult their tutorials starting  here.","category":"page"},{"location":"tutorials/quick_start/#Preliminaries","page":"Quick Start","title":"Preliminaries","text":"","category":"section"},{"location":"tutorials/quick_start/#Software-Setup","page":"Quick Start","title":"Software Setup","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"First, we need to make sure everything is installed. This will include:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"installing Julia \ninstalling the InfiniteOpt.jl, JuMP.jl, and Distributions.jl packages\ninstalling wanted optimizers e.g., Ipopt.jl and HiGHS.jl","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"See Installation for more information.","category":"page"},{"location":"tutorials/quick_start/#Problem-Formulation","page":"Quick Start","title":"Problem Formulation","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Now we need to formulate the problem we want to solve mathematically. For example,  let's define a simple optimal control model:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"beginaligned\n\tundersetx_i(t xi) v_i(t xi) y_w(xi) u_i(t)textmin  int_t in mathcalD_t sum_i in I u_i^2(t) dt \n\ttextst  x_i(0 xi) = x0_i  forall i in I xi in mathcalD_xi\n     v_i(0 xi) = v0_i  forall i in I xi in mathcalD_xi \n\t fracpartial x_i(t xi)partial t = v_i(t xi)  forall i in I t in mathcalD_t xi in mathcalD_xi\n     xifracpartial v_i(t xi)partial t = u_i(t)  forall i in I t in mathcalD_t xi in mathcalD_xi\n     y_w(xi) = sum_i in I(x_i(t_w xi) - p_iw)^2  forall w in W xi in mathcalD_xi \n     y_w(xi) geq 0  forall w in W xi in mathcalD_xi \n     mathbbE_xileftsum_w in W y_w(xi) right leq epsilon \n     xi sim mathcalN(mu sigma^2) \n     t in mathcalD_t\nendaligned","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Notice this model is both dynamic with time t and random with respect to xi.","category":"page"},{"location":"tutorials/quick_start/#Parameter-Specification","page":"Quick Start","title":"Parameter Specification","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Before moving on we'll need to define the necessary constants and problem  parameters. Thus, continuing with our example we define the following in our  Julia session (these could also be put into a script as is shown at the bottom  of this page):","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> Î¼ = 1; Ïƒ = 0.2; # set the distribution parameters \n\njulia> x0 = [0, 0]; v0 = [0, 0]; # set the initial conditions\n\njulia> p = [1 4 6 1; 1 3 0 1]; tw = [0, 25, 50, 60]; # set waypoint specifications\n\njulia> I = 1:2; W = 1:4; # set the finite domains","category":"page"},{"location":"tutorials/quick_start/#Model-Definition","page":"Quick Start","title":"Model Definition","text":"","category":"section"},{"location":"tutorials/quick_start/#Model-Initialization","page":"Quick Start","title":"Model Initialization","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"The first thing we need to do is initialize our InfiniteModel and assign an  appropriate optimizer that will be used to solve its transcripted variant. For our  little example let's choose to use Ipopt:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> using InfiniteOpt, Distributions, Ipopt;\n\njulia> model = InfiniteModel(Ipopt.Optimizer)\nAn InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  Solver: Ipopt\n  Transformation built and up-to-date: false","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Learn more about InfiniteModels and optimizers on our  Infinite Models page.","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Before moving on, let's go ahead make a finite parameter via @finite_parameter  for epsilon since this likely a constant we'll want to update repeatedly  (e.g., to determine a tradeoff curve by varying it): ","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> @finite_parameter(model, Ïµ == 10)\nÏµ","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Learn more about finite parameters on our Finite Parameters  page.","category":"page"},{"location":"tutorials/quick_start/#Infinite-Parameters","page":"Quick Start","title":"Infinite Parameters","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"The next thing we need to do is identify the infinite domains our problem contains  and define an infinite parameter(s) for each one via [@infinite_parameter]. For  this problem we have the time domain t in mathcalD_t and the random domain  xi in mathcalD_xi where xi sim mathcalN(mu sigma^2):","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> @infinite_parameter(model, t in [0, 60], num_supports = 61, \n                           derivative_method = OrthogonalCollocation(3))\nt\n\njulia> @infinite_parameter(model, Î¾ ~ Normal(Î¼, Ïƒ^2), num_supports = 10)\nÎ¾","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Notice we specify the domain/distribution the parameter depends on via in. Here we also specify the number of finite supports we desire for each parameter  that will ultimately be used to reformulate and solve the problem (i.e., discretize).  We also specify the derivative evaluation method associated with t that will be  used evaluate the derivatives numerically. See more information about parameters  on our Infinite Parameters page. Also learn more about  derivative methods on our Derivative Operators page.","category":"page"},{"location":"tutorials/quick_start/#Variables","page":"Quick Start","title":"Variables","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Now that we have an InfiniteModel and infinite parameters let's define our  decision variables. First, infinite variables (ones that depend on infinite  parameters) are defined via  @variable  with the addition of the Infinite variable type argument to specify the  infinite parameters it depends on:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> @variable(model, x[I], Infinite(t, Î¾), start = 0)\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{GeneralVariableRef}:\n x[1](t, Î¾)\n x[2](t, Î¾)\n\njulia> @variable(model, v[I], Infinite(t, Î¾), start = 0)\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{GeneralVariableRef}:\n v[1](t, Î¾)\n v[2](t, Î¾)\n\njulia> @variable(model, u[I], Infinite(t), start = 0)\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{GeneralVariableRef}:\n u[1](t)\n u[2](t)\n\njulia> @variable(model, y[W] >= 0, Infinite(Î¾), start = 0)\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:4\nAnd data, a 4-element Vector{GeneralVariableRef}:\n y[1](Î¾)\n y[2](Î¾)\n y[3](Î¾)\n y[4](Î¾)","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Notice that we specify the initial guess for all of them via start. We also  can symbolically define variable conditions like the lower bound on y.","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"That does it for this example, but other problems might also employ the following:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Finite variables: variables that do not depend on infinite parameters  (defined using @variable)\nSemi-infinite variables: infinite variables where 1 or more parameters are  set a particular point (defined via Restricted Variables).\nPoint variables: infinite variables at a particular point (defined via Restricted Variables).","category":"page"},{"location":"tutorials/quick_start/#Objective-and-Constraints","page":"Quick Start","title":"Objective & Constraints","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Now that the variables and parameters are ready to go, let's define our problem.  First, we can define the objective using  @objective:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> @objective(model, Min, integral(sum(u[i]^2 for i in I), t))\nâˆ«{t âˆˆ [0, 60]}[u[1](t)Â² + u[2](t)Â²]","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Notice that we also employ integral to define the integral. Note that  objectives must evaluate over all included infinite domains. ","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Now let's define the initial conditions using  @constraint  in combination with Restricted Variables which will restrict the domain  of the variables to only be enforced at the initial time:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> @constraint(model, [i in I], x[i](0, Î¾) == x0[i])\n1-dimensional DenseAxisArray{InfOptConstraintRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{InfOptConstraintRef}:\n x[1](0, Î¾) = 0, âˆ€ Î¾ ~ Normal\n x[2](0, Î¾) = 0, âˆ€ Î¾ ~ Normal\n\njulia> @constraint(model, [i in I], v[i](0, Î¾) == v0[i])\n1-dimensional DenseAxisArray{InfOptConstraintRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{InfOptConstraintRef}:\n v[1](0, Î¾) = 0, âˆ€ Î¾ ~ Normal\n v[2](0, Î¾) = 0, âˆ€ Î¾ ~ Normal","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Note it is important that we include appropriate boundary conditions when using  derivatives in our model. For more information please see  Derivative Operators.","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Next, we can add our model constraints that have derivatives using  @constraint  and deriv:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> @constraint(model, c1[i in I], deriv(x[i], t) == v[i])\n1-dimensional DenseAxisArray{InfOptConstraintRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{InfOptConstraintRef}:\n c1[1] : âˆ‚/âˆ‚t[x[1](t, Î¾)] - v[1](t, Î¾) = 0, âˆ€ t âˆˆ [0, 60], Î¾ ~ Normal\n c1[2] : âˆ‚/âˆ‚t[x[2](t, Î¾)] - v[2](t, Î¾) = 0, âˆ€ t âˆˆ [0, 60], Î¾ ~ Normal\n\njulia> @constraint(model, c2[i in I], Î¾ * deriv(v[i], t) == u[i])\n1-dimensional DenseAxisArray{InfOptConstraintRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{InfOptConstraintRef}:\n c2[1] : Î¾*âˆ‚/âˆ‚t[v[1](t, Î¾)] - u[1](t) = 0, âˆ€ t âˆˆ [0, 60], Î¾ ~ Normal\n c2[2] : Î¾*âˆ‚/âˆ‚t[v[2](t, Î¾)] - u[2](t) = 0, âˆ€ t âˆˆ [0, 60], Î¾ ~ Normal","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Next, we can define our last 2 constraints:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> @constraint(model, c3[w in W], y[w] == sum((x[i](tw[w], Î¾) - p[i, w])^2 for i in I))\n1-dimensional DenseAxisArray{InfOptConstraintRef,1,...} with index sets:\n    Dimension 1, 1:4\nAnd data, a 4-element Vector{InfOptConstraintRef}:\n c3[1] : -x[1](0, Î¾)Â² - x[2](0, Î¾)Â² + y[1](Î¾) + 2 x[1](0, Î¾) + 2 x[2](0, Î¾) = 2, âˆ€ Î¾ ~ Normal\n c3[2] : -x[1](25, Î¾)Â² - x[2](25, Î¾)Â² + y[2](Î¾) + 8 x[1](25, Î¾) + 6 x[2](25, Î¾) = 25, âˆ€ Î¾ ~ Normal\n c3[3] : -x[1](50, Î¾)Â² - x[2](50, Î¾)Â² + y[3](Î¾) + 12 x[1](50, Î¾) = 36, âˆ€ Î¾ ~ Normal\n c3[4] : -x[1](60, Î¾)Â² - x[2](60, Î¾)Â² + y[4](Î¾) + 2 x[1](60, Î¾) + 2 x[2](60, Î¾) = 2, âˆ€ Î¾ ~ Normal\n\njulia> @constraint(model, c4, expect(sum(y[w] for w in W), Î¾) <= Ïµ)\nc4 : ð”¼{Î¾}[y[1](Î¾) + y[2](Î¾) + y[3](Î¾) + y[4](Î¾)] - Ïµ â‰¤ 0","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Notice we are able to invoke an expectation simply by calling expect.","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Finally, to address any unwanted degrees of freedom introduced by internal collocation  nodes with OrthogonalCollocation. We should call constant_over_collocation  on any control variables:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> constant_over_collocation.(u, t);\n","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"That's it, now we have our problem defined in InfiniteOpt!","category":"page"},{"location":"tutorials/quick_start/#Solution-and-Queries","page":"Quick Start","title":"Solution & Queries","text":"","category":"section"},{"location":"tutorials/quick_start/#Optimize","page":"Quick Start","title":"Optimize","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Now that our model is defined, let's optimize it via optimize!:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> optimize!(model)\n","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"We can check the solution status via  termination_status:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Thus, our model was solved successfully! For more information please see our  Optimization and Results pages.","category":"page"},{"location":"tutorials/quick_start/#Query-the-Solution","page":"Quick Start","title":"Query the Solution","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Finally, we can query a wide variety of information about our solution. Perhaps  most commonly we'll want to know the objective value and the optimal primal values  of decision variables. This is accomplished via  objective_value and  value:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> opt_obj = objective_value(model);\n\njulia> u_opt = value.(u);","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Note that u_opt will be multi-dimensional combination with the support values used  to transcribe u(t) along the domain of t. We can query those corresponding  support values via supports:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> u_ts = supports.(u)\n1-dimensional DenseAxisArray{Vector{Tuple},1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Vector{Vector{Tuple}}:\n [(0.0,), (1.0,), (2.0,), (3.0,), (4.0,), (5.0,), (6.0,), (7.0,), (8.0,), (9.0,)  â€¦  (51.0,), (52.0,), (53.0,), (54.0,), (55.0,), (56.0,), (57.0,), (58.0,), (59.0,), (60.0,)]\n [(0.0,), (1.0,), (2.0,), (3.0,), (4.0,), (5.0,), (6.0,), (7.0,), (8.0,), (9.0,)  â€¦  (51.0,), (52.0,), (53.0,), (54.0,), (55.0,), (56.0,), (57.0,), (58.0,), (59.0,), (60.0,)]","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"Please see the Results page for more information. ","category":"page"},{"location":"tutorials/quick_start/#Summary-Script","page":"Quick Start","title":"Summary Script","text":"","category":"section"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"The example used in the sections above is summarized in the script below:","category":"page"},{"location":"tutorials/quick_start/","page":"Quick Start","title":"Quick Start","text":"using InfiniteOpt, Distributions, Ipopt\n\n# DEFINE THE PROBLEM CONSTANTS\nÎ¼ = 1; Ïƒ = 0.2\nx0 = [0, 0]; v0 = [0, 0]\np = [1 4 6 1; 1 3 0 1]; tw = [0, 25, 50, 60]\nI = 1:2; W = 1:4\n\n# INITIALIZE THE MODEL\nmodel = InfiniteModel(Ipopt.Optimizer)\n\n# INITIALIZE THE PARAMETERS\n@finite_parameter(model, Ïµ == 10)\n@infinite_parameter(model, t in [0, 60], num_supports = 61, \n                    derivative_method = OrthogonalCollocation(3))\n@infinite_parameter(model, Î¾ ~ Normal(Î¼, Ïƒ^2), num_supports = 10)\n\n# INITIALIZE THE VARIABLES\n@variable(model, x[I], Infinite(t, Î¾), start = 0)\n@variable(model, v[I], Infinite(t, Î¾), start = 0)\n@variable(model, u[I], Infinite(t), start = 0)\n@variable(model, y[W] >= 0, Infinite(Î¾), start = 0)\n\n# SET THE OBJECTIVE\n@objective(model, Min, integral(sum(u[i]^2 for i in I), t))\n\n# SET THE INITIAL CONDITIONS\n@constraint(model, [i in I], x[i](0, Î¾) == x0[i])\n@constraint(model, [i in I], v[i](0, Î¾) == v0[i])\n\n# SET THE PROBLEM CONSTRAINTS\n@constraint(model, c1[i in I], @deriv(x[i], t) == v[i])\n@constraint(model, c2[i in I], Î¾ * @deriv(v[i], t) == u[i])\n@constraint(model, c3[w in W], y[w] == sum((x[i](tw[w], Î¾) - p[i, w])^2 for i in I))\n@constraint(model, c4, expect(sum(y[w] for w in W), Î¾) <= Ïµ)\n\n# ADJUST DEGREES OF FREEDOM FOR CONTROL VARIABLES\nconstant_over_collocation.(u, t)\n\n# SOLVE THE MODEL\noptimize!(model)\n\n# GET THE RESULTS\ntermination_status(model)\nopt_obj = objective_value(model)\nu_opt = value.(u)\nu_ts = supports.(u)","category":"page"},{"location":"manual/extensions/#ext_manual","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"A technical manual for extension packages natively hosted by InfiniteOpt. See the  respective guide for more information.","category":"page"},{"location":"manual/extensions/#InfiniteInterpolations","page":"Extensions","title":"InfiniteInterpolations","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"Enabled via import InfiniteOpt, Interpolations.","category":"page"},{"location":"manual/extensions/#JuMP.value-Tuple{Union{GeneralVariableRef, InfOptConstraintRef, GenericAffExpr{Float64, GeneralVariableRef}, GenericNonlinearExpr{GeneralVariableRef}, GenericQuadExpr{Float64, GeneralVariableRef}}, Interpolations.InterpolationType}","page":"Extensions","title":"JuMP.value","text":"JuMP.value(\n    ref::Union{GeneralVariableRef, JuMP.AbstractJuMPScalar, InfOptConstraintRef},\n    method::Union{Interpolations.InterpolationType, Interpolations.Degree};\n    [kwargs...]\n)::Interpolations.Extrapolation\n\nExtend JuMP.value to return ref as an interpolation object from Interpolations.jl, based on method which specifies the interpolation method.  Currently supported method(s) are:\n\nconstant_interpolation or Constant()\nlinear_interpolation or Linear()\ncubic_spline_interpolation or Cubic()\n\nAll methods support equidistant grid points. However, nonequidistant discretization grids are not compatible with cubic splines.\n\nExamples\n\njulia> y_interp_func = value(y, cubic_spline_interpolation)\n\njulia> y_interp_func(5.4);\n42.0\n\njulia> y_interp_func2 = value(y, Cubic())\n\njulia> y_interp_func2(5.4)\n42.0\n\n\n\n\n\n","category":"method"},{"location":"manual/extensions/#InfiniteMathOptAI","page":"Extensions","title":"InfiniteMathOptAI","text":"","category":"section"},{"location":"manual/extensions/","page":"Extensions","title":"Extensions","text":"Enabled via import InfiniteOpt, MathOptAI.","category":"page"},{"location":"manual/extensions/#MathOptAI.add_variables","page":"Extensions","title":"MathOptAI.add_variables","text":"function MathOptAI.add_variables(\n    model::InfiniteModel, x::Vector{GeneralVariableRef},\n    n::Int,\n    base_name::String,\n)::Vector{GeneralVariableRef}\n\nExtend MathOptAI.add_variables to properly support infinite variables (i.e., ensure the output variables of a predictor have the necessary infinite parameter dependencies). This method should not be directly used by users, it is used to enable the use of  MathOptAI.add_predictor.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#transcription_manual","page":"TranscriptionOpt","title":"TranscriptionOpt","text":"","category":"section"},{"location":"manual/transcribe/","page":"TranscriptionOpt","title":"TranscriptionOpt","text":"A technical manual for InfiniteOpt.TranscriptionOpt (the default transformation  backend). See the respective guide for more information.","category":"page"},{"location":"manual/transcribe/#Definition","page":"TranscriptionOpt","title":"Definition","text":"","category":"section"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionBackend","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.TranscriptionBackend","text":"TranscriptionBackend(\n    [optimizer_constructor];\n    [add_bridges::Bool = true],\n    [update_parameter_functions::Bool = false]\n)::InfiniteOpt.JuMPBackend{Transcription}\n\nReturn an InfiniteOpt.JuMPBackend that uses TranscriptionData  and the Transcription tag. Accepts the same arguments as a typical  JuMP.Model. Optionally, transcribe parameter functions using JuMP.Parameter such that they can be updated for more efficient resolves by setting  update_parameter_functions = true.\n\nExample\n\njulia> backend = TranscriptionBackend();\n\n\n\n\n\n","category":"type"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionData","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.TranscriptionData","text":"TranscriptionData\n\nA DataType for storing the data mapping an InfiniteOpt.InfiniteModel that has been transcribed to a regular JuMP.Model that contains the transcribed variables. This is stored in the data field of  InfiniteOpt.JuMPBackend to make what is called a TranscriptionBackend  via the TranscriptionBackend constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.Transcription","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.Transcription","text":"Transcription <: InfiniteOpt.AbstractJuMPTag\n\nDispatch tag needed for TranscriptionBackend to be based on  InfiniteOpt.JuMPBackend.\n\n\n\n\n\n","category":"type"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.set_parameter_supports","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.set_parameter_supports","text":"set_parameter_supports(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nCollect the infinite parameter supports stored in their respective dictionaries form model and process them into a tuple of vectors where each vector contains the collected supports of a particular infinite parameter. These support collections are ordered in accordance with the definition order of the parameters (i.e., their group integer indices). A support collection assocciated with an independent will be a Vector{Float64} and a support collection associated with a group of dependent parameters will be a Vector{Vector{Float64}}. Note that each collection vector will include an extra final placeholder element comprised of NaNs for convenience in generating support indices via support_index_iterator. This also gathers the associated support labels. \n\nBefore this is all done, InfiniteOpt.add_generative_supports is invoked as needed.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_finite_parameters!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_finite_parameters!","text":"transcribe_finite_parameters!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nCreate a transcription variable (i.e., a JuMP Parameter) for each FiniteParameter stored in model and add it to backend. The variable mapping is also stored in TranscriptionData.finvar_mappings which enables transcription_variable and lookup_by_support.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_finite_variables!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_finite_variables!","text":"transcribe_finite_variables!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nCreate a transcription variable (i.e., a JuMP variable) for each FiniteVariable stored in model and add it to backend. The variable mapping is also stored in TranscriptionData.finvar_mappings which enables transcription_variable and lookup_by_support.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!","text":"transcribe_infinite_variables!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nCreate transcription variables (i.e., JuMP variables) for each InfiniteVariable stored in model and add them to backend. The variable mappings are also stored in TranscriptionData.infvar_mappings in accordance with TranscriptionData.infvar_lookup which enable transcription_variable and lookup_by_support. Note that the supports will not be generated until InfiniteOpt.variable_supports is invoked via InfiniteOpt.supports.  Note that TranscriptionData.infvar_support_labels is also populated.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_parameter_functions!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_parameter_functions!","text":"transcribe_parameter_functions!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nCreate transcription variables (i.e., JuMP Parameters) corresponding to  all supports of each Parameter Function stored in model and add them to  backend. The variable mappings are also stored in  TranscriptionData.infvar_mappings in accordance with  TranscriptionData.infvar_lookup which enable transcription_variable and lookup_by_support. Note that the supports will not be generated until InfiniteOpt.variable_supports is invoked via InfiniteOpt.supports.  Note that TranscriptionData.infvar_support_labels is also populated.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!","text":"transcribe_derivative_variables!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nCreate transcription variables (i.e., JuMP variables) for each Derivative stored in model and add them to backend. The variable mappings are also stored in TranscriptionData.infvar_mappings in accordance with TranscriptionData.infvar_lookup which enable transcription_variable and lookup_by_support. Note that the supports will not be generated until InfiniteOpt.variable_supports is invoked via InfiniteOpt.supports. The  futher derivative evaluation constraints are added when  transcribe_derivative_evaluations! is invoked. Note that  TranscriptionData.infvar_support_labels is also populated.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_semi_infinite_variables!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_semi_infinite_variables!","text":"transcribe_semi_infinite_variables!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nMap each SemiInfiniteVariable in model to transcription variables stored in backend. The variable mappings are also stored in TranscriptionData.infvar_mappings in accordance with TranscriptionData.infvar_lookup which enable transcription_variable and lookup_by_support. Note that transcribe_infinite_variables! must be called first. Note that the supports will not be generated until InfiniteOpt.variable_supports is invoked via InfiniteOpt.supports.  Note that TranscriptionData.infvar_support_labels is also populated.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_point_variables!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_point_variables!","text":"transcribe_point_variables!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nMap each PointVariable in model to a transcription variable stored in backend. The variable mapping is also stored in TranscriptionData.finvar_mappings which enables transcription_variable and lookup_by_support. Note that transcribe_infinite_variables! must be called first and that the info constraints associated with the transcription variable will be updated in accordance with the point variable.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_expression","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcription_expression","text":"transcription_expression(\n    expr::JuMP.AbstractJuMPScalar,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nReturn the transcribed expression(s) corresponding to expr. Errors if expr cannot be transcribed. Also can query via the syntax:\n\ntranscription_expression(\n    expr::JuMP.AbstractJuMPScalar;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nIf the infinite model contains a built transcription backend. By default, this method returns only transcribed expressions associated with public supports. All the  expressions can be returned by setting label = All.\n\nIf expr is infinite, then label will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.\n\nExample\n\njulia> transcription_expression(my_expr, backend)\nx[1] - y\n\njulia> transcription_expression(my_expr)\nx[1] - y\n\n\n\n\n\ntranscription_expression(\n    expr,\n    backend::TranscriptionBackend,\n    support::Vector{Float64}\n    )\n\nGiven the expr from an InfiniteModel, form its transcripted version in accordance with the variable mappings available in backend defined at support. This should only be used once all variables and measures have been transcribed (e.g., via transcribe_finite_variables!).\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_measures!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_measures!","text":"transcribe_measures!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nFor each Measure in model expand it via InfiniteOpt.expand_measure or analytic_expansion as appropriate and transcribe the expanded expression via transcription_expression. Then store the measure to transcripted expression mappings in TranscriptionData.measure_mappings and TranscriptionData.measure_lookup to enable transcription_variable and lookup_by_support. Note that the supports will not be generated until InfiniteOpt.variable_supports is invoked via InfiniteOpt.supports.  Note that TranscriptionData.measure_support_labels is also populated.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_objective!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_objective!","text":"transcribe_objective!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nForm the transcripted version of the objective stored in model and add it to backend. Note that all the variables and measures in model must by transcripted first (e.g., via transcribe_infinite_variables!).\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_constraints!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_constraints!","text":"transcribe_constraints!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nFor each constraint in model form its transcripted version(s) and add them to backend. The mappings are stored in TranscriptionData.constr_mappings and the associated supports are stored in TranscriptionData.constr_supports to enable transcription_constraint and InfiniteOpt.constraint_supports. Note that variable info constraints are simply mapped to the existing info constraints already generated along with the transcription variables. Note that the variables and measures must all first be transcripted (e.g., via transcribe_measures!). Note that  TranscriptionData.constr_support_labels is also populated.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!","text":"transcribe_derivative_evaluations!(\n    backend::TranscriptionBackend, \n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nGenerate the auxiliary derivative evaluation equations and transcribe them  appropriately for all the derivatives in model. These are in turn added to  backend. Note that no mapping information is recorded since the InfiniteModel  won't have any constraints that correspond to these equations. Also note that the variables and measures must all first be transcripted (e.g., via transcribe_derivative_variables!).\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_variable_collocation_restictions!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcribe_variable_collocation_restictions!","text":"transcribe_variable_collocation_restictions!(\n    backend::TranscriptionBackend, \n    model::InfiniteOpt.InfiniteModel\n)::Nothing\n\nAdd constraints to backend that make infinite variables constant over collocation  points following the calls made to InfiniteOpt.constant_over_collocation. Note that  set_parameter_supports and transcribe_infinite_variables! must be called first.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.build_transcription_backend!","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.build_transcription_backend!","text":"build_transcription_backend!(\n    backend::TranscriptionBackend,\n    model::InfiniteOpt.InfiniteModel;\n    [check_support_dims::Bool = true]\n)::Nothing\n\nGiven an empty backend build it using the information stored in model. This is intended for a TranscriptionModel that serves as a internal transformation backend of model. This detail is important to correctly enable internally generated semi-infinite variables during the transcription process such that model is not modified. Note that this will add supports to model via InfiniteOpt.fill_in_supports! for infinite parameters that contain no supports. Also a warning is thrown when the transcription backend contains more than 15,000 support points to alert users when they may naively have a few independent supports whose product quickly yields a very large grid. For example having 3 independent parameters with 100 supports each would result in 1,000,000 supports if all three are together in at least 1 constraint. This  behavior can be overcome using dependent parameters. The warning can be turned off  via check_support_dims = false.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.add_point_variable-Tuple{TranscriptionBackend, PointVariable}","page":"TranscriptionOpt","title":"InfiniteOpt.add_point_variable","text":"InfiniteOpt.add_point_variable(\n    backend::TranscriptionBackend,\n    var::InfiniteOpt.PointVariable\n)::InfiniteOpt.GeneralVariableRef\n\nMake a PointVariableRef and map it to the appropriate transcription variable and return the GeneralVariableRef. This is an extension of add_point_variable for TranscriptionOpt.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.add_semi_infinite_variable-Tuple{TranscriptionBackend, SemiInfiniteVariable}","page":"TranscriptionOpt","title":"InfiniteOpt.add_semi_infinite_variable","text":"InfiniteOpt.add_semi_infinite_variable(\n    backend::TranscriptionBackend,\n    var::InfiniteOpt.SemiInfiniteVariable\n    )::InfiniteOpt.GeneralVariableRef\n\nMake a SemiInfiniteVariableRef and add var to the transcription data  and return the GeneralVariableRef. This is an extension of  add_semi_infinite_variable  for TranscriptionOpt. Note that internal_semi_infinite_variable is also  extended to be able to access the var.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.build_transformation_backend!-Tuple{InfiniteModel, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.build_transformation_backend!","text":"InfiniteOpt.build_transformation_backend!(\n    model::InfiniteOpt.InfiniteModel,\n    backend::TranscriptionBackend;\n    check_support_dims::Bool = true\n)::Nothing\n\nBuild backend and set it as the transformation backend to model. Ths clears out the existing backend and rebuilds it. Optionally,  the dimension check to through a warning if there is potentially  a very large number of supports can be turned off via  check_support_dims = false.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#Queries","page":"TranscriptionOpt","title":"Queries","text":"","category":"section"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_data","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcription_data","text":"transcription_data(backend::TranscriptionBackend)::TranscriptionData\n\nReturn the mapping data used by backend.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.has_internal_supports","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.has_internal_supports","text":"has_internal_supports(backend::TranscriptionBackend)::Bool\n\nReturn a Bool whether backend has any internal supports that were collected.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{GeneralVariableRef, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcription_variable","text":"transcription_variable(\n    vref::InfiniteOpt.GeneralVariableRef,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n     )\n\nReturn the transcribed variable reference(s) corresponding to vref. Errors if no transcription variable is found. Also can query via the syntax:\n\ntranscription_variable(\n    vref::InfiniteOpt.GeneralVariableRef;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nIf the infinite model contains a built TranscriptionBackend. By default, this method returns only transcribed variables associated with public supports. All the  variables can be returned by setting label = All. \n\nIf vref is infinite, then label will be used to search the intersection of variable  supports that use the label. This is defers from the default behavior which  considers the union.\n\nExample\n\njulia> transcription_variable(infvar, trans_backend)\n2-element Array{VariableRef,1}:\n infvar[1]\n infvar[2]\n\njulia> transcription_variable(hdvar, trans_backend)\nhdvar\n\njulia> transcription_variable(infvar)\n2-element Array{VariableRef,1}:\n infvar[1]\n infvar[2]\n\njulia> transcription_variable(hdvar)\nhdvar\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.transformation_variable-Tuple{GeneralVariableRef, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.transformation_variable","text":"InfiniteOpt.transformation_variable(\n    vref::InfiniteOpt.GeneralVariableRef,\n    [backend::TranscriptionBackend];\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nProper extension of InfiniteOpt.transformation_variable for TranscriptionBackends. This simply dispatches to transcription_variable.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.variable_supports-Tuple{Union{InfiniteVariableRef, SemiInfiniteVariableRef}, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.variable_supports","text":"InfiniteOpt.variable_supports(\n    vref::InfiniteOpt.DecisionVariableRef,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nReturn the support alias mapping associated with vref in the transcription backend. Errors if vref does not have transcripted variables.\n\n\n\n\n\nvariable_supports(\n    vref::DecisionVariableRef,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nReturn the supports associated with the mappings of vref in backend. This dispatches off of backend which permits transformation backend extensions. This should throw an error if vref is not associated with the variable mappings stored in backend. Keyword arguments can be added as needed. Note that no extension is necessary for point or finite variables. \n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{GeneralVariableRef, TranscriptionBackend, Vector}","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.lookup_by_support","text":"lookup_by_support(\n    vref::InfiniteOpt.GeneralVariableRef,\n    backend::TranscriptionBackend,\n    support::Vector\n    )\n\nReturn the transcription expression of vref defined at its support. This is intended as a helper method for automated transcription.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.internal_semi_infinite_variable-Tuple{SemiInfiniteVariableRef, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.internal_semi_infinite_variable","text":"InfiniteOpt.internal_semi_infinite_variable(\n    vref::InfiniteOpt.SemiInfiniteVariableRef,\n    backend::TranscriptionBackend\n    )::InfiniteOpt.SemiInfiniteVariable{InfiniteOpt.GeneralVariableRef}\n\nReturn the internal semi-infinite variable associated with vref, assuming it was added internally during measure expansion at the transcription step. This extends InfiniteOpt.internal_semi_infinite_variable as described in its docstring. Errors, if no such variable can be found.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_expression-Tuple{Union{GenericAffExpr, GenericQuadExpr}, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcription_expression","text":"transcription_expression(\n    expr::JuMP.AbstractJuMPScalar,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nReturn the transcribed expression(s) corresponding to expr. Errors if expr cannot be transcribed. Also can query via the syntax:\n\ntranscription_expression(\n    expr::JuMP.AbstractJuMPScalar;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nIf the infinite model contains a built transcription backend. By default, this method returns only transcribed expressions associated with public supports. All the  expressions can be returned by setting label = All.\n\nIf expr is infinite, then label will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.\n\nExample\n\njulia> transcription_expression(my_expr, backend)\nx[1] - y\n\njulia> transcription_expression(my_expr)\nx[1] - y\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.transformation_expression-Tuple{Union{GenericAffExpr, GenericNonlinearExpr, GenericQuadExpr}, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.transformation_expression","text":"InfiniteOpt.transformation_expression(\n    expr::JuMP.AbstractJuMPScalar,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nProper extension of InfiniteOpt.transformation_expression for TranscriptionBackends. This simply dispatches to transcription_expression.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.expression_supports-Tuple{Union{GenericAffExpr, GenericQuadExpr}, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.expression_supports","text":"InfiniteOpt.expression_supports(\n    expr::JuMP.AbstractJuMPScalar,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nReturn the support alias mappings associated with expr. Errors if expr cannot be transcribed.\n\n\n\n\n\nexpression_supports(\n    expr,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nReturn the supports associated with the mappings of expr in backend. This should throw an error if expr is not associated with the variable mappings stored in backend. Keyword arguments can be added as needed. Note that if expr is a GeneralVariableRef this just dispatches to variable_supports.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{InfOptConstraintRef, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.transcription_constraint","text":"transcription_constraint(\n    cref::InfiniteOpt.InfOptConstraintRef,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nReturn the transcribed constraint reference(s) corresponding to cref. Errors if cref has not been transcribed. Also can query via the syntax:\n\ntranscription_constraint(\n    cref::InfiniteOpt.InfOptConstraintRef;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nIf the infinite model contains a built transcription backend. By default, this method returns only transcribed constraints associated with public supports. All the  constraints can be returned by setting label = All.\n\nIf cref is infinite, then label will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.\n\nExample\n\njulia> transcription_constraint(fin_con, backend)\nfin_con : x[1] - y <= 3.0\n\njulia> transcription_constraint(fin_con)\nfin_con : x[1] - y <= 3.0\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.transformation_constraint-Tuple{InfOptConstraintRef, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.transformation_constraint","text":"InfiniteOpt.transformation_constraint(\n    cref::InfiniteOpt.InfOptConstraintRef,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel]\n    )\n\nProper extension of InfiniteOpt.transformation_constraint for TranscriptionBackends. This simply dispatches to transcription_constraint.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.constraint_supports-Tuple{InfOptConstraintRef, TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.constraint_supports","text":"InfiniteOpt.constraint_supports(\n    cref::InfiniteOpt.InfOptConstraintRef,\n    backend::TranscriptionBackend;\n    [label::Type{<:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel])\n\nReturn the support alias mappings associated with cref. Errors if cref is not transcribed.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.parameter_supports-Tuple{TranscriptionBackend}","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.parameter_supports","text":"parameter_supports(backend::TranscriptionBackend)::Tuple\n\nReturn the collected parameter support tuple that is stored in TranscriptionData.supports.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#Updates","page":"TranscriptionOpt","title":"Updates","text":"","category":"section"},{"location":"manual/transcribe/#InfiniteOpt.update_parameter_value-Tuple{TranscriptionBackend, FiniteParameterRef, Real}","page":"TranscriptionOpt","title":"InfiniteOpt.update_parameter_value","text":"InfiniteOpt.update_parameter_value(\n    backend::TranscriptionBackend,\n    fref::InfiniteOpt.FiniteParameterRef,\n    value::Real\n)::Bool\n\nUpdate the value of the finite parameter referenced by fref in backend to value. Returns true if the parameter was found and updated, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#InfiniteOpt.update_parameter_value-Tuple{TranscriptionBackend, ParameterFunctionRef, Function}","page":"TranscriptionOpt","title":"InfiniteOpt.update_parameter_value","text":"InfiniteOpt.update_parameter_value(\n    backend::TranscriptionBackend,\n    pfref::InfiniteOpt.ParameterFunctionRef,\n    value::Function\n)::Bool\n\nUpdate the values of the parameter function referenced by pfref in backend to be evaluated via value. Returns true if the parameter function was found and updated, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"manual/transcribe/#Utilities","page":"TranscriptionOpt","title":"Utilities","text":"","category":"section"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.support_index_iterator","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.support_index_iterator","text":"support_index_iterator(backend::TranscriptionBackend, [group_int_idxs::Vector{Int}])::CartesianIndices\n\nReturn the CartesianIndices that determine the indices of the unique combinations of TranscriptionData.supports stored in backend. If group_int_idxs is specified, then the indices will only include the tuple elements uses indices are included in the parameter group integer indices group_int_idxs and all others will be assigned the last index which should correspond to an appropriately sized placeholder comprised of NaNs. Note this method assumes that set_parameter_supports has already been called and that the last elements of each support vector contains a placeholder value.\n\n\n\n\n\n","category":"function"},{"location":"manual/transcribe/#InfiniteOpt.TranscriptionOpt.index_to_support","page":"TranscriptionOpt","title":"InfiniteOpt.TranscriptionOpt.index_to_support","text":"index_to_support(backend::TranscriptionBackend, index::CartesianIndex)::Vector{Float64}\n\nGiven a particular support index generated via support_index_iterator using backend, return the corresponding support from TranscriptionData.supports using placeholder NaNs as appropriate for tuple elements that are unneeded.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#expr_manual","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"manual/expression/","page":"Expressions","title":"Expressions","text":"A technical manual for variable expressions in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/expression/#par_func_manual","page":"Expressions","title":"Parameter Functions","text":"","category":"section"},{"location":"manual/expression/#Definition","page":"Expressions","title":"Definition","text":"","category":"section"},{"location":"manual/expression/#InfiniteOpt.@parameter_function","page":"Expressions","title":"InfiniteOpt.@parameter_function","text":"@parameter_function(model::InfiniteModel, func_expr, kwargs...)\n\nAdd an anonymous parameter function to the model model described by the keyword arguments kw_args and returns the object reference.\n\n@parameter_function(model::InfiniteModel, var_expr == func_expr, kwargs...)\n\nAdd a parameter function to model described by the expression var_expr, the function expression func_expr, and the keyword arguments kwargs. The  expression var_expr is used to define the parameter function references of the  form varname[...] where the indexing matches the container syntax of other  macros.\n\nThe expression func_expr determines the concrete Julia function that defines the  behavior of parameter function and also specifies the infinite parameters it  depends on. The accepted forms are:\n\nfunc(params...): where func is the function that takes supports of the  infinite parameters params as input and outputs a scalar value.\n(params...) -> my_func_expr: where params are the infinite parameters and  my_func_expr is the source code of the anonymous function.\n\nThe recognized keyword arguments in kwargs are the following:\n\nbase_name: Sets the name prefix used to generate object names. It corresponds to the object name for scalar parameter function, otherwise, the object names are set to base_name[...] for each index ... of the axes axes.\ncontainer: Specify the container type. Defaults to :Auto.\n\nExamples\n\njulia> @parameter_function(model, sin(t))\nsin(t)\n\njulia> func_vect = [sin, cos];\n\njulia> @parameter_function(model, [i = 1:2] == func_vect[i](t))\n2-element Array{GeneralVariableRef,1}:\n sin(t)\n cos(t)\n\njulia> f(t_val, x_vals) = t_val + sum(x_vals)\nf (generic function with 1 method)\n\njulia> @parameter_function(model, pf == f(t, x))\npf(t, x)\n\njulia> g(t_val, a; b = 0) = t_val + a + b\ng (generic function with 1 method)\n\njulia> @parameter_function(model, pf2[i = 1:2] == t -> g(t, i, b = 2 * i ))\n2-element Array{GeneralVariableRef,1}:\n pf2[1](t)\n pf2[2](t)\n\n\n\n\n\n","category":"macro"},{"location":"manual/expression/#InfiniteOpt.parameter_function","page":"Expressions","title":"InfiniteOpt.parameter_function","text":"parameter_function(\n    func::Function, \n    pref_inputs::Union{GeneralVariableRef, Array{GeneralVariableRef}, Tuple}; \n    [name::String = [the name of `func`]]\n)::GeneralVariableRef\n\nMake a parameter function and return a GeneralVariableRef that can be  embedded in InfiniteOpt expressions. This serves as a convenient wrapper for  build_parameter_function and add_parameter_function. For an  even more convenient definition method see @parameter_function.\n\nHere func denotes the function that will take a support of infinite parameters as  input (formatted like pref_inputs) and will return a scalar value. Specifically,  func should be of the form:\n\nfunc(paramvals...)::Union{Real, Bool}\n\nwhere the formatting of paramvals is analagous to point variables (and will be  based on the tuple of infinite parameter references given in parameter_refs). Moreover, func must be a function that returns a scalar numeric value. \n\nErrors if func will not take a support formatted like pref_inputs in  combination with the fargs and fkwargs specified. Also errors if pref_inputs  follow an invalid input format.\n\nExample\n\njulia> p_func = parameter_function(sin, t)\nsin(t)\n\njulia> p_func3 = parameter_function((t_supp) -> 2 * sin(2 * t_supp), t, name = \"mysin\")\nmysin(t)\n\njulia> p_func4 = parameter_function(t, name = \"mysin\") do t_supp\n                    if t_supp <= 5\n                        return sin(t_supp)\n                    else \n                        return 2 * sin(2 * t_supp)\n                    end\n                 end\n\nmysin(t)\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.build_parameter_function","page":"Expressions","title":"InfiniteOpt.build_parameter_function","text":"build_parameter_function(\n    _error::Function, \n    func::Function, \n    parameter_refs::Union{GeneralVariableRef, Array{<:GeneralVariableRef}, Tuple}\n)::ParameterFunction\n\nBuild an ParameterFunction object that employs a parameter function  func that takes instances of the infinite parameter(s) as input. This can  ultimately by incorporated into expressions to enable nonlinear infinite parameter  behavior and/or incorporate data over infinite domains.\n\nHere func should be of the form:\n\nfunc(paramvals...)::Union{Real, Bool}\n\nwhere the formatting of paramvals is analagous to point variables (and will be  based on the tuple of infinite parameter references given in parameter_refs). \n\nErrors if the infinite parameter tuple is formatted incorrectly. The allowed  format follows that of infinite variables. Also errors if the function doesn't  accept a support realization of the parameter_refs as input.\n\nExample\n\njulia> f = build_parameter_function(error, sin, t);\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.ParameterFunction","page":"Expressions","title":"InfiniteOpt.ParameterFunction","text":"ParameterFunction{F <: Function, T <: JuMP.AbstractVariableRef}\n\nA DataType for storing known functions of infinite parameters. These equate to arbitrary  functions that take support instances of infinite parameters parameter_refs in  as input and compute a scalar value as output via func. These can then can  incorporated in expressions via ParameterFunctionRefs.\n\nOnce constructed, these can be called directly and treated like hte functions they wrap:\n\n(pfunc::ParameterFunction)(support...)\n\nwhere support::Tuple matches the format of the corresponding tuple of infinite parameters (e.g., (t, x)). For developers, it is also convenient to pass the vectorized form of the support that comes from support::VectorTuple via:\n\n(pfunc::ParameterFunction)(vect_support::Vector{<:Real})\n\nFields\n\nfunc::F: The function the takes infinite parameters as input and provide a            scalar number as output.\nparameter_refs::Collections.VectorTuple{T}: The infinite parameter references that serve as                        inputs to func. Their formatting is analagous                        to those of infinite variables. \ngroup_int_idxs::Vector{Int}: The parameter group integer indices associated with parameter_refs.\n\n\n\n\n\n","category":"type"},{"location":"manual/expression/#InfiniteOpt.add_parameter_function","page":"Expressions","title":"InfiniteOpt.add_parameter_function","text":"add_parameter_function(\n    model::InfiniteModel,\n    pfunc::ParameterFunction, \n    [name::String]\n)::GeneralVariableRef\n\nAdd an ParameterFunction pfunc to the model using name for  printing and return a GeneralVariableRef such that it can be embedded in  expressions. Errors if the parameter function pfunc points to do not belong to  model. Note that pfunc should be created using build_parameter_function.\n\nExample\n\njulia> f = build_parameter_function(error, sin, t);\n\njulia> fref = add_parameter_function(model, f)\nsin(t)\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.ParameterFunctionData","page":"Expressions","title":"InfiniteOpt.ParameterFunctionData","text":"ParameterFunctionData{F <: ParameterFunction} <: AbstractDataObject\n\nA mutable DataType for storing ParameterFunctions and their data.\n\nFields\n\nfunc::F: The parameter function.\nname::String: The name used for printing.\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nconstraint_indices::Vector{InfOptConstraintIndex}: Indices of dependent constraints.\nsemi_infinite_var_indices::Vector{SemiInfiniteVariableIndex}: Indices of dependent semi-infinite variables.\npoint_var_indices::Vector{PointVariableIndex}: Indices of dependent point variables.\n\n\n\n\n\n","category":"type"},{"location":"manual/expression/#InfiniteOpt.ParameterFunctionIndex","page":"Expressions","title":"InfiniteOpt.ParameterFunctionIndex","text":"ParameterFunctionIndex <: ObjectIndex\n\nA DataType for storing the index of a ParameterFunction.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/expression/#InfiniteOpt.ParameterFunctionRef","page":"Expressions","title":"InfiniteOpt.ParameterFunctionRef","text":"ParameterFunctionRef <: DispatchVariableRef\n\nA DataType for infinite parameter function references.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::ParameterFunctionIndex: Index of the infinite parameter function.\n\n\n\n\n\n","category":"type"},{"location":"manual/expression/#Queries","page":"Expressions","title":"Queries","text":"","category":"section"},{"location":"manual/expression/#JuMP.name-Tuple{ParameterFunctionRef}","page":"Expressions","title":"JuMP.name","text":"JuMP.name(fref::ParameterFunctionRef)::String\n\nExtend JuMP.name to return the base name of fref.\n\nExample\n\njulia> name(fref)\n\"func_name\"\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.raw_function-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.raw_function","text":"raw_function(fref::ParameterFunctionRef)::Function\nraw_function(pfunc::ParameterFunction)::Function\n\nReturns the raw function behind fref that takes a particular support of fref's  infinite parameters as input. \n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.parameter_value-Tuple{ParameterFunctionRef}","page":"Expressions","title":"JuMP.parameter_value","text":"JuMP.parameter_value(fref::ParameterFunctionRef)::ParameterFunction\n\nReturn the current function assigned to fref. See also raw_function.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.call_function","page":"Expressions","title":"InfiniteOpt.call_function","text":"call_function(fref::ParameterFunctionRef, support...)::Float64\n\nSafely evaluates the raw_function of fref at a particular support support point that matches the format of the infinite parameter tuple given when the fref  was defined. This is essentially equivalent to raw_function(fref)(supps...). \n\n\n\n\n\ncall_function(fref::GeneralVariableRef, support...)::Float64\n\nCall the parameter function of fref at support. An ArgumentError is thrown if fref is not a parameter function.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.parameter_refs-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(fref::ParameterFunctionRef)::Tuple\n\nReturn the parameter references associated with fref. This is formatted as a Tuple of containing the parameter references as they inputted to define fref.\n\nExample\n\njulia> parameter_refs(p_func)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.parameter_list-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.parameter_list","text":"parameter_list(fref::ParameterFunctionRef)::Vector{GeneralVariableRef}\n\nReturn a vector of the parameter references that fref depends on. This is primarily an internal method where parameter_refs is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.raw_parameter_refs-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.raw_parameter_refs","text":"raw_parameter_refs(fref::ParameterFunctionRef)::VectorTuple\n\nReturn the raw VectorTuple of the  parameter references that fref depends on. This is primarily an internal method  where parameter_refs  is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.is_used-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.is_used","text":"is_used(fref::ParameterFunctionRef)::Bool\n\nReturn a Bool indicating if fref is used in the model.\n\nExample\n\njulia> is_used(fref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_semi_infinite_variable-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.used_by_semi_infinite_variable","text":"used_by_semi_infinite_variable(fref::ParameterFunctionRef)::Bool\n\nReturn a Bool indicating if fref is used by a semi-infinite infinite variable.\n\nExample\n\njulia> used_by_semi_infinite_variable(fref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_point_variable-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.used_by_point_variable","text":"used_by_point_variable(fref::ParameterFunctionRef)::Bool\n\nReturn a Bool indicating if fref is used by a point variable.\n\nExample\n\njulia> used_by_point_variable(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_measure-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(fref::ParameterFunctionRef)::Bool\n\nReturn a Bool indicating if fref is used by a measure.\n\nExample\n\njulia> used_by_measure(fref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_constraint-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(fref::ParameterFunctionRef)::Bool\n\nReturn a Bool indicating if fref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(fref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.parameter_group_int_indices-Tuple{ParameterFunctionRef}","page":"Expressions","title":"InfiniteOpt.parameter_group_int_indices","text":"parameter_group_int_indices(fref::ParameterFunctionRef)::Vector{Int}\n\nReturn the list of infinite parameter group integer indices used by fref.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.num_parameter_functions","page":"Expressions","title":"InfiniteOpt.num_parameter_functions","text":"num_parameter_functions(model::InfiniteModel)::Int\n\nReturns the number of parameter functions that have been defined in model.\n\nExample\n\njulia> num_parameter_functions(model)\n2\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.all_parameter_functions","page":"Expressions","title":"InfiniteOpt.all_parameter_functions","text":"all_parameter_functions(model::InfiniteModel)::Vector{GeneralVariableRef}\n\nReturns a list of all the individual parameter functions stored in model. \n\nExample\n\njulia> all_parameter_functions(model)\n3-element Array{GeneralVariableRef,1}:\n sin(t)\n cos(t)\n exp(t)\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#Modification","page":"Expressions","title":"Modification","text":"","category":"section"},{"location":"manual/expression/#JuMP.set_name-Tuple{ParameterFunctionRef, String}","page":"Expressions","title":"JuMP.set_name","text":"JuMP.set_name(fref::ParameterFunctionRef, name::String)::Nothing\n\nExtend JuMP.set_name to set the name of a parameter function.\n\nExample\n\njulia> set_name(fref, \"func_name\")\n\njulia> name(fref)\n\"func_name\"\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.set_parameter_value-Tuple{ParameterFunctionRef, Function}","page":"Expressions","title":"JuMP.set_parameter_value","text":"JuMP.set_parameter_value(\n    fref::ParameterFunctionRef, \n    func::Function\n)::Nothing\n\nUpdate the function used by fref to func. Errors if func does not accept the same infinite parameter format as the original function of fref. If possible, this will also update the transformation backend to enable efficient resolves.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.delete-Tuple{InfiniteModel, ParameterFunctionRef}","page":"Expressions","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, fref::ParameterFunctionRef)::Nothing\n\nExtend JuMP.delete to delete parameter functions and their dependencies. Errors  if fref is invalid, meaning it has already been deleted or it belongs to  another model.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#nlp_manual","page":"Expressions","title":"Nonlinear Expressions","text":"","category":"section"},{"location":"manual/expression/#DataTypes","page":"Expressions","title":"DataTypes","text":"","category":"section"},{"location":"manual/expression/#InfiniteOpt.NLPOperator","page":"Expressions","title":"InfiniteOpt.NLPOperator","text":"NLPOperator{F <: Function, G <: Union{Function, Nothing}, \n            H <: Union{Function, Nothing}}\n\nA type for storing new nonlinear operators and their information  that is ultimately for automatic differentiation. The constructor is of the form:\n\n    NLPOperator(name::Symbol, dim::Int, f::Function, \n                       [âˆ‡f::Function, âˆ‡Â²f::Function])\n\nFields\n\nname::Symbol: The name of the operator that is used.\ndim::Int: The number of function arguments.\nf::F: The function to evaluate the operator.\nâˆ‡f::G: The gradient function if one is given.\nâˆ‡Â²f::H: The hessian function if one is given.\n\n\n\n\n\n","category":"type"},{"location":"manual/expression/#Methods","page":"Expressions","title":"Methods","text":"","category":"section"},{"location":"manual/expression/#JuMP.add_nonlinear_operator","page":"Expressions","title":"JuMP.add_nonlinear_operator","text":"JuMP.add_nonlinear_operator(\n    model::InfiniteModel,\n    dim::Int,\n    f::Function,\n    [âˆ‡f::Function,]\n    [âˆ‡Â²f::Function];\n    [name::Symbol = Symbol(f)]\n)\n\nExtend add_nonlinear_operator for InfiniteModels.\n\nAdd a new nonlinear operator with dim input arguments to model and associate it with the name name. Alternatively, @operator can be used for a more convenient syntax.\n\nThe function f evaluates the operator. The optional function âˆ‡f evaluates the first derivative, and the optional function âˆ‡Â²f evaluates the second derivative. âˆ‡Â²f may be provided only if âˆ‡f is also provided.\n\njulia> @variable(model, y);\n\njulia> g(x) = x^2;\n\njulia> new_op = add_nonlinear_operator(model, 1, g)\nNonlinearOperator(g, :g)\n\njulia> @expression(model, new_op(y))\ng(y)\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.all_nonlinear_operators","page":"Expressions","title":"InfiniteOpt.all_nonlinear_operators","text":"all_nonlinear_operators(model::InfiniteModel)::Vector{Symbol}\n\nRetrieve all the operators that are currently added to model.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.name_to_operator","page":"Expressions","title":"InfiniteOpt.name_to_operator","text":"name_to_operator(model::InfiniteModel, name::Symbol)::Union{Function, Nothing}\n\nReturn the nonlinear operator that corresponds to name. Returns nothing if no such operator exists.\n\nwarning: Warning\nCurrently, this does not return functions for default operators.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.added_nonlinear_operators","page":"Expressions","title":"InfiniteOpt.added_nonlinear_operators","text":"user_defined_operators(model::InfiniteModel)::Vector{NLPOperator}\n\nReturn all the operators (and their associated information) that the user has added to model. Each is stored as a NLPOperator.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.add_operators_to_jump","page":"Expressions","title":"InfiniteOpt.add_operators_to_jump","text":"add_operators_to_jump(opt_model::JuMP.Model, inf_model::InfiniteModel)::Nothing\n\nAdd the additional nonlinear operators in inf_model to a JuMP model opt_model. This is intended as an internal method, but it is provided for developers that extend InfiniteOpt to use new JuMPBackends.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#Expression-Methods","page":"Expressions","title":"Expression Methods","text":"","category":"section"},{"location":"manual/expression/#InfiniteOpt.parameter_refs-Tuple{Union{GenericAffExpr, GenericNonlinearExpr, GenericQuadExpr}}","page":"Expressions","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(expr)::Tuple\n\nReturn the tuple of parameter references that determine the infinite dependencies of expr.\n\nExample\n\njulia> parameter_refs(my_expr)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.restrict-Tuple{AbstractJuMPScalar}","page":"Expressions","title":"InfiniteOpt.restrict","text":"restrict(expr::JuMP.AbstractJuMPScalar, supps...)::JuMP.AbstractJuMPScalar\n\nRestrict an infinite expression expr to be enforced over infinite parameter  supports supps. This is limited to expressions only contain infinite variables  with the same kind of infinite parameter dependencies. Note that more conveniently  the expression can be treated as a function for the syntax expr(supps...). \n\nExample\n\njulia> ex = @expression(model, 3y - 2)\n3 y(t) - 2\n\njulia> restrict(ex, 0)\n3 y(0) - 2\n\njulia> ex(0)\n3 y(0) - 2\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.map_expression","page":"Expressions","title":"InfiniteOpt.map_expression","text":"map_expression(\n    transform::Function, \n    expr::JuMP.AbstractJuMPScalar,\n    [write_model::Union{InfiniteModel, AbstractTransformationBackend}]\n)::JuMP.AbstractJuMPScalar\n\nMap and return a new expression of expr where each variable is transformed  via transform. This can be helpful for writing user extensions. For this  to work with new AbstractTransformationBackends,  JuMP.variable_ref_type needs to be defined for the backend. If  write_model is not provided, the JuMP.owner_model(expr) is used. JuMP.owner_model(expr) is used.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.all_expression_variables","page":"Expressions","title":"InfiniteOpt.all_expression_variables","text":"all_expression_variables(expr::JuMP.AbstractJuMPScalar)::Vector\n\nReturns a vector of all the variable references contained in expr.\n\nExample\n\njulia> all_expr_variables(y^2 + z - t)\n3-element Array{GeneralVariableRef,1}:\n y(t)\n z\n t\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.parameter_group_int_indices-Tuple{Any}","page":"Expressions","title":"InfiniteOpt.parameter_group_int_indices","text":"parameter_group_int_indices(expr::JuMP.AbstractJuMPScalar)::Vector{Int}\n\nReturn the list of infinite parameter group integer indices used by expr.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#GeneralVariableRef-User-Methods","page":"Expressions","title":"GeneralVariableRef User Methods","text":"","category":"section"},{"location":"manual/expression/#InfiniteOpt.GeneralVariableRef","page":"Expressions","title":"InfiniteOpt.GeneralVariableRef","text":"GeneralVariableRef <: JuMP.AbstractVariableRef\n\nA DataType that serves as the principal variable reference in InfiniteOpt for building variable expressions. It contains the needed information to create a variable type specifc reference (e.g., InfiniteVariableRef) via dispatch_variable_ref to obtain the correct subtype of DispatchVariableRef based off of index_type. This allows us to construct expressions using concrete containers unlike previous versions of InfiniteOpt which provides us a significant performance boost.\n\nA convenient constructor is:\n\n    GeneralVariableRef(model::InfiniteModel, index::ObjectIndex)\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nraw_index::Int64: The raw index to be used in the index_type constructor.\nindex_type::DataType: The concrete AbstractInfOptIndex type/constructor.\nparam_index::Int: The index of a parameter in DependentParameters. This is ignored for other variable types.\n\n\n\n\n\n","category":"type"},{"location":"manual/expression/#InfiniteOpt.DispatchVariableRef","page":"Expressions","title":"InfiniteOpt.DispatchVariableRef","text":"DispatchVariableRef <: JuMP.AbstractVariableRef\n\nAn abstract type for variable references that are created from GeneralVariableRefs and are used to dispatch to the appropriate methods for that particular variable/parameter/measure type.\n\n\n\n\n\n","category":"type"},{"location":"manual/expression/#InfiniteOpt.FiniteRef","page":"Expressions","title":"InfiniteOpt.FiniteRef","text":"FiniteRef <: DispatchVariableRef\n\nAn abstract type for variable references that are finite.\n\n\n\n\n\n","category":"type"},{"location":"manual/expression/#JuMP.owner_model-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::GeneralVariableRef)::InfiniteModel\n\nExtend JuMP.owner_model to return the model where vref is stored.\n\nExample\n\njulia> owner_model(vref)\nAn InfiniteOpt Model\nMinimization problem with:\n  Finite parameters: 0\n  Infinite parameter: 1\n  Variables: 3\n  Derivatives: 0\n  Measures: 0\n  Objective function type: GenericAffExpr{Float64, GeneralVariableRef}\n  `GenericAffExpr{Float64, GeneralVariableRef}`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\n  `GenericAffExpr{Float64, GeneralVariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n  `GeneralVariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints\nNames registered in the model: c1, c2, t, y, z\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  `t` transcribed over 10 supports\n  Solver: Ipopt\n  Transformation built and up-to-date: true\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.owner_model-Tuple{DispatchVariableRef}","page":"Expressions","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::DispatchVariableRef)::InfiniteModel\n\nExtend JuMP.owner_model to return the model where vref is stored.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.index-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.index","text":"JuMP.index(vref::GeneralVariableRef)::AbstractInfOptIndex\n\nExtend JuMP.index to return the appropriate index of vref.\n\nExample\n\njulia> index(vref)\nFiniteVariableIndex(1)\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.index-Tuple{DispatchVariableRef}","page":"Expressions","title":"JuMP.index","text":"JuMP.index(vref::DispatchVariableRef)::AbstractInfOptIndex\n\nExtend JuMP.index to return the appropriate index of vref.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.dispatch_variable_ref-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.dispatch_variable_ref","text":"dispatch_variable_ref(vef::GeneralVariableRef)::DispatchVariableRef\n\nReturn the concrete DispatchVariableRef this associated with vref. This relies on dispatch_variable_ref being extended for the index type, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.dispatch_variable_ref","page":"Expressions","title":"InfiniteOpt.dispatch_variable_ref","text":"dispatch_variable_ref(model::InfiniteModel, index::AbstractInfOptIndex)\n\nReturn the variable reference associated the type of index. This needs to be defined for each variable reference type.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#JuMP.name-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.name","text":"JuMP.name(vref::GeneralVariableRef)::String\n\nExtend JuMP.name to return the name of vref. It relies on JuMP.name being  defined for the underlying DispatchVariableRef, otherwise an ArgumentError  is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.set_name-Tuple{GeneralVariableRef, String}","page":"Expressions","title":"JuMP.set_name","text":"JuMP.set_name(vref::GeneralVariableRef, name::String)::Nothing\n\nExtend JuMP.set_name to set the name of vref. It relies on JuMP.set_name  being defined for the underlying DispatchVariableRef, otherwise an  ArgumentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.is_valid-Tuple{InfiniteModel, GeneralVariableRef}","page":"Expressions","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::GeneralVariableRef)::Bool\n\nExtend JuMP.is_valid to return Bool if vref is a valid reference.\n\nExample\n\njulia> is_valid(model, vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.is_valid-Tuple{InfiniteModel, DispatchVariableRef}","page":"Expressions","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::DispatchVariableRef)::Bool\n\nExtend JuMP.is_valid to return Bool if vref is a valid reference.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_infinite_variable-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_infinite_variable","text":"used_by_infinite_variable(vref::GeneralVariableRef)::Bool\n\nDefine used_by_infinite_variable for general variable references. It relies on used_by_infinite_variable being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_point_variable-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_point_variable","text":"used_by_point_variable(vref::GeneralVariableRef)::Bool\n\nDefine used_by_point_variable for general variable references. It relies on used_by_point_variable being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_semi_infinite_variable-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_semi_infinite_variable","text":"used_by_semi_infinite_variable(vref::GeneralVariableRef)::Bool\n\nDefine used_by_semi_infinite_variable for general variable references. It relies on used_by_semi_infinite_variable being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_parameter_function-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_parameter_function","text":"used_by_parameter_function(vref::GeneralVariableRef)::Bool\n\nDefine used_by_parameter_function for general variable references. It relies on used_by_parameter_function being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_derivative-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_derivative","text":"used_by_derivative(vref::GeneralVariableRef)::Bool\n\nDefine used_by_derivative for general variable references. It relies on used_by_derivative being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_measure-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(vref::GeneralVariableRef)::Bool\n\nDefine used_by_measure for general variable references. It relies on used_by_measure being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_objective-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vref::GeneralVariableRef)::Bool\n\nDefine used_by_objective for general variable references. It relies on used_by_objective being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.used_by_constraint-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(vref::GeneralVariableRef)::Bool\n\nDefine used_by_constraint for general variable references. It relies on used_by_constraint being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.is_used-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.is_used","text":"is_used(vref::GeneralVariableRef)::Bool\n\nDefine is_used for general variable references. It relies on is_used being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.has_derivative_constraints-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.has_derivative_constraints","text":"has_derivative_constraints(vref::GeneralVariableRef)::Bool\n\nDefine has_derivative_constraints for general variable references. It relies on has_derivative_constraints being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.parameter_value-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.parameter_value","text":"JuMP.parameter_value(vref::DispatchVariableRef)::Union{Real, Function}\n\nExtend JuMP.parameter_value to query the value of vref. It relies on JuMP.parameter_value being defined for the underlying  DispatchVariableRef, otherwise an ArgumentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.set_parameter_value-Tuple{GeneralVariableRef, Any}","page":"Expressions","title":"JuMP.set_parameter_value","text":"JuMP.set_parameter_value(vref::DispatchVariableRef, value::Union{Real, Function})::Nothing\n\nExtend JuMP.set_parameter_value to set the value of vref. It relies on JuMP.set_parameter_value being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.infinite_domain-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.infinite_domain","text":"infinite_domain(prefs; [kwargs...])\n\nDefine infinite_domain for general variable references. It relies on infinite_domain being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.infinite_domain-Tuple{Array{<:GeneralVariableRef}}","page":"Expressions","title":"InfiniteOpt.infinite_domain","text":"infinite_domain(prefs; [kwargs...])\n\nDefine infinite_domain for general variable references. It relies on infinite_domain being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.set_infinite_domain-Tuple{GeneralVariableRef, InfiniteScalarDomain}","page":"Expressions","title":"InfiniteOpt.set_infinite_domain","text":"set_infinite_domain(pref::GeneralVariableRef, domain::InfiniteScalarDomain)::Nothing\n\nSpecify the scalar infinite domain of the infinite parameter pref to domain. Note this will reset/delete all the supports contained in the underlying parameter object. Also, errors if pref is used by a measure. An ArgumentError is thrown if pref is not an infinite parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.set_infinite_domain-Tuple{Array{<:GeneralVariableRef}, InfiniteArrayDomain}","page":"Expressions","title":"InfiniteOpt.set_infinite_domain","text":"set_infinite_domain(prefs::Array{<:GeneralVariableRef},\n                 domain::InfiniteArrayDomain)::Nothing\n\nSpecify the multi-dimensional infinite domain of the dependent infinite parameters prefs to domain. Note this will reset/delete all the supports contained in the underlying DependentParameters object. This will error if the not all of the dependent infinite parameters are included or if any of them are used by measures. An ArgumentError is thrown if prefs are not dependent infinite parameters.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.num_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.num_supports","text":"num_supports(prefs; [kwargs...])\n\nDefine num_supports for general variable references. It relies on num_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.num_supports-Tuple{Array{<:GeneralVariableRef}}","page":"Expressions","title":"InfiniteOpt.num_supports","text":"num_supports(prefs; [kwargs...])\n\nDefine num_supports for general variable references. It relies on num_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.has_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.has_supports","text":"has_supports(prefs; [kwargs...])\n\nDefine has_supports for general variable references. It relies on has_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.has_supports-Tuple{Array{<:GeneralVariableRef}}","page":"Expressions","title":"InfiniteOpt.has_supports","text":"has_supports(prefs; [kwargs...])\n\nDefine has_supports for general variable references. It relies on has_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.supports","text":"supports(\n    expr::JuMP.AbstractJuMPScalar; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel,\n    kwargs...]\n    )\n\nReturn the support associated with expr. Errors if expr is not associated with the constraint mappings stored in the transformation backend.\n\nThe keyword arguments label is what TranscriptionOpt employs and kwargs denote extra ones that user extensions may employ in accordance with their implementation of expression_supports. Errors if such an extension has not been written. \n\nBy default only the public supports are returned, the  full set can be accessed via label = All. Where possible, all the supports of an infinite expression are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters it depends on.\n\nExample\n\njulia> supports(cref)\n2-element Array{Tuple{Float64},1}:\n (0.0,)\n (1.0,)\n\n\n\n\n\nsupports(prefs; [kwargs...])\n\nDefine supports for general variable references. It relies on supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.supports-Tuple{Array{<:GeneralVariableRef}}","page":"Expressions","title":"InfiniteOpt.supports","text":"supports(prefs; [kwargs...])\n\nDefine supports for general variable references. It relies on supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.set_supports-Tuple{GeneralVariableRef, Union{Real, Vector{<:Real}}}","page":"Expressions","title":"InfiniteOpt.set_supports","text":"set_supports(\n    pref::GeneralVariableRef,\n    supports::Union{Real, Vector{<:Real}, UnitRange{<:Real}, StepRange{<:Real}, NTuple, Base.Generator};\n    [force::Bool = false]\n    )::Nothing\n\nSet the support points associated with a single infinite parameter pref. An ArgumentError is thrown if pref is not an independent infinite parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.set_supports-Tuple{Array{<:GeneralVariableRef}, Union{Matrix{<:Real}, Vector{<:Array{<:Real}}}}","page":"Expressions","title":"InfiniteOpt.set_supports","text":"set_supports(\n    prefs::Union{Vector{GeneralVariableRef}, Array{<:GeneralVariableRef}},\n    supports::Union{Array{<:Real, 2}, Vector{<:Array{<:Real}}};\n    [force::Bool = false]\n    )::Nothing\n\nSet the support points associated with dependent infinite parameters prefs. An ArgumentError is thrown if prefs is are not dependent infinite parameters.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.add_supports-Tuple{GeneralVariableRef, Union{Real, Vector{<:Real}}}","page":"Expressions","title":"InfiniteOpt.add_supports","text":"add_supports(\n    pref::GeneralVariableRef,\n    supports::Union{Real, Vector{<:Real}, UnitRange{<:Real}, StepRange{<:Real}, NTuple, Base.Generator}\n    )::Nothing\n\nAdd the support points supports to a single infinite parameter pref. An ArgumentError is thrown if pref is not an independent infinite parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.add_supports-Tuple{Array{<:GeneralVariableRef}, Union{Matrix{<:Real}, Vector{<:Array{<:Real}}}}","page":"Expressions","title":"InfiniteOpt.add_supports","text":"add_supports(\n    prefs::Union{Vector{GeneralVariableRef}, Array{<:GeneralVariableRef}},\n    supports::Union{Array{<:Real, 2}, Vector{<:Array{<:Real}}}\n    )::Nothing\n\nAdd the support points supports to the dependent infinite parameters prefs. An ArgumentError is thrown if prefs is are not dependent infinite parameters.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.delete_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.delete_supports","text":"delete_supports(prefs; [kwargs...])\n\nDefine delete_supports for general variable references. It relies on delete_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.delete_supports-Tuple{Array{<:GeneralVariableRef}}","page":"Expressions","title":"InfiniteOpt.delete_supports","text":"delete_supports(prefs; [kwargs...])\n\nDefine delete_supports for general variable references. It relies on delete_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(prefs; [kwargs...])\n\nDefine fill_in_supports! for general variable references. It relies on fill_in_supports! being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.fill_in_supports!-Tuple{Array{<:GeneralVariableRef}}","page":"Expressions","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(prefs; [kwargs...])\n\nDefine fill_in_supports! for general variable references. It relies on fill_in_supports! being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.raw_parameter_refs-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.raw_parameter_refs","text":"raw_parameter_refsc(vref::GeneralVariableRef)\n\nDefine raw_parameter_refs for general variable references. It relies on raw_parameter_refs being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.parameter_refs-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_refs","text":"parameter_refsc(vref::GeneralVariableRef)\n\nDefine parameter_refs for general variable references. It relies on parameter_refs being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.parameter_list-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_list","text":"parameter_listc(vref::GeneralVariableRef)\n\nDefine parameter_list for general variable references. It relies on parameter_list being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.raw_function-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.raw_function","text":"raw_function(prefs; [kwargs...])\n\nDefine raw_function for general variable references. It relies on raw_function being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.infinite_variable_ref-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_refc(vref::GeneralVariableRef)\n\nDefine infinite_variable_ref for general variable references. It relies on infinite_variable_ref being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.eval_support-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.eval_support","text":"eval_supportc(vref::GeneralVariableRef)\n\nDefine eval_support for general variable references. It relies on eval_support being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.raw_parameter_values-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.raw_parameter_values","text":"raw_parameter_valuesc(vref::GeneralVariableRef)\n\nDefine raw_parameter_values for general variable references. It relies on raw_parameter_values being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.parameter_values-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_values","text":"parameter_valuesc(vref::GeneralVariableRef)\n\nDefine parameter_values for general variable references. It relies on parameter_values being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.significant_digits-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.significant_digits","text":"significant_digits(prefs; [kwargs...])\n\nDefine significant_digits for general variable references. It relies on significant_digits being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.measure_function-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.measure_function","text":"measure_function(mref::GeneralVariableRef)\n\nDefine measure_function for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.measure_data-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.measure_data","text":"measure_data(mref::GeneralVariableRef)\n\nDefine measure_data for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.is_analytic-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.is_analytic","text":"is_analytic(mref::GeneralVariableRef)\n\nDefine is_analytic for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.derivative_argument-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.derivative_argument","text":"derivative_argument(dref::GeneralVariableRef)\n\nDefine derivative_argument for general variable references. Errors if dref does not correspond to a DerivativeRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.operator_parameter-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.operator_parameter","text":"operator_parameter(dref::GeneralVariableRef)\n\nDefine operator_parameter for general variable references. Errors if dref does not correspond to a DerivativeRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.derivative_order-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.derivative_order","text":"derivative_order(dref::GeneralVariableRef)\n\nDefine derivative_order for general variable references. Errors if dref does not correspond to a DerivativeRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.derivative_method-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.derivative_method","text":"derivative_method(prefs; [kwargs...])\n\nDefine derivative_method for general variable references. It relies on derivative_method being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.evaluate-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.evaluate","text":"evaluate(dref::GeneralVariableRef)\n\nDefine evaluate for general variable references. Errors if dref does not correspond to a DerivativeRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.derivative_constraints-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.derivative_constraints","text":"derivative_constraints(dref::GeneralVariableRef)\n\nDefine derivative_constraints for general variable references. Errors if dref does not correspond to a DerivativeRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.delete_derivative_constraints-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.delete_derivative_constraints","text":"delete_derivative_constraints(dref::GeneralVariableRef)\n\nDefine delete_derivative_constraints for general variable references. Errors if dref does not correspond to a DerivativeRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.add_generative_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.add_generative_supports","text":"add_generative_supports(prefs; [kwargs...])\n\nDefine add_generative_supports for general variable references. It relies on add_generative_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.set_derivative_method-Tuple{GeneralVariableRef, AbstractDerivativeMethod}","page":"Expressions","title":"InfiniteOpt.set_derivative_method","text":"set_derivative_method(pref::GeneralVariableRef,\n                      method::AbstractDerivativeMethod\n                      )::Nothing\n\nSpecify the numerical derivative evaluation technique associated with pref. An ArgumentError is thrown if pref is not an infinite parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.has_generative_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.has_generative_supports","text":"has_generative_supports(prefs; [kwargs...])\n\nDefine has_generative_supports for general variable references. It relies on has_generative_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.has_internal_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.has_internal_supports","text":"has_internal_supports(prefs; [kwargs...])\n\nDefine has_internal_supports for general variable references. It relies on has_internal_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.delete-Tuple{InfiniteModel, GeneralVariableRef}","page":"Expressions","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::GeneralVariableRef)::Nothing\n\nExtend JuMP.delete to delete vref and its dependencies. It relies on  JuMP.delete being defined for the underlying DispatchVariableRef, otherwise  an ArgumentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.delete-Tuple{InfiniteModel, Array{<:GeneralVariableRef}}","page":"Expressions","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel,\n            prefs::Array{<:GeneralVariableRef})::Nothing\n\nExtend JuMP.delete to delete a group of dependent infinite parameters and their dependencies. An ArgumentError is thrown if prefs are not dependent infinite parameters.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.has_lower_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::GeneralVariableRef)\n\nDefine JuMP.has_lower_bound for general variable references. It relies on JuMP.has_lower_bound being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.lower_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::GeneralVariableRef)\n\nDefine JuMP.lower_bound for general variable references. It relies on JuMP.lower_bound being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.set_lower_bound-Tuple{GeneralVariableRef, Real}","page":"Expressions","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(vref::GeneralVariableRef, value::Real)::Nothing\n\nDefine JuMP.set_lower_bound for general variable references. It relies on JuMP.set_lower_bound being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.LowerBoundRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::GeneralVariableRef)\n\nDefine JuMP.LowerBoundRef for general variable references. It relies on JuMP.LowerBoundRef being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.delete_lower_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.delete_lower_bound","text":"JuMP.delete_lower_bound(vref::GeneralVariableRef)\n\nDefine JuMP.delete_lower_bound for general variable references. It relies on JuMP.delete_lower_bound being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.has_upper_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::GeneralVariableRef)\n\nDefine JuMP.has_upper_bound for general variable references. It relies on JuMP.has_upper_bound being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.upper_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::GeneralVariableRef)\n\nDefine JuMP.upper_bound for general variable references. It relies on JuMP.upper_bound being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.set_upper_bound-Tuple{GeneralVariableRef, Real}","page":"Expressions","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(vref::GeneralVariableRef, value::Real)::Nothing\n\nDefine JuMP.set_upper_bound for general variable references. It relies on JuMP.set_upper_bound being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.UpperBoundRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::GeneralVariableRef)\n\nDefine JuMP.UpperBoundRef for general variable references. It relies on JuMP.UpperBoundRef being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.delete_upper_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.delete_upper_bound","text":"JuMP.delete_upper_bound(vref::GeneralVariableRef)\n\nDefine JuMP.delete_upper_bound for general variable references. It relies on JuMP.delete_upper_bound being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.is_fixed-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::GeneralVariableRef)\n\nDefine JuMP.is_fixed for general variable references. It relies on JuMP.is_fixed being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.fix_value-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::GeneralVariableRef)\n\nDefine JuMP.fix_value for general variable references. It relies on JuMP.fix_value being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.fix-Tuple{GeneralVariableRef, Real}","page":"Expressions","title":"JuMP.fix","text":"JuMP.fix(vref::GeneralVariableRef, value::Real; force::Bool = false)::Nothing\n\nDefine JuMP.fix for general variable references. It relies on JuMP.fix being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.FixRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::GeneralVariableRef)\n\nDefine JuMP.FixRef for general variable references. It relies on JuMP.FixRef being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.unfix-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.unfix","text":"JuMP.unfix(vref::GeneralVariableRef)\n\nDefine JuMP.unfix for general variable references. It relies on JuMP.unfix being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.start_value-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.start_value","text":"JuMP.start_value(vref::GeneralVariableRef)\n\nDefine JuMP.start_value for general variable references. It relies on JuMP.start_value being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.set_start_value-Tuple{GeneralVariableRef, Real}","page":"Expressions","title":"JuMP.set_start_value","text":"JuMP.set_start_value(vref::GeneralVariableRef, value::Real)::Nothing\n\nDefine JuMP.set_start_value for general variable references. It relies on JuMP.set_start_value being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.is_binary-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::GeneralVariableRef)\n\nDefine JuMP.is_binary for general variable references. It relies on JuMP.is_binary being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.set_binary-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.set_binary","text":"JuMP.set_binary(vref::GeneralVariableRef)\n\nDefine JuMP.set_binary for general variable references. It relies on JuMP.set_binary being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.BinaryRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::GeneralVariableRef)\n\nDefine JuMP.BinaryRef for general variable references. It relies on JuMP.BinaryRef being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.unset_binary-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.unset_binary","text":"JuMP.unset_binary(vref::GeneralVariableRef)\n\nDefine JuMP.unset_binary for general variable references. It relies on JuMP.unset_binary being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.is_integer-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::GeneralVariableRef)\n\nDefine JuMP.is_integer for general variable references. It relies on JuMP.is_integer being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.set_integer-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.set_integer","text":"JuMP.set_integer(vref::GeneralVariableRef)\n\nDefine JuMP.set_integer for general variable references. It relies on JuMP.set_integer being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.IntegerRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::GeneralVariableRef)\n\nDefine JuMP.IntegerRef for general variable references. It relies on JuMP.IntegerRef being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#JuMP.unset_integer-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.unset_integer","text":"JuMP.unset_integer(vref::GeneralVariableRef)\n\nDefine JuMP.unset_integer for general variable references. It relies on JuMP.unset_integer being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.constant_over_collocation-Tuple{GeneralVariableRef, GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.constant_over_collocation","text":"constant_over_collocation(vref::GeneralVariableRef, pref::GeneralVariableRef)::Nothing\n\nDefine constant_over_collocation for general variable references. It wraps around the  method defined for InfiniteVariableRefs.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.core_object","page":"Expressions","title":"InfiniteOpt.core_object","text":"core_object(vref::DispatchVariableRef)::Union{InfOptParameter, InfOptVariable, Measure}\n\nReturn the core object that vref points to. This needs to be extended for type of vref. This should use _data_object to access the data object where the variable object is stored.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.core_object-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.core_object","text":"core_object(vref::GeneralVariableRef)::Union{InfOptParameter, InfOptVariable, Measure}\n\nReturn the core object that vref points to. This is enabled with appropriate definitions of core_object for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.parameter_group_int_indices-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_group_int_indices","text":"parameter_group_int_indices(vref::GeneralVariableRef)::Vector{Int}\n\nReturn the list of infinite parameter group integer indices used by vref.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.parameter_group_int_index","page":"Expressions","title":"InfiniteOpt.parameter_group_int_index","text":"parameter_group_int_index(pref::DispatchVariableRef)::Int\n\nReturn the parameter group integer index for pref assuming it is an infinite parameter. This needs to be defined for the type of pref. This should use the _data_object to get the number.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt.parameter_group_int_index-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_group_int_index","text":"parameter_group_int_index(pref::GeneralVariableRef)::Int\n\nReturn the group integer index for pref assuming it is an infinite parameter. It relies on parameter_group_int_index being properly defined for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt.reformulate_high_order_derivatives!-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.reformulate_high_order_derivatives!","text":"reformulate_high_order_derivatives!(dref::GeneralVariableRef)\n\nDefine reformulate_high_order_derivatives! for general variable references. Errors if dref does not correspond to a DerivativeRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#Developer-Internal-Methods","page":"Expressions","title":"Developer Internal Methods","text":"","category":"section"},{"location":"manual/expression/#InfiniteOpt._add_data_object","page":"Expressions","title":"InfiniteOpt._add_data_object","text":"_add_data_object(model::InfiniteModel, object::AbstractDataObject)::ObjectIndex\n\nAdd object to the appropriate CleverDict in model and return the its index. This needs to be defined for the type of object. These definitions need to use MOIUC.add_item to add the object to the CleverDict.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._data_dictionary","page":"Expressions","title":"InfiniteOpt._data_dictionary","text":"_data_dictionary(vref::DispatchVariableRef)::MOIUC.CleverDict\n\nReturn the CleverDict that stores data objects for the type of vref. This needs to be defined for the type of vref.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._data_object","page":"Expressions","title":"InfiniteOpt._data_object","text":"_data_object(vref::DispatchVariableRef)::AbstractDataObject\n\nReturn the data object associated with vref, in other words the object its index points to in the InfiniteModel. This needs to be defined for the type of vref. This should use _data_dictionary to access the CleverDict that the object is stored in.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._delete_data_object","page":"Expressions","title":"InfiniteOpt._delete_data_object","text":"_delete_data_object(vref::DispatchVariableRef)::Nothing\n\nDelete the concrete AbstractDataObject associated with vref.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._set_core_object","page":"Expressions","title":"InfiniteOpt._set_core_object","text":"_set_core_object(vref::DispatchVariableRef, object)::Nothing\n\nSets the core object that vref points to object. This needs to be extended for types of vref and object. This should use _data_object to access the data object where the variable object is stored.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._infinite_variable_dependencies","page":"Expressions","title":"InfiniteOpt._infinite_variable_dependencies","text":"_infinite_variable_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._infinite_variable_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._infinite_variable_dependencies","text":"_infinite_variable_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of _infinite_variable_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt._semi_infinite_variable_dependencies","page":"Expressions","title":"InfiniteOpt._semi_infinite_variable_dependencies","text":"_semi_infinite_variable_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._semi_infinite_variable_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._semi_infinite_variable_dependencies","text":"_semi_infinite_variable_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of _semi_infinite_variable_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt._point_variable_dependencies","page":"Expressions","title":"InfiniteOpt._point_variable_dependencies","text":"_point_variable_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._point_variable_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._point_variable_dependencies","text":"_point_variable_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of _point_variable_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt._derivative_dependencies","page":"Expressions","title":"InfiniteOpt._derivative_dependencies","text":"_derivative_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._derivative_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._derivative_dependencies","text":"_derivative_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of _derivative_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt._measure_dependencies","page":"Expressions","title":"InfiniteOpt._measure_dependencies","text":"_measure_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._measure_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._measure_dependencies","text":"_measure_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of _measure_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt._generative_measures","page":"Expressions","title":"InfiniteOpt._generative_measures","text":"_generative_measures(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._generative_measures-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._generative_measures","text":"_generative_measures(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of _generative_measures for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt._constraint_dependencies","page":"Expressions","title":"InfiniteOpt._constraint_dependencies","text":"_constraint_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._constraint_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._constraint_dependencies","text":"_constraint_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of _constraint_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/expression/#InfiniteOpt._derivative_constraint_dependencies","page":"Expressions","title":"InfiniteOpt._derivative_constraint_dependencies","text":"_derivative_constraint_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"manual/expression/#InfiniteOpt._derivative_constraint_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._derivative_constraint_dependencies","text":"_derivative_constraint_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of _derivative_constraint_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"examples/Optimal Control/pandemic_control/#Pandemic-Control","page":"Pandemic Control","title":"Pandemic Control","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"A stochastic optimal control problem were we seek to control the spread of a contagion with uncertain parameters.","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Problem-Statement-and-Model","page":"Pandemic Control","title":"Problem Statement and Model","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"We wish to determine optimal social distancing policy to control spread of a contagion and minimize the economic impact of doing so. We'll model the spread of the virus through a given population using the SEIR Model which considers 4 population subsets that follow:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"textSusceptible rightarrow textExposed rightarrow textInfectious rightarrow textRecovered","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"This model is formalized as:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"begingathered\nfracds(t)dt = (u(t) - 1)beta s(t)i(t) \nfracde(t)dt = (1 - u(t))beta s(t)i(t) - xi e(t) \nfracdi(t)dt = xi e(t) - gamma i(t)\nfracdr(t)dt = gamma i(t) \nendgathered","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"where s(t) is the susceptible population, e(t) is the exposed population, i(t) is the infectious population, r(t) is the recovered population, and u(t) in 0 1 is the enforced population isolation (social distancing). The other values denote model parameters that will be specific to the contagion in question.","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"For our case study, we'll consider the incubation constant xi to be an uncertain parameter xi sim mathcalU(underlinexi overlinexi). This introduces to infinite dependencies into our model: time t and uncertain incubation xi. Moreover we'll seek to minimize the isolation measures u(t) that are implemented while limiting the amount of infected individuals i(t) to be below a threshold i_max. Thus, the optimization problem becomes:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"beginaligned\nmin_  int_t in mathcalD_t u(t) dt \n textst  fracpartial s(t xi)partial t = (u(t) - 1)beta s(t xi)i(t xi)  forall t in mathcalD_t xi in mathcalD_xi \n fracpartial e(t xi)partial t = (1 - u(t))beta s(t xi)i(t xi) - xi e(t xi)  forall t in mathcalD_t xi in mathcalD_xi \n fracpartial i(t xi)partial t = xi e(t xi) - gamma i(t xi)  forall t in mathcalD_t xi in mathcalD_xi \n fracpartial r(t xi)partial t = gamma i(t xi)  forall t in mathcalD_t xi in mathcalD_xi \n s(0 xi) = s_0 e(0 xi) = e_0 i(0 xi) = i_0 r(0 xi) = r_0  forall xi in mathcalD_xi \n i(t xi) leq i_max  forall t in mathcalD_t xi in mathcalD_xi \n u(t) in 0 08 \n xi sim mathcalU(underlinexi overlinexi)\nendaligned","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Notice that the SEIR model variables now all depend on both t and xi, except u(t) which means we need to decide our policy before knowing the true value of xi.","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Modeling-in-InfiniteOpt","page":"Pandemic Control","title":"Modeling in InfiniteOpt","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Traditional modeling frameworks like JuMP cannot be used to solve this model directly because it is infinite, contains partial difference equations, and contains a time expectation. We would first have to transform it into a transcripted (discretized) variant by applying all the necessary techniques (e.g., orthogonal collocation over finite elements, trapezoid rule, etc.) which is very combersome and nontrivial in this case.","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"However, we can directly model the above form in InfiniteOpt and it will take care of the rest! Let's get started by importing the needed packages and specifying the model parameters that we'll need.","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"using InfiniteOpt, Ipopt, Distributions, Plots\n\n# Set the SEIR parameters\nÎ³ = 0.303\nÎ² = 0.727\nN = 1e5\nÎ¾_min = 0.1\nÎ¾_max = 0.6\n\n# Set the domain information\ni_max = 0.02\nt0 = 0\ntf = 200\nextra_ts = [0.001, 0.002, 0.004, 0.008, 0.02, 0.04, 0.08, 0.2, 0.4, 0.8]\nnum_samples = 5\n\n# Set the intial condition values\ne0 = 1 / N\ni0 = 0\nr0 = 0\ns0 = 1 - 1 / N;","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Model-Initialization","page":"Pandemic Control","title":"Model Initialization","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Now let's setup our infinite model and select Ipopt as our optimizer that will be used to solve it. This is accomplished making an InfiniteModel:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"model = InfiniteModel(Ipopt.Optimizer);","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Infinite-Parameter-Definition","page":"Pandemic Control","title":"Infinite Parameter Definition","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"We now need to define the infinite parameters t in t_0 t_f and xi sim mathcalU(underlinexi overlinexi). This is accomplished with @infinite_parameter. We'll also include the following specifications:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"use 51 equidistant time points\nspecify that orgothonal collocation using 2 nodes should be used for time derivatives\nspecify that the number of random scenarios should equal num_samples\nadd extra_ts as extra time points","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"@infinite_parameter(model, t âˆˆ [t0, tf], num_supports = 51,\n                    derivative_method = OrthogonalCollocation(3))\n@infinite_parameter(model, Î¾ ~ Uniform(Î¾_min, Î¾_max), num_supports = num_samples)\nadd_supports(t, extra_ts)","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Infinite-Variable-Definition","page":"Pandemic Control","title":"Infinite Variable Definition","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"With our infinite parameters defined, we can now define our infinite variables:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"s(t xi) geq 0\ne(t xi) geq 0\ni(t xi) geq 0\nr(t xi) geq 0\n0 leq u(t) leq 08","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"@variable(model, s â‰¥ 0, Infinite(t, Î¾))\n@variable(model, e â‰¥ 0, Infinite(t, Î¾))\n@variable(model, i â‰¥ 0, Infinite(t, Î¾))\n@variable(model, r â‰¥ 0, Infinite(t, Î¾))\n@variable(model, 0 â‰¤ u â‰¤ 0.8, Infinite(t), start = 0.2)","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"u(t)","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Objective-Definition","page":"Pandemic Control","title":"Objective Definition","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Now its time to add the objective min  int_t in mathcalD_t u(t) dt using @objective:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"@objective(model, Min, âˆ«(u, t))","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"âˆ«{t âˆˆ [0, 200]}[u(t)]","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Constraint-Definition","page":"Pandemic Control","title":"Constraint Definition","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"The last step now to defining our model is to define the constraints using @constraint. This will involve defining the initial conditions:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"s(0 xi) = s_0 e(0 xi) = e_0 i(0 xi) = i_0 r(0 xi) = r_0  forall xi in mathcalD_xi","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"the model equations:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"beginaligned\n fracpartial s(t xi)partial t = (u(t) - 1)beta si(t xi)  forall t in mathcalD_t xi in mathcalD_xi \n fracpartial e(t xi)partial t = (1 - u(t))beta si(t xi) - xi e(t xi)  forall t in mathcalD_t xi in mathcalD_xi \n fracpartial i(t xi)partial t = xi e(t xi) - gamma i(t xi)  forall t in mathcalD_t xi in mathcalD_xi \n fracpartial r(t xi)partial t = gamma i(t xi)  forall t in mathcalD_t xi in mathcalD_xi \nendaligned","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"and the infection limit constraint:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"i(t xi) leq i_max  forall t in mathcalD_t xi in mathcalD_xi","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"# Define the initial conditions\n@constraint(model, s(0, Î¾) == s0)\n@constraint(model, e(0, Î¾) == e0)\n@constraint(model, i(0, Î¾) == i0)\n@constraint(model, r(0, Î¾) == r0)\n\n# Define the SEIR equations\n@constraint(model, s_constr, âˆ‚(s, t) == -(1 - u) * Î² * s * i)\n@constraint(model, e_constr, âˆ‚(e, t) == (1 - u) * Î² * s * i - Î¾ * e)\n@constraint(model, i_constr, âˆ‚(i, t) == Î¾ * e - Î³ * i)\n@constraint(model, r_constr, âˆ‚(r, t) == Î³ * i)\n\n# Define the infection rate limit\n@constraint(model, imax_constr, i â‰¤ i_max)","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"imax_constr : i(t, Î¾) â‰¤ 0.02, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Adjust-Degrees-of-Freedom","page":"Pandemic Control","title":"Adjust Degrees of Freedom","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Since we are using OrthogonalCollocation, this introduces additional collocation points for t. These in turn, will artificially increase the degrees of freedom for u. Thus, we will treat u as a piecewise constant function that is held constant over the internal collocation nodes via constant_over_collocation:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"constant_over_collocation(u, t)","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Display-the-Infinite-Model","page":"Pandemic Control","title":"Display the Infinite Model","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Let's display model now that it is fully defined:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"print(model)","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Min âˆ«{t âˆˆ [0, 200]}[u(t)]\nSubject to\n s(t, Î¾) â‰¥ 0, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n e(t, Î¾) â‰¥ 0, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n i(t, Î¾) â‰¥ 0, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n r(t, Î¾) â‰¥ 0, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n u(t) â‰¥ 0, âˆ€ t âˆˆ [0, 200]\n u(t) â‰¤ 0.8, âˆ€ t âˆˆ [0, 200]\n s(0, Î¾) = 0.99999, âˆ€ Î¾ ~ Uniform\n e(0, Î¾) = 1.0e-5, âˆ€ Î¾ ~ Uniform\n i(0, Î¾) = 0, âˆ€ Î¾ ~ Uniform\n r(0, Î¾) = 0, âˆ€ Î¾ ~ Uniform\n s_constr : âˆ‚/âˆ‚t[s(t, Î¾)] - ((0.727 u(t)*s(t, Î¾) - 0.727 s(t, Î¾)) * i(t, Î¾)) = 0, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n e_constr : âˆ‚/âˆ‚t[e(t, Î¾)] - (((-0.727 u(t)*s(t, Î¾) + 0.727 s(t, Î¾)) * i(t, Î¾)) - (Î¾*e(t, Î¾))) = 0, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n i_constr : -Î¾*e(t, Î¾) + âˆ‚/âˆ‚t[i(t, Î¾)] + 0.303 i(t, Î¾) = 0, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n r_constr : âˆ‚/âˆ‚t[r(t, Î¾)] - 0.303 i(t, Î¾) = 0, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n imax_constr : i(t, Î¾) â‰¤ 0.02, âˆ€ t âˆˆ [0, 200], Î¾ ~ Uniform\n","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Optimize-the-Model","page":"Pandemic Control","title":"Optimize the Model","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Let's solve our model and find the optimal policy. All we have to do is invoke optimize! and the model will automatically be transformed solved behind the scenes:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"optimize!(model)","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"This is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:    17110\nNumber of nonzeros in inequality constraint Jacobian.:      605\nNumber of nonzeros in Lagrangian Hessian.............:     7260\n\nTotal number of variables............................:     4961\n                     variables with only lower bounds:     2420\n                variables with lower and upper bounds:      121\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4900\nTotal number of inequality constraints...............:      605\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:      605\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  4.0000000e+01 9.90e-01 2.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.6937626e+01 5.21e-01 1.09e+03  -1.0 9.90e-01    -  1.10e-02 4.74e-01f  1\n   2  1.4780066e+01 5.11e-01 1.07e+03  -1.0 2.15e+00    -  1.06e-01 1.84e-02h  1\n   3  1.3777585e+01 4.70e-01 9.84e+02  -1.0 7.10e-01    -  3.06e-01 8.10e-02h  1\n   4  1.3781524e+01 4.70e-01 9.83e+02  -1.0 7.35e-01    -  2.32e-02 7.97e-04h  1\n   5  1.3985240e+01 4.65e-01 1.24e+03  -1.0 3.37e+00    -  5.05e-04 9.77e-03f  1\n   6  1.4200296e+01 4.60e-01 1.78e+03  -1.0 3.53e+00    -  6.16e-03 1.04e-02h  1\n   7  1.4301920e+01 4.58e-01 1.77e+03  -1.0 2.07e+00    -  4.13e-03 3.93e-03h  1\n   8  1.4827666e+01 4.48e-01 1.73e+03  -1.0 3.61e+00    -  2.52e-02 2.24e-02h  1\n   9  1.5181816e+01 4.43e-01 1.71e+03  -1.0 1.97e+00    -  9.56e-03 1.22e-02h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  1.6269429e+01 4.27e-01 1.61e+03  -1.0 2.57e+00    -  1.37e-02 3.51e-02h  1\n  11  1.7662228e+01 4.10e-01 1.54e+03  -1.0 2.24e+00    -  4.01e-02 4.06e-02h  1\n  12  2.2127845e+01 3.66e-01 1.45e+03  -1.0 1.31e+00    -  2.40e-02 1.06e-01h  1\n  13  3.3301913e+01 2.72e-01 7.22e+02  -1.0 1.04e+00    -  1.17e-01 2.58e-01h  1\n  14  6.7591750e+01 2.72e-03 9.57e+02  -1.0 5.62e-01    -  2.42e-01 9.90e-01h  1\n  15  6.2651496e+01 1.57e-03 9.08e+02  -1.0 6.93e-01    -  1.76e-01 4.20e-01h  1\n  16  5.9228054e+01 1.76e-03 2.06e+03  -1.0 7.80e-01    -  2.02e-01 4.49e-01h  1\n  17  5.9188553e+01 1.53e-03 2.20e+03  -1.0 1.20e+00    -  9.19e-02 1.27e-01h  1\n  18  5.9528531e+01 1.24e-03 2.44e+03  -1.0 8.35e-01    -  1.42e-01 1.92e-01h  1\n  19  6.0639829e+01 1.00e-03 8.68e+02  -1.0 7.27e-01    -  4.97e-01 3.45e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  6.1049842e+01 9.73e-04 6.74e+02  -1.0 1.04e+00    -  1.18e-01 1.21e-01h  1\n  21  6.1246174e+01 9.11e-04 6.21e+02  -1.0 7.51e-01    -  4.38e-02 6.26e-02h  1\n  22  6.3193057e+01 7.30e-04 5.31e+03  -1.0 1.17e+00    -  1.39e-01 3.20e-01h  1\n  23  6.4563304e+01 1.25e-03 1.16e+04  -1.0 8.86e-01   0.0 1.78e-01 3.67e-01h  1\n  24  6.4834700e+01 1.19e-03 2.77e+03  -1.0 9.86e-01  -0.5 1.96e-01 7.76e-02h  1\n  25  6.5032518e+01 1.12e-03 3.89e+03  -1.0 9.52e-01  -0.1 3.77e-02 5.78e-02h  1\n  26  6.5683529e+01 9.89e-04 1.16e+04  -1.0 1.14e+00   0.4 2.02e-02 1.23e-01h  1\n  27  6.7212078e+01 7.50e-04 3.66e+03  -1.0 7.97e-01  -0.1 3.01e-01 2.45e-01h  1\n  28  6.8657421e+01 8.61e-04 4.69e+03  -1.0 7.06e-01   0.3 2.99e-01 3.17e-01h  1\n  29  6.9207907e+01 8.70e-04 1.36e+03  -1.0 9.67e-01  -0.2 1.78e-01 1.57e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  6.9329392e+01 8.55e-04 7.38e+03  -1.0 5.75e+00  -0.6 5.55e-02 1.71e-02h  3\n  31  6.9835318e+01 5.90e-04 5.52e+04  -1.0 7.56e-01   0.7 2.71e-02 3.19e-01h  1\n  32  7.0313269e+01 8.04e-04 1.00e+05  -1.0 7.50e-01   0.2 1.40e-01 3.56e-01H  1\n  33  7.0008946e+01 8.26e-04 2.75e+04  -1.0 7.44e-01   0.6 3.15e-01 1.99e-01h  1\n  34  7.0104857e+01 7.01e-04 6.13e+04  -1.0 1.13e+00   0.2 7.31e-02 1.41e-01h  1\n  35  7.0296440e+01 5.66e-04 9.96e+04  -1.0 6.72e-01  -0.3 1.18e-01 1.97e-01h  2\n  36  7.0227373e+01 4.67e-04 5.95e+04  -1.0 1.08e+00  -0.8 3.56e-01 1.74e-01h  2\n  37  6.9562353e+01 6.19e-04 6.48e+03  -1.0 6.66e-01  -0.4 3.59e-01 4.05e-01H  1\n  38  6.9272663e+01 5.54e-04 4.76e+03  -1.0 5.30e-01  -0.8 1.08e-01 1.03e-01h  1\n  39  6.9120153e+01 5.00e-04 3.76e+04  -1.0 1.01e+00  -0.4 1.23e-01 9.88e-02h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  6.8326939e+01 3.23e-04 1.44e+05  -1.0 5.41e-01  -0.9 3.48e-01 4.53e-01H  1\n  41  6.7479062e+01 4.22e-04 7.12e+04  -1.0 4.85e-01    -  5.07e-01 5.07e-01H  1\n  42  6.7357158e+01 3.83e-04 4.45e+05  -1.0 1.58e+00  -0.5 2.71e-01 1.08e-01h  1\n  43  6.6948996e+01 2.75e-04 2.51e+05  -1.0 2.50e-01  -0.0 7.60e-02 2.74e-01h  1\n  44  6.6831954e+01 2.26e-04 5.66e+05  -1.0 8.21e-01  -0.5 4.12e-01 1.75e-01h  1\n  45  6.6252430e+01 2.13e-04 1.39e+06  -1.0 1.95e-01    -  1.69e-01 7.35e-01h  1\n  46  6.5958166e+01 1.25e-04 5.88e+03  -1.0 1.23e-01    -  1.00e+00 1.00e+00h  1\n  47  6.5469975e+01 2.87e-05 1.53e+04  -1.7 7.42e-02    -  1.00e+00 1.00e+00f  1\n  48  6.4825620e+01 1.60e-04 1.53e+02  -1.7 1.38e-01  -0.1 1.00e+00 1.00e+00f  1\n  49  6.4609211e+01 1.03e-04 5.83e+05  -2.5 1.20e-01   0.3 7.78e-01 4.39e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  6.4148537e+01 1.58e-04 4.52e+05  -2.5 6.32e-01  -0.1 3.94e-01 2.92e-01f  1\n  51  6.3904144e+01 1.10e-04 2.63e+05  -2.5 1.36e-01   0.3 4.93e-01 4.43e-01f  1\n  52  6.3532346e+01 1.96e-04 9.69e+04  -2.5 3.51e-01  -0.2 4.98e-01 5.91e-01f  1\n  53  6.3438368e+01 3.01e-06 4.22e+04  -2.5 3.25e-02   0.2 2.81e-01 1.00e+00f  1\n  54  6.3348834e+01 1.51e-05 7.20e+03  -2.5 1.62e-01  -0.2 8.30e-01 4.88e-01f  1\n  55  6.3369947e+01 5.67e-07 2.39e+03  -2.5 2.27e-02   0.2 6.68e-01 1.00e+00f  1\n  56  6.3318100e+01 1.11e-05 1.34e+02  -2.5 6.83e-02  -0.3 1.00e+00 1.00e+00f  1\n  57  6.3300907e+01 2.94e-07 6.77e+00  -2.5 1.56e-02   0.1 1.00e+00 1.00e+00h  1\n  58  6.3222864e+01 7.26e-06 4.38e+04  -3.8 1.55e-01  -0.3 5.50e-01 3.87e-01f  1\n  59  6.3166880e+01 5.44e-06 2.33e+04  -3.8 5.77e-02   0.1 2.44e-01 5.87e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  60  6.3149290e+01 4.48e-06 6.79e+02  -3.8 4.28e-02   0.5 4.45e-01 2.63e-01f  1\n  61  6.3084398e+01 5.95e-06 1.01e+04  -3.8 7.59e-02   0.0 3.79e-01 5.73e-01f  1\n  62  6.3081178e+01 5.21e-06 1.78e+04  -3.8 2.87e-02   0.5 9.73e-01 1.26e-01f  1\n  63  6.3041071e+01 2.01e-05 5.57e+03  -3.8 1.52e-01  -0.0 9.97e-01 7.01e-01f  1\n  64  6.3023349e+01 1.24e-05 3.15e+03  -3.8 5.92e-02   0.4 1.00e+00 4.35e-01f  1\n  65  6.3012621e+01 5.82e-06 1.45e+03  -3.8 3.31e-02  -0.1 1.40e-01 5.39e-01f  1\n  66  6.2995112e+01 5.36e-06 6.86e+02  -3.8 7.34e-02   0.4 7.37e-01 5.27e-01f  1\n  67  6.2987099e+01 6.86e-06 3.17e+02  -3.8 1.15e-01  -0.1 3.03e-01 5.38e-01f  1\n  68  6.2979870e+01 4.45e-06 1.84e+02  -3.8 6.50e-02   0.3 3.38e-01 4.22e-01f  1\n  69  6.2967247e+01 4.19e-06 1.73e+02  -3.8 4.28e+00    -  1.27e-01 5.94e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  70  6.2962369e+01 3.46e-06 1.42e+02  -3.8 1.03e+00    -  6.84e-01 1.80e-01f  1\n  71  6.2956287e+01 2.06e-07 1.68e+00  -3.8 2.18e-01    -  1.00e+00 1.00e+00f  1\n  72  6.2956772e+01 4.72e-10 2.56e-02  -3.8 7.54e-02    -  1.00e+00 1.00e+00h  1\n  73  6.2949863e+01 1.85e-07 3.21e+03  -5.7 1.19e-01    -  6.96e-01 4.80e-01f  1\n  74  6.2944283e+01 3.89e-08 6.01e+02  -5.7 1.76e-01    -  8.02e-01 8.07e-01f  1\n  75  6.2943096e+01 4.75e-10 1.07e-02  -5.7 8.33e-02    -  1.00e+00 1.00e+00f  1\n  76  6.2943101e+01 3.42e-12 2.59e-07  -5.7 8.64e-04    -  1.00e+00 1.00e+00h  1\n  77  6.2942942e+01 1.76e-11 5.66e-01  -8.6 7.23e-03    -  9.92e-01 9.89e-01f  1\n  78  6.2942941e+01 7.79e-16 2.15e-08  -8.6 1.46e-04    -  1.00e+00 1.00e+00f  1\n\nNumber of Iterations....: 78\n\n                                   (scaled)                 (unscaled)\nObjective...............:   6.2942940824362253e+01    6.2942940824362253e+01\nDual infeasibility......:   2.1459681143198850e-08    2.1459681143198850e-08\nConstraint violation....:   7.7889084071358639e-16    7.7889084071358639e-16\nVariable bound violation:   7.9550441415318352e-09    7.9550441415318352e-09\nComplementarity.........:   2.5072181829339853e-09    2.5072181829339853e-09\nOverall NLP error.......:   2.5072181829339853e-09    2.1459681143198850e-08\n\n\nNumber of objective function evaluations             = 96\nNumber of objective gradient evaluations             = 79\nNumber of equality constraint evaluations            = 96\nNumber of inequality constraint evaluations          = 96\nNumber of equality constraint Jacobian evaluations   = 79\nNumber of inequality constraint Jacobian evaluations = 79\nNumber of Lagrangian Hessian evaluations             = 78\nTotal seconds in IPOPT                               = 1.183\n\nEXIT: Optimal Solution Found.\n","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Retrieve-and-Plot-the-Results","page":"Pandemic Control","title":"Retrieve and Plot the Results","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Now we can retrieve the optimal results and plot them to visualize the optimal policy. Note that the values of infinite variables will be returned as arrays corresponding to how the supports were used to discretize our model. We can retrieve our values using value.","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Get the results:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"r_opt = value(r) * 100 # make the population fractions into percentages\ns_opt = value(s) * 100\ni_opt = value(i) * 100\ne_opt = value(e) * 100\nu_opt = value(u)\nobj_opt = objective_value(model)\nts = value(t)\nÎ¾s = value(Î¾);","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Plot the values of r(t xi) and s(t xi) over time with confidence bounds:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"r_mean = mean(r_opt, dims = 2)\nr_std = std(r_opt, dims = 2)\nplot(ts, r_mean, label = \"r(t, Î¾)\", linecolor = :red, background_color = :transparent)\nplot!(ts, r_mean + r_std, linecolor = :red, linestyle = :dash, linealpha = 0.4, label = \"\")\nplot!(ts, r_mean - r_std, linecolor = :red, linestyle = :dash, linealpha = 0.4, label = \"\")\n\ns_mean = mean(s_opt, dims = 2)\ns_std = std(s_opt, dims = 2)\nplot!(ts, s_mean, label = \"s(t, Î¾)\", linecolor = :blue)\nplot!(ts, s_mean + s_std, linecolor = :blue, linestyle = :dash, linealpha = 0.4, label = \"\")\nplot!(ts, s_mean - s_std, linecolor = :blue, linestyle = :dash, linealpha = 0.4, label = \"\")\nylabel!(\"Pop. (%)\")\nxlabel!(\"Time (Days)\")","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"<img src=\"data:image/png;base64,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\" />","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Plot the values of i(t xi) and e(t xi) over time with confidence bounds:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"i_mean = mean(i_opt, dims = 2)\ni_std = std(i_opt, dims = 2)\nplot(ts, i_mean, label = \"i(t, Î¾)\", linecolor = :green, background_color = :transparent)\nplot!(ts, i_mean + i_std, linecolor = :green, linestyle = :dash, linealpha = 0.4, label = \"\")\nplot!(ts, i_mean - i_std, linecolor = :green, linestyle = :dash, linealpha = 0.4, label = \"\")\n\ne_mean = mean(e_opt, dims = 2)\ne_std = std(e_opt, dims = 2)\nplot!(ts, e_mean, label = \"e(t, Î¾)\", linecolor = :purple)\nplot!(ts, e_mean + e_std, linecolor = :purple, linestyle = :dash, linealpha = 0.4, label = \"\")\nplot!(ts, e_mean - e_std, linecolor = :purple, linestyle = :dash, linealpha = 0.4, label = \"\")\nylabel!(\"Pop. (%)\")\nxlabel!(\"Time (Days)\")","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"<img src=\"data:image/png;base64,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\" />","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Plot the values of u(t) over time:","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"plot(ts, u_opt, linecolor = :orange, label = \"u(t)\", ylims = (-0.02, 1.02),\n     background_color = :transparent)\nxlabel!(\"Time (Days)\")\nylabel!(\"Distancing Ratio\")","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAGQCAYAAAByNR6YAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdeZxbZdn/8c+dzExnSUoXRQFFWiqiIouyyKr44IbizkhnpiCC1A1R1AfFB63ihguK+vizuCDtZIqDPopocUco4MKighTZZC8iW+0snU4muX9/3Gc6mTTbyTmZ5CTf9+uVF01ycnK3py1Xr/s61wUiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiJSA93ApwN8Ph7WQiQSdL1bi653a9H1bi263jX2TOD+AJ9PhrUQiQRd79ai691adL1by5xd79hcfVEI2su83zEnqxAREREpo14B1meAq4G7gVeWOTYB/B/wOLAZODvv/VcDDwKPAn8B9g51pSIiIiI+1SvAegL4EmCAnjLHnu0d8xRgP+AM4AjvvR5gCFgJLMAFYt+rwXpFREREIuNW4E1ljnkIeEXO8/OBb3s/7gf+mvNeApgA9ipzTtVgiR+63q1F17u16Hq3FtVgebqBXYGNOa/dBizzfrws771RXOD07ArObYCFeY9ydV4iIiIiZbXVewFlLPD+O5rz2giwKOf9sbzPjOCCpVK6gF2Af+a9fj7wlQrW1QPYCo6T5qDr3Vp0vVuLrndrCXK9J4CpSg9u9ADrMdwvxE64AndwQdUjOe/vmveZhcC/y5x3K7AJ2L3KdRlmB33S3HS9W4uud2vR9W4tc3a9G32LcBJ3p+EBOa/tj9smxPtv7nuLgWcA/5iT1YmIiIg0kBcBxwD3Aqu8H09vB74G+GbOsf8N3IDLNh0FPAns673XgSuCPx3YGVgNrK/g+1XkLn7oercWXe/WouvdWubsetdri3A5ruXCncDh3uP9uG3AOLOLzc/HtWj4PbAFeBdws/feJC4g+yrwIeDPwMk1X/2MxcAec/h9UbQRtyUrIiLSMky9F1AnzwSupfoarCSumP5rwOtxTU5lR3vgAufBOq8jqOnrLa1B17u16Hq3ljm73o1e5N7o4sB5zN7SlBkXod9jIiLSghq9yF1EREQkchRgiYiIiIRMAZaIiIhIyBRgiYiIiIRMAZaIiIhIyBRgiYiIiIRMAZaUsgvQW+L9o5g9qkhERERQgCWlfQ7X6wvgacBP895/FPgO+n0kIiIyi/7HKMU8A3gF8EPveSfw0rxjbsPNhnz13C1LRESk8SnAal1vAYbzXvs3br4iuHmRVwBp7/mPgB7gbu/xLO/1HwMrarpSERGRiNEYkxqwKZ7NTABSfwvZYI5lW96rHUBihyNn5lMeAfwi5703A7cAe+Z95gbgIyGtVEREpCkowKqN44Gj672I7TbzIPAPn5/aDZfRKucRYFdcNjTr8ztERESakgKsGjD9fBb4bL3XUQWT8+NJXJarnHnesQquREREPKrBal2bgUU5z5cyc8cgwJ3M3uZM570/bXfgrtBXJyIiEmEKsFrXn4HnAiuBY4DzmZ2F+jVweM7zR4Ax4CzcFuh0/dbh3rEiIiLiUYDVuh4DXgu8BDgROAc4D9jqvf8j4EXM3FWYwQVind7r83Bbim/F9cISERERj2qwWtsG7zHtlpwfbwW+BJwBfNx77WbvMe0NwI3AxhquUUREJHIUYEkpX8N1cC/mGrQ9KCIisgMFWFLKFPBQifcfm6uFiIiIRIlqsERERERCpgBLREREJGQKsERERERCpgBLREREJGQqcg/uAFzjTdnRHsBV9V6EiIjIXFOAFcxVwFtQgFXMo8zurSUiIiJN7JnA/QE+nwxrIRIJut6tRde7teh6t5Y5u96qwRIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERERkZApwBIREREJmQIsERGRJmNTnGtTvDK08w0yZNeyLLTzDXG1HWR+WOdrRAqwREREms8+WJaEdjbDAcAuoZ3PchiGQ0M7XwNSgCUiItJ8khgSIZ4vQYzuME5kL6ITiGM5MozzNSoFWCIiIs0nCaEGWEmgJ5QzxbzzxDgqlPM1KAVYIiIizcaSxAVFYenBhJPBIk4X8CSWA+x65oVyzgakAEtERKTZGJLYcDJOdpguoA0b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\" />","category":"page"},{"location":"examples/Optimal Control/pandemic_control/#Maintenance-Tests","page":"Pandemic Control","title":"Maintenance Tests","text":"","category":"section"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"These are here to ensure this example stays up to date.","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"using Test\n@test termination_status(model) == MOI.LOCALLY_SOLVED\n@test has_values(model)\n@test u_opt isa Vector{<:Real}","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"Test Passed","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"","category":"page"},{"location":"examples/Optimal Control/pandemic_control/","page":"Pandemic Control","title":"Pandemic Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Optimal Control/Fishing/#Fishing-Optimal-Control","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"We will solve an optimal control problem to maximize profit constrained by fish population.","category":"page"},{"location":"examples/Optimal Control/Fishing/#Problem-Statement-and-Model","page":"Fishing Optimal Control","title":"Problem Statement and Model","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"In this system, our input is the fishing rate u, and the profit J will be defined in the objective to maximize. Our profit objective is represented as:","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"beginaligned\nmax_u(t) J(t) \nJ = int_0^10 left(E - fraccxright) u U_max  dt \ntextst  fracdxdt= rx(t)left(1 - fracx(t)kright) - uU_max t in 010 \nx(0) = 70 \n0 leq u(t) leq 1 \nE = 1  c = 175  r = 071  k = 805  U_max = 20 \nJ(0) = 0 \nendaligned","category":"page"},{"location":"examples/Optimal Control/Fishing/#Modeling-in-InfiniteOpt","page":"Fishing Optimal Control","title":"Modeling in InfiniteOpt","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"First we must import InfiniteOpt and other packages.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"using InfiniteOpt, Ipopt, Plots;","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Next we specify our initial conditions and problem variables.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"x0 = 70\nE, c, r, k, Umax = 1, 17.5, 0.71, 80.5, 20;","category":"page"},{"location":"examples/Optimal Control/Fishing/#Model-Initialization","page":"Fishing Optimal Control","title":"Model Initialization","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"We initialize the infinite model with InfiniteModel and select Ipopt as our optimizer that will be used to solve it.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"m = InfiniteModel(Ipopt.Optimizer);","category":"page"},{"location":"examples/Optimal Control/Fishing/#Infinite-Parameter-Definition","page":"Fishing Optimal Control","title":"Infinite Parameter Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"We now define the infinite parameter t in 0 10 to represent time over a 10 year period. We'll also specify 100 equidistant time points.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"@infinite_parameter(m, t in [0, 10], num_supports=100)","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"t","category":"page"},{"location":"examples/Optimal Control/Fishing/#Infinite-Variable-Definition","page":"Fishing Optimal Control","title":"Infinite Variable Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Now that we have our infinite parameter defined, let's specify our infinite variables:","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"1 leq x(t) : fish population at time t\n0 leq u(t) leq 1 : fishing rate\nJ(t) : profit over time","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"@variable(m, 1 <= x, Infinite(t))\n@variable(m, 0 <= u <= 1, Infinite(t));\n@variable(m, J, Infinite(t));","category":"page"},{"location":"examples/Optimal Control/Fishing/#Objective-Definition","page":"Fishing Optimal Control","title":"Objective Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Now we add the objective using @objective to maximize profit J at the end of the 10 year period:","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"@objective(m, Max, J(10));","category":"page"},{"location":"examples/Optimal Control/Fishing/#Constraint-Definition","page":"Fishing Optimal Control","title":"Constraint Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"The last step is to add our constraints. First, define the ODEs which serve as our system model.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"@constraint(m, âˆ‚(J,t) == (E-c/x) * u * Umax)\n@constraint(m, âˆ‚(x,t) == r * x *(1 - x/k) - u*Umax);","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"We also set our initial conditions for x and J.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"@constraint(m, x(0) == x0)\n@constraint(m, J(0) == 0);","category":"page"},{"location":"examples/Optimal Control/Fishing/#Problem-Solution","page":"Fishing Optimal Control","title":"Problem Solution","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Now we're ready to solve! We can solve the model by invoking optimize!:","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"optimize!(m)","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\nThis is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:     1296\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:      400\n\nTotal number of variables............................:      500\n                     variables with only lower bounds:      100\n                variables with lower and upper bounds:      100\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      400\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  0.0000000e+00 6.90e+01 1.45e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1 -1.8548441e+00 6.89e+01 1.12e+01  -1.0 9.50e+03  -2.0 1.44e-04 1.76e-03h  1\n   2 -2.6101623e+00 6.88e+01 1.12e+01  -1.0 3.84e+03  -1.6 3.43e-04 7.39e-04h  1\n   3 -8.1519321e+00 6.85e+01 5.40e+01  -1.0 3.34e+03  -2.1 1.00e-03 4.91e-03h  1\n   4 -1.5382109e+01 6.80e+01 6.91e+01  -1.0 2.26e+03  -2.5 1.14e-03 7.62e-03f  4\n   5 -2.3521800e+01 6.72e+01 6.64e+01  -1.0 2.27e+03    -  1.32e-02 1.07e-02h  3\n   6 -3.2524402e+01 6.62e+01 6.32e+01  -1.0 1.67e+03    -  2.84e-02 1.51e-02h  2\n   7 -3.9860630e+01 6.51e+01 5.06e+01  -1.0 9.09e+02    -  8.43e-02 1.60e-02h  1\n   8 -4.5178330e+01 6.40e+01 3.21e+01  -1.0 2.71e+03    -  3.44e-02 1.70e-02h  1\n   9 -4.9707626e+01 6.30e+01 3.08e+01  -1.0 1.38e+03    -  1.50e-02 1.62e-02h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10 -5.3966386e+01 6.19e+01 3.24e+01  -1.0 2.10e+03    -  1.11e-02 1.72e-02h  1\n  11 -5.5735727e+01 6.14e+01 3.15e+01  -1.0 3.23e+03    -  1.00e-02 9.14e-03h  1\n  12 -5.7438744e+01 6.07e+01 3.26e+01  -1.0 2.39e+03    -  7.16e-03 1.01e-02f  1\n  13 -5.6890891e+01 6.02e+01 3.64e+01  -1.0 4.84e+03    -  2.54e-03 8.82e-03f  1\n  14 -5.6868789e+01 5.97e+01 3.60e+01  -1.0 1.10e+04    -  2.31e-03 7.95e-03f  2\n  15 -5.7110966e+01 5.95e+01 3.69e+01  -1.0 1.97e+03  -2.1 3.18e-03 3.64e-03h  1\n  16 -5.9420322e+01 5.84e+01 4.18e+01  -1.0 1.70e+03  -2.6 3.38e-03 1.82e-02f  1\n  17 -5.9499934e+01 5.83e+01 3.16e+01  -1.0 1.14e+03  -2.2 1.21e-02 1.23e-03h  1\n  18 -6.0120020e+01 5.75e+01 4.82e+01  -1.0 1.34e+03  -1.7 8.68e-03 1.48e-02h  1\n  19 -6.0855779e+01 5.70e+01 4.78e+01  -1.0 1.92e+03  -2.2 5.24e-03 8.16e-03f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20 -6.0963105e+01 5.69e+01 3.59e+01  -1.0 2.14e+03  -1.8 6.02e-03 1.80e-03f  1\n  21 -7.3097707e+01 5.62e+01 4.14e+01  -1.0 2.01e+03  -2.3 1.80e-03 1.27e-02f  1\n  22 -7.3128657e+01 5.61e+01 1.23e+02  -1.0 1.21e+03  -0.9 8.10e-03 1.26e-03h  1\n  23 -7.3128597e+01 5.61e+01 1.53e+03  -1.0 2.73e+03  -0.5 8.41e-03 9.58e-05h  1\n  24 -7.3194925e+01 5.46e+01 7.12e+02  -1.0 3.17e+03  -1.0 7.53e-03 2.73e-02f  1\n  25 -7.3257003e+01 5.42e+01 8.00e+02  -1.0 9.45e+02  -0.6 3.10e-02 7.73e-03f  1\n  26 -7.3260596e+01 5.41e+01 6.85e+02  -1.0 1.39e+03  -1.0 3.96e-02 5.10e-04h  1\n  27 -7.3243186e+01 5.33e+01 4.89e+03  -1.0 1.62e+03  -0.6 9.60e-02 1.49e-02h  1\n  28 -7.3562368e+01 5.20e+01 4.65e+03  -1.0 9.38e+02  -1.1 3.48e-02 2.43e-02f  1\n  29 -7.3562755e+01 5.19e+01 4.54e+03  -1.0 7.25e+02  -0.7 1.17e-01 1.67e-03h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30 -7.3601728e+01 5.06e+01 2.75e+03  -1.0 8.08e+02  -1.1 2.21e-01 2.56e-02f  1\n  31 -7.3564204e+01 4.97e+01 2.75e+03  -1.0 6.83e+02  -0.7 1.07e-01 1.85e-02h  1\n  32 -7.3354094e+01 4.83e+01 2.33e+03  -1.0 7.15e+02  -1.2 8.51e-02 2.78e-02h  1\n  33 -7.4140845e+01 4.62e+01 2.38e+03  -1.0 6.32e+02  -1.7 1.86e-02 4.24e-02f  1\n  34 -7.4005466e+01 4.58e+01 2.31e+03  -1.0 4.26e+02  -1.2 2.16e-02 1.05e-02h  1\n  35 -7.3322754e+01 4.52e+01 2.34e+03  -1.0 6.08e+02  -1.7 1.06e-04 1.22e-02h  2\n  36 -7.3322243e+01 4.52e+01 2.34e+03  -1.0 3.86e+02  -0.4 5.12e-02 9.73e-04h  1\n  37 -7.3320164e+01 4.51e+01 2.34e+03  -1.0 3.79e+02  -0.9 1.03e-01 2.85e-04h  1\n  38 -7.2740602e+01 4.39e+01 2.02e+03  -1.0 5.38e+02  -1.3 1.35e-01 2.71e-02h  1\n  39 -7.1495073e+01 4.25e+01 1.90e+03  -1.0 7.55e+02  -1.8 4.60e-02 3.14e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40 -7.1303911e+01 4.22e+01 1.70e+03  -1.0 4.84e+02  -1.4 1.68e-01 7.67e-03h  1\n  41 -6.9076921e+01 4.05e+01 1.72e+03  -1.0 7.80e+02  -1.9 8.19e-03 4.05e-02f  1\n  42 -6.8670722e+01 4.00e+01 1.71e+03  -1.0 5.03e+02  -1.4 2.03e-03 1.20e-02h  1\n  43 -6.8670014e+01 3.99e+01 1.64e+03  -1.0 4.17e+02  -1.0 4.93e-02 1.68e-03h  1\n  44 -6.8217569e+01 3.94e+01 1.64e+03  -1.0 5.28e+02  -1.5 9.93e-04 1.35e-02h  1\n  45 -6.8217573e+01 3.94e+01 1.06e+03  -1.0 4.19e+02  -1.1 4.44e-01 5.86e-04h  1\n  46 -6.7829649e+01 3.88e+01 1.04e+03  -1.0 5.65e+02  -1.5 2.23e-02 1.55e-02h  1\n  47 -6.7829414e+01 3.88e+01 1.09e+03  -1.0 2.40e+02  -1.1 9.39e-02 4.31e-05h  1\n  48 -6.7135068e+01 3.79e+01 1.03e+03  -1.0 5.82e+02  -1.6 6.14e-02 2.20e-02h  1\n  49 -6.5035447e+01 3.67e+01 9.60e+02  -1.0 8.39e+02  -2.1 4.68e-02 3.15e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50 -6.4843797e+01 3.65e+01 9.09e+02  -1.0 4.02e+02  -1.6 6.57e-02 5.60e-03h  1\n  51 -6.3479506e+01 3.59e+01 9.31e+02  -1.0 1.20e+03  -2.1 4.71e-05 1.66e-02f  1\n  52 -6.3548816e+01 3.59e+01 9.27e+02  -1.0 6.76e+02  -1.7 3.76e-03 1.92e-03h  1\n  53 -6.3548598e+01 3.59e+01 8.86e+02  -1.0 2.83e+02  -1.3 1.16e-01 4.52e-05h  1\n  54 -6.3285066e+01 3.56e+01 8.70e+02  -1.0 7.53e+02  -1.7 6.38e-02 5.79e-03h  1\n  55 -6.2051582e+01 3.50e+01 8.07e+02  -1.0 1.27e+03  -2.2 4.25e-02 1.71e-02f  1\n  56 -6.1758101e+01 3.48e+01 8.47e+02  -1.0 9.05e+02  -1.8 1.03e-01 5.92e-03h  1\n  57 -6.0328811e+01 3.42e+01 7.88e+02  -1.0 1.52e+03  -2.3 4.52e-02 1.83e-02f  1\n  58 -6.0061572e+01 3.40e+01 8.69e+02  -1.0 1.19e+03  -1.8 6.22e-02 4.73e-03h  1\n  59 -5.8602031e+01 3.34e+01 8.14e+02  -1.0 1.48e+03  -2.3 4.38e-02 1.88e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  60 -5.8336469e+01 3.32e+01 8.57e+02  -1.0 1.03e+03  -1.9 4.30e-02 5.04e-03h  1\n  61 -5.7966898e+01 3.30e+01 1.11e+03  -1.0 1.08e+03  -1.5 3.96e-02 7.77e-03h  1\n  62 -5.7078590e+01 3.26e+01 1.09e+03  -1.0 1.81e+03  -1.9 4.27e-02 1.18e-02f  1\n  63 -5.6841293e+01 3.25e+01 1.40e+03  -1.0 1.62e+03  -1.5 3.40e-02 3.42e-03h  1\n  64 -5.5578931e+01 3.20e+01 1.31e+03  -1.0 2.14e+03  -2.0 6.65e-02 1.41e-02f  1\n  65 -5.5291009e+01 3.19e+01 1.68e+03  -1.0 1.88e+03  -1.6 3.86e-02 3.46e-03h  1\n  66 -5.3911861e+01 3.14e+01 1.44e+03  -1.0 2.20e+03  -2.1 9.88e-02 1.45e-02f  1\n  67 -5.3332039e+01 3.12e+01 1.74e+03  -1.0 2.04e+03  -1.6 3.91e-02 6.27e-03f  1\n  68 -5.2104830e+01 3.08e+01 1.44e+03  -1.0 1.95e+03  -2.1 8.01e-02 1.33e-02f  1\n  69 -5.1086135e+01 3.05e+01 1.67e+03  -1.0 2.04e+03  -1.7 4.62e-02 1.08e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  70 -4.9970887e+01 3.01e+01 1.47e+03  -1.0 1.51e+03  -2.2 5.01e-02 1.22e-02f  1\n  71 -4.8771076e+01 2.97e+01 1.55e+03  -1.0 1.78e+03  -1.7 5.53e-02 1.43e-02f  1\n  72 -4.8642430e+01 2.96e+01 2.59e+03  -1.0 1.56e+03  -1.3 5.23e-02 1.61e-03h  1\n  73 -4.6434003e+01 2.90e+01 2.63e+03  -1.0 2.25e+03  -1.8 9.89e-02 2.02e-02f  1\n  74 -4.6217701e+01 2.90e+01 3.65e+03  -1.0 1.68e+03  -1.4 7.31e-02 2.40e-03h  1\n  75 -4.4329808e+01 2.84e+01 3.41e+03  -1.0 1.93e+03  -1.8 6.00e-02 1.89e-02f  1\n  76 -4.3910729e+01 2.83e+01 4.24e+03  -1.0 1.68e+03  -1.4 9.38e-02 4.64e-03f  1\n  77 -4.2230654e+01 2.78e+01 3.77e+03  -1.0 1.58e+03  -1.9 7.54e-02 1.84e-02f  1\n  78 -4.1016603e+01 2.74e+01 4.03e+03  -1.0 1.52e+03  -1.5 8.90e-02 1.46e-02f  1\n  79 -3.9161710e+01 2.68e+01 3.58e+03  -1.0 1.61e+03  -1.9 6.91e-02 2.08e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  80 -3.8916774e+01 2.67e+01 3.65e+03  -1.0 8.55e+02  -1.5 8.70e-02 3.47e-03h  1\n  81 -3.7317470e+01 2.62e+01 3.22e+03  -1.0 1.76e+03  -2.0 7.60e-02 1.98e-02f  1\n  82 -3.6862207e+01 2.60e+01 3.41e+03  -1.0 1.61e+03  -1.6 5.49e-02 5.59e-03f  1\n  83 -3.5750281e+01 2.56e+01 4.02e+03  -1.0 1.25e+03  -1.1 5.98e-02 1.73e-02f  1\n  84 -3.4943221e+01 2.53e+01 3.81e+03  -1.0 1.80e+03  -1.6 6.55e-02 8.81e-03f  1\n  85 -3.3888511e+01 2.49e+01 4.24e+03  -1.0 1.22e+03  -1.2 9.04e-02 1.59e-02f  1\n  86 -3.2359512e+01 2.45e+01 3.93e+03  -1.0 1.72e+03  -1.7 4.97e-02 1.73e-02f  1\n  87 -3.1972051e+01 2.43e+01 3.77e+03  -1.0 8.77e+02  -1.2 1.38e-01 6.96e-03h  1\n  88 -3.0047044e+01 2.38e+01 3.48e+03  -1.0 1.64e+03  -1.7 5.26e-02 2.31e-02f  1\n  89 -2.9908135e+01 2.37e+01 4.30e+03  -1.0 1.25e+03  -1.3 1.02e-01 1.88e-03h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  90 -2.8185232e+01 2.32e+01 3.53e+03  -1.0 1.53e+03  -1.8 1.11e-01 2.29e-02f  1\n  91 -2.7789946e+01 2.31e+01 4.09e+03  -1.0 1.37e+03  -1.3 8.16e-02 5.38e-03h  1\n  92 -2.6406264e+01 2.26e+01 9.61e+02  -1.0 1.32e+03  -1.8 5.21e-01 2.17e-02f  1\n  93 -2.5907022e+01 2.23e+01 7.19e+02  -1.0 9.48e+02  -1.4 7.05e-02 1.06e-02h  1\n  94 -2.4814415e+01 2.17e+01 1.03e+03  -1.0 6.97e+02  -1.0 8.21e-02 3.00e-02h  1\n  95 -2.2729667e+01 2.10e+01 9.91e+02  -1.0 1.42e+03  -1.4 6.88e-02 2.85e-02f  1\n  96 -2.2612328e+01 2.10e+01 2.04e+03  -1.0 5.83e+02  -1.0 8.98e-02 2.31e-03h  1\n  97 -2.0613290e+01 2.04e+01 1.75e+03  -1.0 1.30e+03  -1.5 9.99e-02 2.97e-02f  1\n  98 -2.0476518e+01 2.03e+01 2.98e+03  -1.0 9.70e+02  -1.1 8.89e-02 2.39e-03h  1\n  99 -1.8680567e+01 1.97e+01 2.20e+03  -1.0 1.18e+03  -1.5 1.55e-01 2.98e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 100 -1.8426781e+01 1.96e+01 3.23e+03  -1.0 1.00e+03  -1.1 9.40e-02 4.53e-03h  1\n 101 -1.6882140e+01 1.90e+01 1.58e+03  -1.0 1.04e+03  -1.6 2.59e-01 2.92e-02f  1\n 102 -1.6236404e+01 1.88e+01 2.29e+03  -1.0 9.94e+02  -1.2 8.74e-02 1.22e-02h  1\n 103 -1.5089463e+01 1.83e+01 9.94e+02  -1.0 8.25e+02  -1.6 3.29e-01 2.60e-02f  1\n 104 -1.3445032e+01 1.76e+01 8.79e+02  -1.0 8.54e+02  -1.2 9.09e-02 3.73e-02h  1\n 105 -1.2546694e+01 1.73e+01 9.50e+02  -1.0 1.03e+03  -1.7 9.05e-02 1.96e-02f  1\n 106 -1.1886532e+01 1.70e+01 9.13e+02  -1.0 6.28e+02  -1.3 1.07e-01 1.96e-02f  1\n 107 -1.0379088e+01 1.63e+01 1.08e+03  -1.0 1.01e+03  -1.7 9.44e-02 3.69e-02f  1\n 108 -1.0310464e+01 1.63e+01 8.07e+02  -1.0 6.43e+02  -1.3 6.57e-02 1.86e-03h  1\n 109 -9.6672191e+00 1.60e+01 1.24e+03  -1.0 7.16e+02  -0.9 6.49e-02 1.95e-02h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 110 -8.5729304e+00 1.55e+01 8.90e+02  -1.0 7.18e+02  -1.4 1.36e-01 3.13e-02f  1\n 111 -8.4995146e+00 1.55e+01 1.91e+03  -1.0 6.59e+02  -0.9 8.53e-02 1.98e-03h  1\n 112 -6.4508726e+00 1.47e+01 1.51e+03  -1.0 8.75e+02  -1.4 2.01e-01 4.78e-02f  1\n 113 -6.3816741e+00 1.47e+01 2.51e+03  -1.0 5.48e+02  -1.0 1.08e-01 2.05e-03h  1\n 114 -4.4117376e+00 1.39e+01 1.48e+03  -1.0 7.90e+02  -1.5 3.84e-01 5.09e-02f  1\n 115 -4.2732133e+00 1.39e+01 2.14e+03  -1.0 5.96e+02  -1.0 1.09e-01 4.21e-03h  1\n 116 -2.4458467e+00 1.31e+01 1.25e+03  -1.0 6.94e+02  -1.5 3.96e-01 5.37e-02f  1\n 117 -2.2052570e+00 1.30e+01 1.49e+03  -1.0 5.73e+02  -1.1 1.11e-01 7.99e-03h  1\n 118 -5.6997467e-01 1.23e+01 9.76e+02  -1.0 5.94e+02  -1.6 4.47e-01 5.61e-02f  1\n 119 -2.0428884e-01 1.21e+01 9.24e+02  -1.0 5.00e+02  -1.1 1.18e-01 1.46e-02h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 120  1.2183722e+00 1.14e+01 8.64e+02  -1.0 4.95e+02  -1.6 2.11e-01 5.81e-02f  1\n 121  1.2941454e+00 1.14e+01 8.12e+02  -1.0 4.36e+02  -1.2 1.33e-01 3.44e-03h  1\n 122  3.0173269e+00 1.13e+01 7.29e+02  -1.0 4.95e+02  -1.7 2.47e-01 7.28e-02f  1\n 123  3.1855863e+00 1.10e+01 6.60e+02  -1.0 3.71e+02  -1.3 1.34e-01 8.99e-03h  1\n 124  4.7735325e+00 1.24e+01 5.97e+02  -1.0 4.18e+02  -1.7 2.06e-01 8.31e-02f  1\n 125  4.8266776e+00 1.24e+01 5.27e+02  -1.0 2.73e+02  -1.3 1.53e-01 3.82e-03h  1\n 126  6.2951867e+00 1.13e+01 4.92e+02  -1.0 3.62e+02  -1.8 2.12e-01 8.98e-02f  1\n 127  6.3766365e+00 1.12e+01 4.37e+02  -1.0 2.48e+02  -1.4 1.74e-01 6.59e-03h  1\n 128  7.8907991e+00 1.02e+01 4.01e+02  -1.0 3.20e+02  -1.8 2.61e-01 1.01e-01f  1\n 129  7.9299761e+00 1.02e+01 3.45e+02  -1.0 2.11e+02  -1.4 2.28e-01 3.80e-03h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 130  9.8845242e+00 1.01e+01 2.60e+02  -1.0 2.90e+02  -1.9 2.22e-01 1.29e-01f  1\n 131  9.9524752e+00 1.00e+01 2.78e+02  -1.0 1.68e+02  -1.5 2.75e-01 7.56e-03h  1\n 132  1.2535831e+01 9.23e+00 2.73e+02  -1.0 2.33e+02  -1.9 8.06e-02 1.68e-01f  1\n 133  1.2584030e+01 9.17e+00 2.18e+02  -1.0 1.05e+02  -1.5 3.85e-01 6.64e-03h  1\n 134  1.3714978e+01 6.14e+00 4.27e+02  -1.0 1.28e+02  -1.1 3.93e-01 1.76e-01h  1\n 135  1.4878662e+01 5.85e+00 2.61e+02  -1.0 7.56e+01  -1.6 2.09e-01 1.24e-01f  1\n 136  1.4933646e+01 5.79e+00 5.40e+02  -1.0 7.91e+01  -1.1 1.00e+00 9.25e-03h  1\n 137  1.8811346e+01 6.48e+00 3.79e+02  -1.0 9.37e+01  -1.6 2.94e-01 3.74e-01f  1\n 138  1.8869967e+01 6.37e+00 1.16e+02  -1.0 2.98e+01  -1.2 1.00e+00 1.73e-02h  1\n 139  2.4618068e+01 6.46e+00 4.86e+01  -1.0 4.78e+01  -1.7 5.83e-01 6.61e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 140  5.6088394e+01 1.07e+01 7.43e+01  -1.0 3.15e+01  -2.1 3.17e-01 1.00e+00f  1\n 141  6.8401142e+01 7.82e+00 3.47e+01  -1.0 1.23e+01  -1.7 4.81e-01 1.00e+00f  1\n 142  6.9125304e+01 2.17e+00 6.83e+00  -1.0 4.85e+00  -1.3 8.46e-01 1.00e+00f  1\n 143  7.2449832e+01 9.46e-01 7.08e-01  -1.0 5.64e+00  -1.8 8.82e-01 1.00e+00f  1\n 144  8.0073894e+01 2.19e+00 3.92e+00  -1.7 7.62e+00  -2.2 5.18e-01 1.00e+00f  1\n 145  8.5378975e+01 3.73e+00 4.08e+00  -1.7 1.48e+03    -  4.00e-03 8.65e-03f  1\n 146  9.0984727e+01 5.23e+00 4.01e+00  -1.7 1.57e+02    -  4.87e-02 8.88e-02f  1\n 147  9.4941272e+01 4.36e+00 2.71e+00  -1.7 2.66e+01    -  3.23e-01 1.69e-01f  1\n 148  1.0121743e+02 3.29e+00 2.08e+00  -1.7 5.32e+01    -  1.60e-01 2.43e-01f  1\n 149  1.0462559e+02 2.32e+00 1.48e+00  -1.7 2.98e+01    -  3.48e-01 2.84e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 150  1.0631723e+02 1.52e+00 1.00e+00  -1.7 3.36e+01    -  3.44e-01 3.21e-01h  1\n 151  1.0690588e+02 1.00e+00 6.65e-01  -1.7 3.81e+01    -  3.03e-01 3.35e-01h  1\n 152  1.0698620e+02 7.43e-01 4.79e-01  -1.7 4.61e+01    -  1.00e+00 2.66e-01h  1\n 153  1.0657507e+02 1.31e-01 3.90e-03  -1.7 3.85e+00    -  1.00e+00 1.00e+00h  1\n 154  1.0664006e+02 2.99e-02 2.23e-03  -2.5 1.57e+00    -  1.00e+00 1.00e+00h  1\n 155  1.0678538e+02 7.37e-03 4.11e-03  -3.8 1.12e+00    -  8.96e-01 1.00e+00h  1\n 156  1.0679941e+02 2.16e-03 4.46e-05  -3.8 9.67e-01    -  1.00e+00 1.00e+00h  1\n 157  1.0680822e+02 8.37e-04 6.41e-04  -5.7 6.66e-01    -  8.54e-01 1.00e+00h  1\n 158  1.0680856e+02 1.69e-04 3.04e-05  -5.7 3.32e-01    -  9.83e-01 1.00e+00h  1\n 159  1.0680861e+02 3.53e-05 1.64e-07  -5.7 1.96e-01    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 160  1.0680870e+02 4.30e-06 2.32e-06  -8.6 6.96e-02    -  9.88e-01 1.00e+00h  1\n 161  1.0680871e+02 4.99e-08 2.10e-10  -8.6 8.15e-03    -  1.00e+00 1.00e+00h  1\n 162  1.0680871e+02 1.39e-11 6.76e-14  -9.0 2.52e-03    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 162\n\n                                   (scaled)                 (unscaled)\nObjective...............:  -1.0680870543718251e+02    1.0680870543718251e+02\nDual infeasibility......:   6.7566822382063500e-14    6.7566822382063500e-14\nConstraint violation....:   4.2045828098652596e-12    1.3875123272555356e-11\nVariable bound violation:   8.8945395493311707e-09    8.8945395493311707e-09\nComplementarity.........:   9.1127086454719753e-10    9.1127086454719753e-10\nOverall NLP error.......:   9.1127086454719753e-10    9.1127086454719753e-10\n\n\nNumber of objective function evaluations             = 177\nNumber of objective gradient evaluations             = 163\nNumber of equality constraint evaluations            = 177\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 163\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 162\nTotal seconds in IPOPT                               = 4.427\n\nEXIT: Optimal Solution Found.\n","category":"page"},{"location":"examples/Optimal Control/Fishing/#Extract-and-Plot-the-Results","page":"Fishing Optimal Control","title":"Extract and Plot the Results","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Now we can extract the optimal results and plot them to visualize how the fish population compares to the profit. Note that the values of infinite variables are returned as arrays corresponding to how the supports were used to discretize our model. We can use the value function to extract the values of the infinite variables.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"ts = value(t)\nu_opt = value(u)\nx_opt = value(x)\nJ_opt = value(J);","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Create the plot for the fish population and profit over time.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"p1 = plot(ts, [x_opt, J_opt] ,\n    label=[\"Fish Pop\" \"Profit\"],\n    title=\"State Variables\");","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Create the plot for the fishing rate over time.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"p2 = plot(ts, u_opt,\n    label = \"Fishing Rate\",\n    title = \"Fishing Rate vs Time\");","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Visualize the two plots on one figure.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"plot(p1,p2 ,layout=(2,1), size=(800,600))","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAJYCAIAAAAVFBUnAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd3xUVf438HOml5SZSQ8JaaSQ3kCadEQBaRaQIiK4oKtid62o67Prui42XBWRxbKuP1dWLCyKFGmhJ5NOZkISQhJCepl2p9zz/DE4ZANSQpJJ+bxf/DFz5t4730mGmU/OPfccyhgjAAAAANB9BO4uAAAAAGCgQcACGNRsNlt+fv7BgwcLCwsbGhrcXU5f8dJLL61YsYLjuGvaa+/evatWrdqxY8flN6uqqlqxYsV77713HQUCQF+HgAUwSLW0tDzwwANqtTo5OXncuHGJiYl+fn6RkZErVqzged612UcfffTFF1907SlaW1s3bNjw3//+t1sK3rt3L6U0NDTU4XBccgPGWFRUFKV079691/lc33zzzaZNm2w22zXtVVhYuGHDhtzc3Mtv1tTUtGnTpp07d15HgQDQ14ncXQAAuIHZbJ44cWJubq6/v//y5cujoqJaWlpKS0t37NixadOmDz74QCA4/9fX/fffP2TIkEWLFnXhWc6dO7dq1aqbbrppxowZ11/z+PHjhw0bVlpaumfPnqlTp168wZ49e8rKyiIiIsaPH3+dzzVy5EiNRiMS4RMSALoIHx8Ag9HHH3+cm5ubnJy8f/9+Ly8vV7vVat22bZsrXfUplNJ77rnn+eef/+STTy4ZsDZv3kwIuffeeyml1/lcH3300XUeAQAGOQQsgMHowIEDhJAVK1Z0TFeEEIlEMm/ePOftpqam8vJyxpjVaj1x4oSz0cvLKzo62nm7tbU1KyursrLSYDCEhIRMnjzZz8/PdaiamprCwkJCSFtbm2t3f3//0NBQ1zYNDQ27du2qrq6Wy+WjRo1KS0u7fNn33HPP2rVrt2zZ8u6776pUqo4PGQyGb775RiAQ3H333c6Wqqqq48ePnzlzhuf5qKioKVOmyOXyjrvU19dXVlaGhIQEBAScPHly//79bW1tS5cu9ff3Ly4uNplMaWlpHbPmFQ/YkVarzcrKstvtI0aMGD169OVfl0t2dvaxY8fa29tDQ0OnTZum0Wg6bdDc3HzgwIHTp0/zPO/r65uenh4XF3eVBweAXsUAYPBZsmQJIeSvf/3rZbb5/PPPL/7EmD59uvPRRx99VCwWd3xIJpO98cYbrt2ff/75i3d/5JFHnI/yPP/SSy91CigzZsxobm6+fOU333wzIWTDhg2d2jdu3NixvHHjxnV6an9//x9//LHjLs5h5q+99tp9993n2iwrK4sxlpycTAhpb293bXz1B/zzn/+8ePHijlvOnj3baDS6NnMO0po7d27HfcvKysaMGdNxLw8Pj40bN3bcZvPmzQqFolMZTz755OV/YgDgFghYAIPRG2+8QQgJCAjYtm2b3W6/5DZnz579+eefBQKBv7//z7/Kzs52Prp06dI1a9Zs27atsLAwNzf3ww8/DA4OJoR8++23zg1KS0v/8Y9/EEIyMjJcu5eUlDgffeqppwgh8fHxX375ZVFR0b59+26//XZCyLRp03iev0zl//d//0cIGTNmTKd2ZwD68ssvnXczMzP/3//7f7t27SopKTl69OjatWtlMplSqayoqHDt4sxDQ4cODQoKevvtt/ft2/ftt99WVlaySwWsqz9gcHBwSEjIli1bKisrDxw4MHbsWELIkiVLXJtdHLDq6upCQkIEAsGqVav27t1bXFz82WefBQUFUUq/++475zZlZWVisdjPz++zzz4rKSmpqKjYt2/f2rVrL5+SAcBdELAABqOWlpbExERnF4harZ41a9arr76anZ19cbgRCoVDhw69mmPm5ORQSidPnuxqKSkpIYTcdNNNnbYsLCyklEZERLS2tnZsnz59OiFk586dl3kWjuN8fX0JIcXFxa5GvV5PKdVoNGaz+bd2dKaf559/vlOLQCDIy8vrtPHFAeti69evv+QBCSHHjh1zNba3t/v7+xNCXM9yccBavXo1IeTll1/uePz8/HyRSBQfH++8+8knnzi7xy5TEgD0HX1xKCsA9DRvb+9jx469/PLLUVFRzc3NP/zww/PPP+8c0LNnz56uHTM1NTU0NPTo0aNX3PKf//wnY+zhhx/uNALs/vvvJ4RcfloHiURy1113EUI+++wzV+PmzZsZY4sWLZLJZL+145w5cwghF5c3Y8aMpKSkK9Z89QecMGFCZmam666Hh8eqVasIIf/5z38ueRyHw/Gvf/1LKpU++eSTHdsTExPHjx9fVFR0+vRpQoharSaEnDhx4lonjwAAt8Agd4BBSiaTvfjiiy+++GJJScmRI0f27NmzdetWnU53880379+/f+TIkZff3WKxvPPOO998883p06fPnTvXceosjuOkUull9s3JySGEHD58+A9/+EPH9rq6OkJIRUXF5Z965cqV77777ieffPLKK68IhUKe551ha/ny5a5tamtr//KXv+zevbu6urqxsdHVfvFkqvHx8Zd/ums9YEpKSqeW1NRUQkhRUdElj1xWVtba2urr6/vyyy93esh58IqKirCwsEmTJoWHh3/99deHDx+eOXPmxIkTb7rppotHwQNAH4GABTDYxcbGxsbG3n333a+//vott9xy4sSJP/3pT1u3br3MLg6HY/r06fv27YuKipo/f76fn5+z6+itt96qra212+2XD1gtLS2EkO3btwuFwk4PqdXqixs7SU5OTktLy8nJ2blz5/Tp03ft2lVZWZmUlJSenu7coKamZuTIkTU1NSNGjLjnnnvUarVIJOI4bu3atRdPUuo84Xh513TAjpdSOjlPEba3t1/y4M6fhnNS1osfVavVzi4rDw+PrKysF1544Ztvvvnwww8//PBDkUh0++23v/XWWwEBAVd8CQDQyxCwAOA8Pz+/5557bv78+a5ZFX7Ld999t2/fvunTp2/btq1jHlq3bt3VPJGHhwchZMuWLZeczupqLF++PCcn55NPPpk+fbpz+qsVK1a4Hn3zzTerq6tffPHFjn1CpaWla9eu7drTrVu37uoP6OyH6+jcuXOEkE7nQ108PT0JIdHR0c5ZLS4jKCho48aNH3zwQXZ29q5du/7xj398+eWXVVVV+/fvv6aXAwC9AGOwAOACZ89Tx8mfxGKx3W7vtJlWqyWE3HHHHR3TVVVVVads4ZzH4eLdnfNdHTx4sMt1Ll68WCqVOk9Qbt26VSKRdJxr3jmKfOHChR13yc7O7vLTXdMBnSdAL94yISHhktsPGzbM09Pz5MmTTU1NV1OMSCQaOXLkM888o9VqQ0JCDhw44AxwANCnIGABDEbfffddbW1tp0bG2KZNmwghGRkZrsYhQ4Y0NjaazeaOWzrPglVWVnZsfPHFFzsdMDg4mFJ65syZTu3Lli0TCAR///vfL36I53mTyXTF+jUazZw5cywWy4IFC0wm06233trxxJzzrF/H8qxW66uvvnrFw/6Wi1/vZQ544MCBw4cPu+62tbVt2LCBUnrbbbddcnuRSLRkyRKe55999tmLHzUYDJ1uuCgUCm9vb0LItS5KDQC9AAELYDD68ssvw8LC5s2b99577+3YsWPXrl0b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TMz48eNdd7/77rvQ0FCFQqHT6d54443Tp08HBATce++9zsVqGGMffPDB999/HxkZuXbtWl9f34sPmJKS4uPjM3r06P/85z8///xzTEzMzp07P/30U4vFMmvWrLvvvpsQUlFRsXHjxrFjx27YsEGtVj/11FNxcXG99YoBAGAgY1aLpSTbUnjEUnSUyj3lCSO9Z6+URib02csAr1MXx2DV1NQ0NTVlZGQ472ZmZhYUFBBCCgoKXI1JSUl2u728vDwhIaFbah1UysvLjx49SghRKpUJCQmffPLJwoULg4ODZ82a9fDDDz/44IO1tbVWq9W58datWyMiIp577rm33377wQcf/PLLL3/rsDabrbGx0dPTc8eOHUuXLv373//u7e398MMP19fXP/744/X19W+99VZJSckzzzxz8ODB8ePHl5SUqNXqXnrNAAAw4Dia6sxFRyyFR7iyQklYnDzhBs+pC0W+Qe6uq8d1MWDV19crFAqJROK8q1KpsrOzne3x8fGuzVQqVV1d3eUD1rlz53JyciIiIlwtL7zwwh133HH1xRgMBucN7jeWFmrmyPCvbVb+6g/ZG0SUbBovmjX00qeZv/jii59//pkQMnz48I0bNzobGWM1NTVxcXFJSUnJycmujZOTk5977jlCiEqlmjp16iUP+Morr4jF4v3793t6es6bN2/BggVPP/30bbfdRgh5++23ly9f/vjjjxNCOI774IMPfHx8Ro4cuWPHji+++OL3v//9xUdjjFkslvb29uv6EfQAo9HI8zzt/yfvoVsYjUbGmLurgD7B9U0BvYExR02Z/eQxW0k239YoikkXp4z3vO1hKpUzQsyEELd+fTgcDqvV6nA4unwEmUwmFosvv00XA5ZKpbJYLA6HQygUEkLa29ud/RwqlcpoNLo2c7VfRkBAQEJCwr///W/nXUppaGjoJS+XuwxPT09CiFQqveSjainR3Sl29LGARQjxlvzmQ88999yyZcs6NVJKP/jggxUrVjDGZs2a9dxzzw0ZMoQQ4lp+Ua1Wt7S0XPKA4eHhSqVy8uTJU6dOlUgk5eXliYmJzoeSkpJqamosFgshJCAgwMfHx9mekJBQVlZ2yaNRSmUymfPH3qdQSpVKJQIWOFFKsW4muPTBj6wBxrnKsrngsDn3ABVJZAkjPef9Tjosua+dBHQ4HBzH9fT4pS4GrODgYLFY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xIlNmzZt2LChtLR069atVnh37gRZfn5+tfU11zSEQqHYvHlzSkrKnj17Dh48OGbMGG79xx9/XF5e/uOPP06ZMsXY+MiRIw0ZSs8FzeDgYK6rxly9e/eOiIg4ffr0w4cPW7duzZ0ffPnll03btG7devv27VVVVZcvX+Z+Bd9++21xcfG+ffsa8Y7Ngfsh+Pn5FRQU2LoWAH7CGCwAfpJKpQMGDPj888+vXbsmk8n27dtnnSFB3bp1I4T8/vvvpisZhqm2puEkEskXX3xBCHnvvfeMvVOpqalisXjixImmLY03uzLiepWq9WmFhIT4+/tnZ2dzJwQbYdq0aSzLbt++PT09PTk5uXv37p07d6618r59+37yySfXr193d3c/dOiQTqdr3DtanL+/f0hIiFKpfPDgga1rAeAnBCwAXjEdfM3x9vaWSqV6vd46AWvy5MkSieS7774zXnVICPnhhx/u3LnT6G1OmDChS5cu6enpxnso+Pn56fV6016x4uLitWvXVnshdyusnJwc05UURXED0hctWsTWmMqi5g+wpmnTpgmFws2bN3/33XfEZHj707bg6enp4uLCMIxdnXfjbq7R6B8CANQNpwgBeOWtt97KyMiYOnVqx44dg4KCcnNz165dW1JSMnnyZNOJ7ZpPaGjo559//v777/fq1evVV19t0aLFlStXdu3aNXTo0JMnT3LDg8xFUdRHH300adKkTz/99IUXXhCJRIMHD7527drEiROXLFnSunXrmzdv/v3vf/fw8CguLjZ9Yffu3QkhK1euLC8vb9GiBUVREydO9Pb25saobdu2TalUzpw5s0OHDpWVlQ8fPjx27NjFixfrnRyauyHW8ePH169fL5FITE9TEkIWL16ckpLy0ksvRUREBAcHFxQU/Pvf/1YqlaNGjap5tYENLVq06PDhw7t373706FFiYmJERIRGo3n48OEvv/xy5syZ7OxsWxcI4NgQsAB4pWXLltu2bTM9H0dR1HPPPff1119brYaFCxe6u7t//vnn3BVq7dq127Nnz+XLl0+ePNnohMF1YqWmpu7YsePll1/+5JNPrl27dvr06fj4eK5BXFzce++9x91swqh79+4rVqxYvnz5kiVLuDW9e/f29vZ2c3M7e/bs3Llzd+3adfLkSWN7uVxe7bTj00yfPv348eOVlZUTJ040vSE+ISQ0NPSbb775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\" />","category":"page"},{"location":"examples/Optimal Control/Fishing/#Maintenance-Tests","page":"Fishing Optimal Control","title":"Maintenance Tests","text":"","category":"section"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"These are here to ensure this example stays up to date.","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"using Test\ntol = 1E-6\n@test termination_status(m) == MOI.LOCALLY_SOLVED\n@test has_values(m)\n@test u_opt isa Vector{<:Real}\n@test J_opt isa Vector{<:Real}\n@test isapprox(u_opt[end], 1.0000000088945395, atol=tol)\n@test isapprox(x_opt[end], 31.441105707837544, atol=tol)\n@test isapprox(J_opt[end], 106.80870543718251, atol=tol)","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"Test Passed","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"","category":"page"},{"location":"examples/Optimal Control/Fishing/","page":"Fishing Optimal Control","title":"Fishing Optimal Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Optimal Control/Jennings/#Minimizing-Final-Time-(Jennings-Problem)","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Solve an optimal control problem with a minimal final time. Set up and solve the Jennings optimal control benchmark problem.","category":"page"},{"location":"examples/Optimal Control/Jennings/#Problem-Statement-and-Model","page":"Minimizing Final Time (Jennings Problem)","title":"Problem Statement and Model","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"When solving differential equations over a variable time interval 0t_f, we can apply a time-scaling transformation to normalize the interval to01. This is achieved by introducing a final time parameter t_f. The Jennings optimal control problem divides derivatives by t_f. In practice, t_f appears on the right hand side to avoid any divisions by 0.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"begingathered\nfracfracdxdtt_f =  f(xu) \nfracdxdt = t_f f(xu) \nendgathered","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Our specific problem is defined as the following:","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"beginaligned\nmin_u(t)t_f t_f \ntextst  fracdx_1dt= t_f u  t in 01 \nfracdx_2dt = t_f cos(x_1(t))  t in 01 \nfracdx_3dt = t_f sin(x_1(t))  t in 01 \nx(0) = pi2 4 0 \nx_2(t_f) = 0 \nx_3(t_f) = 0 \n-2 leq u(t) leq 2\nendaligned","category":"page"},{"location":"examples/Optimal Control/Jennings/#Modeling-in-InfiniteOpt","page":"Minimizing Final Time (Jennings Problem)","title":"Modeling in InfiniteOpt","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"First we must import InfiniteOpt and other packages.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"using InfiniteOpt, Ipopt, Plots;","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Next we specify an array of initial conditions.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"x0 = [Ï€/2, 4, 0]; # x(0) for x1, x2, x3","category":"page"},{"location":"examples/Optimal Control/Jennings/#Model-Definition","page":"Minimizing Final Time (Jennings Problem)","title":"Model Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"We initialize the infinite model with InfiniteModel, opting to use the Ipopt solver.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"m = InfiniteModel(Ipopt.Optimizer);","category":"page"},{"location":"examples/Optimal Control/Jennings/#Infinite-Parameter-Definition","page":"Minimizing Final Time (Jennings Problem)","title":"Infinite Parameter Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Recall t is specified as  t in 01:","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"@infinite_parameter(m, t in [0,1],num_supports= 100);","category":"page"},{"location":"examples/Optimal Control/Jennings/#Variable-Definition","page":"Minimizing Final Time (Jennings Problem)","title":"Variable Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Now let's specify decision variables. Notice that t_f is not a function of time and is a singular value.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"@variable(m, x[1:3], Infinite(t))\n@variable(m, -2 <= u <= 2, Infinite(t))\n@variable(m, 0.1 <= tf);","category":"page"},{"location":"examples/Optimal Control/Jennings/#Objective-Definition","page":"Minimizing Final Time (Jennings Problem)","title":"Objective Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Now we add the objective using @objective to minimize final time:","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"@objective(m, Min, tf);","category":"page"},{"location":"examples/Optimal Control/Jennings/#Constraint-Definition","page":"Minimizing Final Time (Jennings Problem)","title":"Constraint Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"The last step is to add our constraints. First, define the ODEs which serve as our system model.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"@constraint(m, âˆ‚(x[1],t) == tf*u)\n@constraint(m, âˆ‚(x[2],t) == tf*cos(x[1]))\n@constraint(m, âˆ‚(x[3],t) == tf*sin(x[1]));","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Set our inital and final conditions for x.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"@constraint(m, [i in 1:3], x[i](0) == x0[i])\n@constraint(m, x[2](1) <=0)\n@constraint(m, x[3](1) <= 1e-1);","category":"page"},{"location":"examples/Optimal Control/Jennings/#Problem-Solution","page":"Minimizing Final Time (Jennings Problem)","title":"Problem Solution","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Now everything is ready for solving! We can solve the model with @optimize!:","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"optimize!(m)","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"This is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:     1794\nNumber of nonzeros in inequality constraint Jacobian.:        2\nNumber of nonzeros in Lagrangian Hessian.............:      700\n\nTotal number of variables............................:      701\n                     variables with only lower bounds:        1\n                variables with lower and upper bounds:      100\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      600\nTotal number of inequality constraints...............:        2\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        2\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.0999999e-01 4.00e+00 7.38e-03  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.0009999e-01 3.98e+00 2.15e+02  -1.0 4.00e+00    -  1.00e+00 4.78e-03h  1\n   2  1.0000218e-01 3.98e+00 1.31e+05  -1.0 4.16e+01    -  4.77e-02 7.77e-05h  1\n   3  1.0000001e-01 3.98e+00 1.32e+05  -1.0 1.41e+05    -  1.41e-05 1.39e-05h  1\n   4  1.0000001e-01 3.98e+00 1.07e+05  -1.0 2.60e+04    -  9.52e-05 5.36e-05h  1\n   5  1.0000001e-01 3.98e+00 2.07e+05  -1.0 1.43e+04    -  1.90e-04 2.73e-05h  1\n   6  1.0000000e-01 3.98e+00 4.50e+05  -1.0 1.27e+05    -  2.01e-05 8.64e-06h  1\n   7r 1.0000000e-01 3.98e+00 1.00e+03   0.6 0.00e+00    -  0.00e+00 4.78e-07R  2\n   8r 1.0014680e-01 4.05e+00 1.92e+03   0.6 6.02e+00    -  6.22e-01 3.69e-02f  1\n   9r 1.0062971e-01 3.58e+00 1.41e+03   0.6 5.18e+00    -  1.00e+00 2.61e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  1.0064745e-01 3.58e+00 3.90e+03  -1.0 3.99e+00    -  1.00e+00 2.60e-04h  1\n  11  1.0105387e-01 3.57e+00 6.14e+03  -1.0 8.03e+02    -  7.79e-04 4.93e-04h  1\n  12  1.0130844e-01 3.57e+00 2.30e+04  -1.0 3.32e+03    -  1.74e-04 4.12e-05h  1\n  13  1.0131275e-01 3.57e+00 2.13e+05  -1.0 1.09e+04    -  2.61e-04 3.20e-05h  1\n  14r 1.0131275e-01 3.57e+00 1.00e+03   0.6 0.00e+00    -  0.00e+00 4.88e-07R  5\n  15r 1.8100817e-01 3.50e+00 1.88e+03   0.6 4.36e+00    -  7.49e-01 5.12e-02f  1\n  16r 1.8669905e-01 2.33e+00 2.00e+02   0.6 2.29e+00    -  9.28e-01 7.89e-01f  1\n  17  1.8722777e-01 2.33e+00 1.68e+02  -1.0 3.81e+00    -  1.34e-01 8.11e-04h  1\n  18  1.8921350e-01 2.33e+00 2.25e+04  -1.0 1.06e+02    -  3.22e-02 2.37e-04h  1\n  19  1.9127731e-01 2.32e+00 3.87e+04  -1.0 4.33e+02    -  5.26e-03 3.02e-03h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  1.9146732e-01 2.32e+00 1.58e+05  -1.0 4.59e+03    -  6.15e-04 1.52e-04h  1\n  21  1.9156826e-01 2.32e+00 9.58e+05  -1.0 8.57e+03    -  3.77e-04 7.65e-05h  1\n  22r 1.9156826e-01 2.32e+00 1.00e+03   0.4 0.00e+00    -  0.00e+00 3.51e-07R  5\n  23r 2.1757015e-01 1.96e+00 7.32e+02   0.4 1.33e+00    -  9.92e-01 2.67e-01f  1\n  24  2.1787418e-01 1.96e+00 3.86e+02  -1.0 3.24e+00    -  7.15e-02 1.89e-04h  1\n  25  2.1823093e-01 1.96e+00 9.27e+05  -1.0 2.86e+01    -  1.05e-01 4.33e-05h  1\n  26  2.1826491e-01 1.96e+00 4.64e+06  -1.0 2.91e+04    -  1.14e-04 2.25e-05h  1\n  27r 2.1826491e-01 1.96e+00 1.00e+03   0.3 0.00e+00    -  0.00e+00 1.55e-07R  2\n  28r 2.6610697e-01 1.14e+00 4.55e+02   0.3 1.52e+00    -  9.91e-01 5.45e-01f  1\n  29r 3.2355056e-01 1.72e-01 3.40e+02   0.3 4.55e+00    -  5.90e-01 2.47e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30r 5.9791076e-01 2.47e-01 8.36e+01   0.3 1.08e+00   0.0 1.00e+00 8.10e-01f  1\n  31r 1.5393156e+00 1.30e+00 3.41e+02  -0.4 4.27e+00   0.4 1.78e-01 4.06e-01f  1\n  32r 1.7522485e+00 3.94e-01 1.40e+02  -0.4 1.26e+00   0.9 8.91e-01 6.62e-01f  1\n  33r 3.0683175e+00 1.80e+00 2.06e+02  -0.4 4.88e+00   0.4 2.65e-01 5.12e-01f  1\n  34r 4.0829865e+00 1.84e+00 2.89e+02  -0.4 1.66e+01  -0.1 2.27e-02 1.02e-01f  1\n  35r 4.2796802e+00 1.60e+00 3.08e+02  -0.4 2.03e+00   0.3 9.01e-01 1.26e-01f  1\n  36r 4.3283517e+00 1.51e+00 3.80e+02  -0.4 6.28e+00    -  1.00e+00 5.78e-02f  1\n  37r 4.3814442e+00 1.08e+00 4.96e+02  -0.4 5.56e-01    -  1.00e+00 2.82e-01f  1\n  38r 4.4392851e+00 1.45e-02 8.75e+00  -0.4 4.17e-01    -  1.00e+00 1.00e+00f  1\n  39  4.6154499e+00 1.30e-02 2.29e-02  -1.0 2.45e-01    -  9.73e-01 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  4.4905204e+00 1.16e-02 2.94e-03  -1.7 3.27e-01    -  1.00e+00 1.00e+00h  1\n  41  4.3393561e+00 6.04e-02 1.38e-02  -3.8 9.67e-01    -  9.08e-01 9.34e-01h  1\n  42  4.2946439e+00 6.77e-02 8.52e-03  -3.8 1.80e+00    -  8.70e-01 1.00e+00h  1\n  43  4.2898253e+00 1.86e-02 1.26e-03  -3.8 2.46e+00    -  1.00e+00 1.00e+00h  1\n  44  4.2875206e+00 4.66e-03 1.80e-04  -3.8 2.82e+00    -  1.00e+00 1.00e+00h  1\n  45  4.2874424e+00 1.23e-04 3.37e-06  -3.8 6.32e-01    -  1.00e+00 1.00e+00h  1\n  46  4.2847486e+00 1.90e-03 3.96e-04  -5.7 1.13e+00    -  8.52e-01 1.00e+00h  1\n  47  4.2846175e+00 4.56e-04 2.07e-05  -5.7 1.34e+00    -  9.72e-01 1.00e+00h  1\n  48  4.2846039e+00 7.22e-05 5.56e-07  -5.7 6.40e-01    -  1.00e+00 1.00e+00h  1\n  49  4.2846034e+00 8.59e-07 6.40e-09  -5.7 5.87e-02    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  4.2845650e+00 6.11e-06 1.18e-06  -8.6 1.22e-01    -  9.77e-01 1.00e+00h  1\n  51  4.2845649e+00 1.55e-08 1.17e-10  -8.6 1.04e-02    -  1.00e+00 1.00e+00h  1\n  52  4.2845648e+00 7.53e-12 5.91e-14  -9.0 1.52e-04    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 52\n\n                                   (scaled)                 (unscaled)\nObjective...............:   4.2845648348476271e+00    4.2845648348476271e+00\nDual infeasibility......:   5.9111156714027925e-14    5.9111156714027925e-14\nConstraint violation....:   7.5290884637979616e-12    7.5290884637979616e-12\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   9.0923652519966629e-10    9.0923652519966629e-10\nOverall NLP error.......:   9.0923652519966629e-10    9.0923652519966629e-10\n\n\nNumber of objective function evaluations             = 67\nNumber of objective gradient evaluations             = 41\nNumber of equality constraint evaluations            = 67\nNumber of inequality constraint evaluations          = 67\nNumber of equality constraint Jacobian evaluations   = 57\nNumber of inequality constraint Jacobian evaluations = 57\nNumber of Lagrangian Hessian evaluations             = 52\nTotal seconds in IPOPT                               = 0.062\n\nEXIT: Optimal Solution Found.\n","category":"page"},{"location":"examples/Optimal Control/Jennings/#Extract-and-Plot-the-Results","page":"Minimizing Final Time (Jennings Problem)","title":"Extract and Plot the Results","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"We can extract the results as arrays using the value function. Notice that we multiply by t_f to scale our time.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"ts = value(t)*value(tf)\nu_opt = value(u)\nx1_opt = value(x[1])\nx2_opt = value(x[2])\nx3_opt = value(x[3]);","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Plot the results","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"plot(ts, u_opt, label = \"u(t)\", linecolor = :black, linestyle = :dash)\nplot!(ts, x1_opt, linecolor = :blue, linealpha = 0.4, label = \"x1\")\nplot!(ts, x2_opt, linecolor = :green, linealpha = 0.4, label = \"x2\")\nplot!(ts, x3_opt, linecolor = :red, linealpha = 0.4, label = \"x3\")","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"<img src=\"data:image/png;base64,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WCy+fv06IaShoeHy5cvW+5OTkz/77LPJhymVyt7e3slPW1tbDQZDfHy8M6OiCGcm5ApTglN2xO7oGe05UnGkvq+ediIAALZjGObw4cObNm3aunXrY489Ntltqamp/f39DQ0N1k+feuqpr3/968uWLcvNzSWEHD9+fNeuXXy+U68vi02jtlKKlJujNt8auvVp66c3Om+s0azBRS0AAO7jxRdf3Lt3b2dn55IlSwwGg0AgIITweLznnnvunXfeefnllwkh3/jGNw4cODA4OCiRSAghf/zjH19//XUn58SKcHaCZEG743bH+sQW1haebT5rmDDQTgQAwF5hYWHLly/n8XhSqdRahISQb3/72729vdbJMoQQLperUqmEQuHNmzcffPDB5ORkJ4dEEc4awzDWkw65DPe9yvcqOiucPxAIAMB1icXi3/3ud9bJMlNFRUX98Ic/dH4eFOEcCXnC1aGrty7YerPvZkFNQa++d+avAQAA9sE+wnnxkfjsjN1Z01NTWFsYqYpcHrycz3HqPl4AANcyNjb24YcfXr58ub29/Wc/+5m3tzftRFgR2kOMd8yehXtMFtORG0ca+htoxwEAYK+enp5f/OIX3d3db7755vDwMO04hKAI7UXIFaZqUtPD0stay07ePDk6Pko7EQAAZUeOHCkpKbHerqqqev31181mc2Bg4NmzZ1955RWq0e6AIrSnYHlw9sJslViVq8ut6q6iHQcAgKa4uLi9e/fW1NSMjIxkZWVJpVIOh42lg32EdsZluMlByZGqyDNNZ2p6ataFrVOKlLRDAYBnGRsjx48TkxMHYfF4ZPNmIrpzDGViYuLhw4cfeeSR+Pj4ZcuWPfHEE84LNBsoQodQi9U743ZWdFYUVBcs9l+cGJDIEIZ2KADwFAIBWbuWOPnELtF0w5iff/75v//97ydPnqytrXVqmtlAEToKQ5hFfovCleFnGs809DekhaepRNOPbwcAsDsWHIxJCCEXLlyoq6sTi8VFRUW7du2iHWd6KELHkglk22K21fTU/LPmn7HesclByRyGjZvIAQDsrr+//5FHHvnDH/4QHBz80EMPJSUlhYeH0w41DbwpO0OMd0yWNqtP35eny+se7aYdBwDAGZ588smHHnpo9+7dKSkp3/nOd/bt2zc2NkYICQsLCwoKIoQsXrxYrVYbjUa6ObEidBIJX/LAggeq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\" />","category":"page"},{"location":"examples/Optimal Control/Jennings/#Maintenance-Tests","page":"Minimizing Final Time (Jennings Problem)","title":"Maintenance Tests","text":"","category":"section"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"These are here to ensure this example stays up to date.","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"using Test\ntol = 1E-6\n@test termination_status(m) == MOI.LOCALLY_SOLVED\n@test has_values(m)\n@test u_opt isa Vector{<:Real}\n@test x1_opt isa Vector{<:Real}\n@test isapprox(x1_opt[end], 3.2501431326448293, atol=tol)\n@test isapprox(objective_value(m), 4.284564834847627, atol=tol)","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"Test Passed","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"","category":"page"},{"location":"examples/Optimal Control/Jennings/","page":"Minimizing Final Time (Jennings Problem)","title":"Minimizing Final Time (Jennings Problem)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Optimal Control/hovercraft/#Hovercraft-Path-Planning","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"","category":"section"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"In this case study, we seek to determine an optimal control policy for the trajectory of a hovercraft that travels to a set of dynamic waypoints while trying to minimize the thrust input.","category":"page"},{"location":"examples/Optimal Control/hovercraft/#Formulation","page":"Hovercraft Path Planning","title":"Formulation","text":"","category":"section"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"The corresponding dynamic optimization problem is expressed:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"beginaligned\n\tundersetx(t) v(t) u(t)textmin  int_t in T u(t)_2^2 dt  \n\ttextst  v(0) = v0\n\t fracdxdt = v(t)  t in T\n     fracdvdt = u(t)  t in T\n     x(t_i) = xw_i  i in I\nendaligned","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"where x(t) is the Cartesian position, v(t) is the velocity, u(t) is the thrust input, xw_i  i in I are the waypoints, and T is the time horizon.","category":"page"},{"location":"examples/Optimal Control/hovercraft/#Model-Definition","page":"Hovercraft Path Planning","title":"Model Definition","text":"","category":"section"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Let's implement this in InfiniteOpt and first import the packages we need:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"using InfiniteOpt, Ipopt","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Next we'll specify our waypoint data:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"xw = [1 4 6 1; 1 3 0 1] # positions\ntw = [0, 25, 50, 60];    # times","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"We initialize the infinite model and opt to use the Ipopt solver:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"m = InfiniteModel(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0));","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Let's specify our infinite parameter which is time t in 0 60:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"@infinite_parameter(m, t in [0, 60], num_supports = 61)","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"t","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Now let's specify the decision variables:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"@variables(m, begin\n    # state variables\n    x[1:2], Infinite(t)\n    v[1:2], Infinite(t)\n    # control variables\n    u[1:2], Infinite(t), (start = 0)\nend)","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"(GeneralVariableRef[x[1](t), x[2](t)], GeneralVariableRef[v[1](t), v[2](t)], GeneralVariableRef[u[1](t), u[2](t)])","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Specify the objective:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"@objective(m, Min, âˆ«(u[1]^2 + u[2]^2, t))","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"âˆ«{t âˆˆ [0, 60]}[u[1](t)Â² + u[2](t)Â²]","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Set the initial conditions with respect to the velocity:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"@constraint(m, [i = 1:2], v[i](0) == 0)","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"2-element Vector{InfOptConstraintRef}:\n v[1](0) = 0\n v[2](0) = 0","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Define the point physics ODEs which serve as our system model:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"@constraint(m, [i = 1:2], âˆ‚(x[i], t) == v[i])\n@constraint(m, [i = 1:2], âˆ‚(v[i], t) == u[i])","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"2-element Vector{InfOptConstraintRef}:\n d/dt[v[1](t)] - u[1](t) = 0, âˆ€ t âˆˆ [0, 60]\n d/dt[v[2](t)] - u[2](t) = 0, âˆ€ t âˆˆ [0, 60]","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Ensure we hit all the waypoints:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"@constraint(m, [i = 1:2, j = eachindex(tw)], x[i](tw[j]) == xw[i, j])","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"2Ã—4 Matrix{InfOptConstraintRef}:\n x[1](0) = 1  x[1](25) = 4  x[1](50) = 6  x[1](60) = 1\n x[2](0) = 1  x[2](25) = 3  x[2](50) = 0  x[2](60) = 1","category":"page"},{"location":"examples/Optimal Control/hovercraft/#Problem-Solution","page":"Hovercraft Path Planning","title":"Problem Solution","text":"","category":"section"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Optimize the model:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"optimize!(m)","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Extract the results. The InfiniteInterpolations extension can be used to get a smooth interpolated function for x, which is invoked when both the Interpolations and InfiniteOpt packages are imported. Here, cubic splines are used as the interpolation method for both x1 and x2:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"using Interpolations\nxFunc = value.(x, cubic_spline_interpolation);","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Query our interpolated function for the values of x1 and x2:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"tvals = LinRange(0, 60, 100)\nx1Vals = xFunc[1](tvals)\nx2Vals = xFunc[2](tvals);","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Plot the results:","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"using Plots\nscatter(xw[1,:], xw[2,:], label = \"Waypoints\")\nxlabel!(\"x_1\")\nylabel!(\"x_2\")\nplot!(x1Vals, x2Vals, label = \"Trajectory\")","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"<img src=\"data:image/png;base64,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\" />","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"That's it, now we have our optimal trajectory!","category":"page"},{"location":"examples/Optimal Control/hovercraft/#Maintenance-Tests","page":"Hovercraft Path Planning","title":"Maintenance Tests","text":"","category":"section"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"These are here to ensure this example stays up to date.","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"using Test\ntol = 1E-6\n@test termination_status(m) == MOI.LOCALLY_SOLVED\n@test has_values(m)\n@test x1Vals isa Vector{<:Real}\n@test x2Vals isa Vector{<:Real}\n@test isapprox(objective_value(m), 0.043685293177035435, atol=tol)\n@test isapprox(value(u[1])[end], -0.010503853944039986, atol=tol)\n@test isapprox(value(u[2])[end], 0.005456780217220367, atol=tol)\n@test isapprox(x1Vals[15], 1.3837274935883543, atol=tol)\n@test isapprox(x2Vals[15], 1.6386021193421085, atol=tol)","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"Test Passed","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"","category":"page"},{"location":"examples/Optimal Control/hovercraft/","page":"Hovercraft Path Planning","title":"Hovercraft Path Planning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"install/#Installation-Guide","page":"Installation","title":"Installation Guide","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"A complete guide to installing all that is necessary to use InfiniteOpt.jl.","category":"page"},{"location":"install/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"InfiniteOpt is a Julia package. Thus, we first need to have an installation of Julia to get started. An appropriate download can be found here. We recommend using  VSCode to edit and run Julia scripts.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"note: Note\nThis version of InfiniteOpt requires that Julia 1.10 or newer be used.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Tip\nWe recommend installing the latest version of Julia. However, for users that  cannot update Julia frequently (e.g., industrial users with IT limitations),  we recommend installing the long term support (LTS) version which is 1.6.","category":"page"},{"location":"install/#Install-Packages","page":"Installation","title":"Install Packages","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Now that Julia has been installed we can add the needed packages. Open up a Julia terminal and enter the package manager:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n\n(v1.12) pkg>","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Tip\nWe recommend you create a Pkg environment for each project you use InfiniteOpt for, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Use the add command in the package to manager to add the following packages:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Distributions (required for stochastic programming)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"For example, to install Distributions we would enter:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(v1.12) pkg> add Distributions","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Now let's install InfiniteOpt:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(v1.12) pkg> add InfiniteOpt","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"info: Info\nInstallation troubles? Check the Common Installation Problems section below.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Alternatively, we can install the current experimental version of  InfiniteOpt via:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(v1.12) pkg> add https://github.com/infiniteopt/InfiniteOpt.jl","category":"page"},{"location":"install/#Install-Optimization-Solvers","page":"Installation","title":"Install Optimization Solvers","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"InfiniteOpt relies on transformation backends to  solve problems. These backends typically depend on optimization solvers which often are not native to Julia and might require commercial licenses. A list of currently supported solvers for JuMPBackends (i.e., transformation backends  that use JuMP) and their corresponding Julia packages is provided in Supported Optimizers.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"For example, we can install Ipopt which is an open-source nonlinear solver:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(v1.12) pkg> add Ipopt","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Now Ipopt can be used as the optimizer (solver) for an infinite model by running:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using InfiniteOpt, Ipopt\n\njulia> model = InfiniteModel(Ipopt.Optimizer) # uses TranscriptionBackend by default","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Most JuMP solver packages follow the ModuleName.Optimizer naming convention, but this may not always be the case. See Infinite Models for more information on defining infinite models and specifying solvers.","category":"page"},{"location":"install/#Common-Installation-Problems","page":"Installation","title":"Common Installation Problems","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Tip\nWhen in doubt, run import Pkg; Pkg.update() to see if updating your packages fixes the issue. Remember you will need to exit Julia and start a new session for the changes to take effect.","category":"page"},{"location":"install/#Check-the-version-of-your-packages","page":"Installation","title":"Check the version of your packages","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Each package is versioned with a three-part number of the form vX.Y.Z. You can check which versions you have installed with:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> ]\n\n(v1.12) pkg> status","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This should almost always be the most-recent release. You can check the releases of a package by going to the relevant GitHub page, and navigating to the \"releases\" page. For example, the list of JuMP releases is available at: https://github.com/infiniteopt/InfiniteOpt.jl/releases.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you need to ask question for help, please include the output of status!","category":"page"},{"location":"install/#Unsatisfiable-requirements-detected","page":"Installation","title":"Unsatisfiable requirements detected","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Did you get an error like  Unsatisfiable requirements detected for package InfiniteOpt? The Pkg  documentation has a  section on how to understand and manage these conflicts.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Typically, these conflicts can be resolved by using  package environments.","category":"page"},{"location":"install/#Installing-new-packages-can-make-InfiniteOpt-downgrade-to-an-earlier-version","page":"Installation","title":"Installing new packages can make InfiniteOpt downgrade to an earlier version","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Another common issue is that after adding a new package, code that previously  worked no longer runs.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This usually happens because the new package is not compatible with the latest version of InfiniteOpt. Therefore, the package manager downgrades InfiniteOpt  to an earlier version!","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Thus, please pay careful attention to the output of the package manager when  adding new packages, especially when you see a package being downgraded!","category":"page"},{"location":"develop/extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Here we provide guidance to various ways InfiniteOpt can be extended.","category":"page"},{"location":"develop/extensions/#Overview","page":"Extensions","title":"Overview","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Extendibility is one of the core ideas of InfiniteOpt so that it can serve as a  convenient tool for those developing and implementing advanced techniques for  infinite dimensional optimization problems. Thus, InfiniteOpt is developed in  a modular manner to readily accommodate user-defined functionality and/or to  serve as useful base in writing a JuMP extension. Admittedly, this modularity  is not perfect and comments/suggestions are welcomed to help us improve this.","category":"page"},{"location":"develop/extensions/#Infinite-Domains","page":"Extensions","title":"Infinite Domains","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Infinite domains are used to characterize the behavior of infinite parameters and  used to govern the behavior of supports in InfiniteOpt. Here we walk through  how user-defined domains can be added to various degrees of functionality. A  template is provided in  ./test/extensions/infinite_domain.jl.  The extension steps employed are:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Define the new struct infinite domain type (only thing required as bare minimum)\nExtendInfiniteOpt.round_domain (enables safe use of significant digit rounding)\nExtend InfiniteOpt.supports_in_domain (enables error checking of supports)\nExtend InfiniteOpt.generate_support_values (enables support generation via num_supports keyword arguments)\nIf a lower bound and upper bound can be reported, extend JuMP lower bound and upper bound methods (enables automatic bound detection in integral)\nExtend InfiniteOpt.MeasureToolbox.generate_expect_data (enables the use of expect) ","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"As an example, let's create a univariate disjoint interval domain as an infinite  domain type. This corresponds to the domain lb_1 ub_1 cup lb_2 ub_2  where ub_1 leq lb_2. First, we need to create the DataType with  inheritance from InfiniteScalarDomain:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"using InfiniteOpt\n\nstruct DisjointDomain <: InfiniteOpt.InfiniteScalarDomain\n    lb1::Float64\n    ub1::Float64\n    lb2::Float64\n    ub2::Float64\n    # constructor\n    function DisjointDomain(lb1::Number, ub1::Number, lb2::Number, ub2::Number)\n        if lb1 > ub1 || lb2 > ub2 || ub1 > lb2\n            error(\"Invalid bounds\")\n        end\n        return new(convert(Float64, lb1), convert(Float64, ub1),\n                   convert(Float64, lb2), convert(Float64, ub2))\n    end\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Notice that we also define the constructor function to error check and convert as  needed (this is recommended, but not required). For basic functionality this is  all we have to do to add a domain in InfiniteOpt.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We can now define infinite parameters using this domain via  @infinite_parameter both anonymously and explicitly:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = InfiniteModel();\n\njulia> t = @infinite_parameter(model, domain = DisjointDomain(0, 1, 3, 4), base_name = \"t\")\nt\n\njulia> @infinite_parameter(model, t in DisjointDomain(0, 1, 3, 4))\nt","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Once defined (without further extension), these parameters can be used as normal  with the following limitations:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Supports must be specified manually (num_supports is not enabled)\nSupports will not be checked if they are in the domain of the infinite domain\nDomain bounds cannot be queried.\nThe DiscreteMeasureData or FunctionalDiscreteMeasureData  must be provided explicitly to evaluate measures","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"However, all of these limitations except for the last one can be eliminated by  extending a few functions as outlined above. To address the last one, we need  to extend generate_integral_data. See [Measure Evaluation Techniques]  for details. ","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"To enable support domain checking which is useful to avoid strange bugs, we will  extend InfiniteOpt.round_domain which rounds the domain to use proper  significant digits and InfiniteOpt.supports_in_domain which returns a  Bool whether a vector of supports is in the domain:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.round_domain(\n    domain::DisjointDomain,\n    sig_digits::Int\n    )\n    lb1 = round(domain.lb1, sigdigits = sig_digits)\n    ub1 = round(domain.ub1, sigdigits = sig_digits)\n    lb2 = round(domain.lb2, sigdigits = sig_digits)\n    ub2 = round(domain.ub2, sigdigits = sig_digits)\n    return DisjointDomain(lb1, ub1, lb2, ub2)\nend\n\nfunction InfiniteOpt.supports_in_domain(\n    supports::Union{Number, Vector{<:Number}},\n    domain::DisjointDomain\n    )\n    return all((domain.lb1 .<= supports .<= domain.ub1) .| (domain.lb2 .<= supports .<= domain.ub2))\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now the checks are enabled, so the following would yield an error because the  support is not in the domain:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> @infinite_parameter(model, domain = DisjointDomain(0, 1, 3, 4), supports = 2)\nERROR: At none:1: `@infinite_parameter(model, domain = DisjointDomain(0, 1, 3, 4), supports = 2)`: Supports violate the domain bounds.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"To enable automatic support generation via the num_supports keyword and with  functions such as fill_in_supports!, we will extend  InfiniteOpt.generate_support_values:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"struct DisjointGrid <: InfiniteOpt.PublicLabel end\n\nfunction InfiniteOpt.generate_support_values(\n    domain::DisjointDomain;\n    num_supports::Int = InfiniteOpt.DefaultNumSupports,\n    sig_digits::Int = InfiniteOpt.DefaultSigDigits\n    )\n    length_ratio = (domain.ub1 - domain.lb1) / (domain.ub1 - domain.lb1 + domain.ub2 - domain.lb2)\n    num_supports1 = Int64(ceil(length_ratio * num_supports))\n    num_supports2 = num_supports - num_supports1\n    supports1 = collect(range(domain.lb1, stop = domain.ub1, length = num_supports1))\n    supports2 = collect(range(domain.lb2, stop = domain.ub2, length = num_supports2))\n    return round.([supports1; supports2], sigdigits = sig_digits), DisjointGrid\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now automatic support generation is enabled, for example:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> par = @infinite_parameter(model, domain = DisjointDomain(0, 2, 3, 4), num_supports = 10)\nnoname\n\njulia> supports(par)\n10-element Vector{Float64}:\n 0.0\n 0.333333333333\n 0.666666666667\n 1.0\n 1.33333333333\n 1.66666666667\n 2.0\n 3.0\n 3.5\n 4.0","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We can extend the appropriate JuMP upper and lower bound functions  if desired which are:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"JuMP.has_lower_bound\nJuMP.lower_bound\nJuMP.set_lower_bound\nJuMP.has_upper_bound\nJuMP.upper_bound\nJuMP.set_upper_bound","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"However, if we want has_lower_bound = false and has_upper_bound = false then  no extension is needed. For our current example we won't do this since lower  and upper bounds aren't exactly clear for a disjoint interval. Please refer to  the template in ./InfiniteOpt/test/extensions/infinite_domain.jl to see how  this is done.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Finally, we can optionally enable the use of expect taken with respect  to infinite parameters with this new domain type by extending  InfiniteOpt.MeasureToolbox.generate_expect_data:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.MeasureToolbox.generate_expect_data(domain::DisjointDomain, \n    pref::GeneralVariableRef, \n    num_supports::Int; \n    kwargs...\n    )\n    for (k, _) in kwargs\n        error(\"Keyword argument `$k` not supported for expectations over \",\n              \"disjoint domains.\")\n    end\n    coeff_func = (supps) -> ones(size(supps)[end]) ./ size(supps)[end] \n    return InfiniteOpt.FunctionalDiscreteMeasureData(pref, coeff_func, 0, All)\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"The above implementation simply sums over all the supports associated with pref  and divides by the total number. Now we can use expect:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> @variable(model, y, Infinite(t))\ny(t)\n\njulia> expect(y, t)\nð”¼{t}[y(t)]","category":"page"},{"location":"develop/extensions/#Derivative-Evaluation-Methods","page":"Extensions","title":"Derivative Evaluation Methods","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Derivative evaluation methods are used to dictate how we form the auxiliary  derivative evaluation equations (derivative constraints) when we evaluate  derivatives in InfiniteOpt. Users may wish to implement their own methods beyond  the finite difference and orthogonal collocation ones we natively provide. Thus,  we provide an API to do just this. A complete template is provided in  ./test/extensions/derivative_method.jl  to help streamline this process. The extension steps are:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Define the new method struct that inherits from the correct  AbstractDerivativeMethod subtype\nExtend InfiniteOpt.allows_high_order_derivatives\nExtend InfiniteOpt.generative_support_info  if the method is a GenerativeDerivativeMethod\nExtend InfiniteOpt.derivative_expr_data\nExtend InfiniteOpt.make_indexed_derivative_expr.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"To exemplify this process let's implement 1st order explicit Euler which is already  implemented via FiniteDifference(Forward()), but let's make our own anyway for  the sake of example. For a first order derivative fracd y(t)dt explicit  Euler is expressed:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"y(t_n+1) = y(t_n) + (t_n+1 - t_n)fracd y(t_n)dt  forall n = 0 1 dots k-1","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Let's get started with step 1 and define our new method struct:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"using InfiniteOpt\n\nstruct ExplicitEuler <: NonGenerativeDerivativeMethod end","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Notice that our method ExplicitEuler inherits from  NonGenerativeDerivativeMethod since explicit Euler uses the existing  support scheme without adding any additional supports. If our desired method  needed to add additional supports (e.g., orthogonal collocation over finite  elements) then we would need to have used GenerativeDerivativeMethod.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now we need to decide if this method will directly support higher order derivatives.  In this case, let's say it won't and define:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"InfiniteOpt.allows_high_order_derivatives(::ExplicitEuler) = false","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Conversely, we could set the output to true if we wanted to directly support higher  order derivatives. In which case, we would need to take the order into account in steps 4 and 5.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Since, this is a NonGenerativeDerivativeMethod we skip step 3. This is  however exemplified in the extension template.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"For step 4, we extend InfiniteOpt.derivative_expr_data.  This function generates all the needed data to make the expressions necessary to build the derivative evaluation equations (derivative  constraints). We assume these relations to be of the form h = 0 where h  is a vector of expressions. Thus, mathematically h should be of the form:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"beginaligned\n y(t_2) - y(t_1) - (t_2 - t_1)fracd y(t_1)dt \n vdots \n y(t_n+1) - y(t_n) - (t_n+1 - t_n)fracd y(t_n)dt \nendaligned","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"The required data must include the support indices used for each derivative  variable and then any other constants needed. In this case, we will need the indices 1 dots n and no additional data (additional data is exemplified  in the extension template). With this in mind let's now extend  InfiniteOpt.derivative_expr_data:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.derivative_expr_data(\n    dref::GeneralVariableRef, \n    order::Int,\n    supps::Vector{Float64},\n    method::ExplicitEuler\n    )\n    # generate the support indices to be used for each call of `make_indexed_derivative_expr`\n    idxs = 1:length(supps)-1\n    # return the indexes and the other iterators\n    return (idxs, ) # output must be a tuple\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Finally, we just need to extend InfiniteOpt.make_indexed_derivative_expr. This will be used to create derivative expressions for each index determined (and additional datum) produced by derivative_expr_data.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.make_indexed_derivative_expr(\n    dref::GeneralVariableRef,\n    vref::GeneralVariableRef,\n    pref::GeneralVariableRef,\n    order::Int,\n    idx,\n    supps::Vector{Float64}, # ordered\n    write_model::Union{InfiniteModel, AbstractTransformationBackend},\n    ::ExplicitEuler,\n    # put extra data args here (none in this case)\n    )\n    # generate the derivative expression h corresponding to the equation of \n    # the form h = 0\n    d = InfiniteOpt.make_reduced_expr(dref, pref, supps[idx], write_model)\n    v1 = InfiniteOpt.make_reduced_expr(vref, pref, supps[idx], write_model)\n    v2 = InfiniteOpt.make_reduced_expr(vref, pref, supps[idx + 1], write_model)\n    return JuMP.@expression(write_model, -(supps[idx+1] - supps[idx]) * d + v2 - v1)\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We used InfiniteOpt.make_reduced_expr as a convenient helper function  to generate the semi-infinite variables/expressions we need to generate at each  support point.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"note: Note\nIf your new derivative method is not compatible can not be broken  up into the derivative_expr_data-make_indexed_derivative_expr  workflow, then you can instead extend InfiniteOpt.evaluate_derivative. This is discouraged where possible since it may make your method incompatible  with backends that depend on the preferred workflow.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now that we have completed all the necessary steps, let's try it out! ","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10], num_supports = 3, \n                           derivative_method = ExplicitEuler());\n\njulia> @variable(model, y, Infinite(t));\n\njulia> dy = deriv(y, t);\n\njulia> evaluate(dy)\n\njulia> derivative_constraints(dy)\n2-element Vector{InfOptConstraintRef}:\n -5 d/dt[y(t)](0) + y(5) - y(0) = 0\n -5 d/dt[y(t)](5) + y(10) - y(5) = 0","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We implemented explicit Euler and it works! Now go and extend away!","category":"page"},{"location":"develop/extensions/#Measure-Evaluation-Techniques","page":"Extensions","title":"Measure Evaluation Techniques","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Measure evaluation methods are used to dictate how to evaluate measures. Users  may wish to apply evaluation methods other than Monte Carlo sampling and/or  Gaussian quadrature methods. To create multiple measures using the same new  evaluation methods, users may want to embed the new evaluation method under the  integral function that does not require explicit construction of  AbstractMeasureData.","category":"page"},{"location":"develop/extensions/#Creating-a-DiscreteMeasureData-Object","page":"Extensions","title":"Creating a DiscreteMeasureData Object","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"The basic way to do that is to write a function that creates  DiscreteMeasureData object and pass the object to measure.  This considers a measure approximation of the form:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"sum_i in I alpha_i f(tau_i) w(tau_i)","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"where alpha_i are coefficients, f(cdot) is the expression being measured,  w(cdot) is a weighting function, and i in I indexes the support points.  Let's consider defining a function that enables the definition of a  uniform grid for a univariate infinite parameter in IntervalDomain.  This example approximation uses a uniformly spaced supports tau_i with  alpha_i = fracub - lbI:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function uniform_grid(param, num_supports)\n    lb = lower_bound(param)\n    ub = upper_bound(param)\n    supps = collect(LinRange(lb, ub, num_supports))\n    coeffs = ones(num_supports) / num_supports * (ub - lb)\n    return DiscreteMeasureData(param, coeffs, supps, lower_bound = lb, upper_bound = ub)\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"It is necessary to pass the infinite parameter reference since the  construction of measure data object needs parameter information. Now let's  apply the new uniform_grid function to infinite parameters in  intervals. We consider a time parameter t and 2D spatial parameter x, and  two variables f(t) and g(x) parameterized by t and x, respectively:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> m = InfiniteModel();\n\njulia> @infinite_parameter(m, t in [0, 5]);\n\njulia> @variable(m, y, Infinite(t));","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now we can use uniform_grid to construct a DiscreteMeasureData and  create a measure using the measure data, as shown below:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> tdata = uniform_grid(t, 6);\n\njulia> y_meas = measure(y, tdata)\nmeasure{t âˆˆ [0, 5]}[y(t)]\n\njulia> expand(y_meas)\n0.8333333333333333 y(0) + 0.8333333333333333 y(1) + 0.8333333333333333 y(2) + 0.8333333333333333 y(3) + 0.8333333333333333 y(4) + 0.8333333333333333 y(5)","category":"page"},{"location":"develop/extensions/#Integral-Evaluation-Methods","page":"Extensions","title":"Integral Evaluation Methods","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"For integrals, we can implement a new approximation method via the extension of  InfiniteOpt.MeasureToolbox.generate_integral_data. This will  allow users to use their custom measure evaluation methods in the  integral function that does not explicitly require a measure data  object. A template for how such an extension is accomplished is provided in  ./test/extensions/measure_eval.jl. In general, such an extension can be created as follows: ","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Define a new empty struct (e.g. my_new_fn) that dispatches your function\nExtend InfiniteOpt.MeasureToolbox.generate_integral_data,  where method is of the type my_new_fn, and domain needs to be a subtype  of AbstractInfiniteDomain that you wish to apply the new evaluation  method to.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Note that this procedure can be used to generate new measure evaluation methods  not only for existing infinite domains, but also for user-defined infinite  domains. ","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"For example, an extension of  InfiniteOpt.MeasureToolbox.generate_integral_data that implements  uniform grid for univariate and multivariate parameters in  IntervalDomain can be created as follows:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"struct UnifGrid <: InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod end\n\nfunction InfiniteOpt.MeasureToolbox.generate_integral_data(\n    pref::InfiniteOpt.GeneralVariableRef,\n    lower_bound::Real,\n    upper_bound::Real,\n    method::UnifGrid;\n    num_supports::Int = InfiniteOpt.DefaultNumSupports,\n    weight_func::Function = InfiniteOpt.default_weight\n    )\n    increment = (upper_bound - lower_bound) / (num_supports - 1)\n    supports = [lower_bound + (i - 1) * increment for i in 1:num_supports]\n    coeffs = ones(num_supports) / num_supports * (upper_bound - lower_bound)\n    return InfiniteOpt.DiscreteMeasureData(\n        pref, coeffs, supports,\n        weight_function = weight_func,\n        lower_bound = lower_bound, \n        upper_bound = upper_bound)\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Also notice that users are free to pass keyword arguments for their new  functions in addition to the required positional arguments. This might be needed  in case if the new evaluation method requires additional information not  captured in the default positional arguments. For example, the multivariate  parameter version above needs to know if the multivariate parameter is  independent in order to throw a warning when needed.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We create measure for y using the uniform_grid method:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> y_int = integral(y, t, num_supports = 6, eval_method = UnifGrid())\nâˆ«{t âˆˆ [0, 5]}[y(t)]\n\njulia> expand(y_int)\n0.8333333333333333 y(0) + 0.8333333333333333 y(1) + 0.8333333333333333 y(2) + 0.8333333333333333 y(3) + 0.8333333333333333 y(4) + 0.8333333333333333 y(5)","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Here we go! We can freely use UnifGrid for infinite parameters residing in  IntervalDomains now.","category":"page"},{"location":"develop/extensions/#meas_data_ext","page":"Extensions","title":"Measure Data","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Measures are used to evaluate over infinite domains. Users may wish to employ  measure abstractions that cannot be readily represented with coefficients and  discretized supports, and thus may wish to extend InfiniteOpt's  measure framework to accommodate other paradigms. This can be accomplished by   implementing a user-defined measure data structure that inherits from  AbstractMeasureData. A template for how such an extension is  accomplished is provided in  ./test/extensions/measure_data.jl.  The extension steps employed are:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Define the new data struct inheriting from AbstractMeasureData (required)\nExtend InfiniteOpt.parameter_refs (required)\nExtend InfiniteOpt.expand_measure (required)\nExtend InfiniteOpt.supports (required if parameter supports are employed in any way)\nExtend InfiniteOpt.add_supports_to_parameters (required if parameter supports are employed in measure evaluation)\nExtend InfiniteOpt.coefficients (useful getter method if applicable)\nExtend InfiniteOpt.weight_function (useful getter method if applicable)\nExtend InfiniteOpt.support_label (needed to enable deletion if supports are added.)\nExtend InfiniteOpt.generative_support_info (Needed if the measure will cause the creation of generative supports)\nMake simple measure constructor wrapper of measure to ease definition.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"To illustrate how this process can be done, let's consider extending InfiniteOpt  to include measure support for assessing the variance of random expressions. The  variance of an expression f(x xi) where x in mathbbR^n are finite  variables and xi in mathbbR^m are random infinite parameters is defined:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"mathbbVf(x xi) = mathbbEleft(f(x xi) - mathbbEf(x xi))^2 right","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Note, we could just accomplish this by nested use of expect, but we  implement this example to illustrate the mechanics of extension.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"First, let's define our new struct inheriting from AbstractMeasureData:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"using InfiniteOpt, Distributions\n\nstruct DiscreteVarianceData <: AbstractMeasureData\n    parameter_refs::Union{GeneralVariableRef, Vector{GeneralVariableRef}}\n    supports::Vector\n    label::DataType\n    # constructor\n    function DiscreteVarianceData(\n        parameter_refs::Union{GeneralVariableRef, Array{<:GeneralVariableRef}},\n        supports::Vector,\n        label::DataType = InfiniteOpt.generate_unique_label()\n        )\n        # convert input as necessary to proper array format\n        if parameter_refs isa Array\n            parameter_refs = convert(Vector, parameter_refs)\n            supports = [convert(Vector, arr) for arr in supports]\n        end\n        return new(parameter_refs, supports, label)\n    end\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We have defined our data type, so let's extend the measure data query  methods to enable its definition. These include:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"parameter_refs\nsupports\nsupport_label","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.parameter_refs(data::DiscreteVarianceData)\n    return data.parameter_refs\nend\n\nfunction InfiniteOpt.supports(data::DiscreteVarianceData)\n    return data.supports\nend\n\nfunction InfiniteOpt.support_label(data::DiscreteVarianceData)\n    return data.label\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We also need to extend InfiniteOpt.add_supports_to_parameters  since support points will be used for measure evaluation later:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.add_supports_to_parameters(data::DiscreteVarianceData)\n    pref = parameter_refs(data)\n    supps = supports(data)\n    label = support_label(data)\n    add_supports(pref, supps, label = label)\n    return\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Note that extending supports is not needed for abstractions that don't involve  discretization of the infinite parameter(s), such as the case for certain  outer approximation techniques. Our extension is now sufficiently constructed to  allow us to define out the new variance measure via measure. For  example:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"# Setup the infinite model\nmodel = InfiniteModel()\n@infinite_parameter(model, xi ~ Normal(), num_supports = 2) # few for simplicity\n@variable(model, y, Infinite(xi))\n@variable(model, z)\n\n# Define out new variance measure\ndata = DiscreteVarianceData(xi, supports(xi))\nmref = measure(2y + z, data, name = \"Var\")\n\n# output\nVar{xi}[2 y(xi) + z]","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Thus, we can define measure references that employ this our new data type.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We can define variance measures now, but now let's extend  expand_measure so that they can be expanded into finite expressions:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.expand_measure(\n    expr::JuMP.AbstractJuMPScalar,\n    data::DiscreteVarianceData,\n    write_model::Union{InfiniteModel, AbstractTransformationBackend}\n    )\n    # define the expectation data\n    expect_data = DiscreteMeasureData(\n                      data.parameter_refs,\n                      1 / length(data.supports) * ones(length(data.supports)),\n                      data.supports, is_expect = true, label = data.label)\n    # define the mean\n    mean = measure(expr, expect_data)\n    # return the expansion of the variance using the data mean\n    return expand_measure((copy(expr) - mean)^2, expect_data, write_model)\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Notice that we reformulated our abstraction in terms of measures with  DiscreteMeasureData so that we could leverage the existing  expand_measure library. Now, new the measure type can be expanded and  moreover infinite models using this new type can be optimized. Let's try  expanding the measure we already defined:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> expand(mref)\ny(-0.556026876146)Â² + 0 z*y(-0.556026876146) - 2 y(-0.44438335711)*y(-0.556026876146) + 0 zÂ² + 0 z*y(-0.44438335711) + y(-0.44438335711)Â²","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Finally, as per recommendation let's make a wrapper method to make defining  variance measures more convenient:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function variance(\n    expr::Union{JuMP.GenericAffExpr, GeneralVariableRef},\n    params::Union{GeneralVariableRef, Array{GeneralVariableRef}};\n    name::String = \"Var\", \n    num_supports::Int = 10,\n    use_existing::Bool = false\n    )\n    # get the supports\n    if use_existing\n        supps = supports.(params)\n    else\n        supps = generate_support_values(infinite_domain(first(params)),\n                                        num_supports = num_supports)\n    end\n    # make the data\n    data = DiscreteVarianceData(params, supps)\n    # built the measure\n    return measure(expr, data, name = name)\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Notice in this case that we only permit linear expressions for expr since  it will be squared by our new measure and we currently only support quadratic  expressions. (This could be overcome by defining a place holder variable  for expr.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now let's use our constructor to repeat the above measure example:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> expand(variance(2y + z, xi, use_existing = true))\ny(-0.556026876146)Â² + 0 z*y(-0.556026876146) - 2 y(-0.44438335711)*y(-0.556026876146) + 0 zÂ² + 0 z*y(-0.44438335711) + y(-0.44438335711)Â²","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We have done it! Now go and extend away!","category":"page"},{"location":"develop/extensions/#Generative-Support-Information","page":"Extensions","title":"Generative Support Information","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"As discussed in the Generative Supports section, generative  supports help enable measure and/or derivative evaluation techniques that require  the creation of generative supports (e.g., orthogonal collocation). Natively, we  provide UniformGenerativeInfo to help accomplish this which works for  creating generative supports uniformly over finite elements as is the case for  orthogonal collocation (note this includes scaling them as need to the size of  each finite element). However, more complex generative support schemes can be  enabled by defining a new concrete AbstractGenerativeInfo subtype. This  section will detail how this can be accomplished in InfiniteOpt. A template for  implementing this is provided in  ./test/extensions/generative_info.jl.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"A new generative support information type can be created via the following:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Define a concrete subtype of AbstractGenerativeInfo (required)\nMake a unique support label that inherits InternalLabel (recommended)\nExtend InfiniteOpt.support_label (required)\nExtend InfiniteOpt.make_generative_supports (required).","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"For the sake of example, let's suppose we want to make a method that generates a  certain amount of random supports for each finite element. First, let's define  our struct RandomGenerativeInfo:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"using InfiniteOpt, Random\n\nstruct RandomGenerativeInfo <: InfiniteOpt.AbstractGenerativeInfo\n    amount::Int # amount of random supports per finite element\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"With that done, let's define a unique support label RandomInternal for these  types of supports and extend support_label:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"struct RandomInternal <: InternalLabel end\n\nfunction InfiniteOpt.support_label(info::RandomGenerativeInfo)\n    return RandomInternal\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Finally, let's extend make_generative_supports to create a vector of the  generative supports based on a RandomGenerativeInfo and the existing model  supports which are passed in the function as input:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.make_generative_supports(info::RandomGenerativeInfo, pref, supps)\n    num_existing = length(supps)\n    num_existing <= 1 && error(\"`$pref` doesn't have enough supports.\")\n    num_internal = info.attr\n    gen_supps = Float64[]\n    for i = 1:num_existing-1 \n        lb = supps[i]\n        ub = supps[i+1]\n        append!(gen_supps, rand(num_internal) * (ub - lb) .+ lb)\n    end\n    return gen_supps\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Our extension is done and now RandomGenerativeInfo can be incorporated by a  GenerativeDerivativeMethod we create or an AbstractMeasureData object of our  choice like FunctionalDiscreteMeasureData. ","category":"page"},{"location":"develop/extensions/#extend_backends","page":"Extensions","title":"Transformation Backends","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"InfiniteOpt provides a convenient interface and abstraction for modeling  infinite-dimensional optimization problems. By default, InfiniteModels are  reformulated into a solvable JuMP.Model via TranscriptionOpt.TranscriptionBackend  which discretizes the model in accordance with the infinite parameter supports.  However, users may wish to employ some other transformation method to produce  the transformation backend. This section will explain how this can be done in  InfiniteOpt. A template for implementing this extension is provided in  ./test/extensions/backend.jl.  Our default sub-module InfiniteOpt.TranscriptionOpt also serves as a good  example.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"A new transformation approach and its corresponding transformation backend can be  extended using the following steps:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Define a mutable struct for variable/constraint mappings and other needed info (required)\nDefine an AbstractTransformationBackend (required)\nExtend Base.empty! for the backend (required)\nExtend build_transformation_backend! (required)\nIf appropriate and NOT a JuMPBackend, extend the following:\ntransformation_model\ntransformation_data\nJuMP.set_attribute (including the suggested attributes)\nJuMP.get_attribute (including the suggested attributes)\nJuMP.optimize!\nJuMP.set_optimizer\nJuMP.bridge_constraints\nJuMP.add_bridge\nJuMP.print_active_bridges\nJuMP.print_active_bridges\nJuMP.compute_conflict!\nJuMP.copy_conflict\nJuMP.mode\nJuMP.backend\nJuMP.unsafe_backend\nJuMP.variable_ref_type\nExtend the following, if possible (also enables result queries for JuMPBackends):\ntransformation_variable\ntransformation_expression\ntransformation_constraint\nExtend the following, if appropriate:\nInfiniteOpt.variable_supports\nInfiniteOpt.expression_supports\nInfiniteOpt.constraint_supports\nAs appropriate and if NOT a JuMPBackend, extend the following:\nThe remaining result related attributes listed in JuMP.get_attribute\nJuMP.lp_sensitivity_report\nInfiniteOpt.warmstart_backend_start_values to enable automated warmstarts\nIf Step 6 was skipped and/or the backend is NOT a JuMPBackend then extend the following:\nInfiniteOpt.map_value (enables JuMP.value)\nInfiniteOpt.map_infinite_parameter_value (enables JuMP.value for infinite parameters)\nInfiniteOpt.map_optimizer_index (enables JuMP.optimizer_index)\nInfiniteOpt.map_reduced_cost (enables JuMP.reduced_cost)\nInfiniteOpt.map_shadow_price (enables JuMP.shadow_cost)\nInfiniteOpt.map_dual (enables JuMP.dual)\nExtend InfiniteOpt.add_point_variable and   InfiniteOpt.add_semi_infinite_variable to use   expand_measure without modifying the infinite model.\nExtend InfiniteOpt.update_parameter_value to enable incremental parameter updates.\nExtend map_value_to_start if the transformation does not return discretized values.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"This may seem like a lot a work, but the majority of the above steps can be skipped for JuMPBackends as exemplified below. A complete extension, showing all the above is provided in the extension template file.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"For the sake of example, let's suppose we want to define a reformulation method  for InfiniteModels that are 2-stage stochastic programs (i.e., only  DistributionDomains are used, infinite variables are random 2nd stage variables,  and finite variables are 1st stage variables). In particular, let's make a simple  method that replaces the infinite parameters with their mean values, giving us  the deterministic mean-valued problem.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"First, let's define the (potentially mutable) struct that will be used to store  our variable and constraint mappings. This case it is quite simple since our  deterministic model will have a 1-to-1 mapping:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"using InfiniteOpt, Distributions\n\nstruct DeterministicData\n    # variable and constraint mapping\n    infvar_to_detvar::Dict{GeneralVariableRef, VariableRef}\n    infconstr_to_detconstr::Dict{InfOptConstraintRef, ConstraintRef}\n    # constructor\n    function DeterministicData()\n        return new(Dict{GeneralVariableRef, VariableRef}(),\n                   Dict{InfOptConstraintRef, ConstraintRef}())\n    end\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now let's define the transformation backend based on JuMPBackend that will use a tag Deterministic:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"struct Deterministic <: AbstractJuMPTag end\n\nconst DeterministicBackend = JuMPBackend{Deterministic, Float64, DeterministicData}\n\n# Constructor\nfunction DeterministicBackend(; kwargs...)\n    return JuMPBackend{Deterministic}(Model(; kwargs...), DeterministicData())\nend\nfunction DeterministicBackend(optimizer_constructor; kwargs...)\n    backend = DeterministicBackend(; kwargs...)\n    set_optimizer(backend.model, optimizer_constructor)\n    return backend\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"With the constructor we can now specify that a given InfiniteModel uses a  DeterministicBackend instead of a TranscriptionBackend or via  set_transformation_backend:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"using Ipopt\n\n# Make model using Ipopt and DeterministicModels\ndbackend = DeterministicBackend(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0))\nmodel = InfiniteModel(dbackend)\n\n# Or equivalently\nmodel = InfiniteModel()\nset_transformation_backend(model, DeterministicBackend())\nset_optimizer(model, optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0))","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now model uses a DeterministicBackend as its transformation backend! With that we can build our InfiniteModel as normal, for example:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"@infinite_parameter(model, Î¾ ~ Uniform())\n@variable(model, y[1:2] >= 0, Infinite(Î¾))\n@variable(model, z)\n@objective(model, Min, z + expect(y[1] + y[2], Î¾))\n@constraint(model, 2y[1] - z <= 42)\n@constraint(model, y[2]^2 + Î¾ == 2)\n@constraint(model, sin(z) >= -1)\nprint(model)\n\n# output\nMin z + ð”¼{Î¾}[y[1](Î¾) + y[2](Î¾)]\nSubject to\n y[1](Î¾) â‰¥ 0.0, âˆ€ Î¾ ~ Uniform\n y[2](Î¾) â‰¥ 0.0, âˆ€ Î¾ ~ Uniform\n 2 y[1](Î¾) - z â‰¤ 42.0, âˆ€ Î¾ ~ Uniform\n y[2](Î¾)Â² + Î¾ = 2.0, âˆ€ Î¾ ~ Uniform\n sin(z) - -1 â‰¥ 0.0","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We have defined our InfiniteModel, but now we need to specify how to  reformulate it into a DeterministicBackend. This is accomplished by extending  build_transformation_backend! which will enable the use of optimize!. A necessary preliminary step though, is to define Base.empty! for DeterministicData:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function Base.empty!(data::DeterministicData)\n    empty!(data.infvar_to_detvar)\n    empty!(data.infconstr_to_detconstr)\n    return data\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"This enables the backend to be cleared out before it is rebuilt which is necessary to allow for modifications to the model. Now, let's define an internal function _make_expression that will use dispatch to  convert an InfiniteOpt expression into a JuMP expression using the mappings  stored in backend's DeterministicData:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"## Make dispatch methods for converting InfiniteOpt expressions\n# GeneralVariableRef\nfunction _make_expression(backend::DeterministicBackend, expr::GeneralVariableRef)\n    return _make_expression(backend, expr, index(expr))\nend\n# IndependentParameterRef\nfunction _make_expression(\n    backend::DeterministicBackend, \n    expr::GeneralVariableRef, \n    ::IndependentParameterIndex\n    )\n    return mean(infinite_domain(expr).distribution) # assuming univariate\nend\n# FiniteParameterRef\nfunction _make_expression(\n    backend::DeterministicBackend, \n    expr::GeneralVariableRef, \n    ::FiniteParameterIndex\n    )\n    return parameter_value(expr)\nend\n# DependentParameterRef\nfunction _make_expression(\n    backend::DeterministicBackend, \n    expr::GeneralVariableRef, \n    ::DependentParameterIndex\n    )\n    return mean(infinite_domain(expr).distribution) # assuming valid distribution\nend\n# DecisionVariableRef\nfunction _make_expression(\n    backend::DeterministicBackend, \n    expr::GeneralVariableRef, \n    ::Union{InfiniteVariableIndex, FiniteVariableIndex}\n    )\n    return backend.data.infvar_to_detvar[expr]\nend\n# MeasureRef --> assume is expectation\nfunction _make_expression(\n    backend::DeterministicBackend, \n    expr::GeneralVariableRef,\n    ::MeasureIndex\n    )\n    return _make_expression(backend, measure_function(expr))\nend\n# AffExpr/QuadExpr/NonlinearExpr\nfunction _make_expression(backend::DeterministicBackend, expr::Union{GenericAffExpr, GenericQuadExpr, GenericNonlinearExpr})\n    return map_expression(v -> _make_expression(backend, v), expr)\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"For simplicity in example, above we assume that only DistributionDomains are  used, there are not any PointVariableRefs, and all MeasureRefs correspond to  expectations. Naturally, a full extension should include checks to enforce that  such assumptions hold. Notice that map_expression is useful for  converting expressions.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now let's extend build_transformation_backend! for DeterministicBackends. This should build out the backend in-place and thus we should also be sure to have it clear out any previous builds with Base.empty!:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.build_transformation_backend!(\n    model::InfiniteModel,\n    backend::DeterministicBackend\n    )\n    # TODO check that `model` is a stochastic model\n    # empty the model for a build/rebuild\n    empty!(backend)\n    backend.model.operator_counter = 0 # clears out any previous user defined operators\n\n    # add user-defined nonlinear operators if there are any\n    add_operators_to_jump(backend.model, model)\n\n    # add variables\n    for vref in all_variables(model)\n        if index(vref) isa InfiniteVariableIndex\n            start = NaN # simple hack for sake of example\n        else\n            start = start_value(vref)\n            start = isnothing(start) ? NaN : start\n        end\n        lb = has_lower_bound(vref) ? lower_bound(vref) : NaN\n        ub = has_upper_bound(vref) ? upper_bound(vref) : NaN\n        if is_fixed(vref)\n            lb = fix_value(vref)\n        end\n        info = VariableInfo(!isnan(lb), lb, !isnan(ub), ub, is_fixed(vref), lb, \n                            !isnan(start), start, is_binary(vref), is_integer(vref))\n        new_vref = add_variable(backend.model, ScalarVariable(info), name(vref))\n        backend.data.infvar_to_detvar[vref] = new_vref\n    end\n\n    # add the objective\n    obj_func = _make_expression(backend, objective_function(model))\n    set_objective(backend.model, objective_sense(model), obj_func)\n\n    # add the constraints\n    for cref in all_constraints(model, Union{GenericAffExpr, GenericQuadExpr, GenericNonlinearExpr})\n        constr = constraint_object(cref)\n        new_func = _make_expression(backend, constr.func)\n        new_constr = build_constraint(error, new_func, constr.set)\n        new_cref = add_constraint(backend.model, new_constr, name(cref))\n        backend.data.infconstr_to_detconstr[cref] = new_cref\n    end\n    return\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Note that Step 5 can be skipped since we are using the JuMPBackend API which inherits  all the needed methods. Now we can build our backend automatically and enable the use of  optimize!:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"optimize!(model)\nprint(transformation_model(model))\n\n# output\nMin z + y[1] + y[2]\nSubject to\n sin(z) - -1.0 â‰¥ 0\n 2 y[1] - z â‰¤ 42\n y[2]Â² = 1.5\n y[1] â‰¥ 0\n y[2] â‰¥ 0","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Note that better variable naming could be used with the reformulated infinite  variables. Moreover, in general extensions of build_transformation_backend!  should account for the possibility that InfiniteModel contains constraints with  DomainRestriction as accessed via domain_restriction.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Now that we have optimized our InfiniteModel via the use the of a  DeterministicBackend, we probably want to access the results. All queries  are enabled via Step 6 where we extend:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"transformation_variable\ntransformation_expression\ntransformation_constraint","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"to return the variable(s)/expression(s)/constraint(s) in the backend. These will use the DeterministicData and should error if no mapping can be  found.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.transformation_variable(\n    vref::GeneralVariableRef,\n    backend::DeterministicBackend\n    )\n    map_dict = backend.data.infvar_to_detvar\n    haskey(map_dict, vref) || error(\"Variable $vref not used in the transformation backend.\")\n    return map_dict[vref]\nend\n\nfunction InfiniteOpt.transformation_expression(\n    expr::JuMP.AbstractJuMPScalar,\n    backend::DeterministicBackend\n    )\n    return _make_expression(backend, expr)\nend\n\nfunction InfiniteOpt.transformation_constraint(\n    cref::InfOptConstraintRef,\n    backend::DeterministicBackend\n    )\n    map_dict = backend.data.infconstr_to_detconstr\n    haskey(map_dict, cref) || error(\"Constraint $cref not used in the transformation backend.\")\n    return map_dict[cref]\nend","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"With these extensions we can now access all the result queries (skipping Steps 8-9). For example:","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"julia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4\n\njulia> result_count(model)\n1\n\njulia> value.(y)\n2-element Vector{Float64}:\n -9.164638781941642e-9\n  1.224744871391589\n\njulia> optimizer_index(z)\nMathOptInterface.VariableIndex(3)","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"We also skip steps 7 and 10 since these are not applicable to this particular  example.","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"That's it!","category":"page"},{"location":"develop/extensions/#Wrapper-Packages","page":"Extensions","title":"Wrapper Packages","text":"","category":"section"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"InfiniteOpt provides a convenient modular interface for defining infinite  dimensional optimization problems, implementing many tedious JuMP extensions  such as facilitating mixed variable expressions. Thus, InfiniteOpt can serve  as a base package for specific types of infinite dimensional problems and/or  solution techniques. These extension packages can implement any of the extensions  shown above and likely will want to introduce wrapper functions and macros to  use package specific terminology (e.g., using random variables instead of  infinite variables).","category":"page"},{"location":"develop/extensions/","page":"Extensions","title":"Extensions","text":"Please reach out to us via the  discussion forum to  discuss your plans before starting this on your own.","category":"page"},{"location":"guide/constraint/#constr_docs","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"A guide for constraints in InfiniteOpt. See the respective  technical manual for more details.","category":"page"},{"location":"guide/constraint/#Overview","page":"Constraints","title":"Overview","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Constraints are a key part of infinite dimensional problems and serve  as a fundamental utility of InfiniteOpt. In particular, InfiniteOpt supports  finite constraints that entail finite variables and/or measures that fully remove any  infinite parameter dependencies (e.g., first stage constraints), infinite  constraints that are enforced over the entire domain of its infinite parameter  dependencies (e.g., path constraints), and restricted constraints which  are enforced over some specified sub-domain of its infinite parameter  dependencies (e.g., boundary conditions). This page will highlight how to  implement these types of constraints in InfiniteOpt.","category":"page"},{"location":"guide/constraint/#Basic-Usage","page":"Constraints","title":"Basic Usage","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Principally, the  @constraint  macro is used to define constraints. First, let's set up an infinite model with  variables that we can add constraints to:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @infinite_parameter(model, x[1:2] in [-2, 2]);\n\njulia> @variable(model, ya, Infinite(t, x));\n\njulia> @variable(model, yb, Infinite(t));\n\njulia> @variable(model, z[1:2]);","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nInfiniteOpt supports all the constraints types offered by JuMP, including vector and semi-definite constraints! Please  see JuMP's constraint documentation  for a thorough explanation of the supported types and syntax.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nNonlinear constraints are defined simply by using @constraint and not  using JuMP.@NLconstraint. See Nonlinear Expressions for  more information. ","category":"page"},{"location":"guide/constraint/#Scalar-Constraints","page":"Constraints","title":"Scalar Constraints","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Scalar constraints use scalar functions of variables. For example, let's define  the constraint  z^2 + 2y_a(t x) leq 0  forall t in 0 10 x in -2 2^2  using @constraint:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, c1, sum(z[i]^2 for i = 1:2) + 2ya <= 0)\nc1 : z[1]Â² + z[2]Â² + 2 ya(t, x) â‰¤ 0, âˆ€ t âˆˆ [0, 10], x[1] âˆˆ [-2, 2], x[2] âˆˆ [-2, 2]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we added an infinite constraint (which infinite with respect to t and x)  to model and stored the corresponding constraint reference to c1. Note that   this is enforced over the full infinite domains of the infinite parameters t  and x which are implicitly used by c1. For scalar constraints like this one,  the allowed constraint operators are ==, <=, â‰¤, >=, and â‰¥.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nLinear algebra constraints can also be used when defining constraints  when . is added in front of the constraint operators (e.g., .<=). This  behavior is further explained in  JuMP's constraint documentation. ","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Similarly, we can define an array of constraints with varied indexes by including  an additional argument before the constraint expression. For example,  let's define 3z_i - 14 = 0  forall i in 12:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, c2[i = 1:2], 3z[i] - 14 == 0)\n2-element Vector{InfOptConstraintRef}:\n c2[1] : 3 z[1] = 14\n c2[2] : 3 z[2] = 14","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we added two constraints to model and stored a vector of the corresponding  constraint references to the Julia variable c2. To learn more about building  containers of constraints please see  JuMP's constraint container documentation.","category":"page"},{"location":"guide/constraint/#Multi-Dimensional-Constraints","page":"Constraints","title":"Multi-Dimensional Constraints","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Building upon JuMP we support a variety of multi-dimensional constraint types.  For example, we can define the vector constraint:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> A = [1 2; 3 4]\n2Ã—2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = [5, 6]\n2-element Vector{Int64}:\n 5\n 6\n\njulia> @constraint(model, A * z - b in MOI.Nonnegatives(2))\n[z[1] + 2 z[2] - 5, 3 z[1] + 4 z[2] - 6] âˆˆ MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"See JuMP's constraint documentation  for a thorough tutorial on the accepted syntax and constraint types.","category":"page"},{"location":"guide/constraint/#Restricted-Constraints","page":"Constraints","title":"Restricted Constraints","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Restricted constraints entail an infinite domain (determined by the infinite  parameters they explicitly/implicitly depend on) that is restricted to a certain  sub-domain. Such constraints are common for enforcing initial/boundary conditions  and for enforcing path constraints over a certain sub-domain.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"These types of constraints are defined adding DomainRestriction. For  example, let's add the initial condition y_b(0) = 0:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, initial, yb == 0, DomainRestriction(iszero, t))\ninitial : yb(t) = 0, âˆ€ t âˆˆ [0, 10]; if iszero(t) = True","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we have added a constraint to model defined over the sub-domain t = 0  in accordance with the initial condition.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"tip: Tip\nBoundary conditions can often be more efficiently defined using  Restricted Variables. For example, the above initial condition  can be expressed:julia> @constraint(model, yb(0) == 0)\nyb(0) = 0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"This syntax is quite general since any function can be defined for more  complex sub-domains can be specified by simply adding more restrictions. To  illustrate this, let's define the constraint  2y_b^2(t x) + z_1 geq 3  forall t = 0  x in -1 1^2:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> restrict(t_s, x_s) = iszero(t_s) && -1 <= x_s <= 1;\n\njulia> @constraint(model, 2ya^2 + z[1] >= 3, DomainRestriction(restrict, t, x))\n2 ya(t, x)Â² + z[1] â‰¥ 3, âˆ€ t âˆˆ [0, 10], x[1] âˆˆ [-2, 2], x[2] âˆˆ [-2, 2]; if restrict(t, x) = True","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Now we have added constraints to our model, and it is ready to be solved!","category":"page"},{"location":"guide/constraint/#Data-Structure","page":"Constraints","title":"Data Structure","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Here we detail the data structures used to store constraints in InfiniteOpt.  In general, constraints in JuMP are of the form: function in set where  function corresponds to a JuMP expression and set corresponds to a MOI  set. This leads to the following data structures:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Constraint Type Function Type Set Type\nScalar JuMP.AbstractJuMPScalar MOI.AbstractScalarSet\nVector Vector{<:JuMP.AbstractJuMPScalar} MOI.AbstractVectorSet\nMatrix Matrix{<:JuMP.AbstractJuMPScalar} MOI.AbstractVectorSet via vectorization","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"The above combos are then stored in  JuMP.ScalarConstraints  and `JuMP.VectorConstraints. ","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Restricted constraints are built upon this data structure where the underlying  constraint is created in the same manner. Then the specified  DomainRestriction are added by creating a  DomainRestrictedConstraint which stores the JuMP.AbstractConstraint  and the restrictions.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"These constraint objects are what store constraints in InfiniteModels. And  these are pointed to by InfOptConstraintRefs.","category":"page"},{"location":"guide/constraint/#Definition","page":"Constraints","title":"Definition","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"In this section, we describe the ins and outs of defining constraints. Note that  this process is analogous to the manner in which variables are defined and added  to the model.","category":"page"},{"location":"guide/constraint/#Manual-Definition","page":"Constraints","title":"Manual Definition","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Defining a constraint principally involves the following steps:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Define the constraint information (i.e., function, set, and domain restrictions)\nConstruct a concrete subtype of JuMP.AbstractConstraint to store the  constraint information\nAdd the AbstractConstraint object to an InfiniteModel and assign a name\nCreate an InfOptConstraintRef that points to the constraint object  stored in the model.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"The constraint objects are specified via JuMP.build_constraint which requires  that the user provides a function, set, and optionally include domain  restrictions. For example, let's build a scalar constraint  3y_a(t x) - y_b^2(t) leq 0  forall t in 0 10 x in -2 2^2 over  its full infinite domain (i.e., have no DomainRestriction):","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> constr = build_constraint(error, 3ya - yb^2, MOI.LessThan(0.0));","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Now the built constraint object can be added to the infinite model via  add_constraint. Let's do so with our example and assign it the name of  c3 (note that adding a name is optional):","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> cref = add_constraint(model, constr, \"c3\")\nc3 : -yb(t)Â² + 3 ya(t, x) â‰¤ 0, âˆ€ t âˆˆ [0, 10], x[1] âˆˆ [-2, 2], x[2] âˆˆ [-2, 2]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we have made our constraint and added it model and now have a constraint  reference cref that we can use to access it.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"The @constraint  macro automate the above steps.","category":"page"},{"location":"guide/constraint/#Macro-Definition","page":"Constraints","title":"Macro Definition","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"As mentioned above in the Basic Usage section, the  @constraint  macro should be used to define constraints with the syntax:  @constraint(model::InfiniteModel, [container/name_expr], constr_expr, [rs::DomainRestriction]).","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"The second argument is optional and is used to assign a name and/or define  indexing variables to be used in the constraint expression. When a name is provided it  is registered and cannot be used again for another constraint or variable name.  The indexing expression can be used to produce an array of constraints as shown  below (notice this is equivalent to looping over individual @constraint calls):","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> crefs = @constraint(model, [i = 1:2], 2z[i] - yb == 0)\n2-element Vector{InfOptConstraintRef}:\n 2 z[1] - yb(t) = 0, âˆ€ t âˆˆ [0, 10]\n 2 z[2] - yb(t) = 0, âˆ€ t âˆˆ [0, 10]\n\njulia> crefs = Vector{InfOptConstraintRef}(undef, 2);\n\njulia> for i = 1:2\n           crefs[i] = @constraint(model, 2z[i] - yb == 0)\n       end\n\njulia> crefs\n2-element Vector{InfOptConstraintRef}:\n 2 z[1] - yb(t) = 0, âˆ€ t âˆˆ [0, 10]\n 2 z[2] - yb(t) = 0, âˆ€ t âˆˆ [0, 10]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Please refer to  JuMP's constraint container documentation  for a thorough tutorial on creating containers of constraints.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Any constraint type supported by JuMP can be specified in the constr_expr  argument. This includes a wealth of constraint types including:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Variable constraints\nScalar constraints\nVector constraints\nConic constraints \nIndicator constraints\nSemi-definite constraints","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"For example, we could define the following semi-definite constraint:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [yb 2yb; 3yb 4yb] >= ones(2, 2), PSDCone())\n[yb(t) - 1    2 yb(t) - 1\n 3 yb(t) - 1  4 yb(t) - 1] âˆˆ PSDCone(), âˆ€ t âˆˆ [0, 10]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"See JuMP's constraint documentation  for a thorough tutorial on the accepted syntax and constraint types.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Finally, restrictions on the inherent infinite domain of a constraint can be  specified via DomainRestriction with the rs argument. The accepted  syntax is DomainRestriction(restrict_func, prefs...) where restrict_func takes a support in the form of prefs... and returns a Bool that indicates if the support is in the domain of interest. Note that prefs must correspond to infinite parameters.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"For example, we can define the constraint y_a^2(t x) + z_i leq 1 and  restrict the infinite domain of x to be 0 1^2:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> restrict2(x_s) = all(0 .<= x_s .<= 1);\n\njulia> @constraint(model, [i = 1:2], ya^2 + z[i] <= 1, DomainRestriction(restrict2, x))\n2-element Vector{InfOptConstraintRef}:\n ya(t, x)Â² + z[1] â‰¤ 1, âˆ€ t âˆˆ [0, 10], x[1] âˆˆ [-2, 2], x[2] âˆˆ [-2, 2]; if restrict2(x) = True\n ya(t, x)Â² + z[2] â‰¤ 1, âˆ€ t âˆˆ [0, 10], x[1] âˆˆ [-2, 2], x[2] âˆˆ [-2, 2]; if restrict2(x) = True","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"tip: Tip\nWhere possible, using Restricted Variables will tend to be more  performant than using DomainRestriction instead.","category":"page"},{"location":"guide/constraint/#Queries","page":"Constraints","title":"Queries","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"In this section, we describe a variety of methods to extract constraint information.","category":"page"},{"location":"guide/constraint/#Basic","page":"Constraints","title":"Basic","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"A number of constraint properties can be extracted via constraint references.  Principally, the validity, name, model, index, and constraint object can be queried  via is_valid,  name,  owner_model,  index,  and constraint_object, respectively. These methods all constitute   extensions of JuMP methods and follow exactly the same behavior. Let's try  them out with the following example:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> is_valid(model, c1) # check if contained in model\ntrue\n\njulia> name(c1) # get the name\n\"c1\"\n\njulia> m = owner_model(c1); # get the model it is added to\n\njulia> index(c1) # get the constraint's index\nInfOptConstraintIndex(1)\n\njulia> constr = constraint_object(c1); # get the raw constraint datatype","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Also, constraint_by_name can be used to retrieve a constraint reference  if only the name is known and its name is unique. For example, let's extract the  reference for \"c1\":","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> cref = constraint_by_name(model, \"c1\")\nc1 : z[1]Â² + z[2]Â² + 2 ya(t, x) â‰¤ 0, âˆ€ t âˆˆ [0, 10], x[1] âˆˆ [-2, 2], x[2] âˆˆ [-2, 2]","category":"page"},{"location":"guide/constraint/#Domain-Restrictions","page":"Constraints","title":"Domain Restrictions","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"As explained above, restricted constraints serve as a key capability of  InfiniteOpt. Information about domain restrictions can be obtained via  has_domain_restriction and domain_restriction which indicate  if a constraint is restricted and what its DomainRestriction are,  respectively. These are exemplified below:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> has_domain_restriction(c1) # check if constraint is bounded\nfalse\n\njulia> has_domain_restriction(initial)\ntrue\n\njulia> domain_restriction(initial)\niszero(t)","category":"page"},{"location":"guide/constraint/#General","page":"Constraints","title":"General","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Constraints can be defined in a number of ways symbolically that differ from  how it is actually stored in the model. This principally occurs since like terms  and constants are combined where possible with the variable terms on the  left-hand side and the constant on the right-hand side. For instance, the  constraint 2y_b(t) + 3y_b(t) - 2 leq 1 + z_1 would be normalized   5y_b(t) - z_1 leq 3. In accordance with this behavior,   normalized_rhs and normalized_coefficient  can be used to query the normalized right-hand side and the coefficient of a  particular variable reference, respectively. Let's employ the above example to  illustrate this:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, constr, 2yb + 3yb - 2 <= 1 + z[1])\nconstr : 5 yb(t) - z[1] â‰¤ 3, âˆ€ t âˆˆ [0, 10]\n\njulia> normalized_rhs(constr)\n3.0\n\njulia> normalized_coefficient(constr, yb)\n5.0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"There also exist a number of methods for querying an infinite model about what  constraints it contains.  list_of_constraint_types can be used query what types of constraints   have been added to a model. This is provided as a list of tuples where the first  element is the expression type and the second element is the set type (recall  that constraints are stored in the form func-in-set). Thus, for our current  model we obtain:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> list_of_constraint_types(model)\n4-element Vector{Tuple{DataType,DataType}}:\n (GenericQuadExpr{Float64, GeneralVariableRef}, MathOptInterface.LessThan{Float64})\n (GenericQuadExpr{Float64, GeneralVariableRef}, MathOptInterface.GreaterThan{Float64})\n (GenericAffExpr{Float64, GeneralVariableRef}, MathOptInterface.LessThan{Float64})\n (GenericAffExpr{Float64, GeneralVariableRef}, MathOptInterface.EqualTo{Float64})","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"This information is useful when used in combination with the  num_constraints and all_constraints methods which can take  the expression type and/or the set type as inputs. Here num_constraints  provides the number of constraints that match a certain type, and all_constraints  returns a list of constraint references matching the criteria provided. These have  been extended beyond JuMP functionality such additional methods have been  provided for the cases in which one wants to query solely off of set or off  expression type. Let's illustrate this with num_constraints:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> num_constraints(model) # total number of constraints\n16\n\njulia> num_constraints(model, GenericQuadExpr{Float64, GeneralVariableRef})\n5\n\njulia> num_constraints(model, MOI.LessThan{Float64})\n5\n\njulia> num_constraints(model, GenericQuadExpr{Float64, GeneralVariableRef},\n                       MOI.LessThan{Float64})\n4                   ","category":"page"},{"location":"guide/constraint/#Modification","page":"Constraints","title":"Modification","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"In this section, we highlight a number of methods that can be used to modify  existing constraints.","category":"page"},{"location":"guide/constraint/#Deletion","page":"Constraints","title":"Deletion","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"All constraints in InfiniteOpt can be removed in like manner to typical JuMP  constraints with the appropriate extension of  delete. This will  remove the corresponding constraint object from the model. However, please note  any registered names will remain registered in the infinite model. This means  that a constraint with a registered name cannot be repeatedly added and removed  using the same name. To exemplify this, let's delete the constraint c1:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> delete(model, c1)","category":"page"},{"location":"guide/constraint/#General-2","page":"Constraints","title":"General","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"There also are a number of ways to modify information and characteristics of  constraints. First, set_name  can be used to specify a new name for a particular constraint. For instance,  let's update the name of initial to \"init_cond\":","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> set_name(initial, \"init_cond\")\n\njulia> initial\ninit_cond : yb(t) = 0, âˆ€ t âˆˆ [0, 10]; if iszero(t) = True","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"We can also update the normalized right hand side constant value or normalized  left hand side variable coefficient value using  set_normalized_rhs and set_normalized_coefficient,  respectively. Let's again consider the constraint 5y_b(t) - z_1 leq 3 as an  example. Let's change the constant term to -1 and the y_b(t) coefficient to 2.5:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> set_normalized_rhs(constr, -1)\n\njulia> set_normalized_coefficient(constr, yb, 2.5)\n\njulia> constr\nconstr : 2.5 yb(t) - z[1] â‰¤ -1, âˆ€ t âˆˆ [0, 10]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nIn some cases, it may be more convenient to dynamically modify coefficients  and other values via the use of finite parameters. This provides an avenue  to update parameters without having to be concerned about the normalized form.  For more information, see the Finite Parameters page. ","category":"page"},{"location":"guide/constraint/#Domain-Restriction","page":"Constraints","title":"Domain Restriction","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Domain Restrictions can be modified or removed from any constraint in  InfiniteOpt. Principally, this is accomplished via   set_domain_restriction and delete_domain_restriction.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nPrevious versions of InfiniteOpt used DomainRestrictions with a more limited syntax. Now DomainRestriction has been introduced to provide a more flexible syntax.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"set_domain_restriction can be employed to specify  what restrictions a constraint has (overwriting any existing ones if forced). It   follows the same syntax, so let's use it to change the bounds on t to t = 0:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> set_domain_restriction(constr, DomainRestriction(iszero, t))\n\njulia> constr\nconstr : 2.5 yb(t) - z[1] â‰¤ -1, âˆ€ t âˆˆ [0, 10]; if iszero(t) = True","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Finally, constraint restrictions can be deleted via  delete_domain_restriction. Now let's delete the domain restrictions  associated with our example:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> delete_domain_restriction(constr)\n\njulia> constr\nconstr : 2.5 yb(t) - z[1] â‰¤ -1, âˆ€ t âˆˆ [0, 10]","category":"page"},{"location":"guide/domains/#infinite_domains_docs","page":"Infinite Domains","title":"Infinite Domains","text":"","category":"section"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"A guide for infinite domains in InfiniteOpt. See the respective  technical manual for more details.","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"note: Note\nPrevious versions of InfiniteOpt referred to infinite domains as infinite  sets. Hence, all the methods and datatypes have been updated accordingly. ","category":"page"},{"location":"guide/domains/#Basic-Usage","page":"Infinite Domains","title":"Basic Usage","text":"","category":"section"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Interval domains are what characterize the behavior of infinite parameters in  InfiniteOpt, since they comprise the domains of infinite parameters. However,  most users will not need to work directly with infinite domains and can instead  focus on the use of infinite parameters as defined via @infinite_parameter  and as discussed on the Infinite Parameters page.","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"However, for convenience below we summarize the infinite domains associated with  InfiniteOpt:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Domain Type Domain Type\nIntervalDomain lb ub InfiniteScalarDomain\nUniDistributionDomain sim mathcalD subseteq mathbbR InfiniteScalarDomain\nMultiDistributionDomain sim mathcalD subseteq mathbbR^n InfiniteArrayDomain\nCollectionDomain Combination of Univariate Domains InfiniteArrayDomain","category":"page"},{"location":"guide/domains/#Infinite-Domain-Classes","page":"Infinite Domains","title":"Infinite Domain Classes","text":"","category":"section"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"The domain of a given infinite parameter(s) is described by an infinite domain (domain)  inherited from AbstractInfiniteDomain. InfiniteOpt natively supports  two domain sub-groups, namely InfiniteScalarDomains and InfiniteArrayDomains.  These correspond to a single independent infinite parameter and a dependent multi-dimensional  group of infinite parameters, respectively. We describe each group's natively  supported domains below.","category":"page"},{"location":"guide/domains/#Univariate-Domains","page":"Infinite Domains","title":"Univariate Domains","text":"","category":"section"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Univariate infinite domains (i.e., InfiniteScalarDomains) are one-dimensional  domains (subseteq mathbbR) that describe the behavior of one single independent  infinite parameter (i.e., infinite parameters made using independent = true). The  two natively supported concrete types are IntervalDomains and UniDistributionDomains.","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"IntervalDomains describe a continuous interval from some lower bound up to  some upper bound. Where the range is inclusive of the bounds. Such domains often  arise for parameters that pertain to time and/or spatial position. For example,  to define a position interval -2 2 we would use:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> domain = IntervalDomain(-2, 2)\n[-2, 2]","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Note that (semi-)infinite bounds are acceptable, as shown in the following example:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> infinite_domain = IntervalDomain(-Inf, Inf)\n[-Inf, Inf]","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"UniDistributionDomains pertain to the co-domain of a univariate distribution.  In other words, these correspond to the underlying distributions that characterize  uncertain scalar parameters. These domains are compatible with any univariate  distribution native to Distributions.jl. For example, let's make a UniDistributionDomain that depends on a Beta distribution:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> using Distributions;\n\njulia> domain = UniDistributionDomain(Beta(2,2))\nBeta{Float64}(Î±=2.0, Î²=2.0)","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"User-defined distributions are also permissible so long as they are created in accordance with Distributions.jl.","category":"page"},{"location":"guide/domains/#Multivariate-Domains","page":"Infinite Domains","title":"Multivariate Domains","text":"","category":"section"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Multivariate infinite domains (i.e., [InfiniteArrayDomain])(@ref)s are multi-dimensional  domains that define the behavior of a group of dependent infinite parameters  (i.e., an array of infinite parameters where independent = false). This is a  unique feature to InfiniteOpt that enables a much richer set of possibilities  for modeling infinite domain. Natively two domain types are supported:  MultiDistributionDomains and CollectionDomains. ","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"MultiDistributionDomains correspond to the co-domain of a multi-variate  (or matrix-variate) distribution which characterizes the behavior of multi-dimensional  uncertain parameters. Again, these correspond to any appropriate distribution  defined in Distributions.jl. For example, we can make a MultiDistributionDomain  that depends on a 2D normal distribution as follows:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> using Distributions;\n\njulia> dist = MvNormal([0., 0.], [1. 0.; 0. 2.]);\n\njulia> domain = MultiDistributionDomain(dist)\nFullNormal(\ndim: 2\nÎ¼: [0.0, 0.0]\nÎ£: [1.0 0.0; 0.0 2.0]\n)","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"note: Note\nThe dimensions (shape) of a chosen distribution used in an MultiDistriubtionDomain  must match those of the corresponding infinite parameter array.","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Finally, CollectionDomains are a dependent collection of InfiniteScalarDomains that correspond to a group of infinite parameters that are treated dependently.  This can be useful when the user wishes to have complete control over how the  supports are generated for a group independent parameters where the default  combinatorial approach in not wanted. For example, let's make a set of IntervalDomains:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> domain = CollectionDomain([IntervalDomain(-2, 2), IntervalDomain(-1, 4)])\nCollectionDomain with 2 domains:\n [-2, 2]\n [-1, 4]","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Now we could use this domain in define a two-dimensional infinite parameter of which  we can have the freedom to define a non-combinatorial support grid.","category":"page"},{"location":"guide/domains/#Bound-Query/Modification-Methods-for-Infinite-Domains","page":"Infinite Domains","title":"Bound Query/Modification Methods for Infinite Domains","text":"","category":"section"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Once an infinite domain is created, one can query the lower bound and upper bound of the domain  similar to how one queries the bounds of a JuMP variable. Thus, the functions  JuMP.has_lower_bound, JuMP.has_upper_bound, JuMP.lower_bound, JuMP.upper_bound  are all applicable to infinite domains mentioned above. For example, for an IntervalDomain [-2, 2] we can query the bound information as follows:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> domain = IntervalDomain(-2, 2);\n\njulia> has_lower_bound(domain)\ntrue\n\njulia> has_upper_bound(domain)\ntrue\n\njulia> lower_bound(domain)\n-2.0\n\njulia> upper_bound(domain)\n2.0","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"In addition, we can also apply JuMP.set_lower_bound and JuMP.set_upper_bound  to IntervalDomains to generate a new domain with updated bounds. Note that this will not modify the original domain. For example, we can change the bounds of the set [-2, 2] as follows:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> set_lower_bound(domain, -1)\n[-1, 2]\n\njulia> set_upper_bound(domain, 1)\n[-2, 1]","category":"page"},{"location":"guide/domains/#Support-Generation-for-Infinite-Domains","page":"Infinite Domains","title":"Support Generation for Infinite Domains","text":"","category":"section"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"InfiniteOpt provides a systematic interface to generate support points for  infinite domains. This is crucial as support generation decides how each  infinite-dimensional parameter, which is subject to certain infinite domain, is  discretized later in the transcription stage. The interface will allow users to  automatically generate support points using our default methods. Later we will  also show that users can also input support points manually for an infinite  parameter. Please note that these methods are called by the  @infinite_parameter macro when the num_supports keyword is used.  Thus, users typically will not need to use this interface directly.","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"In InfiniteOpt supports can be generated via generate_supports  function. For example, let's generate 5 equidistant support points for the  IntervalDomain [-2, 2]:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> supps, label = generate_supports(domain, num_supports = 5)\n([-2.0, -1.0, 0.0, 1.0, 2.0], UniformGrid)","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Note that the number of supports generated is specified via num_supports  keyword argument, which will take a default value of 10 if not specified. The  function generate_supports returns a vector of the supports generated, and a  label that denotes the underlying method. In this case the label returned is  UniformGrid, which is the default support generation method for  IntervalDomains. Another support generation method implemented for  IntervalDomains is MCSample, which is to sample from a uniform distribution  over the interval. To use this method, users need to specify a second positional  argument, as shown in the following example:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> generate_supports(domain, MCSample, num_supports = 5, sig_digits = 5)\n([-0.3772, -1.7258, 1.4486, -1.6561, 0.64645], MCSample)","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"In this case, the returned label is MCSample, instead of UniformGrid.","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"generate_supports can also be applied to DistributionDomains. The default  (and currently only) method implemented for DistributionDomains is  WeightedSample, which generates Monte Carlo samples that are weighted based on  the underlying probability density function of the distribution. For example, a  domain of support points for a 2D normal distribution can be generated as  follows:","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"julia> dist = MvNormal([0., 0.], [1. 0.;0. 2.]);\n\njulia> domain = MultiDistributionDomain(dist);\n\njulia> supps, label = generate_supports(domain, num_supports = 3)\n([0.679107426036 -0.353007400301 0.586617074633; 1.17155358277 -0.190712174623 0.420496392851], WeightedSample)","category":"page"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"For those who are interested in coding up their own support generation functions,  generate_supports is an interface that calls the proper  generate_support_values function based on the type of domain and value  of method. Therefore, to use custom support generation methods, users can  implement extensions for generate_support_values with a different  method label from the existing methods. See Extensions for full details.","category":"page"},{"location":"guide/domains/#User-Defined-Domains","page":"Infinite Domains","title":"User Defined Domains","text":"","category":"section"},{"location":"guide/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"Furthermore, custom infinite domains that inherit AbstractInfiniteDomain can  also be defined. See Extensions for more information.","category":"page"},{"location":"guide/extensions/#ext_docs","page":"Extensions","title":"Extension Packages","text":"","category":"section"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"Here, we document extension packages that extend the base capabilities of InfiniteOpt.","category":"page"},{"location":"guide/extensions/#interpolate","page":"Extensions","title":"InfiniteInterpolations","text":"","category":"section"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"This extension uses Interpolations.jl to automatically convert discretized solution values into continuous functions. This extension is enabled by importing both InfiniteOpt and Interpolations:","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"julia> using InfiniteOpt, Interpolations","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"Now let's solve a model:","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"julia> using HiGHS; model = InfiniteModel(HiGHS.Optimizer);\n\njulia> @infinite_parameter(model, t âˆˆ [0, 1], num_supports = 5);\n\njulia> @variable(model, y >= 0, Infinite(t));\n\njulia> @objective(model, Min, âˆ«(y, t));\n\njulia> @constraint(model, y >= 2t);\n\njulia> set_silent(model); optimize!(model)\n\njulia> discrete_y = value(y)\n5-element Vector{Float64}:\n 0.0\n 0.5\n 1.0\n 1.5\n 2.0","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"where we get vector of five values for y since 5 supports are used to discretize y(t). To obtain a continuous representation, we can use interpolation by specifying one of three supported kinds:","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"constant_interpolation or Constant()\nlinear_interpolation or Linear()\ncubic_spline_interpolation or Cubic()","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"For our example, let's choose a linear interpolation:","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"julia> continuous_y = value(y, linear_interpolation);\n\njulia> continuous_y(0.1)\n0.2\n\njulia> continuous_y(0.25)\n0.5","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"Note we could have equivalently used value(y, Linear()).","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"warning: Warning\nThere is a type piracy conflict between JuMP and OffsetArrays  (a dependency of Interpolations.jl). As a result, type piracy issues may arise  when Interpolations is loaded in (typically when JuMP.DenseAxisArrays are used).  Hence, we recommend using Array containers when using this extension.","category":"page"},{"location":"guide/extensions/#InfiniteMathOptAI","page":"Extensions","title":"InfiniteMathOptAI","text":"","category":"section"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"This extension allows us to import machine learning models into InfiniteModels via MathOptAI. This is enabled by importing InfiniteOpt and MathOptAI:","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"julia> using InfiniteOpt, MathOptAI","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"Now we can incorporate any predictor (i.e., machine learning model) supported by MathOptAI which includes neural networks, Gaussian processes, decision trees, and generalized linear  models. For instance, consider the neural ODE with the right-hand side:","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"julia> using Flux\n\njulia> NN = Flux.Chain(Flux.Dense(2 => 3, Flux.relu), Flux.Dense(3 => 1));","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"Let's create an InfiniteModel those poses a neural operator constraint with NN. This is accomplished by using MathOptAI.add_predictor:","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t âˆˆ [0, 1]);\n\njulia> @variable(model, y >= 0, Infinite(t));\n\njulia> f, formulation = add_predictor(model, NN, [y, t]);\n\njulia> @constraint(model, âˆ‚(y, t) == only(f))\nd/dt[y(t)] - moai_Affine[1](t) = 0, âˆ€ t âˆˆ [0, 1]","category":"page"},{"location":"guide/extensions/","page":"Extensions","title":"Extensions","text":"Here, f is the vector of output variables (only 1 in this case) and formulation is an object that stores all the variables and constraints created to embed NN in model. To learn more about MathOptAI's syntax, please visit  MathOptAI's documentation.","category":"page"},{"location":"guide/model/#infinite_model_docs","page":"Infinite Models","title":"Infinite Models","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"A guide for creating infinite models and understanding how they work. See the  respective technical manual for more details.","category":"page"},{"location":"guide/model/#Overview","page":"Infinite Models","title":"Overview","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Infinite models are expressed via the InfiniteModel datatype which is at the core of InfiniteOpt. These model objects are designed to emulate the behavior of Model  objects in JuMP. These data objects store the parameters, variables, measures, objective, constraints, and all other data used in InfiniteOpt. This differs from JuMP models which store such information in a MathOptInterface model backend.","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"note: Note\nInfiniteOpt's InfiniteModels are intended to be used for  infinite-dimensional optimization problems. Finite problems (e.g.,  directly modeling a discrete time model) should instead be modeled using  Model's in JuMP.","category":"page"},{"location":"guide/model/#Basic-Usage","page":"Infinite Models","title":"Basic Usage","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Infinite models can be initialized with no arguments by default:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  Solver: none\n  Transformation built and up-to-date: false","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Ultimately, model will be solved via a transformation backend. By default,  we see that a TranscriptionBackend (a JuMP Model that will contain  a transcribed, i.e., a discretized model) is used. To specify, a backend  of our choice, we use the syntax:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt\n\njulia> model = InfiniteModel(TranscriptionBackend())\nAn InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  Solver: none\n  Transformation built and up-to-date: false","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Since TranscriptionBackends are a common choice, we can just pass a JuMP  compatible optimizer (i.e., solver) to the model and a TranscriptionBackend  that uses that optimizer will be initialized:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, Ipopt\n\njulia> model = InfiniteModel(Ipopt.Optimizer)\nAn InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  Solver: Ipopt\n  Transformation built and up-to-date: false","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"For completeness, the table of currently supported JuMP compatible optimizers  is provided below in Supported Optimizers.","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"We can also specify optimizer attributes via optimizer_with_attributes which allows us to append as many attributes as we like, for example:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, Ipopt\n\njulia> jump_opt = optimizer_with_attributes(Ipopt.Optimizer, \"output_level\" => 0);\n\njulia> model = InfiniteModel(jump_opt)\nAn InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  Solver: Ipopt\n  Transformation built and up-to-date: false","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Now you have an initialized InfiniteModel that is ready for your mathematical model to be defined and optimized!","category":"page"},{"location":"guide/model/#Advanced-Definition-Information","page":"Infinite Models","title":"Advanced Definition Information","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"As noted above, InfiniteModels contain a transformation backend that will ultimately  be used to optimize the InfiniteModel via a transformed version of it. Such backends  typically have methods to transform an InfiniteModel into a transformed model that  can be optimized; moreover, they store necessary data to map back to the InfiniteModel. ","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"By default, InfiniteModels use a TranscriptionBackend which will store a transcribed (i.e., discretized) version of the infinite model. More information on TranscriptionBackendss is provided in Model Transcription. Notably, the main argument TranscriptionBackend is an appropriate JuMP compatible  optimizer:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, Ipopt\n\njulia> backend = TranscriptionBackend(Ipopt.Optimizer)\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: Ipopt\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"We query the underlying transformation backend, transformation model, and transformation data via transformation_backend,  transformation_model, and transformation_data, respectively:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt; model = InfiniteModel();\n\njulia> tbackend = transformation_backend(model)\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none\n\njulia> tmodel = transformation_model(model)\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none\n\njulia> data = transformation_data(model);","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"A new transformation backend is specified via set_transformation_backend:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, Ipopt; model = InfiniteModel();\n\njulia> set_transformation_backend(model, TranscriptionBackend(Ipopt.Optimizer))\n\njulia> tbackend = transformation_backend(model)\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: Ipopt\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Again, since TranscriptionBackend is the default, the following models are equivalent:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, Ipopt; \n\njulia> model1 = InfiniteModel();\n\njulia> set_transformation_backend(model1, TranscriptionBackend(Ipopt.Optimizer, add_bridges = false))\n\njulia> model2 = InfiniteModel(Ipopt.Optimizer, add_bridges = false)\nAn InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  Solver: Ipopt\n  Transformation built and up-to-date: false","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"More information on implementing custom transformation backends is located on the  Extensions page.","category":"page"},{"location":"guide/model/#Supported-Optimizers","page":"Infinite Models","title":"Supported Optimizers","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Supported optimizers (e.g., solvers) depend on the transformation backend being  used. For JuMPBackends such as TranscriptionBackend, any  JuMP compatible optimizer (i.e., has a MathOptInterface implementation) can be  used. Please refer to JuMP's current solver documentation  to learn what solvers are supported and how to install them.","category":"page"},{"location":"guide/model/#Object-Dictionaries","page":"Infinite Models","title":"Object Dictionaries","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Like JuMP.Models, InfiniteModels register the name symbols of macro defined  objects. This enables us to access such objects by indexing the InfiniteModel  with the appropriate symbol. This is particularly useful for function defined  models. For example:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> function make_model(num_supports)\n        model = InfiniteModel()\n        @infinite_parameter(model, t âˆˆ [0, 10], num_supports = num_supports)\n        @variable(model, y >= 42, Infinite(t))\n        @objective(model, Min, âˆ«(y, t))\n        return model\n       end\nmake_model (generic function with 1 method)\n\njulia> model1 = make_model(2); model2 = make_model(4);\n\njulia> y1 = model1[:y]\ny(t)","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Note that when macro defined objects are deleted from an InfiniteModel that the  corresponding symbols in the object dictionary are not removed by default. This  can be accomplished by use of  JuMP.unregister  (please click on its link for usage information).","category":"page"},{"location":"manual/backend/#opt_manual","page":"Backends","title":"Transformation Backends","text":"","category":"section"},{"location":"manual/backend/","page":"Backends","title":"Backends","text":"A technical manual for optimizing (solving) InfiniteOpt models via  transformation backends. See the respective guide  for more information.","category":"page"},{"location":"manual/backend/#Optimize","page":"Backends","title":"Optimize","text":"","category":"section"},{"location":"manual/backend/#JuMP.optimize!-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.optimize!","text":"JuMP.optimize!(model::InfiniteModel; [kwargs...])\n\nExtend JuMP.optimize! to optimize infinite models using the internal transformation backend. Calls build_transformation_backend! if the optimizer model isn't up-to-date. The kwargs correspond to keyword arguments passed to build_transformation_backend! if any are defined. The kwargs can also  include arguments that are passed to an optimize hook if one was set with  JuMP.set_optimize_hook. Typically, this returns nothing, but  certain backends may return something.\n\nExample\n\njulia> optimize!(model)\n\njulia> has_values(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#Backend-Settings/Queries","page":"Backends","title":"Backend Settings/Queries","text":"","category":"section"},{"location":"manual/backend/#InfiniteOpt.transformation_model-Tuple{InfiniteModel}","page":"Backends","title":"InfiniteOpt.transformation_model","text":"transformation_model(model::InfiniteModel)\n\nReturn the underlying model used by the transformation backend.\n\nExample\n\njulia> trans_model = transformation_model(model)\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_data-Tuple{InfiniteModel}","page":"Backends","title":"InfiniteOpt.transformation_data","text":"transformation_data(model::InfiniteModel)\n\nReturn the underlying data (typically mapping data) used by the  transformation backend. \n\nExample\n\njulia> mapping_data = transformation_data(model);\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_backend","page":"Backends","title":"InfiniteOpt.transformation_backend","text":"transformation_backend(\n    model::InfiniteModel\n    )::AbstractTransformationBackend\n\nRetrieve the transformation backend used by the model.\n\nExample\n\njulia> transformation_backend(model)\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none\n\n\n\n\n\n","category":"function"},{"location":"manual/backend/#InfiniteOpt.set_transformation_backend","page":"Backends","title":"InfiniteOpt.set_transformation_backend","text":"set_transformation_backend(\n    model::InfiniteModel, \n    backend::AbstractTransformationBackend\n    )::Nothing\n\nSpecify a new transformation backend backend for the model. Note that all data/settings/results associated with the previous backend  will be removed.\n\nExample\n\njulia> transformation_backend(model)\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none\n\njulia> set_transformation_backend(model, TranscriptionBackend(Ipopt.Optimizer))\n\njulia> transformation_backend(model)\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: Ipopt\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none\n\n\n\n\n\n","category":"function"},{"location":"manual/backend/#InfiniteOpt.build_transformation_backend!-Tuple{InfiniteModel}","page":"Backends","title":"InfiniteOpt.build_transformation_backend!","text":"build_transformation_backend!(model::InfiniteModel; [kwargs...])::Nothing\n\nBuild the model used by the underlying transformation backend stored in model such  that it is ready to solve. Specifically, translate the InfiniteOpt formulation  stored in model into (typically an appoximate) formulation that is compatible  with the backend. This is called automatically by optimize!; however, it this  method can be used to build the transformation backend without solving it.\n\nExample\n\njulia> build_transformation_backend!(model)\n\njulia> transformation_backend_ready(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_variable-Tuple{GeneralVariableRef}","page":"Backends","title":"InfiniteOpt.transformation_variable","text":"transformation_variable(vref::GeneralVariableRef; [kwargs...])\n\nReturns the variable(s) used by the transformation backend to represent vref.  Certain backends may also allow the use of keyward arguments. \n\nThe default backend TranscriptionOpt uses the keyword arguments:\n\nlabel::Type{<:AbstractSupportLabel} = PublicLabel\n\nBy default only variables corresponding to public supports are returned, the  full set can be accessed via label = All. Where possible, all the transcripted variables of infinite variables are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters it depends on.\n\nExample\n\njulia> transformation_variable(x) # infinite variable\n2-element Array{VariableRef,1}:\n x(0.0)\n x(1.0)\n\njulia> transformation_variable(z) # finite variable\nz\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_expression-Tuple{AbstractJuMPScalar}","page":"Backends","title":"InfiniteOpt.transformation_expression","text":"transformation_expression(\n    expr::JuMP.AbstractJuMPScalar; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel,\n    kwargs...]\n    )\n\nReturn the reformulation expression(s) stored in the transformation backend that correspond to expr. Also errors if no such expression can be found in the transformation backend (meaning one or more of the underlying variables have not been transformed).\n\nThe keyword argument label is what TranscriptionOpt employs and kwargs denote extra ones that user extensions may employ in accordance with their implementation of transformation_expression. Errors if such an extension has not been written. \n\nBy default only the expressions associated with public supports are returned, the  full set can be accessed via label = All. Where possible, all the transformed expressions are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters it depends on. The corresponding supports are obtained via  supports using the same keyword arguments.\n\nExample\n\njulia> transformation_expression(my_expr) # finite expression\nx(0.0) - y\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_constraint-Tuple{InfOptConstraintRef}","page":"Backends","title":"InfiniteOpt.transformation_constraint","text":"transformation_constraint(\n    cref::InfOptConstraintRef; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel, \n    kwargs...]\n    )\n\nReturn the reformulation constraint(s) stored in the transformation backend that  correspond to cref. Errors if no such constraint can be found in the transformation backend.\n\nThe keyword argument label is what TranscriptionOpt employs and kwargs denote extra ones that user extensions may employ in accordance with their implementation of transformation_constraint. Errors if such an extension has not been written. \n\nBy default only the constraints associated with public supports are returned, the  full set can be accessed via label = All. Where possible, all the transformed cosntraints are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters it depends on. The corresponding supports are obtained via  supports using the same keyword arguments.\n\nExample\n\njulia> transformation_constraint(c1) # finite constraint\nc1 : x(0.0) - y <= 3.0\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.supports-Tuple{Union{MeasureRef, ParameterFunctionRef, DecisionVariableRef}}","page":"Backends","title":"InfiniteOpt.supports","text":"supports(\n    vref::DecisionVariableRef; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel, \n    kwargs...]\n    )::Vector{<:Tuple}\n\nReturn the supports associated with vref in the transformation model. Errors if InfiniteOpt.variable_supports has not been extended for the transformation backend type or if vref is not reformulated in the transformation backend.\n\nThe keyword argument label is what TranscriptionOpt employs and kwargs denote extra ones that user extensions may employ in accordance with their implementation of variable_supports. Errors if such an extension has not been written. \n\nBy default only the public supports are returned, the  full set can be accessed via label = All. Where possible, all the supports of infinite variables are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters it depends on.\n\nExample\n\njulia> supports(vref)\n2-element Array{Tuple{Float64},1}:\n (0.0,)\n (1.0,)\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.supports-Tuple{AbstractJuMPScalar}","page":"Backends","title":"InfiniteOpt.supports","text":"supports(\n    expr::JuMP.AbstractJuMPScalar; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel,\n    kwargs...]\n    )\n\nReturn the support associated with expr. Errors if expr is not associated with the constraint mappings stored in the transformation backend.\n\nThe keyword arguments label is what TranscriptionOpt employs and kwargs denote extra ones that user extensions may employ in accordance with their implementation of expression_supports. Errors if such an extension has not been written. \n\nBy default only the public supports are returned, the  full set can be accessed via label = All. Where possible, all the supports of an infinite expression are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters it depends on.\n\nExample\n\njulia> supports(cref)\n2-element Array{Tuple{Float64},1}:\n (0.0,)\n (1.0,)\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.supports-Tuple{InfOptConstraintRef}","page":"Backends","title":"InfiniteOpt.supports","text":"supports(cref::InfOptConstraintRef; \n         [label::Type{<:AbstractSupportLabel} = PublicLabel,\n         kwargs...])\n\nReturn the support associated with cref. Errors if cref is not associated with the constraint mappings stored in the transformation backend.\n\nThe keyword argument label is what TranscriptionOpt employs and kwargs denote extra ones that user extensions may employ in accordance with their implementation of constraint_supports. Errors if such an extension has not been written. \n\nBy default only the public supports are returned, the  full set can be accessed via label = All. Where possible, all the supports of the constraint are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters it depends on.\n\nExample\n\njulia> supports(cref)\n2-element Array{Tuple{Float64},1}:\n (0.0,)\n (1.0,)\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.set_optimizer-Tuple{InfiniteModel, Any}","page":"Backends","title":"JuMP.set_optimizer","text":"JuMP.set_optimizer(\n    model::InfiniteModel,\n    [optimizer_constructor;\n    add_bridges::Bool = true, \n    kwargs...]\n    )\n\nExtend JuMP.set_optimizer to set optimizer used by the underlying  transformation backend associated with model. If a backend uses  JuMP then add_bridges can be used as a keyword argument.\n\nExample\n\njulia> set_optimizer(model, HiGHS.Optimizer)\n\njulia> transformation_model(model)\nA JuMP Model\nâ”œ solver: HiGHS\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.set_silent-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.set_silent","text":"JuMP.set_silent(model::InfiniteModel)\n\nExtend JuMP.set_silent to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.set_attribute with attribute MathOptInterface.Silent().\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.unset_silent-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.unset_silent","text":"JuMP.unset_silent(model::InfiniteModel)\n\nExtend JuMP.unset_silent to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.set_attribute with attribute MathOptInterface.Silent().\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.set_time_limit_sec-Tuple{InfiniteModel, Real}","page":"Backends","title":"JuMP.set_time_limit_sec","text":"JuMP.set_time_limit_sec(model::InfiniteModel, value::Real)\n\nExtend JuMP.set_time_limit_sec to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.set_attribute with attribute MOI.TimeLimitSec().\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.unset_time_limit_sec-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.unset_time_limit_sec","text":"JuMP.unset_time_limit_sec(model::InfiniteModel)\n\nExtend JuMP.unset_time_limit_sec to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.set_attribute with attribute MathOptInterface.TimeLimitSec().\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.time_limit_sec-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.time_limit_sec","text":"JuMP.time_limit_sec(model::InfiniteModel)\n\nExtend JuMP.time_limit_sec to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.get_attribute with attribute MathOptInterface.TimeLimitSec().\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.solver_name-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.solver_name","text":"JuMP.solver_name(model::InfiniteModel)\n\nExtend JuMP.solver_name to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.get_attribute with attribute MathOptInterface.SolverName().\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.mode-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.mode","text":"JuMP.mode(model::InfiniteModel)\n\nExtend JuMP.mode to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.mode.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.compute_conflict!-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.compute_conflict!","text":"JuMP.compute_conflict!(model::InfiniteModel)\n\nExtend JuMP.compute_conflict! to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.compute_conflict!.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.copy_conflict-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.copy_conflict","text":"JuMP.copy_conflict(model::InfiniteModel)\n\nExtend JuMP.copy_conflict to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.copy_conflict.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.bridge_constraints-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.bridge_constraints","text":"JuMP.bridge_constraints(model::InfiniteModel)\n\nExtend JuMP.bridge_constraints to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.bridge_constraints.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.add_bridge-Tuple{InfiniteModel, Any}","page":"Backends","title":"JuMP.add_bridge","text":"JuMP.add_bridge(model::InfiniteModel, value)\n\nExtend JuMP.add_bridge to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.add_bridge.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.print_active_bridges-Tuple{IO, InfiniteModel, Vararg{Any}}","page":"Backends","title":"JuMP.print_active_bridges","text":"JuMP.print_active_bridges([io::IO = stdout,] model::InfiniteModel)\n\nJuMP.print_active_bridges([io::IO = stdout,] model::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar})\n\nJuMP.print_active_bridges([io::IO = stdout,] model::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar}, ::Type{<:MOI.AbstractSet})\n\nJuMP.print_active_bridges([io::IO = stdout,] model::InfiniteModel, ::Type{<:MOI.AbstractSet})\n\nExtend JuMP.print_active_bridges to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.print_active_bridges.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.print_bridge_graph-Tuple{IO, InfiniteModel}","page":"Backends","title":"JuMP.print_bridge_graph","text":"JuMP.print_bridge_graph([io::IO = stdout,] model::InfiniteModel)\n\nExtend JuMP.print_bridge_graph to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.print_bridge_graph.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.set_attribute-Tuple{InfiniteModel, Any, Any}","page":"Backends","title":"JuMP.set_attribute","text":"JuMP.set_attribute(model::InfiniteModel, attr, value)::Nothing\n\nSpecify an attribute attr to the transformation backend of  model. Typically, this corresponds to MOI.AbstractOptimizerAttributes.\n\nExample\n\njulia> set_attribute(model, MOI.TimeLimitSec(), 42.0)\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.set_attributes","page":"Backends","title":"JuMP.set_attributes","text":"JuMP.set_attributes(model::InfiniteModel, pairs::Pair...)::Nothing\n\nSpecify multiple optimizer transformation backend attributes as Pairs of the form attr => value which are used for set_attribute(model, attr, value).\n\nExample\n\njulia> set_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\n\n\n\n\n","category":"function"},{"location":"manual/backend/#JuMP.get_attribute-Tuple{InfiniteModel, Any}","page":"Backends","title":"JuMP.get_attribute","text":"JuMP.get_attribute(model::InfiniteModel, attr)\n\nRetrieve an attribute attr from the transformation backend of  model. Typically, this corresponds to MOI.AbstractOptimizerAttributes.\n\nExample\n\njulia> get_attribute(model, MOI.TimeLimitSec())\n60.0\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.backend-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.backend","text":"JuMP.backend(model::InfiniteModel)\n\nExtend JuMP.backend to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.backend.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.unsafe_backend-Tuple{InfiniteModel}","page":"Backends","title":"JuMP.unsafe_backend","text":"JuMP.unsafe_backend(model::InfiniteModel)\n\nExtend JuMP.unsafe_backend to accept InfiniteModels. This relies on the underlying transformation  backend supporting JuMP.unsafe_backend.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#Transformation-Backend-API","page":"Backends","title":"Transformation Backend API","text":"","category":"section"},{"location":"manual/backend/#InfiniteOpt.AbstractTransformationBackend","page":"Backends","title":"InfiniteOpt.AbstractTransformationBackend","text":"AbstractTransformationBackend\n\nAbstract type for transformation backends to InfiniteModels. Any user-defined  backend type should inherit this type. \n\n\n\n\n\n","category":"type"},{"location":"manual/backend/#InfiniteOpt.JuMPBackend","page":"Backends","title":"InfiniteOpt.JuMPBackend","text":"JuMPBackend{TAG <: AbstractJuMPTag, T, D} <: AbstractTransformationBackend\n\nA transformation backend type for transformation backends that use JuMP Models. This serves as the main extension point for defining new JuMP-based backends. In  which case a new AbstractJuMPTag should be made with which the  JuMPBackend is created:\n\nbackend = JuMPBackend{MyTag}(model::JuMP.GenericModel, data)\n\nwhere data stores information used by the backend (typically mapping information  to the overlying InfiniteModel). \n\nThe JuMP Model can be accessed by transformation_model and the data  can be retrieved via transformation_data.\n\n\n\n\n\n","category":"type"},{"location":"manual/backend/#InfiniteOpt.AbstractJuMPTag","page":"Backends","title":"InfiniteOpt.AbstractJuMPTag","text":"AbstractJuMPTag\n\nAbstract type to enable dispatch between differnent transformation backends that  use the extension API provided by JuMPBackend. \n\n\n\n\n\n","category":"type"},{"location":"manual/backend/#InfiniteOpt.transformation_model-Tuple{AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.transformation_model","text":"transformation_model(backend::AbstractTransformationBackend)\n\nReturn the underlying model used by the backend. This serves as an  extension point for new backend types. No extension is needed for  JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_data-Tuple{AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.transformation_data","text":"transformation_data(backend::AbstractTransformationBackend)\n\nReturn the underlying data (typically mapping data) used by the backend.  This serves as an extension point for new backend types. No extension  is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.get_attribute-Tuple{AbstractTransformationBackend, Any}","page":"Backends","title":"JuMP.get_attribute","text":"JuMP.get_attribute(backend::AbstractTransformationBackend, attr)\n\nRetrieve some attribute attr from the backend. This is a general  purpose method typically used to query optimizer related information.  This serves as an extension point for new backend types. New backends should include extensions for the following attributes as appropriate:     - MOI.Silent     - MOI.TimeLimitSec     - MOI.RawOptimizerAttribute     - MOI.SolverName     - MOI.TerminationStatus     - MOI.RawStatusString     - MOI.PrimalStatus     - MOI.DualStatus     - MOI.SolveTimeSec     - MOI.ResultCount     - MOI.SimplexIterations     - MOI.BarrierIterations     - MOI.NodeCount     - MOI.ObjectiveBound     - MOI.RelativeGap     - MOI.ObjectiveValue     - MOI.DualObjectiveValue\n\nNo extension is needed for JuMPBackends. \n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.set_attribute-Tuple{AbstractTransformationBackend, Any, Any}","page":"Backends","title":"JuMP.set_attribute","text":"JuMP.set_attribute(backend::AbstractTransformationBackend, attr, value)::Nothing\n\nSpecify some attribute attr to the backend. This is a general  purpose method typically used to set optimizer related information.  This serves as an extension point for new backend types. New backends should include extensions for attributes of type:     - MOI.Silent     - MOI.TimeLimitSec     - MOI.RawOptimizerAttribute\n\nNo extension is needed for JuMPBackends. \n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#Base.empty!-Tuple{AbstractTransformationBackend}","page":"Backends","title":"Base.empty!","text":"Base.empty!(backend::AbstractTransformationBackend)\n\nEmpty backend of all its contents. For new backend types, this needs to  be defined such that empty!(model::InfiniteModel) works. For  JuMPBackends this defaults to\n\nempty!(transformation_model(backend))\nempty!(transformation_data(backend))\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.build_transformation_backend!-Tuple{InfiniteModel, AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.build_transformation_backend!","text":"build_transformation_backend!(\n    model::InfiniteModel, \n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )::Nothing\n\nGiven model, transform it into the representation used by backend.  Once completed, backend should be ready to be solved. This serves as  an extension point for new types of backends. If needed, keyword arguments can be added. Typically, this should clear out the backend before reconstructing it.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.optimize!-Tuple{AbstractTransformationBackend}","page":"Backends","title":"JuMP.optimize!","text":"JuMP.optimize!(backend::AbstractTransformationBackend)\n\nInvoke the relevant routines to solve the underlying model used by  backend. Note that build_transformation_backend! will be  called before this method is. This needs to be extended for new  backend types, but no extension is needed for JuMPBackends. Optionally, information can be returned if desired.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.set_optimizer-Tuple{AbstractTransformationBackend, Any}","page":"Backends","title":"JuMP.set_optimizer","text":"JuMP.set_optimizer(\n    backend::AbstractTransformationBackend,\n    optimizer_constructor;\n    [kwargs...]\n    )::Nothing\n\nSpecify the optimizer optimizer_constructor that should be used by backend.  This is intended as an extension point for new transformation backend types.  Keyword arguments can be added as needed. No extension is necessary for  JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.mode-Tuple{AbstractTransformationBackend}","page":"Backends","title":"JuMP.mode","text":"JuMP.mode(backend::AbstractTransformationBackend)\n\nImplement JuMP.mode for transformation backends. If applicable, this should be extended for  new backend types. No extension is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.compute_conflict!-Tuple{AbstractTransformationBackend}","page":"Backends","title":"JuMP.compute_conflict!","text":"JuMP.compute_conflict!(backend::AbstractTransformationBackend)\n\nImplement JuMP.compute_conflict! for transformation backends. If applicable, this should be extended for  new backend types. No extension is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.copy_conflict-Tuple{AbstractTransformationBackend}","page":"Backends","title":"JuMP.copy_conflict","text":"JuMP.copy_conflict(backend::AbstractTransformationBackend)\n\nImplement JuMP.copy_conflict for transformation backends. If applicable, this should be extended for  new backend types. No extension is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.bridge_constraints-Tuple{AbstractTransformationBackend}","page":"Backends","title":"JuMP.bridge_constraints","text":"JuMP.bridge_constraints(backend::AbstractTransformationBackend)\n\nImplement JuMP.bridge_constraints for transformation backends. If applicable, this should be extended for  new backend types. No extension is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.add_bridge-Tuple{AbstractTransformationBackend, Any}","page":"Backends","title":"JuMP.add_bridge","text":"JuMP.add_bridge(backend::AbstractTransformationBackend, value)\n\nImplement JuMP.add_bridge for transformation backends. If applicable, this should be extended for  new backend types. No extension is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.print_active_bridges-Tuple{IO, AbstractTransformationBackend, Vararg{Any}}","page":"Backends","title":"JuMP.print_active_bridges","text":"JuMP.print_active_bridges(\n    io::IO, \n    backend::AbstractTransformationBackend, \n    args...\n    )\n\nImplment JuMP.print_active_bridges for transformation backends. If applicable, this  should be extended for new backend types. No extension is needed for  JuMPBackends. Here, args can be one of the following:\n\nempty (print all the bridges)\nthe objective type (print the objective bridges)\na function type and set type from a constraint\na constraint set type\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.print_bridge_graph-Tuple{IO, AbstractTransformationBackend}","page":"Backends","title":"JuMP.print_bridge_graph","text":"JuMP.print_bridge_graph(\n    io::IO, \n    backend::AbstractTransformationBackend\n    )\n\nImplment JuMP.print_bridge_graph for transformation backends. If applicable, this  should be extended for new backend types. No extension is needed for  JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.variable_ref_type-Tuple{AbstractTransformationBackend}","page":"Backends","title":"JuMP.variable_ref_type","text":"JuMP.variable_ref_type(backend::AbstractTransformationBackend)\n\nImplement JuMP.variable_ref_type for transformation backends. If applicable, this should be extended for  new backend types. No extension is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.backend-Tuple{AbstractTransformationBackend}","page":"Backends","title":"JuMP.backend","text":"JuMP.backend(backend::AbstractTransformationBackend)\n\nImplement JuMP.backend for transformation backends. If applicable, this should be extended for  new backend types. No extension is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#JuMP.unsafe_backend-Tuple{AbstractTransformationBackend}","page":"Backends","title":"JuMP.unsafe_backend","text":"JuMP.unsafe_backend(backend::AbstractTransformationBackend)\n\nImplement JuMP.unsafe_backend for transformation backends. If applicable, this should be extended for  new backend types. No extension is needed for JuMPBackends.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_variable-Tuple{GeneralVariableRef, AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.transformation_variable","text":"transformation_variable(\n    vref::GeneralVariableRef, \n    backend::AbstractTransformationBackend; \n    [kwargs...]\n    )\n\nReturn the variable(s) that map to vref used by backend. This serves as an  extension point for new backend types. If needed, keywords arguments can be  added.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_expression-Tuple{Any, AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.transformation_expression","text":"transformation_expression(expr, backend::AbstractTransformationBackend; [kwargs...])\n\nReturn the reformulation expression(s) stored in the transformation backend that correspond to expr. This needs to be defined for extensions that implement a new  AbstractTransformationBackend. Keyword arguments can be added as needed. Note that if expr is a GeneralVariableRef this just dispatches to transformation_variable.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_constraint-Tuple{InfOptConstraintRef, AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.transformation_constraint","text":"transformation_constraint(\n    cref::InfOptConstraintRef,\n    backend::AbstractTransformationBackend; \n    [kwargs...]\n    )\n\nReturn the reformulation constraint(s) stored in the transformation backend  that correspond to cref. This needs to be defined for extensions that  implement a custom transformation backend type. Keyword arguments can be  added as needed.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.variable_supports-Tuple{Any, AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.variable_supports","text":"variable_supports(\n    vref::DecisionVariableRef,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nReturn the supports associated with the mappings of vref in backend. This dispatches off of backend which permits transformation backend extensions. This should throw an error if vref is not associated with the variable mappings stored in backend. Keyword arguments can be added as needed. Note that no extension is necessary for point or finite variables. \n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.expression_supports-Tuple{Any, AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.expression_supports","text":"expression_supports(\n    expr,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nReturn the supports associated with the mappings of expr in backend. This should throw an error if expr is not associated with the variable mappings stored in backend. Keyword arguments can be added as needed. Note that if expr is a GeneralVariableRef this just dispatches to variable_supports.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.constraint_supports-Tuple{InfOptConstraintRef, AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.constraint_supports","text":"constraint_supports(\n    cref::InfOptConstraintRef\n    backend::AbstractTransformationBackend; \n    [kwargs...]\n    )\n\nReturn the supports associated with the mappings of cref in backend. This should throw an error if cref is not associated with the variable mappings stored in backend. Keyword arguments can be added as needed.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.transformation_backend_ready","page":"Backends","title":"InfiniteOpt.transformation_backend_ready","text":"transformation_backend_ready(model::InfiniteModel)::Bool\n\nReturn Bool if the transformation backend model is up-to-date with model and  ready to be optimized.\n\nExample\n\njulia> transformation_backend_ready(model)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/backend/#InfiniteOpt.set_transformation_backend_ready","page":"Backends","title":"InfiniteOpt.set_transformation_backend_ready","text":"set_transformation_backend_ready(model::InfiniteModel, status::Bool)::Nothing\n\nSet the status of the transformation backend model to whether it is up-to-date or  not. Note is more intended as an internal function, but is useful for extensions.\n\nExample\n\njulia> set_transformation_backend_ready(model, true)\n\njulia> transformation_backend_ready(model)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/backend/#InfiniteOpt.update_parameter_value-Tuple{AbstractTransformationBackend, Any, Any}","page":"Backends","title":"InfiniteOpt.update_parameter_value","text":"update_parameter_value(\n    backend::AbstractTransformationBackend,\n    ref::Union{FiniteParameterRef, ParameterFunctionRef},\n    value\n)::Bool\n\nIf backendis built, then this method updates whatrefcorresponds to in thebackendtovalue, then it returns aBoolon whether the update was successful. This is intended as an extension point for newAbstractTransformationBackends to more efficiently handle parameter updates for resolves. This defaults tofalse, meaning that no update occurs (forcing the backend to be rebuilt). Users should use [JuMP.setparametervalue`](@ref) rather than call this method directly.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.warmstart_backend_start_values-Tuple{AbstractTransformationBackend}","page":"Backends","title":"InfiniteOpt.warmstart_backend_start_values","text":"warmstart_backend_start_values(\n    backend::AbstractTransformationBackend; \n    [kwargs...]\n)::Nothing\n\nUse the previous solution values stored in backend to warmstart the start values to be used for the next optimize! call. This serves as an extension point  for new backend types.\n\n\n\n\n\n","category":"method"},{"location":"manual/backend/#InfiniteOpt.map_value_to_start","page":"Backends","title":"InfiniteOpt.map_value_to_start","text":"map_value_to_start(\n    vref::GeneralVariableRef,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n)::Function\n\nMap the optimized values of the infinite variable vref (obtained with backend)  to a function that can be used to set the start value of vref. If Interpolations is loaded, this will default to returning an interpolation function based on the optimized values (assuming they are discretized).\n\n\n\n\n\n","category":"function"},{"location":"guide/finite_parameter/#finite_param_docs","page":"Finite Parameters","title":"Finite Parameters","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"A guide for the definition and use of finite parameters in InfiniteOpt. See  the respective technical manual for more details.","category":"page"},{"location":"guide/finite_parameter/#Overview","page":"Finite Parameters","title":"Overview","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Often a mathematical model needs to be optimized several times in accordance with a set of fixed parameter values. In such cases, it is typically preferable to modify these values in place without having to redefine the entire model. This ability is provided in InfiniteOpt via @finite_parameter which permits users to define finite parameters whose values can later be modified as needed. Furthermore, at the optimization step these parameters are replaced with their numeric values. Thus, not adding unnecessary decision variables as is typically done in JuMP models using JuMP.fix on placeholder variables.  ","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"warning: Warning\nIn some cases, using @finite_parameter can unexpectedly make  the underlying transformation backend contain nonlinear constraints/objectives. This  occurs when a quadratic expression is mutliplied by a finite parameter  (making a GenericNonlinearExpr):julia> model = InfiniteModel(); @variable(model, z); @finite_parameter(model, p == 2);\n\njulia> @objective(model, Min,  p * z^2) # becomes a nonlinear objective \np * (zÂ²)In these cases, a nonlinear solver like Ipopt should be used or the  finite parameter syntax should be avoided if a quadratic solver like  Gurobi is needed.","category":"page"},{"location":"guide/finite_parameter/#Basic-Usage","page":"Finite Parameters","title":"Basic Usage","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Once an InfiniteModel model has been defined we can add a finite parameter via @finite_parameter. For example, let's define a maximum cost parameter called max_cost with an initial value of 42:","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"julia> @finite_parameter(model, max_cost == 42)\nmax_cost","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Notice that a Julia variable called max_cost is returned that contains a GeneralVariableRef that points to the finite parameter we have just created. An array of parameters can also be defined following standard JuMP macro syntax:","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"julia> values = [2, 3.2, 1];\n\njulia> @finite_parameter(model, params[i = 1:3] == values[i])\n3-element Vector{GeneralVariableRef}:\n params[1]\n params[2]\n params[3]","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"The @finite_parameter macro emulates all typical JuMP functionality and can define anonymous parameters, use JuMP containers and more. We refer to its documentation below to learn more. Once a finite parameter is defined the corresponding GeneralVariableRef can be used in expressions, objectives, measures, and constraints just like infinite parameters.","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"The value of a finite parameter can be checked using parameter_value and can modified using set_parameter_value. For example, let's update the value of max_cost to be now be 10.2:","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"julia> parameter_value(max_cost)\n42.0\n\njulia> set_parameter_value(max_cost, 10.2)\n\njulia> parameter_value(max_cost)\n10.2","category":"page"},{"location":"manual/constraint/#constr_manual","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"manual/constraint/","page":"Constraints","title":"Constraints","text":"A technical manual for constraints in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/constraint/#Definition","page":"Constraints","title":"Definition","text":"","category":"section"},{"location":"manual/constraint/","page":"Constraints","title":"Constraints","text":"Note that constraints are defined principally with  JuMP.@constraint  which originates from JuMP.jl. Below we show build methods for  DomainRestrictedConstraints, but any JuMP.AbstractConstraint can be used.","category":"page"},{"location":"manual/constraint/#InfiniteOpt.DomainRestriction","page":"Constraints","title":"InfiniteOpt.DomainRestriction","text":"DomainRestriction{F <: Function}\n\nTag for specifiying restricted domains for constraints. These are created via\n\nDomainRestriction(restriction_func::Function, parameter_refs...)\n\nwhere restrict_func is a function that accepts a support that follows the formatting of parameter_refs and returns Bool on whether that support should be included in the domain of the constraint.\n\nExample\n\n@infinite_parameter(model, t in [0, 1])\n@infinite_parameter(model, x in [-1, 1])\n@variable(model, y, Infinite(t, x))\n\nrestrict_func(t_s, x_s) = (0 <= t_s <= 0.5) && (x_s < 0)\nrestriction = DomainRestriction(restrict_func, t, x)\n@constraint(model, y^2 >= 42, restriction)\n\n\n\n\n\n","category":"type"},{"location":"manual/constraint/#JuMP.build_constraint-Tuple{Function, Any, MathOptInterface.AbstractSet, DomainRestriction}","page":"Constraints","title":"JuMP.build_constraint","text":"JuMP.build_constraint(\n    _error::Function,\n    func,\n    set::MOI.AbstractSet,\n    restriction::DomainRestriction\n)::DomainRestrictedConstraint\n\nExtend JuMP.buid_constraint to handle including a restriction to its inherit  infinite parameter domain in addition to the traditional func in set setup.  This returns a DomainRestrictedConstraint that can then  be added via JuMP.add_constraint. Errors if the restriction is not compatible  with infinite parameter domains. \n\nExample\n\n@infinite_parameter(model, t in [0, 1])\n@infinite_parameter(model, x in [-1, 1])\n@variable(model, y, Infinite(t, x))\n\nrestrict_func(t_s, x_s) = (0 <= t_s <= 0.5) && (x_s < 0)\nrestriction = DomainRestriction(restrict_func, t, x)\ncon = build_constraint(error, y + 2, MOI.LessThan(0.0), restriction);\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#InfiniteOpt.DomainRestrictedConstraint","page":"Constraints","title":"InfiniteOpt.DomainRestrictedConstraint","text":"DomainRestrictedConstraint{C <: JuMP.AbstractConstraint, \n                           F <: Function,\n                           T <: JuMP.AbstractVariableRef\n                           } <: JuMP.AbstractConstraint\n\nA DataType for creating a constraint with enforced restrictions on its domain.  For example, this may pertain to excluding a boundary condition.\n\nFields\n\nconstraint::C: The optimization constraint.\nrestrictions::ParameterFunction{F, VT}: Returns Bool whether constraint \n\nshould be added at particular point in the infinite parameter domain.\n\n\n\n\n\n","category":"type"},{"location":"manual/constraint/#JuMP.add_constraint-Tuple{InfiniteModel, AbstractConstraint, String}","page":"Constraints","title":"JuMP.add_constraint","text":"JuMP.add_constraint(\n    model::InfiniteModel,\n    c::JuMP.AbstractConstraint,\n    [name::String = \"\"]\n)::InfOptConstraintRef\n\nExtend JuMP.add_constraint to add a constraint c to an infinite model model with name name. Returns an appropriate constraint reference whose type depends on what variables are used to define the constraint. Errors if any  variables do not belong to model. This is primarily used as an internal method for the constraint macros.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @variable(model, g, Infinite(t));\n\njulia> @variable(model, x);\n\njulia> constr = build_constraint(error, g + x, MOI.EqualTo(42));\n\njulia> cref = add_constraint(model, constr, \"name\")\nname : g(t) + x = 42.0, âˆ€ t âˆˆ [0, 10]\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#InfiniteOpt.ConstraintData","page":"Constraints","title":"InfiniteOpt.ConstraintData","text":"ConstraintData{C <: JuMP.AbstractConstraint} <: AbstractDataObject\n\nA mutable DataType for storing constraints and their data.\n\nFields\n\nconstraint::C: The constraint.\ngroup_int_idxs::Vector{Int}: The group integer indices of the parameter objects that the                                constraint depends on.\nname::String: The name used for printing.\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nis_info_constraint::Bool: Is this is constraint based on variable info   (e.g., lower bound)\n\n\n\n\n\n","category":"type"},{"location":"manual/constraint/#InfiniteOpt.InfOptConstraintIndex","page":"Constraints","title":"InfiniteOpt.InfOptConstraintIndex","text":"InOptConstraintIndex <: ObjectIndex\n\nA DataType for storing the index of a constraint.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/constraint/#InfiniteOpt.InfOptConstraintRef","page":"Constraints","title":"InfiniteOpt.InfOptConstraintRef","text":"InfOptConstraintRef\n\nA DataType for constraints that are in InfiniteModels\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::InfOptConstraintIndex: Index of the constraint in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/constraint/#Queries","page":"Constraints","title":"Queries","text":"","category":"section"},{"location":"manual/constraint/#JuMP.owner_model-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::InfOptConstraintRef)::InfiniteModel\n\nExtend JuMP.owner_model to return the infinite model associated with cref.\n\nExample\n\njulia> model = owner_model(cref)\nAn InfiniteOpt Model\nMinimization problem with:\n  Finite parameters: 0\n  Infinite parameter: 1\n  Variables: 3\n  Derivatives: 0\n  Measures: 0\n  Objective function type: GenericAffExpr{Float64, GeneralVariableRef}\n  `GenericAffExpr{Float64, GeneralVariableRef}`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\n  `GenericAffExpr{Float64, GeneralVariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n  `GeneralVariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints\nNames registered in the model: c1, c2, t, y, z\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  `t` transcribed over 10 supports\n  Solver: Ipopt\n  Transformation built and up-to-date: true\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.index-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.index","text":"JuMP.index(cref::InfOptConstraintRef)::InfOptConstraintIndex\n\nExtend JuMP.index to return the index of an InfiniteOpt constraint cref.\n\nExample\n\njulia> index(cref)\nInfOptConstraintIndex(2)\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.constraint_object-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::InfOptConstraintRef)::JuMP.AbstractConstraint\n\nExtend JuMP.constraint_object to return the constraint object associated with  cref.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @variable(model, x <= 1);\n\njulia> cref = UpperBoundRef(x);\n\njulia> obj = constraint_object(cref)\nScalarConstraint{GeneralVariableRef,MathOptInterface.LessThan{Float64}}(x,\nMathOptInterface.LessThan{Float64}(1.0))\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.name-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.name","text":"JuMP.name(cref::InfOptConstraintRef)::String\n\nExtend JuMP.name to return the name of an InfiniteOpt constraint.\n\nExample\n\njulia> name(cref)\n\"constr_name\"\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.constraint_by_name-Tuple{InfiniteModel, String}","page":"Constraints","title":"JuMP.constraint_by_name","text":"JuMP.constraint_by_name(\n    model::InfiniteModel,\n    name::String\n)::Union{InfOptConstraintRef, Nothing}\n\nExtend JuMP.constraint_by_name to return the constraint reference associated with name if one exists or returns nothing. Errors if more than one constraint uses the same name.\n\nExample\n\njulia> constraint_by_name(model, \"constr_name\")\nconstr_name : x + pt = 3.0\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.list_of_constraint_types-Tuple{InfiniteModel}","page":"Constraints","title":"JuMP.list_of_constraint_types","text":"JuMP.list_of_constraint_types(model::InfiniteModel)::Vector{Tuple{DataType, DataType}}\n\nExtend JuMP.list_of_constraint_types to return a list of tuples that contain  all the used combinations of function types and set types in the model.\n\nExample\n\njulia> all_constraints(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GeneralVariableRef, MathOptInterface.LessThan{Float64})\n (GeneralVariableRef, MathOptInterface.GreaterThan{Float64})\n (GeneralVariableRef, MathOptInterface.Integer)\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.num_constraints-Tuple{InfiniteModel, Any, Any}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel, [function_type], [set_type])::Int\n\nExtend JuMP.num_constraints to return the number of constraints with a  partiuclar function type and set type.\n\nExample\n\njulia> num_constraints(model, FiniteVariableRef, MOI.LessThan)\n1\n\njulia> num_constraints(model, FiniteVariableRef)\n3\n\njulia> num_constraints(model, MOI.LessThan)\n2\n\njulia> num_constraints(model)\n4\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.all_constraints-Tuple{InfiniteModel, Any, Any}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(\n    model::InfiniteModel,\n    [function_type], \n    [set_type]\n)::Vector{InfOptConstraintRef}\n\nExtend JuMP.all_constraints to return a list of all the constraints with a  particular function type and set type.\n\nExample\n\njulia> all_constraints(model, GeneralVariableRef, MOI.LessThan)\n1-element Array{InfOptConstraintRef,1}:\n x â‰¤ 1.0\n\njulia> all_constraints(model, GeneralVariableRef)\n3-element Array{InfOptConstraintRef,1}:\n x â‰¥ 0.0\n x â‰¤ 3.0\n x integer\n\njulia> all_constraints(model, MOI.GreaterThan)\n3-element Array{InfOptConstraintRef,1}:\n x â‰¥ 0.0\n g(t) â‰¥ 0.0, âˆ€ t âˆˆ [0, 6]\n g(0.5) â‰¥ 0.0\n\njulia> all_constraints(model)\n5-element Array{InfOptConstraintRef,1}:\n x â‰¥ 0.0\n x â‰¤ 3.0\n x integer\n g(t) â‰¥ 0.0, âˆ€ t âˆˆ [0, 6]\n g(0.5) â‰¥ 0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.is_valid-Tuple{InfiniteModel, InfOptConstraintRef}","page":"Constraints","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, cref::InfOptConstraintRef)::Bool\n\nExtend JuMP.is_valid to return Bool whether an InfiniteOpt constraint  reference is valid.\n\nExample\n\njulia> is_valid(model, cref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#InfiniteOpt.parameter_refs-Tuple{InfOptConstraintRef}","page":"Constraints","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(cref::InfOptConstraintRef)::Tuple\n\nReturn the tuple of infinite parameter references that determine the infinite dependencies of cref.\n\nExample\n\njulia> parameter_refs(cref)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#InfiniteOpt.has_domain_restriction","page":"Constraints","title":"InfiniteOpt.has_domain_restriction","text":"has_domain_restriction(cref::InfOptConstraintRef)::Bool\n\nReturn a Bool indicating if cref is limited to a sub-domain as defined by a DomainRestriction object.\n\nExample\n\njulia> has_domain_restriction(cref)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/constraint/#InfiniteOpt.domain_restriction","page":"Constraints","title":"InfiniteOpt.domain_restriction","text":"domain_restriction(cref::InfOptConstraintRef)::ParameterFunction\n\nReturn the domain restriction formated as a ParameterFunction  associated with the constraintcref. Errors if it does not have a domain restriction.\n\nExample\n\njulia> domain_restriction(cref)\nrestrict_func(t)\n\n\n\n\n\n","category":"function"},{"location":"manual/constraint/#JuMP.normalized_rhs-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.normalized_rhs","text":"JuMP.normalized_rhs(cref::InfOptConstraintRef)::Float64\n\nReturn the right-hand side term of cref after JuMP has converted the constraint into its normalized form.\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.normalized_coefficient-Tuple{InfOptConstraintRef, GeneralVariableRef}","page":"Constraints","title":"JuMP.normalized_coefficient","text":"JuMP.normalized_coefficient(cref::InfOptConstraintRef,\n                            variable::GeneralVariableRef)::Float64\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form.\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#InfiniteOpt.parameter_group_int_indices-Tuple{InfOptConstraintRef}","page":"Constraints","title":"InfiniteOpt.parameter_group_int_indices","text":"parameter_group_int_indices(cref::InfOptConstraintRef)::Vector{Int}\n\nReturn the list of infinite parameter group integer indices used by cref.\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#InfiniteOpt.core_object-Tuple{InfOptConstraintRef}","page":"Constraints","title":"InfiniteOpt.core_object","text":"core_object(cref::InfOptConstraintRef)::JuMP.AbstractConstraint\n\nReturn the core underlying constraint object for cref. This is intended for the developer API. For general usage, JuMP.constraint_object should be used instead.\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#InfiniteOpt.is_variable_domain_constraint","page":"Constraints","title":"InfiniteOpt.is_variable_domain_constraint","text":"is_variable_domain_constraint(cref::InfOptConstraintRef)::Bool\n\nReturns a Bool whether cref was created based on a variable's domain. For instance, it could be the upper bound of a variable y(t) which is normally queried via UpperBoundRef. This is intended as a helper function for developers of new transformation backends which typically ignore these constraints, since they are taken care of when the variables are processed.\n\n\n\n\n\n","category":"function"},{"location":"manual/constraint/#Modification","page":"Constraints","title":"Modification","text":"","category":"section"},{"location":"manual/constraint/#JuMP.set_name-Tuple{InfOptConstraintRef, String}","page":"Constraints","title":"JuMP.set_name","text":"JuMP.set_name(cref::InfOptConstraintRef, name::String)::Nothing\n\nExtend JuMP.set_name to specify the name of a constraint cref.\n\nExample\n\njulia> set_name(cref, \"new_name\")\n\njulia> name(cref)\n\"new_name\"\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#InfiniteOpt.set_domain_restriction","page":"Constraints","title":"InfiniteOpt.set_domain_restriction","text":"set_domain_restriction(\n    cref::InfOptConstraintRef,\n    restriction:DomainRestriction\n)::Nothing\n\nSpecify a new DomainRestriction object restriction for the  constraint cref\n\nExample\n\njulia> restrict_func(t_s) = 0 <= t_s <= 0.5;\n\njulia> set_domain_restriction(cref, DomainRestrictions(restrict_func, t))\n\njulia> domain_restriction(cref)\nrestrict_func(t)\n\n\n\n\n\n","category":"function"},{"location":"manual/constraint/#InfiniteOpt.delete_domain_restriction","page":"Constraints","title":"InfiniteOpt.delete_domain_restriction","text":"delete_domain_restriction(cref::InfOptConstraintRef)::Nothing\n\nDelete the domain restriction of the constraint cref.\n\nExample\n\njulia> delete_domain_restriction(c1)\n\n\n\n\n\n","category":"function"},{"location":"manual/constraint/#JuMP.set_normalized_rhs-Tuple{InfOptConstraintRef, Real}","page":"Constraints","title":"JuMP.set_normalized_rhs","text":"JuMP.set_normalized_rhs(cref::InfOptConstraintRef, value::Real)::Nothing\n\nSet the right-hand side term of constraint to value. Note that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x â‰¤ 1.0\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x â‰¤ 4.0\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.add_to_function_constant-Tuple{InfOptConstraintRef, Real}","page":"Constraints","title":"JuMP.add_to_function_constant","text":"JuMP.add_to_function_constant(cref::InfOptConstraintRef, value::Real)::Nothing\n\nAdd value to the function constant term. Note that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1. ```\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.set_normalized_coefficient-Tuple{InfOptConstraintRef, GeneralVariableRef, Real}","page":"Constraints","title":"JuMP.set_normalized_coefficient","text":"JuMP.set_normalized_coefficient(cref::InfOptConstraintRef,\n                                variable::GeneralVariableRef,\n                                value::Real)::Nothing\n\nSet the coefficient of variable in the constraint constraint to value. Note that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\njulia> con\ncon : 5 x â‰¤ 2.0\n\njulia> set_normalized_coefficient(con, x, 4)\n\njulia> con\ncon : 4 x â‰¤ 2.0\n\n\n\n\n\n","category":"method"},{"location":"manual/constraint/#JuMP.delete-Tuple{InfiniteModel, InfOptConstraintRef}","page":"Constraints","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, cref::InfOptConstraintRef)::Nothing\n\nExtend JuMP.delete to delete an InfiniteOpt constraint and all associated  information. Errors if cref is invalid.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z â‰¥ 0.0\n g(t) + z â‰¥ 42.0, âˆ€ t âˆˆ [0, 6]\n\njulia> delete(model, cref)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z â‰¥ 0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#measure_manual","page":"Measures","title":"Measure Operators","text":"","category":"section"},{"location":"manual/measure/","page":"Measures","title":"Measures","text":"A technical manual for measures in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/measure/#Measure-Data","page":"Measures","title":"Measure Data","text":"","category":"section"},{"location":"manual/measure/#InfiniteOpt.AbstractMeasureData","page":"Measures","title":"InfiniteOpt.AbstractMeasureData","text":"AbstractMeasureData\n\nAn abstract type to define data for measures to define the behavior of Measure.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef, Vector{<:Real}, Vector{<:Real}}","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData(pref::GeneralVariableRef,\n    coefficients::Vector{<:Real},\n    supports::Vector{<:Real};\n    [label::Type{<:AbstractSupportLabel} = generate_unique_label(),\n    weight_function::Function = [`default_weight`](@ref),\n    lower_bound::Real = NaN,\n    upper_bound::Real = NaN,\n    is_expect::Bool = false]\n    )::DiscreteMeasureData\n\nReturns a 1-dimensional DiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for DiscreteMeasureData. Errors if supports are out bounds or an unequal number of supports and coefficients are given. Note that by default a unique label is generated via generate_unique_label to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.\n\nExample\n\njulia> data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2]);\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.DiscreteMeasureData-Tuple{Array{GeneralVariableRef}, Vector{<:Real}, Vector{<:Array{<:Real}}}","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData(\n    prefs::Array{GeneralVariableRef},\n    coefficients::Vector{<:Real},\n    supports::Vector{<:Array{<:Real}};\n    label::Type{<:AbstractSupportLabel} = generate_unique_label(),\n    weight_function::Function = [`default_weight`](@ref),\n    lower_bounds::Array{<:Real} = [NaN...],\n    upper_bounds::Array{<:Real} = [NaN...],\n    is_expect::Bool = false\n    )::DiscreteMeasureData\n\nReturns a DiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for parameter_refs. A description of the other arguments is provided in the documentation for DiscreteMeasureData. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or if mixed infinite parameter types are given. Note that by default a unique label is generated via generate_unique_label to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.\n\nExample\n\njulia> data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]]);\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.DiscreteMeasureData","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData{P <: Union{JuMP.AbstractVariableRef,\n                    Vector{<:JuMP.AbstractVariableRef}},\n                    N, B <: Union{Float64, Vector{Float64}},\n                    F <: Function\n                    } <: AbstractMeasureData\n\nA DataType for immutable measure abstraction data where the abstraction is of the form: measure = int_tau in T f(tau) w(tau) dtau approx sum_i = 1^N alpha_i f(tau_i) w(tau_i). The supports and coefficients are immutable (i.e., they will not change even if supports are changed for the underlying infinite parameter.) This type can be used for both 1-dimensional and multi-dimensional measures.\n\nFields\n\nparameter_refs::P: The infinite parameter(s) over which the integration occurs.                      These can be comprised of multiple independent parameters,                      but dependent parameters cannot be mixed with other types.\ncoefficients::Vector{Float64}: Coefficients alpha_i for the above                                  measure abstraction.\nsupports::Array{Float64, N}: Supports points tau_i. This is a Vector                                if only one parameter is given, otherwise it is                                a Matrix where the supports are stored column-wise.\nlabel::DataType: Label for the support points tau_i when stored in the                  infinite parameter(s), stemming from AbstractSupportLabel.\nweight_function::F: Weighting function w must map an individual                              support value to a Real scalar value.\nlower_bounds::B: Lower bound in accordance with T, this denotes the                   intended interval of the measure and should be NaN if ignored\nupper_bounds::B: Same as above but the upper bound.\nis_expect::Bool: Is this data associated with an expectation call?\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef, Function, Int64, Type{<:AbstractSupportLabel}}","page":"Measures","title":"InfiniteOpt.FunctionalDiscreteMeasureData","text":"FunctionalDiscreteMeasureData(pref::GeneralVariableRef,\n    coeff_func::Function,\n    min_num_supports::Int,\n    label::Type{<:AbstractSupportLabel};\n    [weight_function::Function = [`default_weight`](@ref),\n    lower_bound::Real = NaN,\n    upper_bound::Real = NaN,\n    is_expect::Bool = false,\n    generative_support_info::AbstractGenerativeInfo = NoGenerativeSupports()]\n    )::FunctionalDiscreteMeasureData\n\nReturns a 1-dimensional FunctionalDiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for FunctionalDiscreteMeasureData. Errors if pref is not an infinite parameter. Built-in choices for label include:\n\nAll: Use all of the supports stored in pref\nMCSample: Use Monte Carlo samples associated with pref\nWeightedSample: Use weighted Monte Carlo samples associated with pref\nUniformGrid: Use uniform grid points associated with pref.\n\nExample\n\njulia> data = FunctionalDiscreteMeasureData(pref, my_func, 20, UniformGrid);\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{Array{GeneralVariableRef}, Function, Int64, Type{<:AbstractSupportLabel}}","page":"Measures","title":"InfiniteOpt.FunctionalDiscreteMeasureData","text":"FunctionalDiscreteMeasureData(prefs::Array{GeneralVariableRef},\n    coeff_func::Function,\n    min_num_supports::Int,\n    label::Type{<:AbstractSupportLabel};\n    [weight_function::Function = [`default_weight`](@ref),\n    lower_bounds::Array{<:Real} = [NaN...],\n    upper_bounds::Array{<:Real} = [NaN...],\n    is_expect::Bool = false]\n    )::FunctionalDiscreteMeasureData\n\nReturns a multi-dimensional FunctionalDiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for an array of infinite parameters. A description of the other arguments is provided in the documentation for FunctionalDiscreteMeasureData. Errors if prefs are not infinite parameters or if the mixed parameter types are provided. Built-in choices for label include:\n\nAll: Use all of the supports stored in prefs\nMCSample: Use Monte Carlo samples associated with prefs\nWeightedSample: Use weighted Monte Carlo samples associated with prefs\nUniformGrid: Use uniform grid points associated with prefs.\n\nExample\n\njulia> data = FunctionalDiscreteMeasureData(prefs, my_func, 20, MCSample);\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.FunctionalDiscreteMeasureData","page":"Measures","title":"InfiniteOpt.FunctionalDiscreteMeasureData","text":"FunctionalDiscreteMeasureData{P <: Union{JuMP.AbstractVariableRef,\n                              Vector{<:JuMP.AbstractVariableRef}},\n                              B <: Union{Float64, Vector{Float64}},\n                              I <: AbstractGenerativeInfo,\n                              F1 <: Function,\n                              F2 <: Function\n                              } <: AbstractMeasureData\n\nA DataType for mutable measure abstraction data where the abstraction is of the form: measure = int_tau in T f(tau) w(tau) dtau approx sum_i = 1^N alpha_i f(tau_i) w(tau_i). This abstraction is equivalent to that of DiscreteMeasureData, but the difference is that the supports are not fully known at the time of measure creation. Thus, functions are stored that will be used to generate the concrete support points tau_i and their coefficients alpha_i when the measure is evaluated (expanded). These supports are identified/generated in accordance with the label with a gaurantee that at least num_supports are generated. For example, if label = MCSample and num_supports = 100 then the measure will use all of the supports stored in the parameter_refs with the label MCSample and will ensure there are at least 100 are generated. This type can be used for both 1-dimensional and multi-dimensional measures.\n\nFor 1-dimensional measures over independent infinite parameters, the  generative_supp_info specifies the info needed to make generative supports based  on those with that exist with label. Note that only 1 kind of generative  supports are allowed for each infinite parameter.\n\nFields\n\nparameter_refs::P: The infinite parameter(s) over which the integration occurs.                    These can be comprised of multiple independent parameters,                    but dependent parameters cannot be mixed with other types.\ncoeff_function::F1: Coefficient generation function making alpha_i                             for the above measure abstraction. It should take                             all the supports as input (formatted as an Array)                             and return the corresponding vector of coefficients.\nmin_num_supports::Int: Specifies the minimum number of supports tau_i                      desired in association with parameter_refs and label.\nlabel::DataType: Label for the support points tau_i which are/will be                  stored in the infinite parameter(s), stemming from AbstractSupportLabel.\ngenerative_supp_info::I: Information needed to generate supports based on other   existing ones.\nweight_function::F2: Weighting function w must map an individual                             support value to a Real scalar value.\nlower_bounds::B: Lower bounds in accordance with T, this denotes the                 intended interval of the measure and should be NaN if ignored\nupper_bounds::B: Same as above but the upper bounds.\nis_expect::Bool: Is this data associated with an expectation call?\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(\n    data::AbstractMeasureData\n    )::Union{GeneralVariableRef, Array{GeneralVariableRef}}\n\nReturn the infinite parameter reference(s) in data. This is intended as an internal function to be used with measure addition. User-defined measure data types will need to extend this function otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.support_label-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.support_label","text":"support_label(data::AbstractMeasureData)::Type{<:AbstractSupportLabel}\n\nReturn the label stored in data associated with its supports. This is intended as en internal method for measure creation and ensures any new supports are added to parameters with such a label. User-defined measure data types should extend this functionif supports are used, otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.generative_support_info-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.generative_support_info","text":"generative_support_info(data::AbstractMeasureData)::AbstractGenerativeInfo\n\nReturn the generative support creation info that corresponds to data. This is  intended as an internal method and only needs to be extended for user-defined  measure data types that use generative supports.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#JuMP.lower_bound-Tuple{AbstractMeasureData}","page":"Measures","title":"JuMP.lower_bound","text":"JuMP.lower_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}\n\nReturn the lower bound associated with data that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise NaN is returned\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#JuMP.upper_bound-Tuple{AbstractMeasureData}","page":"Measures","title":"JuMP.upper_bound","text":"JuMP.upper_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}\n\nReturn the lower bound associated with data that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise NaN is returned.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.supports-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.supports","text":"supports(data::AbstractMeasureData)::Array{Float64}\n\nReturn the supports associated with data and its infinite parameters. This is intended as en internal method for measure creation and ensures any new supports are added to parameters. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.num_supports-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.num_supports","text":"num_supports(data::AbstractMeasureData)::Int\n\nReturn the number supports associated with data and its infinite parameters. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.min_num_supports","text":"min_num_supports(data::AbstractMeasureData)::Int\n\nReturn the minimum number of supports associated with data. By fallback, this will just return num_supports(data). This is primarily intended for internal queries of FunctionalDiscreteMeasureData, but can be extended for other measure data types if needed.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.coefficient_function","text":"coefficient_function(data::AbstractMeasureData)::Function\n\nReturn the coefficient function stored in data associated with its expansion abstraction is there is such a function. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown for unsupported types.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.coefficients-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.coefficients","text":"coefficients(data::AbstractMeasureData)::Vector{<:Real}\n\nReturn the coefficients associated with data associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.weight_function-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.weight_function","text":"weight_function(data::AbstractMeasureData)::Function\n\nReturn the weight function stored in data associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.default_weight","page":"Measures","title":"InfiniteOpt.default_weight","text":"default_weight(t) = 1\n\nDefault weight function for DiscreteMeasureData and FunctionalDiscreteMeasureData. Returns 1 regardless of the input value.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#Definition","page":"Measures","title":"Definition","text":"","category":"section"},{"location":"manual/measure/#General","page":"Measures","title":"General","text":"","category":"section"},{"location":"manual/measure/#InfiniteOpt.measure","page":"Measures","title":"InfiniteOpt.measure","text":"measure(expr::JuMP.AbstractJuMPScalar,\n        data::AbstractMeasureData;\n        [name::String = \"measure\"])::GeneralVariableRef\n\nReturn a measure reference that evaluates expr using according to data. The measure data data determines how the measure is to be evaluated. Typically, the DiscreteMeasureData and the FunctionalDiscreteMeasureData constructors can be used to for data. The variable expression expr can contain InfiniteOpt variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Typically, this is called inside of JuMP.@expression, JuMP.@objective, and JuMP.@constraint in a manner similar  to sum. Note measures are not explicitly evaluated until  build_transformation_backend! is called or unless they are expanded via  expand or expand_all_measures!.\n\nExample\n\njulia> tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2]);\n\njulia> xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]]);\n\njulia> constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)\nmeasure{t}[g(t) - s + 2] + sÂ²\n\njulia> @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))\nmeasure{xs}[g(t) - 1 + measure{xs}[T(t, x)]]\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.@measure","page":"Measures","title":"InfiniteOpt.@measure","text":"@measure(expr::JuMP.AbstractJuMPScalar,\n         data::AbstractMeasureData;\n         [name::String = \"measure\"])::GeneralVariableRef\n\nAn efficient wrapper for measure, please see its doc string for more information.\n\n\n\n\n\n","category":"macro"},{"location":"manual/measure/#InfiniteOpt.build_measure","page":"Measures","title":"InfiniteOpt.build_measure","text":"build_measure(expr::JuMP.AbstractJuMPScalar,\n              data::AbstractMeasureData)::Measure\n\nBuild and return a Measure given the expression to be measured expr using measure data data. This principally serves as an internal method for measure definition. Errors if the supports associated with data violate an finite variable parameter bounds of finite variables that are included in the measure.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.Measure","page":"Measures","title":"InfiniteOpt.Measure","text":"Measure{T <: JuMP.AbstractJuMPScalar, V <: AbstractMeasureData}\n\nA DataType for measure abstractions. The abstraction is determined by data and is enacted on func when the measure is evaluated (expended).\n\nFields\n\nfunc::T The InfiniteOpt expression to be measured.\ndata::V Data of the abstraction as described in a AbstractMeasureData           concrete subtype.\ngroup_int_idxs::Vector{Int}: The parameter group integer indices of the evaluated                             measure expression (i.e., the group integer indices of                             func excluding those that belong to data).\nconstant_func::Bool: Indicates if func is not parameterized by the infinite                        parameters in data. (i.e., do the group integer indices of                        func and data have no intersection?) This is useful                        to enable analytic evaluations if possible.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.add_measure","page":"Measures","title":"InfiniteOpt.add_measure","text":"add_measure(model::InfiniteModel, meas::Measure,\n            name::String = \"measure\")::GeneralVariableRef\n\nAdd a measure to model and return the corresponding measure reference. This operates in a manner similar to JuMP.add_variable. Note this intended as an internal method.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.add_supports_to_parameters","text":"add_supports_to_parameters(data::AbstractMeasureData)::Nothing\n\nAdd supports as appropriate with data to the underlying infinite parameters. This is an internal method with by add_measure and should be defined for user-defined measure data types.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.MeasureIndex","page":"Measures","title":"InfiniteOpt.MeasureIndex","text":"MeasureIndex <: ObjectIndex\n\nA DataType for storing the index of a Measure.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureData","page":"Measures","title":"InfiniteOpt.MeasureData","text":"MeasureData{M <: Measure} <: AbstractDataObject\n\nA mutable DataType for storing Measures and their data.\n\nFields\n\nmeasure::M: The measure structure.\nname::String: The base name used for printing name(meas_expr d(par)).\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nconstraint_indices::Vector{InfOptConstraintIndex}: Indices of dependent constraints.\nderivative_indices::Vector{DerivativeIndex}: Indices of dependent derivatives.\nin_objective::Bool: Is this used in objective?\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureRef","page":"Measures","title":"InfiniteOpt.MeasureRef","text":"MeasureRef <: DispatchVariableRef\n\nA DataType for referring to measure abstractions.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::MeasureIndex: Index of the measure in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#Integrals","page":"Measures","title":"Integrals","text":"","category":"section"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}","page":"Measures","title":"InfiniteOpt.MeasureToolbox.integral","text":"integral(expr::JuMP.AbstractJuMPScalar,\n         pref::GeneralVariableRef,\n         [lower_bound::Real = lower_bound(pref),\n         upper_bound::Real = upper_bound(pref);\n         kwargs...])::GeneralVariableRef\n\nReturns a measure reference that evaluates the integral of expr with respect to infinite parameter pref from lower_bound to upper_bound. This thus considers integrals of the form: int_p in P expr(p) w(p) dp where p is an infinite parameter and w is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of AbstractMeasureData via generate_integral_data in accordance with the keyword arugment eval_method that is then used with measure. Note that it is preferred to call @integral when expr is not just a single variable reference. Errors for bad bound input.\n\nThe keyword arguments are as follows:\n\neval_method::AbstractUnivariateMethod: Used to determine the   numerical evaluation scheme. Possible choices include:\nAutomatic()\nUniTrapezoid()\nUniMCSampling()\nUniIndepMCSampling()\nQuadrature()\nGaussHermite()\nGaussLegendre()\nFEGaussLobatto()\nGaussLageurre()\nGaussLobatto()\nGaussChebyshev(order)\nGaussRadau()\nGaussJacobi(Î±, Î²)\nnum_supports: The minimum number of supports to be generated (if used by   eval_method)\nweight_func: w(p) above with parameter value inputs and scalar output\n\nSee set_uni_integral_defaults to update the default keyword argument values for all one-dimensional integral calls.\n\nExample\n\njulia> @infinite_parameter(model, x in [0, 1])\nx\n\njulia> @variable(model, f, Infinite(x))\nf(x)\n\njulia> int = integral(f, x)\nâˆ«{x âˆˆ [0, 1]}[f(x)]\n\njulia> expand(int)\n0.2 f(0.8236475079774124) + 0.2 f(0.9103565379264364) + 0.2 f(0.16456579813368521) + 0.2 f(0.17732884646626457) + 0.2 f(0.278880109331201)\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.âˆ«-Tuple{AbstractJuMPScalar, GeneralVariableRef, Real, Real}","page":"Measures","title":"InfiniteOpt.MeasureToolbox.âˆ«","text":"âˆ«(expr::JuMP.AbstractJuMPScalar,\n  pref::GeneralVariableRef,\n  [lower_bound::Real = NaN,\n  upper_bound::Real = NaN;\n  kwargs...])::GeneralVariableRef\n\nA convenient wrapper for integral. The âˆ« unicode symbol is produced  via \\int.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.uni_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.uni_integral_defaults","text":"uni_integral_defaults()::Dict{Symbol, Any}\n\nGet the default keyword argument values for defining one-dimensional integrals.\n\njulia> uni_integral_defaults()\nDict{Symbol,Any} with 1 entry:\n  :eval_method => Automatic()\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.set_uni_integral_defaults","text":"set_uni_integral_defaults(; kwargs...)::Nothing\n\nSet the default keyword argument settings for one-dimensional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling integral with a single infinite parameter.\n\nExample\n\njulia> uni_integral_defaults()\nDict{Symbol,Any} with 1 entry:\n  :eval_method => Automatic()\n\n\njulia> set_uni_integral_defaults(num_supports = 5, eval_method = Quadrature(),\n                                 new_kwarg = true)\n\njulia> uni_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :new_kwarg             => true\n  :num_supports          => 5\n  :eval_method           => Quadrature()\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.clear_uni_integral_defaults","text":"clear_uni_integral_defaults()::Nothing\n\nClears and resets the keyword argument defaults for univariate integrals to their  default state. \n\nExample\n\njulia> uni_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :new_kwarg             => true\n  :num_supports          => 5\n  :eval_method           => Quadrature()\n\njulia> clear_uni_integral_defaults()\n\njulia> uni_integral_defaults()\nDict{Symbol,Any} with 1 entry:\n  :eval_method => Automatic()\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar, Array{GeneralVariableRef}, Union{Real, Array{<:Real}}, Union{Real, Array{<:Real}}}","page":"Measures","title":"InfiniteOpt.MeasureToolbox.integral","text":"integral(expr::JuMP.AbstractJuMPScalar,\n         prefs::Array{GeneralVariableRef},\n         [lower_bounds::Union{Real, Array{<:Real}} = [lower_bound(pref)...],\n         upper_bounds::Union{Real, Array{<:Real}} = [upper_bound(pref)...];\n         kwargs...])::GeneralVariableRef\n\nReturns a measure reference that evaluates the integral of expr with respect to infinite parameters prefs from lower_bounds to upper_bounds. This thus considers integrals of the form: int_p in P expr(p) w(p) dp where p is an infinite parameter and w is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of AbstractMeasureData via generate_integral_data in accordance with the keyword arugment eval_method that is then used with measure. Note that it is preferred to call @integral when expr is not just a single variable reference. Errors when the container types and dimensions do not match or the bounds are invalid.\n\nThe keyword arguments are as follows:\n\neval_method::AbstractMultivariateMethod: Used to determine the   numerical evaluation scheme. Possible choices include:\nAutomatic()\nMultiMCSampling()\nMultiIndepMCSampling()\nnum_supports: The minimum number of supports to be generated (if used by   eval_method)\nweight_func: w(p) above with parameter value inputs and scalar output\n\nSee set_multi_integral_defaults to update the default keyword argument values for all multi-dimensional integral calls.\n\nExample\n\njulia> @infinite_parameter(model, x[1:2] in [0, 1], independent = true);\n\njulia> @variable(model, f, Infinite(x));\n\njulia> int = integral(f, x)\nâˆ«{x âˆˆ [0, 1]^2}[f(x)]\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.âˆ«-Tuple{AbstractJuMPScalar, Array{GeneralVariableRef}, Union{Real, Array{<:Real}}, Union{Real, Array{<:Real}}}","page":"Measures","title":"InfiniteOpt.MeasureToolbox.âˆ«","text":"âˆ«(expr::JuMP.AbstractJuMPScalar,\n  prefs::Array{GeneralVariableRef},\n  [lower_bounds::Union{Real, Array{<:Real}} = NaN,\n  upper_bounds::Union{Real, Array{<:Real}} = NaN;\n  kwargs...])::GeneralVariableRef\n\nA convenient wrapper for integral. The unicode symbol âˆ« is produced  via \\int.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.multi_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.multi_integral_defaults","text":"multi_integral_defaults()::Dict{Symbol, Any}\n\nGet the default keyword argument values for defining multi-dimensional integrals.\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 1 entry:\n  :eval_method => Automatic()\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.set_multi_integral_defaults","text":"set_multi_integral_defaults(; kwargs...)::Nothing\n\nSet the default keyword argument settings for multi-dimesnional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling integral with an array of infinite parameters.\n\nExample\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 1 entry:\n  :eval_method => Automatic()\n\njulia> set_multi_integral_defaults(num_supports = 5, new_kwarg = true)\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :new_kwarg             => true\n  :num_supports          => 5\n  :eval_method           => Automatic()\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.clear_multi_integral_defaults","text":"clear_multi_integral_defaults()::Nothing\n\nClears and resets the keyword argument defaults for multivariate integrals to their  default state. \n\nExample\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :new_kwarg             => true\n  :num_supports          => 5\n  :eval_method           => Automatic()\n\njulia> clear_multi_integral_defaults()\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 1 entry:\n  :eval_method => Automatic()\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.@integral","page":"Measures","title":"InfiniteOpt.MeasureToolbox.@integral","text":"@integral(expr::JuMP.AbstractJuMPScalar,\n          prefs::Union{GeneralVariableRef, Array{GeneralVariableRef}},\n          [lower_bounds::Union{Real, Array{<:Real}} = default_bounds,\n          upper_bounds::Union{Real, Array{<:Real}} = default_bounds;\n          kwargs...])::GeneralVariableRef\n\nAn efficient wrapper for integral and integral. Please see the above doc strings for more information.\n\n\n\n\n\n","category":"macro"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.@âˆ«","page":"Measures","title":"InfiniteOpt.MeasureToolbox.@âˆ«","text":"@âˆ«(expr::JuMP.AbstractJuMPScalar,\n   prefs::Union{GeneralVariableRef, Array{GeneralVariableRef}},\n   [lower_bounds::Union{Real, Array{<:Real}} = default_bounds,\n   upper_bounds::Union{Real, Array{<:Real}} = default_bounds;\n   kwargs...])::GeneralVariableRef\n\nA convenient wrapper for @integral. The unicode symbol âˆ« is produced  via \\int.\n\n\n\n\n\n","category":"macro"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.AbstractIntegralMethod","page":"Measures","title":"InfiniteOpt.MeasureToolbox.AbstractIntegralMethod","text":"AbstractIntegralMethod\n\nAn abstract type for integral evaluation methods use in combination with integral and generate_integral_data.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.Automatic","page":"Measures","title":"InfiniteOpt.MeasureToolbox.Automatic","text":"Automatic <: AbstractIntegralMethod\n\nAn integral evaluation type for automically selecting an appropriate integral evaluation method. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod","page":"Measures","title":"InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod","text":"AbstractUnivariateMethod <: AbstractIntegralMethod\n\nAn abstract type for integral evaluation methods for 1-dimensional integrals.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.UniTrapezoid","page":"Measures","title":"InfiniteOpt.MeasureToolbox.UniTrapezoid","text":"UniTrapezoid <: AbstractUnivariateMethod\n\nAn integral evalution method that uses the trapezoid rule to in combination with all parameter supports available when the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this method will ignore the num_supports keyword argument. The upper and lower bounds of the integral  will automatically be added as supports. Note this is valid only for finite integral domains. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.UniMCSampling","page":"Measures","title":"InfiniteOpt.MeasureToolbox.UniMCSampling","text":"UniMCSampling <: AbstractUnivariateMethod\n\nAn integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy num_supports and it will include all supports with the MCSample label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.UniIndepMCSampling","page":"Measures","title":"InfiniteOpt.MeasureToolbox.UniIndepMCSampling","text":"UniIndepMCSampling <: AbstractUnivariateMethod\n\nAn integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to UniMCSampling. However, this variant will generate its own set of supports and ignore all other supports with the MCSample label. Note this is valid only for finite integral domains. This is not compatible with individual dependent parameters. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.Quadrature","page":"Measures","title":"InfiniteOpt.MeasureToolbox.Quadrature","text":"Quadrature <: AbstractUnivariateMethod\n\nA general integral evaluation method that will automatically select the appropriate quadrature method to approximate the integral. Please note that this will generate a unique set of parameter supports and will ignore existing supports when the integral is evaluated and thus should be used with caution. However, this method is able to handle infinite and semi-infinite integral domains. This is not compatible with individual dependent parameters. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.GaussHermite","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussHermite","text":"GaussHermite <: AbstractUnivariateMethod\n\nAn integral evaulation method that uses Gauss-Hermite quadrature to evaluate integrals. This is valid for infinite integral domains.  It will take this form:\n\nint_-^ f(x) e^-x^2 approx sum_i=1^n alpha_i f(x_i)\n\nUsing the weight function: w(x) = e^-x^2\n\nNote this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.GaussLegendre","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussLegendre","text":"GaussLegendre <: FiniteGaussQuad\n\nAn integral evaulation method that uses Gauss-Legendre quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.GaussRadau","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussRadau","text":"GaussRadau <: FiniteGaussQuad\n\nAn integral evaulation method that uses Gauss-Radau quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.GaussLobatto","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussLobatto","text":"GaussLobatto <: FiniteGaussQuad\n\nAn integral evaulation method that uses Gauss-Lobatto quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.GaussJacobi","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussJacobi","text":"GaussJacobi <: FiniteGaussQuad\n\nAn integral evaulation method that uses Gauss-Jacobi quadrature to evaluate integrals. It will take this form:\n\nint_-1^1 f(x) (1-x)^alpha (1+x)^beta dx approx sum_i=1^n alpha_i f(x_i)\n\nWhere, \n\n(1-x)^alpha (1+x)^beta \n\nis the weight function. This is valid for finite integral domains. This requires the user to input the alpha and beta shape parameters for their function. This will then generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters. If Î± or Î² is < -1, an error will be returned.  \n\nFields\n\nÎ±::Float64: Shape parameter that must be > -1\nÎ²::Float64: Shape parameter that must be > -1\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.FEGaussLobatto","page":"Measures","title":"InfiniteOpt.MeasureToolbox.FEGaussLobatto","text":"FEGaussLobatto <: AbstractUnivariateMethod\n\nIntegral evaluation method that allows for the user to specify supports to be included in quadrature evaluation. The upper and lower bounds of the integral will automatically  be added as supports. This method uses Gauss Lobatto quadrature to decompose the overall Integral into smaller integrals that span the user defined supports as follows:\n\nint_x_1^x_3 f(x) dx = int_x_1^x_2 f(x) dx + int_x_2^x_3 f(x) dx\n\nwhere the integrals are evaluated using Gauss Lobatto quadrature:\n\nint f(x) dx approx sum_i=1^n alpha_i f(x_i)\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.GaussChebyshev","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussChebyshev","text":"GaussChebyshev <: FiniteGaussQuad\n\nAn integral evaulation method that uses Gauss-Chebyshev quadrature to evaluate integrals. This is valid for finite integral domains. This requires the user to input the order of Guass-Chebyshev Quadrature they want to use.  If the order is not between 1 and 4 an error will be returned.  The integral evaluated is as follows:\n\nint_-1^1 f(x) w(x) approx sum_i=1^n alpha_i f(x_i)\n\nThe weight functions are as follows: \n\n1st order: w(x)  =  frac1sqrt1-x^2\n2nd order: w(x) = sqrt1-x^2\n3rd order: w(x) = sqrt(1+x)(1-x)\n4th order: w(x) = sqrt(1-x)(1+x)\n\nThis will then generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.\n\nFields\n\norder::Int: Specifies the order of Gauss-Chebyshev Quadrature. Must be between 1 and 4.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.GaussLaguerre","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussLaguerre","text":"GaussLaguerre <: AbstractUnivariateMethod\n\nAn integral evaulation method that uses Gauss-Laguerre quadrature to evaluate integrals. This is valid for semi-infinite integral domains. \n\nThis method evaluates the following integral:\n\nint_0^+ f(x) e^-x approx sum_i=1^n alpha_i f(x_i)\n\nUsing the weight function:\n\nw(x) = e^-x\n\nNote this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod","page":"Measures","title":"InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod","text":"AbstractMultivariateMethod <: AbstractIntegralMethod\n\nAn abstract type for integral evaluation methods for multi-dimensional integrals.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.MultiMCSampling","page":"Measures","title":"InfiniteOpt.MeasureToolbox.MultiMCSampling","text":"MultiMCSampling <: AbstractMultivariateMethod\n\nAn integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy num_supports and it will include all supports with the MCSample label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains. If an array of independent infinite parameters is specified, they must use the same amount of supports. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling","page":"Measures","title":"InfiniteOpt.MeasureToolbox.MultiIndepMCSampling","text":"MultiIndepMCSampling <: AbstractMultivariateMethod\n\nAn integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to MultiMCSampling. However, this variant will generate its own set of supports and ignore all other supports with the MCSample label. Note this is valid only for finite integral domains. Contains no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data","page":"Measures","title":"InfiniteOpt.MeasureToolbox.generate_integral_data","text":"generate_integral_data(\n    prefs::Union{InfiniteOpt.GeneralVariableRef, Vector{InfiniteOpt.GeneralVariableRef}},\n    lower_bounds::Union{Real, Vector{<:Real}},\n    upper_bounds::Union{Real, Vector{<:Real}},\n    method::V; [num_supports::Int = InfiniteOpt.DefaultNumSupports,\n    weight_func::Function = InfiniteOpt.default_weight,\n    extra_kwargs...]\n    )::InfiniteOpt.AbstractMeasureData where {V <: AbstractIntegralMethod}\n\nGenerate the appropriate concrete realization of AbstractMeasureData using method. Here prefs, lower_bounds, and upper_bounds will always have a 1 to 1 correspondence when this is called from integral. Please refer to the method docstrings for an explanation of each one.\n\nUser-defined method extensions should first define a concrete method type inheriting from AbstractUnivariateMethod or AbstractMultivariateMethod as appropriate and then implement extend this method using that type for method.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#Expectations","page":"Measures","title":"Expectations","text":"","category":"section"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.expect","page":"Measures","title":"InfiniteOpt.MeasureToolbox.expect","text":"expect(expr::JuMP.AbstractJuMPScalar,\n       prefs::Union{GeneralVariableRef, Array{GeneralVariableRef};\n       [num_supports::Int = DefaultNumSupports])::GeneralVariableRef\n\nMakes a measure for expr based on its expectation with respect to prefs. For  prefs with distribution domains this is essentially equivalent to \n\n1/total_num_supports * support_sum(expr, prefs, label = WeightedSample)\n\nThus, for these domain types it only considers supports that are added to prefs  via generation on creation (i.e., specifying the num_supports keyword when  creating prefs). For incorporating other supports consider  calling integral and using the weight_func argument to specify the  probability density function.\n\nFor a single infinite parameter defined over a bounded interval domain the syntax  becomes:\n\n    expect(expr::JuMP.AbstractJuMPScalar,\n           prefs::GeneralVariableRef;\n           [num_supports::Int = DefaultNumSupports,\n           pdf::Function = (supp) -> 1 / (ub - lb)])::GeneralVariableRef\n\nThe behavior with the default pdf is equivalent to evaluating the mean value  theorem for integrals for expr with respect to pref using  UniTrapezoid. Other density functions can be given via pdf. Errors  if the interval domain is not bounded.\n\nNote that num_supports should be 0 if a single dependent parameter is given. Also, note that it is preferred to call @expect when expr is not just a single variable reference.\n\nExample\n\njulia> @infinite_parameter(model, x ~ Normal(), num_supports = 2)\nx\n\njulia> @variable(model, f, Infinite(x))\nf(x)\n\njulia> meas = expect(f, x)\nð”¼{x}[f(x)]\n\njulia> expand(meas)\n0.5 f(0.6791074260357777) + 0.5 f(0.8284134829000359)\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.@expect","page":"Measures","title":"InfiniteOpt.MeasureToolbox.@expect","text":"@expect(expr::JuMP.AbstractJuMPScalar,\n        prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};\n        [num_supports::Int = DefaultNumSupports, \n        kwargs...]\n        )::GeneralVariableRef\n\nAn efficient wrapper for expect. Please see its doc string more information.\n\n\n\n\n\n","category":"macro"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.ð”¼","page":"Measures","title":"InfiniteOpt.MeasureToolbox.ð”¼","text":"ð”¼(expr::JuMP.AbstractJuMPScalar,\n  prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}};\n  [num_supports::Int = DefaultNumSupports, \n  kwargs...]\n  )::GeneralVariableRef)\n\nA convenient wrapper for expect. The unicode symbol ð”¼ is produced by  \\bbE.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.@ð”¼","page":"Measures","title":"InfiniteOpt.MeasureToolbox.@ð”¼","text":"@ð”¼(expr::JuMP.AbstractJuMPScalar,\n   prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};\n   [num_supports::Int = DefaultNumSupports],\n   kwargs...)::GeneralVariableRef\n\nA convenient wrapper for @expect. The unicode symbol ð”¼ is produced by  \\bbE.\n\n\n\n\n\n","category":"macro"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.generate_expect_data","page":"Measures","title":"InfiniteOpt.MeasureToolbox.generate_expect_data","text":"generate_expect_data(domain::AbstractInfiniteDomain, \n                     prefs::Union{GeneralVariableRef, Vector{GeneralVariableRef}}, \n                     num_supports::Int; \n                     [kwargs...])::AbstractMeasureData\n\nGenerate a concrete instance of AbstractMeasureData in accordance with the  domain and infinite parameter(s) prefs given for computing the expectation.  This is intended as an internal method, but should be extended for user defined  infinite domain types.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#Support-Sum","page":"Measures","title":"Support Sum","text":"","category":"section"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.@support_sum","page":"Measures","title":"InfiniteOpt.MeasureToolbox.@support_sum","text":"@support_sum(expr::JuMP.AbstractJuMPScalar,\n             prefs::Union{GeneralVariableRef, Array{GeneralVariableRef}};\n             label = All\n             )::GeneralVariableRef\n\nAn efficient wrapper for support_sum please see its doc string for more information.\n\n\n\n\n\n","category":"macro"},{"location":"manual/measure/#InfiniteOpt.MeasureToolbox.support_sum","page":"Measures","title":"InfiniteOpt.MeasureToolbox.support_sum","text":"support_sum(expr::JuMP.AbstractJuMPScalar,\n            params::Union{GeneralVariableRef, Array{GeneralVariableRef}};\n            label = All\n            )::GeneralVariableRef\n\nCreates a measure that represents the sum of the expression over a parameter(s) using all of its supports corresponding to label. Also, note that it is  preferred to call @support_sum when expr is not just a  single variable reference.\n\nExample\n\njulia> @infinite_parameter(model, x in [0, 1], supports = [0.3, 0.7])\nx\n\njulia> @variable(model, f, Infinite(x))\nf(x)\n\njulia> meas = support_sum(f, x)\nsupport_sum{x}[f(x)]\n\njulia> expand(meas)\nf(0.3) + f(0.7)\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#Queries","page":"Measures","title":"Queries","text":"","category":"section"},{"location":"manual/measure/#JuMP.name-Tuple{MeasureRef}","page":"Measures","title":"JuMP.name","text":"JuMP.name(mref::MeasureRef)::String\n\nExtend JuMP.name to return the name associated with a measure reference.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.num_measures","page":"Measures","title":"InfiniteOpt.num_measures","text":"num_measures(model::InfiniteModel)::Int\n\nReturn the number of measures defined in model.\n\nExample\n\njulia> num_measures(model)\n2\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.all_measures","page":"Measures","title":"InfiniteOpt.all_measures","text":"all_measures(model::InfiniteModel)::Vector{GeneralVariableRef}\n\nReturn the list of all measures added to model.\n\nExamples\n\njulia> all_measures(model)\n2-element Array{GeneralVariableRef,1}:\n âˆ«{t âˆˆ [0, 6]}[w(t, x)]\n ð”¼{x}[w(t, x)]\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.measure_function","page":"Measures","title":"InfiniteOpt.measure_function","text":"measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar\n\nReturn the function associated with mref.\n\nExample\n\njulia> measure_function(meas)\ny(x, t) + 2\n\n\n\n\n\nmeasure_function(mref::GeneralVariableRef)\n\nDefine measure_function for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.measure_data","page":"Measures","title":"InfiniteOpt.measure_data","text":"measure_data(mref::MeasureRef)::AbstractMeasureData\n\nReturn the measure data associated with mref.\n\nExample\n\njulia> data = measure_data(meas);\n\njulia> typeof(data)\nFunctionalDiscreteMeasureData{Vector{GeneralVariableRef},Vector{Float64}}\n\n\n\n\n\nmeasure_data(mref::GeneralVariableRef)\n\nDefine measure_data for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.is_analytic","page":"Measures","title":"InfiniteOpt.is_analytic","text":"is_analytic(mref::MeasureRef)::Bool\n\nReturn if mref is evaluated analytically.\n\nExample\n\njulia> is_analytic(meas)\nfalse\n\n\n\n\n\nis_analytic(mref::GeneralVariableRef)\n\nDefine is_analytic for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.parameter_refs-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(mref::MeasureRef)::Tuple\n\nReturn the tuple of infinite parameters that the measured expression associated mref depends on once the measure has been evaluated. Note that this will correspond to the parameter dependencies of the measure function excluding those included in the measure data.\n\nExample\n\njulia> parameter_refs(meas)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.is_used-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.is_used","text":"is_used(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used in the model.\n\nExample\n\njulia> is_used(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.used_by_derivative-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_derivative","text":"used_by_derivative(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a derivative.\n\nExample\n\njulia> used_by_derivative(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(mref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.used_by_measure-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a measure.\n\nExample\n\njulia> used_by_measure(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.used_by_objective-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by the objective.\n\nExample\n\njulia> used_by_objective(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.core_object-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.core_object","text":"core_object(mref::MeasureRef)::Measure\n\nRetrieve the underlying core Measure object for vref.  This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.parameter_group_int_indices-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.parameter_group_int_indices","text":"parameter_group_int_indices(mref::MeasureRef)::Vector{Int}\n\nReturn the list of infinite parameter group integer indices used by mref.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#Modification","page":"Measures","title":"Modification","text":"","category":"section"},{"location":"manual/measure/#JuMP.set_name-Tuple{MeasureRef, String}","page":"Measures","title":"JuMP.set_name","text":"JuMP.set_name(mref::MeasureRef, name::String)::Nothing\n\nExtend JuMP.set_name to specify the name of a measure reference.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#JuMP.delete-Tuple{InfiniteModel, MeasureRef}","page":"Measures","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, mref::MeasureRef)::Nothing\n\nExtend JuMP.delete to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.\n\nExample\n\njulia> print(model)\nMin âˆ«{t âˆˆ [0, 6]}[g(t)] + z\nSubject to\n z â‰¥ 0.0\n âˆ«{t âˆˆ [0, 6]}[g(t)] = 0\n g(t) + z â‰¥ 42.0, âˆ€ t âˆˆ [0, 6]\n g(0.5) = 0\n\njulia> delete(model, meas)\n\njulia> print(model)\nMin z\nSubject to\n z â‰¥ 0.0\n 0 = 0\n g(t) + z â‰¥ 42.0, âˆ€ t âˆˆ [0, 6]\n g(0.5) = 0\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#Expansion","page":"Measures","title":"Expansion","text":"","category":"section"},{"location":"manual/measure/#InfiniteOpt.expand","page":"Measures","title":"InfiniteOpt.expand","text":"expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar\n\nReturn a JuMP scalar function containing the explicit expansion of the measure mref. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and semi-infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with measure to expand measures on the fly.\n\nThis is useful for extensions that employ a custom transformation backend since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending expand_measure. Optionally, analytic_expansion can also be extended which is triggered by is_analytic for such types if analytic expansion is possible in certain cases.\n\nExample\n\njulia> tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])\n\njulia> expr = expand(measure(g + z + T - h - 2, tdata))\n0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2\n\n\n\n\n\nexpand(mref::GeneralVariableRef)\n\nDefine expand for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.expand_all_measures!","page":"Measures","title":"InfiniteOpt.expand_all_measures!","text":"expand_all_measures!(model::InfiniteModel)::Nothing\n\nExpand all of the measures used in the objective and/or constraints of model. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and semi-infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression.\n\nThis is useful for extensions that employ a custom transformation backend since it can be used evaluate measures before model is translated into the new model. This method can also be extended to handle custom measure data types by extending expand_measure. Note that this method leverages expand_measure via expand_measures. Optionally, analytic_expansion can also be extended which is triggered by is_analytic for such types if analytic expansion is possible in certain cases.\n\nExample\n\njulia> print(model)\nMin integral{t âˆˆ [0, 6]}[g(t)*t] + z\nSubject to\n T(t, x) â‰¥ 0.0, âˆ€ t âˆˆ [0, 6], xi âˆˆ [-1, 1]\n z â‰¥ 0.0\n g(t) + z â‰¥ 42.0, âˆ€ t âˆˆ [0, 6]\n integral{t âˆˆ [0, 6]}[T(t, x)] â‰¥ 0.0, âˆ€ x âˆˆ [-1, 1]\n\njulia> expand_all_measures!(model)\n\njulia> print(model)\nMin 3 g(6) + z\nSubject to\n T(t, x) â‰¥ 0.0, âˆ€ t âˆˆ [0, 6], xi âˆˆ [-1, 1]\n z â‰¥ 0.0\n g(t) + z â‰¥ 42.0, âˆ€ t âˆˆ [0, 6]\n 0.5 T(0, x) + 0.5 T(6, xi) â‰¥ 0.0, âˆ€ x âˆˆ [-1, 1]\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.expand_measure","page":"Measures","title":"InfiniteOpt.expand_measure","text":"expand_measure(\n    expr, \n    data::AbstractMeasureData,\n    write_model::Union{InfiniteModel, AbstractTransformationBackend}\n    )::JuMP.AbstractJuMPScalar\n\nReturn the finite reformulation of a measure containing a variable/parameter expression expr with measure data data. Here write_model is the target model where this expanded expression will be used. Thus, any variables that need to be created will be added to write_model. The methods make_point_variable_ref and make_semi_infinite_variable_ref should be used as appropriate to create these variables. Note this is intended as an internal function, but will need to be extended for unsupported expr types and for user-defined measure data types. Principally, this is leveraged to enable the user methods expand and expand_all_measures!.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.analytic_expansion","page":"Measures","title":"InfiniteOpt.analytic_expansion","text":"analytic_expansion(\n    expr, \n    data::AbstractMeasureData,\n    write_model::Union{InfiniteModel, AbstractTransformationBackend}\n    )::JuMP.AbstractJuMPScalar\n\nAnalytically, evaluate measure in the simple case where the measure expression expr doesn't depend on data and thus expr can be treated as a constant in conjunction with an analytic result of the data. This is intended as an internal method that is used by expand and expand_measures. For unrecognized data types, expand_measure is called instead. User defined measure data type may choose to extend this method if desired. This is triggered when is_analytic(mref) = true.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.expand_measures","page":"Measures","title":"InfiniteOpt.expand_measures","text":"expand_measures(\n    expr, \n    write_model::Union{InfiniteModel, AbstractTransformationBackend}\n    )\n\nExpand all MeasureRefs in expr in-place via expand_measure and return the expanded expression. This is an internal method used by expand_all_measures! and TranscriptionOpt but can be useful for user-defined transformation backend extensions that add implement add_point_variable/add_semi_infinite_variable in combination  with expand_measure. write_model is the model that the measure variables are  added to as described in expand_measure.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.make_point_variable_ref","page":"Measures","title":"InfiniteOpt.make_point_variable_ref","text":"make_point_variable_ref(\n    write_model::Union{InfiniteModel, AbstractTransformationBackend},\n    ivref::GeneralVariableRef,\n    support::Vector{Float64}\n    )::GeneralVariableRef\n\nMake a point variable for infinite variable/derivative ivref at support, add it to the write_model, and return the GeneralVariableRef. This is an internal method for point variables produced by expanding measures via expand_measure. This is also useful for those writing extension transformation backends and wish to expand measures without modifiying the InfiniteModel. In such cases, write_model should be the transformation backend and  add_point_variable  should be extended appropriately for point variables. Errors if write_model is an transformation backend and add_point_variable is not properly extended. \n\nNote this is also accomodates infinite parameter functions, in which case the  infinite parameter function is called with the support as input. \n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.make_semi_infinite_variable_ref","page":"Measures","title":"InfiniteOpt.make_semi_infinite_variable_ref","text":"make_semi_infinite_variable_ref(\n    write_model::Union{InfiniteModel, AbstractTransformationBackend},\n    ivref::GeneralVariableRef,\n    eval_support::Vector{Float64}\n    )::GeneralVariableRef\n\nMake a semi-infinite variable for infinite variable/derivative/parameter  function ivref at eval_support (see SemiInfiniteVariable), add it to  the write_model, and return the GeneralVariableRef. This is an internal method  for semi-infinite variables  produced by expanding measures via expand_measure. This is also useful  for those writing extension transformation backends and wish to expand measures without  modifiying the InfiniteModel. In such cases, write_model should be the  transformation backend and  add_semi_infinite_variable  should be extended appropriately for semi-infinite variables. Errors if  write_model is an transformation backend and add_semi_infinite_variable is not  properly extended. Note this is only intended for transformation backends that are  currently stored in InfiniteModel.backend.\n\n\n\n\n\n","category":"function"},{"location":"manual/measure/#InfiniteOpt.add_point_variable-Tuple{AbstractTransformationBackend, Any}","page":"Measures","title":"InfiniteOpt.add_point_variable","text":"add_point_variable(\n    backend::AbstractTransformationBackend, \n    var::PointVariable\n)::GeneralVariableRef\n\nAdd a point variable var to the  tranformation backend backend and return the correct InfiniteOpt  variable reference. This is an internal method used by  make_point_variable_ref to make point variables when the write_model  is an transformation backend. This is useful for extensions that wish to expand  measures, but without changing the original InfiniteModel. An error is thrown  for unextended backend types.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.add_semi_infinite_variable-Tuple{AbstractTransformationBackend, Any}","page":"Measures","title":"InfiniteOpt.add_semi_infinite_variable","text":"add_semi_infinite_variable(\n    backend::AbstractTransformationBackend, \n    var::SemiInfiniteVariable, \n    )::GeneralVariableRef\n\nAdd a semi-infinite variable var to the transformation backend backend and return the correct InfiniteOpt variable reference. This is an internal  method used by make_semi_infinite_variable_ref to make semi-infinite  variables when the write_model is a transformation backend. This is useful for  extensions that wish to expand measures, but without changing the original  InfiniteModel. An error is thrown for new transformation backend types. Note if this is  extended, than internal_semi_infinite_variable should also be extended  in order to direct semi-infinite variables references to the underlying  SemiInfiniteVariable.\n\n\n\n\n\n","category":"method"},{"location":"manual/measure/#InfiniteOpt.internal_semi_infinite_variable","page":"Measures","title":"InfiniteOpt.internal_semi_infinite_variable","text":"internal_semi_infinite_variable(\n    vref::SemiInfiniteVariableRef,\n    backend::AbstractTransformationBackend\n    )::SemiInfiniteVariable\n\nReturn the semi-infinite variable object of vref assuming it is an internal variable made during measure expansion within a transformation backend. This will apply to transformation backend extensions that utilize add_measure_variable in combination with expand_measure.\n\n\n\n\n\n","category":"function"},{"location":"guide/objective/#obj_docs","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"A guide specifying and modifying objective functions in InfiniteOpt. See the  respective technical manual for more details.","category":"page"},{"location":"guide/objective/#Overview","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Naturally, objective functions serve as a key aspect of optimization problems in  general and this is certainly the case with infinite dimensional ones. In  InfiniteOpt objectives are defined in much the same way they are in JuMP.  One key idea is that the objective must evaluate to a finite expression which means  it must only explicitly contain finite variables and point variables. Infinite  expressions must be summarized by a measure (e.g., taking the expectation of a random variable).","category":"page"},{"location":"guide/objective/#obj_basic","page":"Objectives","title":"Basic Usage","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Principally, the objective function is specified via  @objective  as is done in JuMP. For example, let's define the stochastic objective to  minimize 05 x_1 + 05 x_2 + mathbbE_xi y^2 - y:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> @infinite_parameter(model, Î¾ ~ Normal())\nÎ¾\n\njulia> @variable(model, y, Infinite(Î¾))\ny(Î¾)\n\njulia> @variable(model, x[1:2])\n2-element Vector{GeneralVariableRef}:\n x[1]\n x[2]\n\njulia> @objective(model, Min, 0.5x[1] + 0.5x[2] + ð”¼(y^2 - y, Î¾))\n0.5 x[1] + 0.5 x[2] + ð”¼{Î¾}[y(Î¾)Â² - y(Î¾)]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Note that the second argument indicates the objective sense which can be  expressed Min for minimization problems and Max for maximization problems.  The objective function (expression) must be finite containing only finite variables,  point variables, and/or measures. Also, any included measures must fully summarize  all infinite parameters contained in the expression they summarize.  For example, if we define an infinite variable z(Î¾, t), then the measure  ð”¼(z, Î¾) could not be included since the resulting expression would still  be infinite with respect to t. However, adding a measure for t would result  in a valid object to add to an objective: âˆ«(ð”¼(z, Î¾), t).","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"note: Note\nNonlinear objectives are defined simply by using @objective and not  using JuMP.@NLobjective. See Nonlinear Expressions for  more information. ","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Now we can add objectives to our infinite models. For more detailed information,  please review the information below.  ","category":"page"},{"location":"guide/objective/#Queries","page":"Objectives","title":"Queries","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"This section will highlight the available methods for extracting objective  information. These are all derived from extensions to JuMP functions and thus  follow syntax.","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Principally, these methods correspond to  objective_sense,  objective_function, and  objective_function_type  which return the objective sense (a subtype of MOI.OptimizationSense), the  objective function (expression), and the objective function type, respectively.  These methods are demonstrated in accordance with the example presented above in  the Basic Usage section:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\njulia> objective_function(model)\n0.5 x[1] + 0.5 x[2] + ð”¼{Î¾}[y(Î¾)Â² - y(Î¾)]\n\njulia> objective_function_type(model)\nGenericAffExpr{Float64, GeneralVariableRef}","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"The objective sense can be one of three possibilities: MIN_SENSE, MAX_SENSE,  or FEASIBILITY_SENSE. The later sense applies to models that contain no  objective function.","category":"page"},{"location":"guide/objective/#Modification","page":"Objectives","title":"Modification","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"This section will review the methods that can be used to modify the objective.  First, we'll consider the useful  set_objective_coefficient  method, and then we'll explain the methods that enable @objective.","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"The coefficient of a particular variable in an objective can be readily updated  via set_objective_coefficient.  This is useful repeatedly optimizing an infinite model with varied objective  coefficients (e.g., varied tradeoff parameters). For example, let's consider  updating the coefficient of x[1] in the previous example from 0.5 to 0.25:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> set_objective_coefficient(model, x[1], 0.25)\n\njulia> objective_function(model)\n0.25 x[1] + 0.5 x[2] + ð”¼{Î¾}[y(Î¾)Â² - y(Î¾)]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Now let's consider the modification methods that enable the @objective macro.  The objective function is specified via  set_objective_function  which simply updates the expression stored in the objective. For example,  let's update out objective to simply be 05x_1 + 05x_2:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> set_objective_function(model, 0.5x[1] + 0.5x[2])\n\njulia> objective_function(model)\n0.5 x[1] + 0.5 x[2]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"The objective sense is updated via  set_objective_sense  which can specify the sense as one of the MOI.OptimizationSense subtypes. For  example, let's change the current objective to be maximization problem:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> set_objective_sense(model, MOI.MAX_SENSE)\n\njulia> objective_sense(model)\nMAX_SENSE::OptimizationSense = 1","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"The above 2 methods are both called via  set_objective.  This is the function that enables @objective behind the scenes. Thus, the  previous 2 examples could have been implemented equivalently in the following  ways:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> set_objective(model, MOI.MAX_SENSE, 0.5x[1] + 0.5x[2])\n\njulia> @objective(model, Max, 0.5x[1] + 0.5x[2])\n0.5 x[1] + 0.5 x[2]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Notice that @objective offers a more intuitive syntax and is also  more efficient at parsing expressions.","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"note: Note\nWhen possible, the  @objective  since it is more stable and efficient than the set_objective_[aspect]  methods due to its enhanced methodology for parsing expressions.","category":"page"},{"location":"guide/result/#result_docs","page":"Results","title":"Results","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"A guide for querying optimized InfiniteOpt models. See the respective  technical manual for more details.","category":"page"},{"location":"guide/result/#Overview","page":"Results","title":"Overview","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"So far we have covered defining, transforming, and optimizing InfiniteModels.  Now comes the point to extract information from our optimized model. This is done  following extended versions of JuMPs querying functions in combination with  the mapping information stored in the transformation backend. Thus, this page will  walk through the use of these result query functions.","category":"page"},{"location":"guide/result/#Basic-Usage","page":"Results","title":"Basic Usage","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Let's revisit the example from the optimization page to get us started:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> using InfiniteOpt, Ipopt;\n\njulia> model = InfiniteModel(Ipopt.Optimizer);\n\njulia> set_attribute(model, \"print_level\", 0);\n\njulia> @infinite_parameter(model, t in [0, 10], num_supports = 10);\n\njulia> @variable(model, y >= 0, Infinite(t));\n\njulia> @variable(model, z >= 0);\n\njulia> @objective(model, Min, 2z);\n\njulia> @constraint(model, c1, z >= y);\n\njulia> @constraint(model, c2, y(0) == 42);\n\njulia> print(model)\nMin 2 z\nSubject to\n y(t) â‰¥ 0, âˆ€ t âˆˆ [0, 10]\n z â‰¥ 0\n c1 : z - y(t) â‰¥ 0, âˆ€ t âˆˆ [0, 10]\n c2 : y(0) = 42\n\njulia> optimize!(model)\n","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Now that the model has been optimized, let's find out what happened. To determine  why the optimizer stopped, we can use  termination_status to report the corresponding MathOptInterface  termination code (possible codes are explained  here.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Here we see that our model was locally solved via Ipopt and that is why it  stopped. Furthermore, we can query the primal and dual problem optimalities via  primal_status and  dual_status, respectively.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1\n\njulia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"The possible statuses are detailed here.  These results are useful in knowing if information can be drawn from the primal  and/or dual and what it means. We can also verify that we indeed have answers  via has_values which indicates if our model has optimized variable  values.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> has_values(model)\ntrue","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"And indeed we do have values.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Now we can query the objective value via objective_value which reports the optimal objective value.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> objective_value(model)\n83.99999998250514","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Great now we can inquire about variable values via  value. First, let's retrieve the value of z:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> value(z)\n41.99999999125257","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We get a single value since z is a FiniteVariable and therefore finite. Now  let's retrieve the \"value\" of y(t) which is infinite with respect to t:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> value(y)\n10-element Vector{Float64}:\n 42.0\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Notice here we obtain an array of values since these correspond to the  transcribed finite (discretized) variables used to solve the problem. We obtain  the corresponding support (discretized t) values via supports:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> supports(y)\n10-element Vector{Tuple}:\n (0.0,)\n (1.11111111111,)\n (2.22222222222,)\n (3.33333333333,)\n (4.44444444444,)\n (5.55555555556,)\n (6.66666666667,)\n (7.77777777778,)\n (8.88888888889,)\n (10.0,)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"There is 1-to-1 correspondence between these supports and the values reported  above. Note that these are stored in tuples to facilitate multiple infinite  parameter dependencies.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"note: Note\nThe values for an array of variables is obtained via the vectorized call  of value following the syntax:value.(::AbstractArray{<:GeneralVariableRef})This also holds true for many other methods in InfiniteOpt. For example,  adding the dot also vectorizes dual and set_binary.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We can query the dual of a constraint via  dual if a model has duals available as indicated by has_duals:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> has_duals(model)\ntrue\n\njulia> dual(c1)\n10-element Vector{Float64}:\n 1.9999999988666093\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"c1 is an infinite constraint, and thus we obtain the duals of its transcribed  versions. The underlying infinite parameter(s) and support values are queried  via parameter_refs and supports:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> parameter_refs(c1)\n(t,)\n\njulia> supports(c1)\n10-element Vector{Tuple}:\n (0.0,)\n (1.11111111111,)\n (2.22222222222,)\n (3.33333333333,)\n (4.44444444444,)\n (5.55555555556,)\n (6.66666666667,)\n (7.77777777778,)\n (8.88888888889,)\n (10.0,)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"These again all have a 1-to-1 correspondence.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"note: Note\nIn the case that our variables/constraints depend on multiple infinite  parameters, an n-dimensional array will typically be returned whose dimensions correspond to the supports of the infinite parameters. ","category":"page"},{"location":"guide/result/#Interpolation-Based-Continuous-Values","page":"Results","title":"Interpolation-Based Continuous Values","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"We can use interpolations to obtain continuous functions instead of discretized value arrays. See the InfiniteInterpolations guide to learn more.","category":"page"},{"location":"guide/result/#Termination-Queries","page":"Results","title":"Termination Queries","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Termination queries are those that question about how the infinite model was  solved and what its optimized state entails. Programmatically, such queries on  the InfiniteModel are simply routed to its optimizer model.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"The commonly used queries include termination_status,  primal_status, dual_status, objective_value, result_count, and solve_time. The first four are well  exemplified in the Basic Usage section above and are helpful in quickly  understanding the optimality status of a given model following the many possible  statuses reported by MathOptInterface which are documented  here.  We use result_count to determine how many solutions are recorded in the  optimizer.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> result_count(model)\n1","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"This is useful since it informs what results there are which can be specified  via the result keyword argument in many methods such as primal_status,  dual_status, objective_value, value, dual, and more.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We use solve_time to determine the time in seconds used by the optimizer until  it terminated its search.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> solve_time(model)\n0.004999876022338867","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Note that this query might not be supported with all solvers.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"The above status queries are designed to report information in a consistent  format irrespective of the chosen optimizer. However, raw_status will  provide the optimality status verbatim as reported by the optimizer. Thus,  following our example with Ipopt we obtain:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> raw_status(model)\n\"Solve_Succeeded\"","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Also, we obtain the best objective bound via objective_bound which  becomes particularly useful solutions that are suboptimal. However, this method  is not supported by all optimizers and in this case Ipopt is one such optimizer.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Finally, we get the best dual objective value via dual_objective_value  if the optimizer supplies this information which again Ipopt does not.","category":"page"},{"location":"guide/result/#Variable-Queries","page":"Results","title":"Variable Queries","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Information about the optimized variables is gathered consistently in comparison  to typical JuMP models. With InfiniteModels this is done by querying the  transformation backend and using its stored variable mappings to return the correct  information. Thus, here the queries are extended to work with the specifics of  the transformation backend to return the appropriate info.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"note: Note\nLike supports the all variable based query methods below also employ the  label::Type{AbstractSupportLabel} = PublicLabel keyword argument that by  default will return the desired information associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via label = All.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"First, we should verify that the transformed variable in fact has variable values  via has_values. In our example, we have:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> has_values(model)\ntrue","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"So we have values readily available to be extracted.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Now value can be used to query the  values as shown above in the Basic Usage section. This works by calling the  appropriate map_value defined by the transformation backend. By default, this employs the map_value fallback which uses  transformation_variable to do the mapping. Details on how to extend these  methods for user-defined transformation backends is explained on the Extensions page.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We also, support call to value that use an expression of variables as input.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Finally, the optimizer index of a variable is queried via  optimizer_index which  reports back the index of the variable as used in the MathOptInterface  backend:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> optimizer_index(z)\nMathOptInterface.VariableIndex(1)\n\njulia> optimizer_index(y)\n10-element Vector{MathOptInterface.VariableIndex}:\n MathOptInterface.VariableIndex(2)\n MathOptInterface.VariableIndex(3)\n MathOptInterface.VariableIndex(4)\n MathOptInterface.VariableIndex(5)\n MathOptInterface.VariableIndex(6)\n MathOptInterface.VariableIndex(7)\n MathOptInterface.VariableIndex(8)\n MathOptInterface.VariableIndex(9)\n MathOptInterface.VariableIndex(10)\n MathOptInterface.VariableIndex(11)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"As noted previously, an array is returned for y(t) in accordance with its  transcription variables. In similar manner to value, this is enabled by  appropriate versions of map_optimizer_index.","category":"page"},{"location":"guide/result/#Constraint-Queries","page":"Results","title":"Constraint Queries","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Like variables, a variety of information can be queried about constraints.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"note: Note\nLike supports, all the constraint query methods below also employ the  label::Type{AbstractSupportLabel} = PublicLabel keyword argument that by  default will return the desired information associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via label = All.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"First, recall that constraints are stored in the form function-in-set where  generally function contains the variables and coefficients and the set contains  the relational operator and the constant value. With this understanding, we  query the value of a constraint's function via  value:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> constraint_object(c1).func # show the function expression of c1\nz - y(t)\n\njulia> value(c1)\n10-element Vector{Float64}:\n -8.747427671096375e-9\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Again, we obtain an array of values since c1 is infinite due to its dependence  on x(t). Behind the scenes this is implemented via the appropriate extensions  of map_value.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Next the optimizer index(es) of the transcribed constraints in the  MathOptInterface backend provided via  optimizer_index.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> optimizer_index(c1)\n10-element Vector{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}:\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(5)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(6)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(7)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(8)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(9)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(10)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Here 10 indices are given in accordance with the transcription constraints.  The mapping between these and the original infinite constraints is managed via  the appropriate extensions of map_optimizer_index.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We can also query dual information from our constraints if it is available.  First, we should verify that dual information is available via  has_duals:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> has_duals(model)\ntrue","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Now we can query the duals via dual.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> dual(c1)\n10-element Vector{Float64}:\n 1.9999999988666093\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Here we obtain the optimal dual values for each transcribed version of c1. This  is enabled via the proper extensions of map_dual.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Finally, we query the shadow price of a constraint via  shadow_price. This denotes  the change in the objective value due to an infinitesimal relaxation of the  constraint. For c1 we get:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> shadow_price(c1)\n10-element Vector{Float64}:\n -1.9999999988666093\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"This is computed via interrogating the duals and the objective sense.","category":"page"},{"location":"guide/result/#LP-Sensitivity","page":"Results","title":"LP Sensitivity","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"We also conduct sensitivity analysis for linear problems using  lp_sensitivity_report. This  will generate a InfOptSensitivityReport which contains mapping to the  ranges indicating how much a constraint RHS constant or an objective  coefficient can be changed without violating the feasibility of the solution.  This is further explained in the JuMP documentation  here.  Furthermore, this analysis can only be employed for a solver that implements  MOI.ConstraintBasisStatus. In our running example up above, Ipopt.jl does not  support this A solver like Gurobi.jl does.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> report = lp_sensitivity_report(model);\n\njulia> report[c1]\n10-element Vector{Tuple{Float64, Float64}}:\n (-42.0, Inf)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n\njulia> report[z]\n(-2.0, Inf)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Note that like other query methods, an array of ranges will be provided with testing the sensitivity of an infinite constraint RHS in accordance with the discretization scheme. Also, keyword arguments (like label) can  be invoked when indexing the report:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> report[c1, label = All]\n10-element Vector{Tuple{Float64, Float64}}:\n (-42.0, Inf)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)","category":"page"},{"location":"guide/result/#Direct-Queries","page":"Results","title":"Direct Queries","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"We can directly interrogate the transformation backend to get more  information. For instance, with TranscriptionBackends we can get  the underlying JuMP.Model via transformation_model and  then call whatever JuMP query we want:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> solution_summary(transformation_model(model))\n* Solver : Ipopt\n\n* Status\n  Termination status : LOCALLY_SOLVED\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Message from the solver:\n  \"Solve_Succeeded\"\n\n* Candidate solution\n  Objective value      : 83.99999998250514\n\n* Work counters\n  Solve time (sec)   : 0.01000","category":"page"},{"location":"manual/model/#infinite_model_manual","page":"Infinite Models","title":"Infinite Models","text":"","category":"section"},{"location":"manual/model/","page":"Infinite Models","title":"Infinite Models","text":"A technical manual for infinite dimensional models. See the respective  guide for more information.","category":"page"},{"location":"manual/model/#Models","page":"Infinite Models","title":"Models","text":"","category":"section"},{"location":"manual/model/#InfiniteOpt.InfiniteModel","page":"Infinite Models","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel <: JuMP.AbstractModel\n\nA DataType for storing all of the mathematical modeling information needed to model an optmization problem with an infinite-dimensional decision space.\n\n\n\n\n\n","category":"type"},{"location":"manual/model/#InfiniteOpt.InfiniteModel-Tuple{}","page":"Infinite Models","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel([backend::AbstractTransformationBackend = TranscriptionBackend()])\n\nReturn a new infinite model that uses backend. For the default case with  TranscriptionBackend, the opimizer_constructor and other arguments can be  given directly:\n\nInfiniteModel(\n    optimizer_constructor;\n    [add_bridges::Bool = true]\n    )\n\nwhere optimizer_constructor and add_bridges are passed on to the underying  JuMP Model. \n\nA different transformation backend can be specified later on using set_transformation_backend.\n\nExample\n\njulia> using InfiniteOpt, JuMP, Ipopt;\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  Solver: none\n  Transformation built and up-to-date: false\n\njulia> model = InfiniteModel(Ipopt.Optimizer)\nAn InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information:\n  Backend type: TranscriptionBackend\n  Solver: Ipopt\n  Transformation built and up-to-date: false\n\n\n\n\n\n","category":"method"},{"location":"manual/model/#JuMP.object_dictionary-Tuple{InfiniteModel}","page":"Infinite Models","title":"JuMP.object_dictionary","text":"JuMP.object_dictionary(model::InfiniteModel)::Dict{Symbol, Any}\n\nReturn the dictionary that maps the symbol name of a macro defined object (e.g.,  a parameter, variable, or constraint) to the corresponding object. Objects are  registered to a specific symbol in the macros. For example,  @variable(model, x[1:2, 1:2]) registers the array of variables x to the symbol :x.\n\n\n\n\n\n","category":"method"},{"location":"manual/model/#InfiniteOpt.has_internal_supports","page":"Infinite Models","title":"InfiniteOpt.has_internal_supports","text":"has_internal_supports(pref::Union{IndependentParameterRef, DependentParameterRef})::Bool\n\nIndicate if pref has internal supports that will be hidden from the user by  default. \n\n\n\n\n\nhas_internal_supports(prefs; [kwargs...])\n\nDefine has_internal_supports for general variable references. It relies on has_internal_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"function"},{"location":"manual/model/#Base.empty!-Tuple{InfiniteModel}","page":"Infinite Models","title":"Base.empty!","text":"Base.empty!(model::InfiniteModel)::InfiniteModel\n\nClear out model of everything except the optimizer information and return the  cleared model. \n\n\n\n\n\n","category":"method"},{"location":"manual/model/#JuMP.set_optimize_hook-Tuple{InfiniteModel, Union{Nothing, Function}}","page":"Infinite Models","title":"JuMP.set_optimize_hook","text":"JuMP.set_optimize_hook(\n    model::InfiniteModel, \n    hook::Union{Function, Nothing}\n    )::Nothing\n\nSet the function hook as the optimize hook for model where hook should  have be of the form hook(model::InfiniteModel; hook_specfic_kwargs..., kwargs...).  The kwargs are those passed to optimize!. The hook_specifc_kwargs  are passed as additional keywords by the user when they call optimize!.\n\nNotes\n\nThe optimize hook should generally modify the model, or some external state\n\nin some way, and then call optimize!(model; ignore_optimize_hook = true) to optimize the problem, bypassing the hook.\n\nUse set_optimize_hook(model, nothing) to unset an optimize hook.\n\n\n\n\n\n","category":"method"},{"location":"manual/model/#InfiniteOpt.parameter_refs-Tuple{InfiniteModel}","page":"Infinite Models","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(model::InfiniteModel)::Tuple\n\nReturns a tuple of the infinite parameters used by model.\n\nFor developers, note that the integer index of each element is what is referred to as an infinite parameter group integer index which corresponds to parameter_group_int_indices.\n\nExample\n\njulia> parameter_refs(model)\n(t, x)\n\n\n\n\n\n","category":"method"},{"location":"manual/model/#InfiniteOpt.parameter_group_indices","page":"Infinite Models","title":"InfiniteOpt.parameter_group_indices","text":"parameter_group_indices(model::InfiniteModel)::Vector{Union{IndependentParameterIndex, DependentParametersIndex}}\n\nReturn a list the indices that correspond to the independent infinite parameter groups that have been added to model. This provides the infinite parameter indicies that correspond to the integer indices reported by parameter_group_int_indices. For instance, a group integer index of  2 corresponds to the infinite parameter index stored at  parameter_group_indices(model)[2]. This is intended for advanced users writing  new types of AbstractTransformationBackends.\n\n\n\n\n\n","category":"function"},{"location":"manual/model/#Abstract-Dependencies","page":"Infinite Models","title":"Abstract Dependencies","text":"","category":"section"},{"location":"manual/model/#InfiniteOpt.AbstractDataObject","page":"Infinite Models","title":"InfiniteOpt.AbstractDataObject","text":"AbstractDataObject\n\nAn abstract type for DataTypes that store core variable DataTypes and their model specific information (e.g., dependency mappings). These are what are stored in the InfiniteModel CleverDicts.\n\n\n\n\n\n","category":"type"},{"location":"manual/model/#InfiniteOpt.AbstractInfOptIndex","page":"Infinite Models","title":"InfiniteOpt.AbstractInfOptIndex","text":"AbstractInfOptIndex\n\nAn abstract type for all index objects used in InfiniteOpt.\n\n\n\n\n\n","category":"type"},{"location":"manual/model/#InfiniteOpt.ObjectIndex","page":"Infinite Models","title":"InfiniteOpt.ObjectIndex","text":"ObjectIndex <: AbstractInfOptIndex\n\nAn abstract type for indices of objects stored in MOI.Utilities.CleverDicts.\n\n\n\n\n\n","category":"type"},{"location":"guide/expression/#expr_docs","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"A guide for the defining and understanding the variable expressions used in InfiniteOpt. See the technical manual for more details.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"note: Note\nNonlinear modeling is now handled in InfiniteOpt via JuMP's new nonlinear interface. See Nonlinear Expressions for more information.","category":"page"},{"location":"guide/expression/#Overview","page":"Expressions","title":"Overview","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Expressions in InfiniteOpt (also called functions) refer to mathematical statements involving variables and numbers. Thus, these comprise the mathematical expressions used that are used in measures, objectives, and constraints. Programmatically, InfiniteOpt simply extends JuMP expression types and methods.","category":"page"},{"location":"guide/expression/#par_func_docs","page":"Expressions","title":"Parameter Functions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Rather than construct an explicit symbolic expression, we might want to provide a more complex function of infinite parameter(s) (e.g., nonlinear setpoint tracking). Thus, we provide parameter function objects that wrap arbitrary Julia functions that take infinite parameters as input and output  a scalar value. Mathematically, these can can be interpreted infinite variables constrained to a particular known function. These are created via @parameter_function or parameter_function and is exemplified below by defining a parameter function f(t) that uses sin(t):","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> using InfiniteOpt;\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @parameter_function(model, f == sin(t))\nf(t)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Here, we created a parameter function object, added it to model, and then created a Julia variable f that serves as a GeneralVariableRef that points to it. From here we can treat f as a normal infinite variable and use it with measures, and constraints. For example, we can do the following:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @variable(model, y, Infinite(t));\n\njulia> f(0)\nf(0)\n\njulia> meas = integral(y - f, t)\nâˆ«{t âˆˆ [0, 10]}[y(t) - f(t)]\n\njulia> @constraint(model, y - f <= 0)\ny(t) - f(t) â‰¤ 0, âˆ€ t âˆˆ [0, 10]","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"We can also define parameter functions that depend on multiple infinite parameters and even use an anonymous Julia function if desired:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @infinite_parameter(model, x[1:2] in [-1, 1]);\n\njulia> @parameter_function(model, myname == (t, x) -> t + sum(x))\nmyname(t, x)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"In many applications, we may also desire to define an array of parameter functions that each use a different realization of some parent function by varying some additional positional/keyword arguments. We readily support this behavior since parameter functions can be defined with additional known arguments:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @parameter_function(model, pfunc_alt[i = 1:3] == t -> mysin(t, as[i], b = 0))\n3-element Vector{GeneralVariableRef}:\n pfunc_alt[1](t)\n pfunc_alt[2](t)\n pfunc_alt[3](t)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"The use of parameter_function is convenient for enabling do-block syntax which  often handy. For instance, when defining a time-varied setpoint for optimal control:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> setpoint = parameter_function(t, name = \"setpoint\") do t_supp\n                    if t_supp <= 5\n                        return 2.0\n                    else\n                        return 10.2\n                    end\n                 end\nsetpoint(t)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Please consult the following links for more information about defining parameter functions: @parameter_function and parameter_function.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"We can also update the underlying function as often required for repeated solves. This is accomplished via  set_parameter_value:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> set_parameter_value(setpoint, t -> 5)\n","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Beyond this, there are a number of query and modification methods that can be employed for parameter functions and these are detailed in the technical manual.","category":"page"},{"location":"guide/expression/#Variable-Hierarchy","page":"Expressions","title":"Variable Hierarchy","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Expressions employ variable reference types inherited from JuMP.AbstractVariableRef to form expression objects. InfiniteOpt uses a hierarchy of such types to organize the complexities associated with modeling infinite dimensional programs. The figure below summarizes this hierarchy of variable reference types where the abstract types are depicted in green and the concrete types are shown blue.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"(Image: tree)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"In consistently with JuMP expression support, GeneralVariableRef exists as a variable reference type that is able to represent any of the above concrete subtypes of DispatchVariableRef. This allows the expression containers to be homogeneous in variable type which provides improved performance.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"However, the variable hierarchy is used for variable methods. To accomplish this, appropriate GeneralVariableRef dispatch methods are implemented (which are detailed in User Methods section at the bottom of this page) that utilize dispatch_variable_ref to create the appropriate concrete subtype of DispatchVariableRef and call the appropriate underlying method. These dispatch methods have been implemented for all public methods and the underlying methods are what are documented in the method manuals throughout the User Guide pages.","category":"page"},{"location":"guide/expression/#Affine-Expressions","page":"Expressions","title":"Affine Expressions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"An affine expression pertains to a mathematical function of the form:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"f_a(x) = a_1x_1 +  + a_nx_n + b","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"where x in mathbbR^n denote variables, a in mathbbR^n denote coefficients, and b in mathbbR denotes a constant value. Such expressions, are prevalent in any problem than involves linear constraints and/or objectives.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"In InfiniteOpt, affine expressions can be defined directly using Julia's arithmetic operators (i.e., +, -, *, etc.) or using @expression.  For example, let's define the expression 2y(t) + z - 3t noting that the following methods are equivalent:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @variable(model, y, Infinite(t))\ny(t)\n\njulia> @variable(model, z)\nz\n\njulia> expr = 2y + z - 3t\n2 y(t) + z - 3 t\n\njulia> expr = 2 * y + z - 3 * t\n2 y(t) + z - 3 t\n\njulia> expr = @expression(model, 2y + z - 3t)\n2 y(t) + z - 3 t\n\njulia> typeof(expr)\nGenericAffExpr{Float64, GeneralVariableRef}","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Notice that coefficients to variables can simply be put alongside variables without having to use the * operator. Also, note that all of these expressions are stored in a container referred to as a GenericAffExpr which is a JuMP object for storing affine expressions.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"note: Note\nWhere possible, it is preferable to use @expression for defining expressions as it is much more efficient than explicitly using the standard operators.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"GenericAffExpr objects contain 2 fields which are:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"constant::CoefType The constant value of the affine expression.\nterms::OrderDict{VarType, CoefType} A dictionary mapping variables to coefficients.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"For example, let's see what these fields look like in the above example:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> expr.terms\nOrderedCollections.OrderedDict{GeneralVariableRef, Float64} with 3 entries:\n  y(t) => 2.0\n  z    => 1.0\n  t    => -3.0\n\njulia> expr.constant\n0.0","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Notice that the ordered dictionary preserves the order in which the variables appear in the expression.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"More information can be found in the documentation for affine expressions in JuMP.","category":"page"},{"location":"guide/expression/#Quadratic-Expressions","page":"Expressions","title":"Quadratic Expressions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"A quadratic function pertains to a mathematical function of the form:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"f_q(x) = a_1x_1^2 + a_2 x_1 x_2 +  + a_m x_n^2 + f_a(x)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"where x in mathbbR^n are the variables, f_a(x) mathbbR^n mapsto mathbbR is an affine function, and m = n(n+1)2 is the number of unique combinations of variables x. Like affine expressions, quadratic expressions can be defined via Julia's arithmetic operators or via @expression. For example, let's define 2y^2(t) - zy(t) + 42t - 3 using the following equivalent methods:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> expr = 2y^2 - z * y + 42t - 3\n2 y(t)Â² - z*y(t) + 42 t - 3\n\njulia> expr = @expression(model, 2y^2 - z * y + 42t - 3)\n2 y(t)Â² - z*y(t) + 42 t - 3\n\njulia> typeof(expr)\nGenericQuadExpr{Float64, GeneralVariableRef}","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Again, notice that coefficients need not employ *. Also, the object used to store the expression is a GenericQuadExpr which is a JuMP object used for storing quadratic expressions.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"GenericQuadExpr object contains 2 data fields which are:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"aff::GenericAffExpr{CoefType,VarType} An affine expression\nterms::OrderedDict{UnorderedPair{VarType}, CoefType} A dictionary mapping quadratic variable pairs to coefficients.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Here the UnorderedPair type is unique to JuMP and contains the fields:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"a::AbstractVariableRef One variable in a quadratic pair\nb::AbstractVariableRef The other variable in a quadratic pair.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Thus, this form can be used to store arbitrary quadratic expressions. For example, let's look at what these fields look like in the above example:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> expr.aff\n42 t - 3\n\njulia> typeof(expr.aff)\nGenericAffExpr{Float64, GeneralVariableRef}\n\njulia> expr.terms\nOrderedCollections.OrderedDict{UnorderedPair{GeneralVariableRef}, Float64} with 2 entries:\n  UnorderedPair{GeneralVariableRef}(y(t), y(t)) => 2.0\n  UnorderedPair{GeneralVariableRef}(z, y(t))    => -1.0","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Notice again that the ordered dictionary preserves the order.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"More information can be found in the documentation for quadratic expressions in JuMP.","category":"page"},{"location":"guide/expression/#nlp_guide","page":"Expressions","title":"Nonlinear Expressions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"In this section, we walk you through the ins and out of working with general nonlinear (i.e., not affine or quadratic) expressions in InfiniteOpt.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"info: Info\nOur previous InfiniteOpt specific nonlinear API as been removed in favor of JuMP's new and improved nonlinear interface. Thus, InfiniteOpt now strictly uses the same expression structures as JuMP.","category":"page"},{"location":"guide/expression/#Basic-Usage","page":"Expressions","title":"Basic Usage","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"We can define nonlinear expressions in similar manner to how affine/quadratic expressions are made in JuMP. For instance, we can make an expression using normal Julia code outside a macro:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @infinite_parameter(model, t âˆˆ [0, 1]); @variable(model, y, Infinite(t));\n\njulia> expr = exp(y^2.3) * y - 42\n(exp(y(t) ^ 2.3) * y(t)) - 42.0\n\njulia> typeof(expr)\nGenericNonlinearExpr{GeneralVariableRef}","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Thus, the nonlinear expression expr of type GenericNonlinearExpr is created and can be readily incorporated into other expressions, the objective, and/or constraints. For macro-based definition, we simply use the @expression, @objective, and @constraint macros as normal:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @expression(model, expr, exp(y^2.3) * y - 42)\n(exp(y(t) ^ 2.3) * y(t)) - 42.0\n\njulia> @objective(model, Min, âˆ«(0.3^cos(y^2), t))\nâˆ«{t âˆˆ [0, 1]}[0.3 ^ cos(y(t)Â²)]\n\n\njulia> @constraint(model, constr, y^y * sin(y) + sum(y^i for i in 3:4) == 3)\nconstr : (((y(t) ^ y(t)) * sin(y(t))) + (y(t) ^ 3) + (y(t) ^ 4)) - 3.0 = 0, âˆ€ t âˆˆ [0, 1]","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"note: Note\nThe legacy @NLexpression, @NLobjective, and @NLconstraint macros in JuMP are not supported by InfiniteOpt.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Natively, we support all the same nonlinear operators that JuMP does. See JuMP's documentation for more information.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"We can interrogate which nonlinear operators our model currently supports by invoking all_nonlinear_operators. Moreover, we can add additional operators (see Adding Nonlinear Operators for more details).","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Finally, we highlight that nonlinear expressions in InfiniteOpt support the same linear algebra operations as affine/quadratic expressions:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @variable(model, v[1:2]); @variable(model, Q[1:2, 1:2]);\n\njulia> @expression(model, v' * Q * v)\n0.0 + ((Q[1,2]*v[1] + Q[2,2]*v[2]) * v[2]) + ((Q[1,1]*v[1] + Q[2,1]*v[2]) * v[1])","category":"page"},{"location":"guide/expression/#Function-Tracing","page":"Expressions","title":"Function Tracing","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"In similar manner to Symbolics.jl, we support function tracing. This means that we can create nonlinear modeling expression using Julia functions that satisfy certain criteria. For instance:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> myfunc(x) = sin(x^3) / tan(2^x);\n\njulia> expr = myfunc(y)\nsin(y(t) ^ 3) / tan(2.0 ^ y(t))","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"However, there are certain limitations as to what internal code these functions can contain. The following CANNOT be used:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"loops (unless it only uses very simple operations)\nif-statements (see workaround below)\nunrecognized operators (if they cannot be traced).","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"tip: Tip\nIf a particular function is not amendable for tracing, try adding it as a new nonlinear operator instead. See Adding Nonlinear Operators for details.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"We can readily work around the if-statement limitation using op_ifelse which is a nonlinear operator version of Base.ifelse and follows the same syntax. For example, the function:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"function mylogicfunc(x)\n    if x >= 0\n        return x^3\n    else\n        return 0\n    end\nend","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"is not amendable for function tracing, but we can rewrite it as:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> function mylogicfunc(x)\n          return op_ifelse(op_greater_than_or_equal_to(x, 0), x^3, 0)\n       end\nmylogicfunc (generic function with 1 method)\n\njulia> mylogicfunc(y)\nifelse(y(t) >= 0, y(t) ^ 3, 0)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"which is amendable for function tracing. Note that the basic logic operators (e.g., <=) have special nonlinear operator analogues when used outside of a macro. See JuMP's documentation for more details.","category":"page"},{"location":"guide/expression/#Linear-Algebra","page":"Expressions","title":"Linear Algebra","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"As described above in the Basic Usage Section, we support basic linear algebra operations with nonlinear expressions! This relies on our basic extensions of MutableArithmetics, but admittedly this implementation is not perfect in terms of efficiency.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"tip: Tip\nUsing linear algebra operations with nonlinear expression provides user convenience, but is less efficient than using sums. Thus, sum should be used instead when efficiency is critical.julia> v' * Q * v # convenient linear algebra syntax\n(+(0.0) + ((Q[1,1]*v[1] + Q[2,1]*v[2]) * v[1])) + ((Q[1,2]*v[1] + Q[2,2]*v[2]) * v[2])\n\njulia> sum(v[i] * Q[i, j] * v[j] for i in 1:2, j in 1:2) # more efficient\n((((v[1]*Q[1,1]) * v[1]) + ((v[2]*Q[2,1]) * v[1])) + ((v[1]*Q[1,2]) * v[2])) + ((v[2]*Q[2,2]) * v[2])","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"We can also set vectorized constraints using the .==, .<=, and .>= operators:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @variable(model, W[1:2, 1:2]);\n\njulia> @constraint(model, W * Q * v .== 0)\n2-element Vector{InfOptConstraintRef}:\n ((+(0.0) + ((W[1,1]*Q[1,1] + W[1,2]*Q[2,1]) * v[1])) + ((W[1,1]*Q[1,2] + W[1,2]*Q[2,2]) * v[2])) - 0.0 = 0\n ((+(0.0) + ((W[2,1]*Q[1,1] + W[2,2]*Q[2,1]) * v[1])) + ((W[2,1]*Q[1,2] + W[2,2]*Q[2,2]) * v[2])) - 0.0 = 0","category":"page"},{"location":"guide/expression/#Adding-Nonlinear-Operators","page":"Expressions","title":"Adding Nonlinear Operators","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"In a similar spirit to JuMP and Symbolics, we can add nonlinear operators such that they can be directly incorporated into nonlinear expressions as atoms (they will not be traced). This is done via the @operator macro. We can register any operator that takes scalar arguments (which can accept inputs of type Real):","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> h(a, b) = a * b^2; # an overly simple example operator\n\njulia> @operator(model, op_h, 2, h);\n\njulia> op_h(y, 42)\nop_h(y(t), 42)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"tip: Tip\nWhere possible it is preferred to use function tracing instead. This improves performance and can prevent unintentional errors. See Function Tracing for more details.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"To highlight the difference between function tracing and operator definition consider the following example:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> f(a) = a^3;\n\njulia> f(y) # user-function gets traced\ny(t) ^ 3\n\njulia> @operator(model, op_f, 1, f) # create nonlinear operator\nNonlinearOperator(f, :op_f)\n\njulia> op_f(y) # function is no longer traced\nop_f(y(t))","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Thus, nonlinear operators are incorporated directly. This means that their gradients and hessians will need to determined as well (typically occurs behind the scenes via auto-differentiation with the selected optimizer model backend). However, again please note that in this case tracing is preferred since f can be traced.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Let's consider a more realistic example where the function is not amenable to tracing:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> function g(a)\n          v = 0\n          for i in 1:4\n              v *= v^a\n              if v >= 1\n                 return v\n              end\n          end\n          return a\n       end;\n\njulia> @operator(model, op_g, 1, g);\n\njulia> op_g(y)\nop_g(y(t))","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Notice this example is a little contrived still, highlighting that in most cases we can avoid adding operators. However, one exception to this trend, are functions from other packages that we might want to use. For example, perhaps we would like to use the eta function from SpecialFunctions.jl which is not natively supported:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> using SpecialFunctions\n\njulia> @operator(model, op_eta, 1, eta)\nNonlinearOperator(eta, :op_eta)\n\njulia> op_eta(y)\nop_eta(y(t))","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Now in some cases we might wish to specify the gradient and hessian of a univariate operator to avoid the need for auto-differentiation. We can do this, simply by adding them as additional arguments in @operator:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> my_squared(a) = a^2; gradient(a) = 2 * a; hessian(a) = 2;\n\njulia> @operator(model, op_square, 1, my_squared, gradient, hessian);\n\njulia> op_square(y)\nop_square(y(t))","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Note the specification of the hessian is optional (it can separately be computed via auto-differentiation if need be).","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"For multivariate functions, we can specify the gradient following the same gradient function structure that JuMP uses:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> w(a, b) = a * b^2;\n\njulia> function wg(v, a, b)\n          v[1] = b^2\n          v[2] = 2 * a * b\n          return\n       end;\n\njulia> @operator(model, op_w, 2, w, wg)\nNonlinearOperator(w, :op_w)\n\njulia> op_w(42, y)\nop_w(42, y(t))","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Note that the first argument of the gradient needs to accept an AbstractVector{Real} that is then filled in place.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"note: Note\nWe do not currently support vector inputs or vector valued functions directly, since typically JuMP optimizer model backends don't support them.","category":"page"},{"location":"guide/expression/#More-Details","page":"Expressions","title":"More Details","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"For more details, please consult JuMP's Documentation.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Hanging-Chain-Problem","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"We will solve a reformulated version of the Hanging Chain Problem from the Constrained Optimization Problem Set.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Problem-Statement-and-Model","page":"Hanging Chain Problem","title":"Problem Statement and Model","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"In this problem, we seek to minimize the potential energy of a chain of length L suspended between points a and b. The potential energy constrained by length is represented by:","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"begingathered\nint_0^1 x(1 + (x)^2)^12  dt\nendgathered","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"Our optimization problem is defined as follows:","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"beginaligned\nmin_xu x_2(t_f)\ntextst  quad dotx_1= u\ndotx_2 = x_1(1+u^2)^12\ndotx_3 = (1+u^2)^12\nx(t_0) = (a00)^T\nx_1(t_f) = b\nx_3(t_f) = L\nx(t) in 010\nu(t) in -1020\nendaligned","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Modeling-in-InfiniteOpt","page":"Hanging Chain Problem","title":"Modeling in InfiniteOpt","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"First we must import InfiniteOpt and other packages.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"using InfiniteOpt, Ipopt, Plots;","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"Next we specify our initial conditions and problem variables.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"a, b, L = 1, 3, 4\nx0 = [a, 0, 0]\nxtf = [b, NaN, L];","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Model-Definition","page":"Hanging Chain Problem","title":"Model Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"We initialize the infinite model with InfiniteModel and select Ipopt as our optimizer that will be used to solve it.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"m = InfiniteModel(Ipopt.Optimizer);","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Infinite-Parameter-Definition","page":"Hanging Chain Problem","title":"Infinite Parameter Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"We define the infinite parameter t as  t in 01. The bounds are arbitrary for this problem:","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"@infinite_parameter(m, t in [0,1], num_supports = 100);","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Infinite-Variable-Definition","page":"Hanging Chain Problem","title":"Infinite Variable Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"Now let's specify variables. We define x as a vector containing the state variables for position, energy and chain length. u is our control variable.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"@variable(m, 0 <= x[1:3] <= 10, Infinite(t))\n@variable(m, -10 <= u <= 20, Infinite(t));","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Objective-Definition","page":"Hanging Chain Problem","title":"Objective Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"We specify the objective using @objective to minimize potential energy at the final time:","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"@objective(m, Min, x[2](1));","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Constraint-Definition","page":"Hanging Chain Problem","title":"Constraint Definition","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"The last step is to add our constraints. First, define the ODEs which serve as our system model.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"@constraint(m, âˆ‚(x[1],t) == u)\n@constraint(m, âˆ‚(x[2],t) == x[1] * (1 + u^2)^(1/2))\n@constraint(m, âˆ‚(x[3],t) == (1 + u^2)^(1/2));","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"We also set our initial and final conditions for x.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"@constraint(m, [i in 1:3], x[i](0) == x0[i])\n@constraint(m, x[1](1) == xtf[1])\n@constraint(m, x[3](1) == xtf[3]);","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Problem-Solution","page":"Hanging Chain Problem","title":"Problem Solution","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"Now we can solve the model with optimize!:","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"optimize!(m)","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"This is Ipopt version 3.14.19, running with linear solver MUMPS 5.8.1.\n\nNumber of nonzeros in equality constraint Jacobian...:     1596\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:      400\n\nTotal number of variables............................:      700\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      400\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      602\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  9.9999900e-03 3.99e+00 1.00e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  8.6845875e-02 1.95e+01 1.61e+04  -1.0 6.57e+01    -  2.56e-03 3.02e-01f  1\n   2  1.7965356e-01 1.87e+01 2.25e+04  -1.0 5.31e+01   4.0 3.21e-02 4.23e-02h  1\n   3  1.8137048e-01 1.87e+01 2.33e+04  -1.0 4.73e+01   4.4 6.31e-02 6.68e-04h  1\n   4  1.8140295e-01 1.87e+01 1.89e+06  -1.0 4.83e+01   4.9 1.26e-01 1.22e-05h  1\n   5  1.9254888e-01 1.86e+01 2.48e+06  -1.0 4.81e+01   4.4 2.04e-01 4.17e-03h  1\n   6  2.0905429e-01 1.85e+01 3.64e+06  -1.0 4.86e+01   4.8 1.09e-01 6.07e-03h  1\n   7  2.2802793e-01 1.84e+01 3.41e+07  -1.0 4.82e+01   5.2 3.59e-01 6.93e-03h  1\n   8  2.8201307e-01 1.80e+01 3.06e+07  -1.0 4.62e+01   4.7 1.02e-01 2.02e-02h  1\n   9  3.1317553e-01 1.78e+01 3.47e+07  -1.0 4.47e+01   5.2 2.45e-01 1.13e-02h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  3.4723467e-01 1.76e+01 4.07e+07  -1.0 4.39e+01   5.6 5.62e-02 1.22e-02h  1\n  11  3.8552094e-01 1.73e+01 6.10e+07  -1.0 4.28e+01   6.0 6.34e-02 1.37e-02h  1\n  12  4.0843146e-01 1.72e+01 6.02e+07  -1.0 3.93e+01   5.6 7.08e-03 8.64e-03h  1\n  13  4.1028640e-01 1.72e+01 1.02e+08  -1.0 3.99e+01   6.0 6.60e-02 6.60e-04h  1\n  14  4.3553508e-01 1.70e+01 3.20e+08  -1.0 4.04e+01   6.4 1.31e-01 8.93e-03h  1\n  15  4.5808211e-01 1.69e+01 3.20e+08  -1.0 3.81e+01   5.9 2.79e-02 8.08e-03h  1\n  16  4.6870391e-01 1.68e+01 3.89e+08  -1.0 3.84e+01   6.4 7.68e-02 3.74e-03h  1\n  17  5.1251695e-01 1.66e+01 5.77e+08  -1.0 3.84e+01   6.8 8.31e-02 1.54e-02f  1\n  18  5.2292005e-01 1.65e+01 5.69e+08  -1.0 3.52e+01   6.3 1.53e-02 3.70e-03h  1\n  19  5.2697033e-01 1.65e+01 6.03e+08  -1.0 3.63e+01   6.7 6.98e-02 1.42e-03h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  6.1393774e-01 1.60e+01 7.16e+08  -1.0 3.66e+01   7.2 8.66e-02 3.03e-02f  1\n  21  7.3213394e-01 1.53e+01 6.54e+08  -1.0 3.40e+01   7.6 6.77e-03 4.09e-02f  1\n  22  8.0635655e-01 1.49e+01 6.80e+08  -1.0 3.09e+01   8.0 4.06e-04 2.55e-02f  1\n  23  8.5443045e-01 1.47e+01 1.27e+09  -1.0 2.92e+01   8.4 1.25e-03 1.65e-02f  1\n  24  8.5472095e-01 1.47e+01 7.25e+08  -1.0 2.70e+01   8.0 4.02e-02 9.99e-05h  1\n  25  9.4924730e-01 1.42e+01 1.17e+09  -1.0 2.79e+01   8.4 7.89e-03 3.24e-02f  1\n  26  9.7274767e-01 1.41e+01 1.75e+09  -1.0 2.61e+01   8.8 1.73e-05 8.07e-03f  1\n  27  9.7893019e-01 1.41e+01 1.74e+09  -1.0 2.48e+01   8.3 7.44e-02 2.13e-03h  1\n  28  1.1355863e+00 1.33e+01 2.81e+09  -1.0 2.54e+01   8.8 2.24e-05 5.39e-02f  1\n  29  1.1851152e+00 1.31e+01 5.26e+09  -1.0 2.26e+01   9.2 1.46e-03 1.71e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  1.1875976e+00 1.31e+01 6.54e+09  -1.0 2.07e+01   8.7 5.75e-02 8.61e-04h  1\n  31  1.3495034e+00 1.23e+01 1.76e+10  -1.0 2.16e+01   9.1 1.24e-03 5.62e-02f  1\n  32  1.4016517e+00 1.21e+01 4.27e+10  -1.0 1.92e+01   9.6 1.85e-04 1.84e-02f  1\n  33  1.7460477e+00 1.06e+01 5.77e+10  -1.0 1.75e+01   9.1 1.05e-02 1.22e-01f  1\n  34  1.7872628e+00 1.05e+01 9.82e+10  -1.0 1.38e+01   9.5 1.91e-05 1.53e-02f  1\n  35  1.8094359e+00 1.04e+01 1.72e+11  -1.0 1.38e+01   9.9 4.00e-05 8.30e-03f  1\n  36  4.4588974e+00 6.90e+00 1.58e+12  -1.0 1.32e+01   9.5 4.08e-06 9.90e-01f  1\n  37  4.4745421e+00 6.74e+00 1.56e+12  -1.0 6.33e+00   9.9 2.59e-05 2.30e-02f  1\n  38  5.1417859e+00 6.94e+00 1.26e+12  -1.0 5.94e+00   9.4 4.03e-05 9.90e-01f  1\n  39  5.1719734e+00 4.63e+00 1.06e+13  -1.0 5.68e+00   8.9 4.41e-06 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  5.1832694e+00 3.21e-02 4.22e+09  -1.0 4.15e+00    -  1.28e-02 1.00e+00f  1\n  41  5.1788564e+00 5.04e-02 3.35e+07  -1.0 3.22e-01    -  9.90e-01 1.00e+00h  1\n  42  5.1788481e+00 7.84e-08 3.38e+05  -1.0 4.09e+00    -  9.90e-01 1.00e+00H  1\n  43  5.1788481e+00 3.55e-15 3.37e+03  -1.0 6.69e-08   8.4 9.90e-01 1.00e+00h  1\n  44  5.1788481e+00 3.55e-15 3.33e+01  -1.0 3.78e-10   8.0 9.90e-01 1.00e+00h  1\n  45  5.1788481e+00 7.11e-15 2.41e+04  -2.5 2.21e-11   7.5 9.98e-01 1.00e+00h  1\n  46  5.1788481e+00 3.55e-15 6.85e-04  -2.5 6.62e-11   7.0 1.00e+00 1.00e+00h  1\n  47  5.1788481e+00 3.55e-15 3.20e-04  -5.7 9.28e-11   6.5 1.00e+00 1.00e+00h  1\n  48  5.1788481e+00 3.55e-15 3.20e-04  -5.7 2.78e-10   6.1 1.00e+00 1.00e+00h  1\n  49  5.1788481e+00 3.55e-15 3.20e-04  -5.7 8.35e-10   5.6 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  5.1788481e+00 3.55e-15 3.20e-04  -5.7 2.50e-09   5.1 1.00e+00 1.00e+00h  1\n  51  5.1788481e+00 3.55e-15 3.20e-04  -5.7 7.51e-09   4.6 1.00e+00 1.00e+00h  1\n  52  5.1788481e+00 3.55e-15 3.20e-04  -5.7 2.25e-08   4.2 1.00e+00 1.00e+00h  1\n  53  5.1788481e+00 3.55e-15 3.20e-04  -5.7 6.76e-08   3.7 1.00e+00 1.00e+00h  1\n  54  5.1788481e+00 3.55e-15 3.20e-04  -5.7 2.03e-07   3.2 1.00e+00 1.00e+00h  1\n  55  5.1788481e+00 1.55e-14 3.20e-04  -5.7 6.09e-07   2.7 1.00e+00 1.00e+00h  1\n  56  5.1788481e+00 1.41e-13 3.20e-04  -5.7 1.83e-06   2.2 1.00e+00 1.00e+00h  1\n  57  5.1788480e+00 1.27e-12 3.20e-04  -5.7 5.48e-06   1.8 1.00e+00 1.00e+00h  1\n  58  5.1788478e+00 1.14e-11 3.20e-04  -5.7 1.64e-05   1.3 1.00e+00 1.00e+00h  1\n  59  5.1788472e+00 1.03e-10 3.20e-04  -5.7 4.93e-05   0.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  60  5.1788454e+00 9.23e-10 3.20e-04  -5.7 1.48e-04   0.3 1.00e+00 1.00e+00h  1\n  61  5.1788401e+00 8.31e-09 3.20e-04  -5.7 4.44e-04  -0.1 1.00e+00 1.00e+00h  1\n  62  5.1788242e+00 7.48e-08 3.20e-04  -5.7 1.33e-03  -0.6 1.00e+00 1.00e+00h  1\n  63  5.1787764e+00 6.72e-07 3.20e-04  -5.7 3.99e-03  -1.1 1.00e+00 1.00e+00h  1\n  64  5.1786336e+00 6.02e-06 3.20e-04  -5.7 1.20e-02  -1.6 1.00e+00 1.00e+00h  1\n  65  5.1782082e+00 5.36e-05 3.18e-04  -5.7 3.57e-02  -2.1 1.00e+00 1.00e+00h  1\n  66  5.1769614e+00 4.65e-04 3.15e-04  -5.7 1.06e-01  -2.5 1.00e+00 1.00e+00h  1\n  67  5.1734633e+00 3.77e-03 3.05e-04  -5.7 3.08e-01  -3.0 1.00e+00 1.00e+00h  1\n  68  5.1647170e+00 2.53e-02 2.79e-04  -5.7 8.45e-01  -3.5 1.00e+00 1.00e+00h  1\n  69  5.1477342e+00 4.35e-01 4.38e-03  -5.7 2.07e+00  -4.0 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  70  5.1417721e+00 3.72e-01 3.75e-03  -5.7 2.30e+01  -4.4 2.47e-01 1.52e-01h  1\n  71  5.1377087e+00 2.16e-01 2.18e-03  -5.7 1.88e+00  -4.0 1.00e+00 5.02e-01h  1\n  72  5.1361997e+00 2.05e-01 2.08e-03  -5.7 2.00e+01  -4.5 7.16e-01 5.02e-02h  1\n  73  5.1336538e+00 9.94e-02 1.00e-03  -5.7 2.07e+00  -4.1 1.00e+00 5.21e-01h  1\n  74  5.1330946e+00 9.88e-02 9.99e-04  -5.7 2.07e+02  -4.5 5.45e-02 6.36e-03h  1\n  75  5.1307954e+00 4.17e-02 4.08e-04  -5.7 1.98e+00  -4.1 1.00e+00 8.89e-01h  1\n  76  5.1302295e+00 9.65e-03 1.57e-04  -5.7 7.68e-01  -3.7 1.00e+00 8.70e-01h  1\n  77  5.1293859e+00 2.43e-02 2.12e-04  -5.7 1.78e+00  -4.2 1.00e+00 1.00e+00f  1\n  78  5.1287870e+00 6.63e-03 1.32e-04  -5.7 7.20e-01  -3.7 1.00e+00 1.00e+00h  1\n  79  5.1284409e+00 9.41e-03 1.47e-04  -5.7 3.65e+00  -4.2 1.00e+00 1.69e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  80  5.1283044e+00 1.90e-03 6.65e-05  -5.7 3.02e-01  -3.8 1.00e+00 8.81e-01h  1\n  81  5.1279412e+00 3.28e-02 3.31e-04  -5.7 1.01e+00  -4.3 1.00e+00 1.00e+00h  1\n  82  5.1273694e+00 1.07e-01 6.94e-04  -5.7 4.08e+01  -4.7 2.66e-01 7.73e-02h  1\n  83  5.1273611e+00 1.06e-01 6.88e-04  -5.7 2.30e+00  -4.3 1.00e+00 1.12e-02h  1\n  84  5.1269621e+00 3.07e-03 1.51e-05  -5.7 2.16e+00    -  1.00e+00 1.00e+00f  1\n  85  5.1270446e+00 4.86e-06 2.73e-08  -5.7 1.06e-01    -  1.00e+00 1.00e+00h  1\n  86  5.1270303e+00 1.32e-05 3.04e-02  -8.6 8.78e-03    -  1.00e+00 1.00e+00h  1\n  87  5.1270301e+00 1.66e-09 1.68e-11  -8.6 1.11e-04    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 87\n\n                                   (scaled)                 (unscaled)\nObjective...............:   5.1270301228513375e+00    5.1270301228513375e+00\nDual infeasibility......:   1.6799484678272097e-11    1.6799484678272097e-11\nConstraint violation....:   1.6636390043345273e-09    1.6636390043345273e-09\nVariable bound violation:   3.6669586446530026e-40    3.6669586446530026e-40\nComplementarity.........:   2.5155079248684823e-09    2.5155079248684823e-09\nOverall NLP error.......:   2.5155079248684823e-09    2.5155079248684823e-09\n\n\nNumber of objective function evaluations             = 89\nNumber of objective gradient evaluations             = 88\nNumber of equality constraint evaluations            = 89\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 88\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 87\nTotal seconds in IPOPT                               = 0.160\n\nEXIT: Optimal Solution Found.\n","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Extract-and-Plot-the-Results","page":"Hanging Chain Problem","title":"Extract and Plot the Results","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"Extract the results using value. Note that they are returned as arrays corresponding to the supports used to discretize the model.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"ts = value(t)\nu_opt = value(u)\nx1_opt = value(x[1])\nx2_opt = value(x[2])\nx3_opt = value(x[3]);","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"We can also check the objective value:","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"@show(objective_value(m))","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"5.1270301228513375","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"Create the plot for the state variables and input over time.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"p1 = plot(ts, [x1_opt, x2_opt, x3_opt],\n\n    label=[\"x1\" \"x2\" \"x3\"],\n    title=\"State Variables\")\n\np2 = plot(ts, u_opt,\n    label=\"u(t)\",\n    title=\"Input\");","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"Visualize the two plots on one figure.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"plot(p1, p2, layout=(2,1), size=(800,600))","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"<img src=\"data:image/png;base64,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9/tnzpy5bNmyERe0t7c7nc7UDz0SiUjn77rrrubm5mg02t/fX1pa+s4774x53SHNRm0M4XA41RJ+9rOfnXTSSdL5K6+88r777kt9acwrDun38MMPv/nmm2VlZa+//vpBL7j55pvPOuuseDze3d3tcDg++eQTzrnb7TYajf/4xz8453fdddcJJ5xwhNXIj4D1wAMPnH322dLjrq4ulUrl9XqHX9DS0qLX66VQxTlvamr63//9X875woULb7vtNunk66+/Xl5ePoa1howY0RjUarXP5/uqi/v6+ohoYGCAc75ixYozzjhjjGoJY6K5ufnRRx+VHj/33HNz584dcUF7e3tBQcGBT5w4cWLqnff222+/7LLLMlpPGAOjNobh6uvrV65cKT2+8sorlyxZkvH6wZibNGnSQQOWKIo2m+3999+XDq+//vobbriBc/7ss8/OmzdPOul2u1UqVU9Pz5FUID+GCLu6uhoaGqTH1dXVgiDs2LFjxAWVlZU6nU46nDJlSldXl3R+ypQp0smGhoa+vj7My8l3IxoDY2xEYxju1VdfbWpqcjgc0uF7771nsVhqamruv//+A0cQIO+M+AXftm3bgde43W6n01lWVnbVVVe5XC4iisVi/f39qVY0ZcqUgz4R8suhNAbJe++99/nnn5933nmpMw8++KDZbJ45c+af/vSnjFcUss3lcrnd7gPfAYY3IavVWlxcfITvDPkRsLxer8FgSB0ajUa32z38Ao/HM/wCk8kkXTD8iUajkXPu9XrHpMqQKaM2hpRPP/30nnvuefbZZ6XDY4899tNPP929e/fzzz+/YsWKhx9+eCyqC5k04hfc7XbzL2+uWlRUtGbNmr6+vnfffbe7u/uqq64iIo/HwznX6/WpJ0rBC/LaqI0hZfny5ZdcckmqAVx33XUtLS27d+++4447Lrvssg8//HCMagxZIsWAA98BRny4pILEYcuPgOV0On0+n/RYCkmFhYXDLygoKEhdQERut1u6wOl0phKVx+NRKBSpzgzIU6M2BsnGjRvPPPPM3/3ud8ccc4x0ZtKkSfX19Tqd7phjjrnjjjv+7//+b+wqDZkx4he8sLCQMTb8AqvVOnfuXJ1OV1tb++ijj77++uvxeNzhcCgUilQr8ng8RUVFY111SLdRG4PE5/P9+c9/vuKKK1JnZs+ePWHCBL1ef9FFFy1YsOCvf/3rGNUYssTpdBLRge8Awz9caFiQOGz5EbAaGhrWrl0rPd60aZNWqy0vLx9+wZQpU3p6eqRbQoho/fr1Uu9fQ0PD+vXrpZPr1q2bPHmyQqEYw4pD+o1oDDqdbuLEiSOuaW9vP+OMMx577LGzzjrroC8Si8WUSmVmKwqZ19jYOPwXPNXnf1CxWEyhUAiCoFAo6urq1q1bJ51fv359alwA8tchNoY//vGP1dXVRx111EG/ineG8cBsNpeVlR34DjD8w+Xzzz8fGBioq6s7opKOZALXmNm3b5/ZbH7hhRf6+vpOP/3066+/Xjp/zz33PPPMM9LjU0899eqrr965c+evfvWryspK6R6xtWvXWq3Wd999d+vWrdOmTVu6dGnWvgdIkxGNQZqcyIc1hu7u7qKioquuumrVfn6/n3O+YsWKjz76aPv27X/9619LSkqeeOKJbH4bkA5vvPFGcXHxZ599tmnTpoqKCumxLsHzAAAgAElEQVTWFs75Oeec8+9//5tz/ve///2tt97q7e3917/+dfTRRy9cuFC64LHHHps2bdrWrVv/+c9/Wq3WdevWZe17gDQZtTFI5syZ89hjjw1/4iOPPLJp06bu7u7f/OY3Wq0WjUEGPvnkk1WrVpWUlPzyl79ctWqVdFfcn//85xtvvFG64Be/+MWcOXO6u7v//ve/m83mjo4Oznk4HC4sLPztb3/b39+/cOHCBQsWHGE18iOqO53OV1999a677rr33ntPPvnk1KoVgiCkOoH/53/+5yc/+clxxx1XU1Pzt7/9TfpfyKxZs5YtW/bTn/40FApdcMEFN954Y9a+B0iTEY1hyZIl0vlUY/j888+nTp3a29ub+tKzzz5rNBr37du3dOlSt9tdWlp63333/fjHP87a9wBp8t3vfvfuu+++/PLLRVG86aabLrzwQum8IAz1zUej0Ycffnjnzp12u/2000674447pPM33njjwMDAmWeeqdfrn3zyyZkzZ2bnG4D0GbUxENGePXssFsull146/IkbNmx47rnn4vF4dXX1G2+8gcYgA88//3xbW1tjY+O777777rvvLlu2zGw2M8ZSgeH222/3+XynnXaaxWL5/e9/L/VUabXaN95449Zbb33kkUfmz5//9NNPH2E1GP+KaYAAAAAAcHjyYw4WAAAAQB5BwAIAAABIMwQsAAAAgDRDwAIAAABI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\" />","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/#Maintenance-Tests","page":"Hanging Chain Problem","title":"Maintenance Tests","text":"","category":"section"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"These are here to ensure this example stays up to date.","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"using Test\ntol = 1E-6\n@test termination_status(m) == MOI.LOCALLY_SOLVED\n@test has_values(m)\n@test u_opt isa Vector{<:Real}\n@test x1_opt isa Vector{<:Real}\n@test isapprox(objective_value(m), 5.127030122851338, atol=tol)\n@test isapprox(u_opt[end], 7.20355021172144, atol=tol)","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"Test Passed","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"","category":"page"},{"location":"examples/Optimal Control/Hanging Chain/","page":"Hanging Chain Problem","title":"Hanging Chain Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guide/parameter/#inf_par_docs","page":"Infinite Parameters","title":"Infinite Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"A guide for infinite parameters in InfiniteOpt. See the respective  technical manual for more details.","category":"page"},{"location":"guide/parameter/#Overview","page":"Infinite Parameters","title":"Overview","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Infinite parameters are what live on the infinite domains of infinite dimensional   mathematical optimization problems. In dynamic optimization this  corresponds to time and in stochastic optimization this to uncertain parameters  that follow a certain underlying statistical distribution. InfiniteOpt  considers natively two kinds of infinite parameters, ones defined over  continuous intervals and ones characterized by a distribution (others can be  added by defining a user-defined type). These can be used to parameterize  infinite variables, semi-infinite variables, point variables, derivatives,   measures, and can be used directly inside constraints. ","category":"page"},{"location":"guide/parameter/#Basic-Usage","page":"Infinite Parameters","title":"Basic Usage","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"First, we need to initialize and add infinite parameters to our InfiniteModel.  This can be accomplished using @infinite_parameter. For example, let's  define a parameter for time in a time interval from 0 to 10:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> using InfiniteOpt\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now t is a Julia variable that stores a GeneralVariableRef which  points to where the time parameter is stored in model. It can now be used with  infinite variables, derivatives, measures, and constraints as described in their   respective user guide sections.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"When the model is optimized, t will be transcribed (discretized) over its domain  following its support points (assuming the transformation backend relies on discretization). Users can specify support points via the   num_supports or supports keyword arguments. For example, if we desire to  have only 10 equidistant supports then we could have instead defined t: ","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], num_supports = 10)\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"More complex support schemes can be specified via supports such as:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0, 2, 7, 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Where we specified t to use 4 supports: 0, 2, 7, and 10.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also add supports after t has been initialized. This can be accomplished  with add_supports. For example, consider the initial case where t has  no supports and we now wish to add 4 supports:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> add_supports(t, [0., 2.5, 7.5, 10.])\n\njulia> supports(t)\n4-element Vector{Float64}:\n  0.0\n  2.5\n  7.5\n 10.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Here only 4 supports are specified for the sake of example. Alternatively, we  could have initialized the parameter and added supports in just one step using  the supports keyword argument:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0., 2.5, 7.5, 10.])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We could also define a random parameter described by a distribution. This can be  accomplished using @infinite_parameter in combination with a  distribution from  Distributions.jl. For  example let's define a vector of independent random parameters described by a  Normal distribution:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> using Distributions\n\njulia> @infinite_parameter(model, Î¾[i = 1:3] ~ Normal(), independent = true)\n3-element Vector{GeneralVariableRef}:\n Î¾[1]\n Î¾[2]\n Î¾[3]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that we use ~ instead of in when specifying distributions. We also could have  used i as an index to assign a different distribution to each parameter.  Supports can also be specified for each parameter as shown above. Similarly, the  num_supports keyword is used to generate random supports.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"More interestingly, we can also define multi-variate random parameters, for example:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, Î¸[1:2] ~ MvNormal([0, 0], [1, 1]))\n2-element Vector{GeneralVariableRef}:\n Î¸[1]\n Î¸[2]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now we have infinite parameters t and Î¾ that are ready to be used in  defining infinite variables and constraints. We also mention here that the  @infinite_parameter macro is designed to closely emulate  JuMP.@variable and thus handles arrays and keyword arguments in the same way.  This is described in more detail below.","category":"page"},{"location":"guide/parameter/#Parameter-Definition","page":"Infinite Parameters","title":"Parameter Definition","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Defining/initializing an infinite parameter principally involves the following  steps (these are typically automated by @infinite_parameter):","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Define an AbstractInfiniteDomain\nDefine support points within the domain to later discretize the parameter\nConstruct an InfOptParameter to store this information\nAdd the InfOptParameter object to an InfiniteModel and assign a name\nCreate a GeneralVariableRef(s) that points to the parameter object","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Infinite domain definition is described above in the  Infinite Domains section. The supports should be  a vector of finite numbers that are drawn from the domain of the infinite domain.  These supports will be used to transcribe the InfiniteModel in preparation for  it to be optimized. If desired, the supports can be specified after the parameter  is defined and the support container of the defined parameter will be temporarily  empty.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"InfOptParameter is an abstract data type that encompasses all concrete  infinite parameter types. The concrete type for individual infinite parameters  is IndependentParameter, since these parameters are independent of  other parameters. On the other hand, DependentParameters handle  multivariate infinite parameters, within which each individual parameter is not  independent. These are useful for characterizing, for example, parameters  subject to multivariate distribution.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Regardless of the specific concrete type, the build_parameter function  is used to construct an InfOptParameter. For example, let's create a time  parameter t in 0 10 with supports [0, 2, 5, 7, 10]:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> domain = IntervalDomain(0, 10)\n[0, 10]\n\njulia> t_param = build_parameter(error, domain, supports = [0, 2, 5, 7, 10]);","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now that we have a InfOptParameter that contains an IntervalDomain and supports,  let's now add t_param to our InfiniteModel using add_parameter  and assign it the name of t: ","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t_ref = add_parameter(model, t_param, \"t\")\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also create an anonymous infinite parameter by dropping the name from  the add_parameter function call. For example:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t_ref_noname = add_parameter(model, t_param)\nnoname","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now suppose we want to create an infinite parameter that is a random variable  with a given distribution. We follow the same procedure as above, except we use  distributions from Distributions.jl to define a UniDistributionDomain.  For example, let's consider a random variable x in mathcalN(01) with  supports [-0.5, 0.5]:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = Normal(0., 1.)\nNormal{Float64}(Î¼=0.0, Ïƒ=1.0)\n\njulia> domain = UniDistributionDomain(dist)\nNormal{Float64}(Î¼=0.0, Ïƒ=1.0)\n\njulia> x_param = build_parameter(error, domain, supports = [-0.5, 0.5]);","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Again, we use add_parameter to add x_param to the InfiniteModel and  assign it the name x:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> x_ref = add_parameter(model, x_param, \"x\")\nx","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that add_parameter does not register the name of the parameters into the  model that it adds to. As shown in Macro Definition, the  macro definition does not allow for multiple parameters sharing the same name and  will throw an error if it happens.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For dependent parameters, we do not provide a publicly available build_parameter   method due to inherent complexities. Thus, it is recommended to construct these   using @infinite_parameter. However, these can be constructed manually  via the basic constructor for DependentParameters and then invoking  add_parameters. Note that this should be done with caution since most  error checking will be omitted in this case.","category":"page"},{"location":"guide/parameter/#param_macro","page":"Infinite Parameters","title":"Macro Definition","text":"","category":"section"},{"location":"guide/parameter/#One-Dimensional-Parameters","page":"Infinite Parameters","title":"One-Dimensional Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"One user-friendly way of defining infinite parameters is by macro  @infinite_parameter. The macro executes the same process as the  manual definition (steps listed in Parameter Definition), but allows  the users to manipulate several features of the defined infinite parameters.  Again, let's consider a time parameter t in 0 10 with supports  [0, 2, 5, 7, 10]. We use in (or âˆˆ) to define the domain that an infinite  parameter is subject to (any InfiniteScalarDomain for single  parameters). For example, we can define t in 0 10:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Similarly, we can define a random infinite parameter subject to some  distribution using ~ as the operator. For example, a Gaussian infinite  parameter with mean 0 and standard deviation 1 can be defined:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> using Distributions\n\njulia> dist = Normal(0., 1.)\nNormal{Float64}(Î¼=0.0, Ïƒ=1.0)\n\njulia> @infinite_parameter(model, Î¾ ~ dist, num_supports = 10)\nÎ¾","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For anonymous definition, we use either the domain or distribution keywords:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t = @infinite_parameter(model, domain = [0, 10], supports = [0, 2, 5, 7, 10], \n                               base_name = \"t\")\nt\n\njulia> Î¾ = @infinite_parameter(model, distribution = dist, num_supports = 10, \n                               base_name = \"Î¾\")\nÎ¾","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"All the definitions above return a GeneralVariableRef that refers to  the parameter object.","category":"page"},{"location":"guide/parameter/#Multi-Dimensional-Parameters","page":"Infinite Parameters","title":"Multi-Dimensional Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also define multi-dimensional infinite parameters in a concise way. For  example, consider a position parameter x in 0 1^3:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x[1:3] in [0, 1], independent = true, num_supports = 3)\n3-element Vector{GeneralVariableRef}:\n x[1]\n x[2]\n x[3]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Here we used independent = true to signify that each x[i] can be treated  independently. Hence, the overall infinite domain is the cartesian product of  their individual domains. In this example, we defined 3 supports for each x[i]  such that there will be 3^3 = 27 supports for the overall domain:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> supports(x[1])\n3-element Vector{Float64}:\n 0.0\n 0.5\n 1.0\n\njulia> supports(x)\n3Ã—27 Matrix{Float64}:\n 0.0  0.5  1.0  0.0  0.5  1.0  0.0  0.5  â€¦  1.0  0.0  0.5  1.0  0.0  0.5  1.0\n 0.0  0.0  0.0  0.5  0.5  0.5  1.0  1.0     0.0  0.5  0.5  0.5  1.0  1.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For multivariate random infinite parameters, we commonly wish their individual  domains to not be treated independently. Hence, we'll want independent = false  (the default value). For example, a 2-dimensional parameter  theta sim mathcalN(mu Sigma) is defined:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = MvNormal([0, 0], [1 0; 0 2])\nFullNormal(\ndim: 2\nÎ¼: [0.0, 0.0]\nÎ£: [1.0 0.0; 0.0 2.0]\n)\n\njulia> @infinite_parameter(model, Î¸[1:2] ~ dist, num_supports = 3)\n2-element Vector{GeneralVariableRef}:\n Î¸[1]\n Î¸[2]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Here 3 supports are generated for all the parameters simultaneously according to  the distribution. ","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> supports(Î¸)\n2Ã—3 Matrix{Float64}:\n 0.942971  1.52507   -1.20577\n 0.189395  0.175223   0.440976","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We refer to groups of parameters defined this way as dependent infinite  parameters. In principle, nonrandom infinite parameter types can be made  dependent as well when users wish to avoid the Cartesian product of their  supports.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Anonymous groups of parameters can be defined as follows:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> x = @infinite_parameter(model, [1:3] in [0, 1], independent = true, \n                               num_supports = 3, base_name = \"x\")\n3-element Vector{GeneralVariableRef}:\n x[1]\n x[2]\n x[3]\n\njulia> Î¸ = @infinite_parameter(model, [1:2] ~ dist, num_supports = 3, base_name = \"Î¸\")\n2-element Vector{GeneralVariableRef}:\n Î¸[1]\n Î¸[2]","category":"page"},{"location":"guide/parameter/#Containers-for-Multi-Dimensional-Parameters","page":"Infinite Parameters","title":"Containers for Multi-Dimensional Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Unlike other modelling objects, only Array containers are supported for infinite parameters. ","category":"page"},{"location":"guide/parameter/#Supports","page":"Infinite Parameters","title":"Supports","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter, its supports are a finite set of points that the  parameter will take (or possibly take, if the parameter is random). Assuming the underlying transformation backend relies on a discretization strategy (as is the case with TranscriptionBackend), these supports will be used when building the transcription backend to approximate all variables/expressions parameterized by the infinite parameter over a grid of points.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Once an infinite parameter is defined, users can access the supports using  supports function:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0, 2, 5, 7, 10])\nt\n\njulia> supports(t)\n5-element Vector{Float64}:\n  0.0\n  2.0\n  5.0\n  7.0\n 10.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"note: Note\nMost support query functions have a keyword argument label that is used  to specify the type of supports that will be involved in the query. By default,  this will be PublicLabel which will correspond to any supports that are  reported to the user by default, but will exclude any supports that have  InternalLabels (e.g., internal collocation nodes). The full set can always  be obtained via label = All. We can also query more specific subsets of  support information with more specific labels such as label = UniformGrid.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We also provide functions that access other related information about the  supports. For example, has_supports checks whether a parameter has  supports, while num_supports gives the number of supports associated  with a parameter:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> has_supports(t)\ntrue\n\njulia> num_supports(t)\n5","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now suppose we want to add more supports to the t, which is already assigned  with some supports. We can use add_supports function to achieve this  goal:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> add_supports(t, [3, 8])\n\njulia> supports(t)\n7-element Vector{Float64}:\n  0.0\n  2.0\n  3.0\n  5.0\n  7.0\n  8.0\n 10.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"At times, we might want to change the supports completely. In those cases, the  function set_supports resets the supports for a certain parameter with  new supports provided:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set_supports(t, [0,3,5,8,10], force = true)\n\njulia> supports(t)\n5-element Vector{Float64}:\n  0.0\n  3.0\n  5.0\n  8.0\n 10.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the keyword argument [force] must be set as [true] if the  parameter has been assigned with supports. Users can also delete all the  supports of a parameter with delete_supports.","category":"page"},{"location":"guide/parameter/#Automatic-Support-Generation-During-Parameter-Definition","page":"Infinite Parameters","title":"Automatic Support Generation During Parameter Definition","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For the examples in the Parameter Definition, we have seen how to  manually add supports to an infinite parameter. For a quick automatic  generation of support points, though, users do not have to input the support  points. Instead, the number of support points generated is supplied.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter subject to an IntervalDomain, uniformly spaced  supports including both ends are generated across the interval. For example,  defining a time parameter t in 0 10 with 4 supports using  build_parameter gives","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> domain = IntervalDomain(0, 10)\n[0, 10]\n\njulia> t_param = build_parameter(error, domain, num_supports = 4, sig_digits = 3);","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Using macro definition we have","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], num_supports = 4, sig_digits = 3)\nt\n\njulia> supports(t)\n4-element Vector{Float64}:\n  0.0   \n  3.33\n  6.67\n 10.0   \n","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the user can use the keyword argument sig_digits to dictate the  significant figures for the supports. The default value of sig_digits is 12.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter that follows a univariate distribution,  supports are sampled from the underlying distribution. For example, we can  define an infinite parameter subject to a normal distribution with mean 0 and  variance 1:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x ~ Normal(), num_supports = 4)\nx\n\njulia> supports(x)\n4-element Vector{Float64}:\n 0.123901231206\n 0.133922757653\n 0.942970533446\n 1.52506890851  ","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For multivariate distributions, though, we require support points are provided  in the definition. However, we can use fill_in_supports! to generate  supports for parameters following multivariate distributions. See  Automatic Support Generation For Defined Parameters for details.","category":"page"},{"location":"guide/parameter/#Automatic-Support-Generation-For-Defined-Parameters","page":"Infinite Parameters","title":"Automatic Support Generation For Defined Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"So far, we have seen that in both definition methods it is allowed to initialize  a parameter with no supports. This is done by not specifying supports and  num_supports. However, infinite parameters would not be allowed at the  transcription step since it needs information about how to discretize the  infinite parameters. In previous examples, we have shown that users can add  supports to a defined parameter using methods add_supports and  set_supports.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In this section we introduce automatic support generation for defined  parameters with no associated supports. This can be done using the  fill_in_supports! functions. fill_in_supports! can take as  argument a GeneralVariableRef or an  Array{<:GeneralVariableRef}, in which case it will generate  supports for the associated infinite parameter. Alternatively,  fill_in_supports! can also take an InfiniteModel as an  argument, in which case it will generate supports for all infinite parameters  of the InfiniteModel with no supports.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The fill_in_supports! method allows users to specify integer keyword  arguments num_supports and sig_digits. num_supports dictates the  number of supports to be generated, and sig_digits dictates the significant  figures of generated supports desired. The default values are 10 and 12,  respectively.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The ways by which supports are automatically generated are as follows. If the  parameter is in an IntervalDomain, then we generate an array of supports  that are uniformly distributed along the interval, including the two ends. For  example, consider a 3D position parameter x distributed in the unit cube  [0, 1]. We can generate supports for that point in the following way:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x[1:3] in [0, 1], independent = true);\n\njulia> fill_in_supports!.(x, num_supports = 3);\n\njulia> supports.(x)\n3-element Vector{Vector{Float64}}:\n [0.0, 0.5, 1.0]\n [0.0, 0.5, 1.0]\n [0.0, 0.5, 1.0]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the dot syntax because fill_in_supports! takes single  GeneralVariableRef as argument. In each dimension, three equally spaced  supports ([0.0, 0.5, 1.0]) are generated. Since the independent keyword is  set as true, the transcription stage will create a three-dimensional grid for  all variables parameterized by x, with each point separated by 0.5 units in  each dimension. We can view this grid by simply invoking supports without the   vectorized syntax:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> supports(x)\n3Ã—27 Matrix{Float64}:\n 0.0  0.5  1.0  0.0  0.5  1.0  0.0  0.5  â€¦  1.0  0.0  0.5  1.0  0.0  0.5  1.0\n 0.0  0.0  0.0  0.5  0.5  0.5  1.0  1.0     0.0  0.5  0.5  0.5  1.0  1.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"If the parameter is in a UniDistributionDomain or  MultiDistributionDomain, fill_in_supports!  samples num_supports supports from the distribution. Recall that support  generation is not allowed for parameters under multivariate distribution during  parameter definition. However, if the parameter is defined first without  supports, fill_in_supports! allows for supports generation. For  example, for a 2D random variable Î¾ under a multivariate Gaussian  distribution, we can generate supports for it in the following way:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = MvNormal([0., 0.], [1. 0.; 0. 2.])\nFullNormal(\ndim: 2\nÎ¼: [0.0, 0.0]\nÎ£: [1.0 0.0; 0.0 2.0]\n)\n\n\njulia> @infinite_parameter(model, Î¾[1:2] ~ dist);\n\njulia> fill_in_supports!(Î¾, num_supports = 3)\n\njulia> supports(Î¾)\n2Ã—3 Matrix{Float64}:\n 0.942971  1.52507   -1.20577\n 0.189395  0.175223   0.440976","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that fill_in_supports! only fill in supports for parameters with no  associated supports. To modify the supports of parameters already associated  with some supports, refer to Supports for how to do that.","category":"page"},{"location":"guide/parameter/#Parameter-Queries","page":"Infinite Parameters","title":"Parameter Queries","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In addition to the modeling framework, this package provides many functions for  users to access information about the model. This section will go over basic  functions for accessing parameter information.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Once a (possibly large-scale) InfiniteModel is built, the users might want to  check if an infinite parameter is actually used in any way. This could be  checked by is_used function as follows:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x in [0, 1])\nx\n\njulia> is_used(x)\nfalse\n","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"This function checks if the parameter is used by any constraint, measure, or  variable. Similarly, functions used_by_constraint,  used_by_measure and used_by_infinite_variable can be applied to  find out any dependency of specific types on the infinite parameter.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In addition, sometimes we need to check if a certain GeneralVariableRef  for an infinite parameter is valid with an InfiniteModel model, meaning that the  parameter reference actually refers to some parameter associated with the model. We  extend the JuMP.is_valid function from JuMP for that purpose. To see how  to use this, for example,","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> pref1 = GeneralVariableRef(model, 1, IndependentParameterIndex);\n\njulia> pref2 = GeneralVariableRef(model, 2, IndependentParameterIndex);\n\njulia> is_valid(model, pref1)\ntrue\n\njulia> is_valid(model, pref2)\nfalse","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The second call of is_valid returns false because the model does  not have parameter with index 2 yet.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also access different information about the domain that the infinite  parameter is in. This is given by infinite_domain, which takes a  [GeneralVariableRef] as argument. For example, we have","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> infinite_domain(x)\n[0, 1]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"infinite_domain might be more useful if the infinite parameter is in a  UniDistributionDomain or MultiDistributionDomain, by which users  can access information about the underlying distribution. On the other hand,  if we already know that the parameter is in an interval domain, we can use  JuMP.has_lower_bound, JuMP.lower_bound,  JuMP.has_upper_bound, JuMP.upper_bound to retrieve information  about the interval domain in a more specific way:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> has_lower_bound(x)\ntrue\n\njulia> lower_bound(x)\n0.0\n\njulia> has_upper_bound(x)\ntrue\n\njulia> upper_bound(x)\n1.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"A quick way for users to obtain a GeneralVariableRef for a parameter with  a known name would be through parameter_by_name function. This  function takes an InfiniteModel and the parameter name in string,  and returns a GeneralVariableRef for that parameter. For example, ","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> pref = parameter_by_name(model, \"x\")\nx","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"If there is no parameter associated with that name, the function would return  nothing. Otherwise, if multiple parameters share the same name, the function  would throw an error.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now we introduce two additional functions that we can use to access parameter  information for an InfiniteModel. The function  num_parameters returns the number of infinite parameters associated  with a model, while all_parameters returns the list of all infinite  parameter references in the model. For a quick example: ","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, y[1:2] in [0, 5])\n2-element Vector{GeneralVariableRef}:\n y[1]\n y[2]\n\njulia> num_parameters(model)\n3\n\njulia> all_parameters(model)\n3-element Vector{GeneralVariableRef}:\n x   \n y[1]\n y[2]","category":"page"},{"location":"guide/parameter/#Parameter-Modification","page":"Infinite Parameters","title":"Parameter Modification","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In this section we introduce a few shortcuts for users to modify defined  infinite parameters.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"First, once an infinite parameter is defined, we can change its name by calling  the [JuMP.set_name] function, which takes the [GeneralVariableRef] of  the parameter that needs a name change and the name string as arguments. For  example, to change the parameter x to t we can do:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> JuMP.set_name(x, \"t\")\n\njulia> all_parameters(model)\n3-element Vector{GeneralVariableRef}:\n t   \n y[1]\n y[2]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Similarly, we can also change the infinite domain that the parameter is in  using the set_infinite_domain function as follows:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t = parameter_by_name(model, \"t\")\nt\n\njulia> set_infinite_domain(t, IntervalDomain(0, 5))\n\njulia> infinite_domain(t)\n[0, 5]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For parameters in an IntervalDomain, we extend  JuMP.set_lower_bound and JuMP.set_upper_bound functions  for users to modify the lower bounds and upper bounds. For example,","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> JuMP.set_lower_bound(t, 1)\n\njulia> JuMP.set_upper_bound(t, 4)\n\njulia> infinite_domain(t)\n[1, 4]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We do not support setting lower bounds and upper bounds for random parameters  in a UniDistributionDomain and will throw an error if users attempt to do  so. If users want to set lower bound and upper bound for a random infinite  parameter, consider using Distributions.Truncated, which creates a truncated  distribution from a univariate distribution.","category":"page"},{"location":"guide/parameter/#gen_supp_docs","page":"Infinite Parameters","title":"Generative Supports","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Generative supports denote supports that are generated based on existing supports   (treated as finite elements). These are important for enabling certain measure   and derivative evaluation schemes. Examples of such supports include internal   collocation nodes and quadrature supports generated for quadrature methods that  decompose the infinite domain such that existing supports are incorporated. Users  shouldn't modify these directly, but extension writers will need to utilize the  generative support API when developing measures and/or derivative evaluation  methods that need to generate supports based on existing ones (e.g., adding  a new orthogonal collocation method). More information about extension writing  for either case is given on the Extensions page. For enhanced context, we  outline the general API below.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Information about producing generative supports are stored via concrete subtypes  of AbstractGenerativeInfo. Each IndependentParameter stores one of  these objects (the default being NoGenerativeSupports). Hence, a  particular independent parameter can only be associated with 1 generative support  scheme. We currently provide 1 concrete generative subtype of  AbstractGenerativeInfo which is UniformGenerativeInfo.  UniformGenerativeInfo stores the necessary information to make generative  supports that are uniformly applied to each finite element formed by the existing  supports. For example, let's say we want to use a generative support scheme that  adds 1 generative support exactly in the middle of each finite element with a  unique support label to we'll call MyGenLabel:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> struct MyGenLabel <: InfiniteOpt.InternalLabel end;\n\njulia> UniformGenerativeInfo([0.5], MyGenLabel)\nUniformGenerativeInfo([0.5], MyGenLabel)","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Users can make other generative support schemes as described on the Extensions  page. ","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"These AbstractGenerativeInfo objects are added to parameters as needed via the  addition of measures and/or derivative methods that require generative supports.  We can always check what generative information is currently associated with a  particular parameter via generative_support_info.  The generation of these supports is handled automatically at the appropriate  times via add_generative_supports. We can always check if generative  supports have been created for a particular parameter with  has_generative_supports.","category":"page"},{"location":"examples/Stochastic Optimization/flexible_design/#Power-Network-Flexibility-Design","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"","category":"section"},{"location":"examples/Stochastic Optimization/flexible_design/","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"Here we consider a stochastic flexibility design problem that is inspired from an example problem in Pulsipher JL, Zavala VM. A scalable stochastic programming approach for the design of flexible systems. Computers & Chemical Engineering. 2019 Sep 2;128:69-76. See the paper here.","category":"page"},{"location":"examples/Stochastic Optimization/flexible_design/#Modeling-and-Solution","page":"Power Network Flexibility Design","title":"Modeling and Solution","text":"","category":"section"},{"location":"examples/Stochastic Optimization/flexible_design/","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"using InfiniteOpt, HiGHS, Distributions, Random\n\n# Set the covariance matrix for the uncertain parameters\nÎ¸_nom = [0.; 60.; 10.]\ncovar = [80. 0 0; 0 80. 0; 0 0 120.]\n\n# Set the dimensions\nn_z = 3; n_Î¸ = 3; n_d = 3\n\n# Set the problem parameters\nc = ones(n_d) / sqrt(n_d)\nc_max = 5\nU = 10000\nnum_samples = 100 # more should be used (kept small for doc generation)\n\n# Seed such that the results are reproducible\nRandom.seed!(42)\n\n# Initialize the model\nm = InfiniteModel(HiGHS.Optimizer)\nset_silent(m)\n\n# Set the uncertainty parameters\n@infinite_parameter(m, Î¸[i = 1:n_Î¸] ~ MvNormal(Î¸_nom, covar),\n                    num_supports = num_samples)\n\n# Initialize the variables\n@variable(m, 0 <= y <= 1, Infinite(Î¸))\n@variable(m, z[1:n_z], Infinite(Î¸))\n@variable(m, d[1:n_d] >= 0)\n\n# Set objective function\n@objective(m, Max, expect(1 - y, Î¸))\n\n# Set the line capacity constraints\n@constraint(m, f1, -z[1] - 35 - d[1] <= y * U)\n@constraint(m, f2, z[1] - 35 - d[1] <= y * U)\n@constraint(m, f3, -z[2] - 50 - d[2] <= y * U)\n@constraint(m, f4, z[1] - 50 - d[2] <= y * U)\n\n# Set the generator capacity constraints\n@constraint(m, f5, -z[3] <= y * U)\n@constraint(m, f6, z[3] - 100 - d[3] <= y * U)\n\n# Set the node balance constraints\n@constraint(m, h1, z[1] - Î¸[1] == 0)\n@constraint(m, h2, -z[1] -z[2] + z[3] - Î¸[2] == 0)\n@constraint(m, h3, z[2] - Î¸[3] == 0)\n\n# Enforce the minimum SF\n@constraint(m, max_cost, sum(c[i] * d[i] for i = 1:n_d) <= c_max)\n\n# Solve and and obtain results\noptimize!(m)\nif has_values(m)\n    opt_y = value(y)\n    opt_d = value.(d)\n    opt_obj = objective_value(m)\nend\n\n# Estimate the value of SF\nSF = 1 - sum(opt_y .>= 1e-8) / num_samples\n\n# Print the results\nprint(\"------------------RESULTS------------------\\n\")\nprint(\"Optimal Objective:     \", opt_obj, \"\\n\")\nprint(\"Optimal Cost:          \", sum(c[i] * opt_d[i] for i = 1:n_d), \"\\n\")\nprint(\"Maximum Cost:          \", c_max, \"\\n\")\nprint(\"Predicted SF:          \", 100 * SF, \"%\\n\")\nprint(\"Optimal Design Values: \", opt_d, \"\\n\\n\")","category":"page"},{"location":"examples/Stochastic Optimization/flexible_design/","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"------------------RESULTS------------------\nOptimal Objective:     1.0000000000000007\nOptimal Cost:          5.0\nMaximum Cost:          5\nPredicted SF:          100.0%\nOptimal Design Values: [0.0, 0.0, 8.660254037844386]\n\n","category":"page"},{"location":"examples/Stochastic Optimization/flexible_design/#Maintenance-Tests","page":"Power Network Flexibility Design","title":"Maintenance Tests","text":"","category":"section"},{"location":"examples/Stochastic Optimization/flexible_design/","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"These are here to ensure this example stays up to date.","category":"page"},{"location":"examples/Stochastic Optimization/flexible_design/","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"using Test\n@test termination_status(m) == MOI.OPTIMAL\n@test opt_y isa Vector{<:Real}","category":"page"},{"location":"examples/Stochastic Optimization/flexible_design/","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"Test Passed","category":"page"},{"location":"examples/Stochastic Optimization/flexible_design/","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"","category":"page"},{"location":"examples/Stochastic Optimization/flexible_design/","page":"Power Network Flexibility Design","title":"Power Network Flexibility Design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/derivative/#deriv_manual","page":"Derivatives","title":"Derivative Operators","text":"","category":"section"},{"location":"manual/derivative/","page":"Derivatives","title":"Derivatives","text":"A technical manual for derivatives in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/derivative/#Definition","page":"Derivatives","title":"Definition","text":"","category":"section"},{"location":"manual/derivative/#InfiniteOpt.deriv","page":"Derivatives","title":"InfiniteOpt.deriv","text":"deriv(expr::JuMP.AbstractJuMPScalar, pref1::GeneralVariableRef[, ....]\n      )::Union{JuMP.AbstractJuMPScalar, Float64}\n\nApply appropriate calculus methods to define and return the derivative expression of expr  with respect to the infinite parameter(s) pref1, pref2, etc. in that respective  order. This will implicilty build and add individual [Derivative`](@ref)s as  appropriate. Errors if no infinite parameter is given or if the parameters are  not infinite.\n\nExample\n\njulia> @infinite_parameter(m, t in [0, 1])\nt\n\njulia> @variable(m, y, Infinite(t))\ny(t)\n\njulia> @variable(m, z)\nz\n\njulia> deriv_expr = deriv(y^2 + z, t, t)\n2 âˆ‚Â²/âˆ‚tÂ²[y(t)]*y(t) + 2 âˆ‚/âˆ‚t[y(t)]Â²\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.âˆ‚","page":"Derivatives","title":"InfiniteOpt.âˆ‚","text":"âˆ‚(expr::JuMP.AbstractJuMPScalar, pref1::GeneralVariableRef[, ....]\n  )::Union{JuMP.AbstractJuMPScalar, Float64}\n\nThis serves as a convenient unicode wrapper for deriv. The âˆ‚ is  produced via \\partial.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.@deriv","page":"Derivatives","title":"InfiniteOpt.@deriv","text":"@deriv(expr, pref_expr1[, ...])::Union{JuMP.AbstractJuMPScalar, Float64}\n\nThe macro variant of deriv that is more efficient for expression building  and enables symbolic differential operator parameter defintions via pref_exprs.  Like deriv expr can be any InfiniteOpt expression and the appropriate calculus  rules will applied to expr to take its derivative with respect to the indicated  infinite parameters detailed by the pref_exprs. The resulting derivative  expression will contain individual derivatives that were created and added to the  InfiniteModel as needed. Here each pref_expr arugment can be of the form:\n\npref::GeneralVariableRef: An indiviudal infinite parameter reference\n(pref::GeneralVariableRef)^(p::Int): An infinite parameter applied p times.\n\nThus, the syntax @deriv(expr, pref^2) is equivalent to @deriv(expr, pref, pref). \n\nThis will error if pref_expr is an unrecongnized syntax, no infinite parameter  is given, or if any of the specified parameters are not infinite.\n\nExample\n\njulia> @infinite_parameter(m, t in [0, 1])\nt\n\njulia> @variable(m, y, Infinite(t))\ny(t)\n\njulia> @variable(m, z)\nz\n\njulia> deriv_expr = @deriv(y^2 + z, t^2)\n2 âˆ‚Â²/âˆ‚tÂ²[y(t)]*y(t) + 2 âˆ‚/âˆ‚t[y(t)]Â²\n\n\n\n\n\n","category":"macro"},{"location":"manual/derivative/#InfiniteOpt.@âˆ‚","page":"Derivatives","title":"InfiniteOpt.@âˆ‚","text":"@âˆ‚(expr, pref_expr1[, ...])::Union{JuMP.AbstractJuMPScalar, Float64}\n\nThis serves as a convenient unicode wrapper for @deriv. The âˆ‚ is  produced via \\partial.\n\n\n\n\n\n","category":"macro"},{"location":"manual/derivative/#InfiniteOpt.Deriv","page":"Derivatives","title":"InfiniteOpt.Deriv","text":"Deriv{V, P} <: InfOptVariableType\n\nA DataType to assist in making derivative variables. This can be passed as an  extra argument to @variable to make such a variable: \n\n@variable(model, var_expr, Deriv(inf_var, inf_par [, order]), kwargs...)\n\nHere, inf_var is the infinite variable that is being operated on and inf_par  is the infinite parameter that the derivative is defined with respect to. order  is an optional argument and defaults to 1.\n\nFields\n\nargument::V: The infinite variable being operated on.\noperator_parameter::P: The infinite parameter that determines the derivative.\norder::Int: The derivative order (defaults to 1 if not given).\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#JuMP.build_variable-Tuple{Function, VariableInfo, Deriv}","page":"Derivatives","title":"JuMP.build_variable","text":"JuMP.build_variable(\n    _error::Fu`nction,\n    info::JuMP.VariableInfo, \n    var_type::Deriv`\n)::InfiniteVariable{GeneralVariableRef}\n\nBuild and return a first order derivative based on info and var_type. Errors  if the information in var_type is invalid. See Deriv for more  information.\n\nExample\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);\n\njulia> deriv_var = build_variable(error, info, Deriv(y, t));\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.build_derivative","page":"Derivatives","title":"InfiniteOpt.build_derivative","text":"build_derivative(\n    _error::Function, \n    info::JuMP.VariableInfo, \n    argument_ref::GeneralVariableRef, \n    parameter_ref::GeneralVariableRef,\n    order::Int = 1\n)::Derivative\n\nConstructs and returns a Derivative with a differential operator that  depends on parameter_ref and operates on argument_ref. The order of the derivative  is dictated by order. Variable info can also  be provided to associate this derivative with bounds and a starting value function  like that of infinite variables. Errors when argument_ref is not an  infinite/semi-infinite variable or derivative that depends on parameter_ref.\n\nExample ```julia-repl  julia> @infinite_parameter(m, t in [0, 1]); @variable(m, y, Infinite(t));\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);\n\njulia> build_derivative(error, info, y, t) Derivative{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Float64}(false, 0.0, false, 0.0, false, 0.0, false, 0.0, false, false), true, y(t), t, 1) ````\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.Derivative","page":"Derivatives","title":"InfiniteOpt.Derivative","text":"Derivative{\n    V <: JuMP.AbstractVariableRef,\n    LB <: Union{Float64, ParameterFunction}, \n    UB <: Union{Float64, ParameterFunction}, \n    FX <: Union{Float64, ParameterFunction}, \n    ST <: Union{Float64, ParameterFunction}\n    } <: JuMP.AbstractVariable\n\nA DataType for storing core infinite derivative information. This follows a  derivative of the form: fracpartial y(alpha hdots)partial alpha  where y(alpha hdots) is an infinite variable and alpha is an infinite  parameter. Here, both y and alpha must be scalars. Higher-order derivatives  are also supported: fracpartial^n y(alpha hdots)partial alpha^n. \n\nVariable domain info (e.g., bounds, start value) can be specified via info in like manner to InfiniteVariables. Also, the variable reference type V must pertain to infinite variables and parameters.\n\nFields\n\ninfo::JuMP.VariableInfo: JuMP variable information.\nvariable_ref::V: The variable reference of the infinite variable argument.\nparameter_ref::V: The variable reference of the infinite parameter that defines the  differential operator.\norder::Int: The order of the derivative.\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.add_derivative","page":"Derivatives","title":"InfiniteOpt.add_derivative","text":"add_derivative(\n    model::InfiniteModel,\n    d::Derivative, \n    [name::String = \"\"]\n)::GeneralVariableRef\n\nAdds a derivative d to model and returns a GeneralVariableRef that points  to it. Errors if the derivative dependencies do not belong to model. Note that  d should be built using build_derivative to avoid nuance internal  errors.\n\nExample\n\njulia> @infinite_parameter(m, t in [0, 1]); @variable(m, y, Infinite(t));\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);\n\njulia> d = build_derivative(error, info, y, t, 2);\n\njulia> dref = add_derivative(m, d)\nâˆ‚Â²/âˆ‚tÂ²[y(t)]\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.DerivativeIndex","page":"Derivatives","title":"InfiniteOpt.DerivativeIndex","text":"DerivativeIndex <: ObjectIndex\n\nA DataType for storing the index of a Derivative.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.DerivativeRef","page":"Derivatives","title":"InfiniteOpt.DerivativeRef","text":"DerivativeRef <: DispatchVariableRef\n\nA DataType for untranscripted derivative references.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::DerivativeIndex: Index of the derivative in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#Queries","page":"Derivatives","title":"Queries","text":"","category":"section"},{"location":"manual/derivative/#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.derivative_argument","text":"derivative_argument(dref::DerivativeRef)::GeneralVariableRef\n\nReturns the infinite variable/derivative reference that is the input the differential operator (i.e., the dependent variable of the derivative).\n\nExample\n\njulia> derivative_argument(dref) \nx(t)\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.operator_parameter","text":"operator_parameter(dref::DerivativeRef)::GeneralVariableRef\n\nReturns the infinite parameter reference that is what the differential operator  is operating with respect to (i.e., the independent  variable of the derivative).\n\nExample\n\njulia> operator_parameter(dref) \nt\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.derivative_order-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.derivative_order","text":"derivative_order(dref::DerivativeRef)::Int\n\nReturn the what order the derivative is.\n\nExample\n\njulia> derivative_order(dref) \n1\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.num_derivatives","page":"Derivatives","title":"InfiniteOpt.num_derivatives","text":"num_derivatives(model::InfiniteModel)::Int\n\nReturns the number of derivatives that have been defined in model.\n\nExample\n\njulia> num_derivatives(model)\n12\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.all_derivatives","page":"Derivatives","title":"InfiniteOpt.all_derivatives","text":"all_derivatives(model::InfiniteModel)::Vector{GeneralVariableRef}\n\nReturns a list of all the individual derivatives stored in model. \n\nExample\n\njulia> all_derivatives(model)\n3-element Array{GeneralVariableRef,1}:\n âˆ‚/âˆ‚t[T(x, t)]\n âˆ‚/âˆ‚x[T(x, t)]\n âˆ‚/âˆ‚x[âˆ‚/âˆ‚t[T(x, t)]]\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(dref::DerivativeRef)::Tuple\n\nReturn the parameter references associated with the infinite derivative dref. This is formatted as a Tuple of containing the parameter references as they inputted to define dref.\n\nExample\n\njulia> parameter_refs(deriv)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.parameter_list-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.parameter_list","text":"parameter_list(dref::DerivativeRef)::Vector{GeneralVariableRef}\n\nReturn a vector of the parameter references that dref depends on. This is primarily an internal method where parameter_refs is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.raw_parameter_refs","text":"raw_parameter_refs(dref::DerivativeRef)::VectorTuple\n\nReturn the raw VectorTuple of the  parameter references that dref depends on. This is primarily an internal method  where parameter_refs  is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.parameter_group_int_indices-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.parameter_group_int_indices","text":"parameter_group_int_indices(dref::DerivativeRef)::Vector{Int}\n\nReturn the list of infinite parameter group integer indices used by dref.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.core_object-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.core_object","text":"core_object(dref::DerivativeRef)::Derivative\n\nRetrieve the underlying core Derivative object for dref.  This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#Evaluation","page":"Derivatives","title":"Evaluation","text":"","category":"section"},{"location":"manual/derivative/#InfiniteOpt.AbstractDerivativeMethod","page":"Derivatives","title":"InfiniteOpt.AbstractDerivativeMethod","text":"AbstractDerivativeMethod\n\nAn abstract type for storing derivative evaluation data that is pertinent to its  reformation/transcription. \n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.GenerativeDerivativeMethod","page":"Derivatives","title":"InfiniteOpt.GenerativeDerivativeMethod","text":"GenerativeDerivativeMethod <: AbstractDerivativeMethod\n\nAn abstract type for derivative evaluation method types that will require support  generation when employed (e.g., internal node points associated with orthogonal  collocation). Such methods can be used with derivatives that depend on independent  infinite parameters, but cannot be used for ones that depend on dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.OrthogonalCollocation","page":"Derivatives","title":"InfiniteOpt.OrthogonalCollocation","text":"OrthogonalCollocation{\n    Q <: MeasureToolbox.AbstractUnivariateMethod\n} <: GenerativeDerivativeMethod\n\nA DataType for storing information about orthogonal collocation over finite  elements to approximate derivatives. The constructor is of the form:\n\n    OrthogonalCollocation(\n        num_nodes::Int, \n        [quad::AbstractUnivariateMethod = GaussLobatto]\n    )\n\nNote that if num_nodes > 2 and the problem contains control variables, then  constant_over_collocation  should probably be used on those variables.\n\nNote that only 1st order derivatives are supported. If higher order derivatives  are given, then they are recursively reformulated into a system of 1st order  differential equations which are then discretized using orthogonal collocation. \n\nFields\n\nnum_nodes::Int: The number of collocation points (nodes) per finite element.\nquadrature_method::Q: The quadrature method uses to choose the collocation points.\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.NonGenerativeDerivativeMethod","page":"Derivatives","title":"InfiniteOpt.NonGenerativeDerivativeMethod","text":"NonGenerativeDerivativeMethod <: AbstractDerivativeMethod\n\nAn abstract type for derivative evaluation method types that do not require the  definition of additional support points. Such methods are amendable to any  derivative in InfiniteOpt including those with dependent infinite parameter  dependencies.\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.FiniteDifference","page":"Derivatives","title":"InfiniteOpt.FiniteDifference","text":"FiniteDifference{T <: FDTechnique} <: NonGenerativeDerivativeMethod\n\nA DataType for information about finite difference method applied to  a derivative evaluation. Note that the constructor is of the form:\n\n    FiniteDifference([technique::FDTechnique = Backward()],\n                     [add_boundary_constr::Bool = true])\n\nwhere technique is the indicated finite difference method to be applied and.  Supported techniques include:\n\nForward\nCentral\nBackward\n\nThese are all first order methods in terms of truncation error. Moreover, they  support derivatives of any order (except Central does not support odd orders  greater than 1). The add_boundary_constr argument indicates if the finite difference equation  corresponding to a boundary support should be included. Thus, for backward  difference this corresponds to the terminal point and for forward difference  this corresponds to the initial point. We recommend using  add_boundary_constr = false when an final condition is given with a backward  method or when an initial condition is given with a forward method. Note that  this argument is ignored for central finite difference which cannot include  any boundary points. \n\nFields \n\ntechnique::T: Mathematical technqiue behind finite difference\nadd_boundary_constraint::Bool: Indicate if the boundary constraint should be  included in the transcription (e.g., the terminal boundary backward equation for  backward difference)\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.FDTechnique","page":"Derivatives","title":"InfiniteOpt.FDTechnique","text":"FDTechnique\n\nAn abstract data type for labels of specific techniques applied in the finite  difference method in derivative evaluation.\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.Forward","page":"Derivatives","title":"InfiniteOpt.Forward","text":"Forward <: FDTechnique\n\nA technique label for finite difference method that implements a forward  difference approximation with first order truncation error. Supports any  derivative order (i.e., 1st derivatives, 2nd derivatives, etc.).\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.Central","page":"Derivatives","title":"InfiniteOpt.Central","text":"Central <: FDTechnique\n\nA technique label for finite difference method that implements a central  difference approximation with first order truncation error. Supports  derivatives of order 1, 2, 4, 6, etc.\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.Backward","page":"Derivatives","title":"InfiniteOpt.Backward","text":"Backward <: FDTechnique\n\nA technique label for finite difference method that implements a backward  difference approximation with first order truncation error. Supports any derivative order (i.e., 1st derivatives, 2nd derivatives, etc.).\n\n\n\n\n\n","category":"type"},{"location":"manual/derivative/#InfiniteOpt.derivative_method-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.derivative_method","text":"derivative_method(dref::DerivativeRef)::AbstractDerivativeMethod\n\nReturns the evaluation method employed by dref that determines the numerical  computation scheme that will be used to evaluate the derivative. Note that this  is set on by the infinite parameter with respect to which the derivative is  defined.\n\nExample\n\njulia> derivative_method(dref) \nFiniteDifference(Backward, true)\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.set_derivative_method","page":"Derivatives","title":"InfiniteOpt.set_derivative_method","text":"set_derivative_method(pref::IndependentParameterRef, \n                      method::AbstractDerivativeMethod)::Nothing\n\nSpecfies the desired derivative evaluation method method for derivatives that are  taken with respect to pref. Any internal supports exclusively associated with  the previous method will be deleted. Also, if any derivatives were evaluated  manually, the associated derivative evaluation constraints will be deleted. Errors  if new derivative method generates supports that are incompatible with existing  measures.\n\nExample\n\njulia> set_derivative_method(d, OrthogonalCollocation(2))\n\n\n\n\n\n\nset_derivative_method(pref::GeneralVariableRef,\n                      method::AbstractDerivativeMethod\n                      )::Nothing\n\nSpecify the numerical derivative evaluation technique associated with pref. An ArgumentError is thrown if pref is not an infinite parameter.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.set_all_derivative_methods","page":"Derivatives","title":"InfiniteOpt.set_all_derivative_methods","text":"set_all_derivative_methods(model::InfiniteModel, \n                           method::AbstractDerivativeMethod)::Nothing\n\nSets the desired evaluation method method for all the derivatives currently added  to model. Note that this is done with respect to the infinite parameters.\n\nExample\n\njulia> set_all_derivative_methods(model, OrthogonalCollocation(2))\n\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.evaluate-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.evaluate","text":"evaluate(dref::DerivativeRef)::Nothing\n\nNumerically evaluate dref by computing its auxiliary derivative constraints  (e.g., collocation equations) and add them to the model. For normal usage, it is  recommended that this method not be called directly and instead have TranscriptionOpt  handle these equations. Errors if evaluate_derivative is not  defined for the derivative method employed.\n\nThe resulting constraints can be accessed via derivative_constraints.\n\nExample\n\njulia> m = InfiniteModel(); @infinite_parameter(m, t in [0,2]); @variable(m, T, Infinite(t));\n\njulia> dref = @deriv(T,t)\nâˆ‚/âˆ‚t[T(t)]\n\njulia> add_supports(t, [0, 0.5, 1, 1.5, 2])\n\njulia> evaluate(dref)\n\njulia> derivative_constraints(dref)\nFeasibility\n4-element Array{InfOptConstraintRef,1}:\n 0.5 âˆ‚/âˆ‚t[T(t)](0.5) - T(0.5) + T(0) = 0.0\n 0.5 âˆ‚/âˆ‚t[T(t)](1) - T(1) + T(0.5) = 0.0\n 0.5 âˆ‚/âˆ‚t[T(t)](1.5) - T(1.5) + T(1) = 0.0\n 0.5 âˆ‚/âˆ‚t[T(t)](2) - T(2) + T(1.5) = 0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.evaluate_all_derivatives!","page":"Derivatives","title":"InfiniteOpt.evaluate_all_derivatives!","text":"evaluate_all_derivatives!(model::InfiniteModel)::Nothing\n\nEvaluate all the derivatives in model by adding the corresponding auxiliary  equations to model. See evaluate for more information.\n\nExample\n\njulia> m = InfiniteModel();\n\njulia> @infinite_parameter(m, t in [0,2], supports = [0, 1, 2]);\n\njulia> @infinite_parameter(m, x in [0,1], supports = [0, 0.5, 1]);\n\njulia> @variable(m, T, Infinite(x, t));\n\njulia> dref1 = @deriv(T, t); dref2 = @deriv(T, x^2);\n\njulia> evaluate_all_derivatives!(m)\n\njulia> print(m)\nFeasibility\nSubject to\n âˆ‚/âˆ‚t[T(x, t)](x, 1) - T(x, 1) + T(x, 0) = 0.0, âˆ€ x âˆˆ [0, 1]\n âˆ‚/âˆ‚t[T(x, t)](x, 2) - T(x, 2) + T(x, 1) = 0.0, âˆ€ x âˆˆ [0, 1]\n 0.25 âˆ‚Â²/âˆ‚xÂ²[T(x, t)](1, t) - T(1, t) + 2 T(0.5, t) - T(0, t) = 0.0, âˆ€ t âˆˆ [0, 2]\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.has_derivative_constraints-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.has_derivative_constraints","text":"has_derivative_constraints(dref::DerivativeRef)::Bool\n\nReturn a Bool whether dref has been evaluated within the InfiniteModel and  has derivative constraints that have been added to the InfiniteModel. Note this  does not indicate if such constraints have been added to the transformation backend. Thus,  with normal usage (i.e., not using evaluate) this should always return false.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.derivative_constraints","text":"derivative_constraints(dref::DerivativeRef)::Vector{InfOptConstraintRef}\n\nReturn a list of the derivative evaluation constraints for dref that have been  added directly to the InfiniteModel associated with dref. An empty vector is  returned is there are no such constraints.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.delete_derivative_constraints","text":"delete_derivative_constraints(dref::DerivativeRef)::Nothing\n\nDelete any derivative constraints of dref that have been directly added to the  InfiniteModel.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.make_indexed_derivative_expr","page":"Derivatives","title":"InfiniteOpt.make_indexed_derivative_expr","text":"make_indexed_derivative_expr(\n    dref::GeneralVariableRef,\n    vref::GeneralVariableRef,\n    pref::GeneralVariableRef,\n    order::Int,\n    idx,\n    supps::Vector{Float64},\n    write_model::Union{InfiniteModel, AbstractTransformationBackend},\n    method::AbstractDerivativeMethod,\n    expr_params...\n    )\n\nProduce an expression that numerically approvides the derivative dref at a  particular support value (supps[idx]) where supps are the ordered support  values of the derivative parameter pref. This is an extension point for  developers adding a new method type. It should be defined in connection with  an extension to derivative_expr_data. evaluate_derivative  will then use these to generate derivative approximation equations. \n\nThis considers a derivative of  order order on vref taken with respect to pref. The resulting expression  is intended for write_model and the method make_reduced_expr  can be helpful for generating semi-infinite and point variables of vref. Additionally, parameter values needed for the approximation (e.g., Î”t) can  be provided as extra arguments (note that these must be scalars). The  iteration data used to provide idx and expr_params is created using  derivative_expr_data. \n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.derivative_expr_data","page":"Derivatives","title":"InfiniteOpt.derivative_expr_data","text":"derivative_expr_data(\n    dref::GeneralVariableRef, \n    order::Int,\n    supps::Vector{Float64},\n    method::AbstractDerivativeMethod,\n    )::Tuple\n\nProduce the data needed to generated derivative approximation equations for  the derivative dref in accordance with make_indexed_derivative_expr.  This is intended as an extension point when defining new derivative approximation  methods. It should return a tuple of interators needed to generate the constraint  expressions with make_indexed_derivative_expr and it is used within  evaluate_derivative (given dref, vref, pref, order,  supps, write_model, and method) to generate a constraint expression  constr_expr for each index of idxs:\n\nidxs, extra_itrs... = derivative_expr_data(dref, order, supps, method)\nfor (idx, extra_data...) in zip(idxs, extra_itrs...)\n    constr_expr = make_indexed_derivative_expr(\n        dref, \n        vref, \n        pref, \n        order, \n        idx, \n        supps, \n        write_model, \n        method, \n        extra_data...\n        )\nend\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.evaluate_derivative","page":"Derivatives","title":"InfiniteOpt.evaluate_derivative","text":"evaluate_derivative(\n    dref::GeneralVariableRef, \n    vref::GeneralVariableRef,\n    method::AbstractDerivativeMethod,\n    write_model::Union{InfiniteModel, AbstractTransformationBackend}\n    )::Vector{JuMP.AbstractJuMPScalar}\n\nBuild expressions for derivative dref evaluated in accordance with  method. Here, vref is normally the derivative_argument, but  for derivative methods that do not support higher order derivatives, vref  will be substituted with appropriate placeholder variables such that dref  can be reformulated as a first derivative. The expressions are of the form  lhs - rhs, where lhs is a function of derivatives evaluated at some  supports for certain infinite parameter, and rhs is a function of the  derivative arguments evaluated at some supports for certain infinite parameter.  For example, for finite difference methods at point t = 1, lhs is  Î”t * âˆ‚/âˆ‚t[T(1)], and rhs could be T(1+Î”t) - T(1) in case of forward  difference mode. This is intended as a helper function for evaluate, which  will take the the expressions generated by this method and generate  constraints that approximate the derivative values by setting the expressions  as 0. \n\nFor developers defining a new type of derivative method, they should extend  derivative_expr_data and make_indexed_derivative_expr if at  all possible. However, if this is not possible, then one can extend  evaluate_derivative directly to encode custom methods for approximating  derivatives. This should invoke add_derivative_supports if the method is  generative and users will likely find it convenient to use make_reduced_expr.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.allows_high_order_derivatives","page":"Derivatives","title":"InfiniteOpt.allows_high_order_derivatives","text":"allows_high_order_derivatives(method::AbstractDerivativeMethod)::Bool\n\nReturns a Bool on whether method supports derivatives with orders higher than  one. If false is returned, then higher order derivatives will be automatically  reformulated into a system of first order derivatives. This is intended as an  internal method and needs to be extended for any new AbstractDerivativeMethod.\n\n\n\n\n\n","category":"function"},{"location":"manual/derivative/#InfiniteOpt.reformulate_high_order_derivatives!-Tuple{DerivativeRef}","page":"Derivatives","title":"InfiniteOpt.reformulate_high_order_derivatives!","text":"reformulate_high_order_derivatives(dref::DerivativeRef)::Vector{GeneralVariableRef}\n\nConvert higher-order derivatives into first-order derivatives and add them to the model if the derivative method employed by dref does not support higher-order derivatives. This is intended as an internal method and is automatically called  when evaluating derivatives. For convenience, this method can also be called for an entire model via reformulate_high_order_derivatives(model::InfiniteModel).\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.generative_support_info-Tuple{AbstractDerivativeMethod}","page":"Derivatives","title":"InfiniteOpt.generative_support_info","text":"generative_support_info(method::AbstractDerivativeMethod)::AbstractGenerativeInfo\n\nReturn the AbstractGenerativeInfo associated with method. This is  intended as an internal method and should be extended for user-defined derivative  methods are GenerativeDerivativeMethods.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}","page":"Derivatives","title":"InfiniteOpt.support_label","text":"support_label(method::GenerativeDerivativeMethod)\n\nReturn the support label associated with method if there is one, errors otherwise.  This depends on generative_support_info  being defined for the type of method.\n\n\n\n\n\n","category":"method"},{"location":"manual/derivative/#InfiniteOpt.make_reduced_expr","page":"Derivatives","title":"InfiniteOpt.make_reduced_expr","text":"make_reduced_expr(\n    vref::GeneralVariableRef, \n    pref::GeneralVariableRef, \n    support::Float64, \n    write_model::Union{InfiniteModel, AbstractTransformationBackend}\n    )\n\nmake_reduced_expr(\n    vref::GeneralVariableRef, \n    pref::GeneralVariableRef, \n    supports::Vector{Float64}, \n    idx::Int, \n    write_model::Union{InfiniteModel, AbstractTransformationBackend}\n    )\n\nGiven the argument variable vref and the operator parameter pref from a  derivative, build and return the reduced expression in accordance to the support  support with respect to pref. New point/semi-infinite variables will be written to  write_model. This is solely intended as a helper function for derivative  evaluation. Instead of providing the support directly, one can also provide the  vector of supports supports and the index that retreives the support of interest;  this is useful an an extension point for backends that only want the index. \n\n\n\n\n\n","category":"function"},{"location":"manual/variable/#var_manual","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"manual/variable/","page":"Variables","title":"Variables","text":"A technical manual for variables in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/variable/#Definition","page":"Variables","title":"Definition","text":"","category":"section"},{"location":"manual/variable/","page":"Variables","title":"Variables","text":"Note that the principle way for defining variables is by using  JuMP.@variable  which originates from JuMP.jl.","category":"page"},{"location":"manual/variable/#Infinite","page":"Variables","title":"Infinite","text":"","category":"section"},{"location":"manual/variable/#InfiniteOpt.InfOptVariableType","page":"Variables","title":"InfiniteOpt.InfOptVariableType","text":"InfOptVariableType\n\nAn abstract DataType for variable type objects used to create InfiniteOpt  variables via JuMP.@variable.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.Infinite","page":"Variables","title":"InfiniteOpt.Infinite","text":"Infinite <: InfOptVariableType\n\nA DataType to assist in making infinite variables. This can be passed as an  extra argument to @variable to make an infinite variable: \n\n@variable(model, var_expr, Infinite(parameter_refs...), args..., kwargs...)\n\nHere parameter_refs can be a single parameter reference, a single parameter  array with parameters defined in the same macro call, or multiple arguments where  each argument is either of the first two options listed.\n\nFields\n\nparameter_refs::VectorTuple{GeneralVariableRef}: The infinite parameters the variable will depend on.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#JuMP.build_variable-Tuple{Function, VariableInfo, Infinite}","page":"Variables","title":"JuMP.build_variable","text":"JuMP.build_variable(\n    _error::Function,\n    info::JuMP.VariableInfo, \n    var_type::Infinite\n)::InfiniteVariable\n\nBuild and return an infinite variable based on info and var_type. Errors if  the infinite parameter references included in var_type are invalid. See  Infinite for more information.\n\nExample\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite(t));\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.add_variable-Tuple{InfiniteModel, InfiniteVariable, String}","page":"Variables","title":"JuMP.add_variable","text":"JuMP.add_variable(model::InfiniteModel, var::InfiniteVariable,\n                  [name::String = \"\"])::GeneralVariableRef\n\nExtend the JuMP.add_variable function to accomodate infinite variable  types. Adds a variable to an infinite model model and returns a  GeneralVariableRef. Primarily intended to be an internal function of  the constructor macro @variable. However, it can be used in combination with JuMP.build_variable to add  infinite variables to an infinite model object. Errors if invalid parameter reference(s) are included in var.\n\nExample\n\njulia> @infinite_parameter(m, t in [0, 10]);\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite(t));\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.InfiniteVariable","page":"Variables","title":"InfiniteOpt.InfiniteVariable","text":"InfiniteVariable{\n    LB <: {Float64, ParameterFunction}, \n    UB <: {Float64, ParameterFunction}, \n    FX <: {Float64, ParameterFunction}, \n    ST <: {Float64, ParameterFunction}, \n    T <: JuMP.AbstractVariableRef\n} <: JuMP.AbstractVariable\n\nA DataType for storing core infinite variable information. Note that indices that refer to the same dependent parameter group must be in the same tuple element. It is important to note that the subfields of info can be comprised of  ParameterFunctions such that each evaluates to a Float64 given an infinite parameter support that matches the format encoded in parameter_refs. \n\nFields\n\ninfo::JuMP.VariableInfo{LB, UB, FX, ST}: JuMP variable information.\nparameter_refs::Collections.VectorTuple{T}: The infinite parameter references that parameterize the  variable.\ngroup_int_idxs::Vector{Int}: The parameter group integer indices associated with parameter_refs.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.restrict","page":"Variables","title":"InfiniteOpt.restrict","text":"restrict(ivref::GeneralVariableRef, supps...)::GeneralVariableRef\n\nRestrict the input domain of an infinite variable/derivative ivref in  accordance with the infinite parameters and/or values supps. Here supps must  match the formatting of ivref's infinite parameters. Here the following  outputs are possible:\n\nEquivalent to @variable(model, variable_type = Point(ivref, supps...) if  supps are a complete support point\nEquivalent to @variable(model, variable_type = SemiInfinite(ivref, supps...)  if supps are a partial support point.\n\nConveniently, we can also invoke this method by calling ivref(supps...).\n\nErrors if ivref is not an infinite variable or derivative or the formatting of  supps is incorrect. Will warn if supps only contain infinite parameters and  will simply return ivref.\n\nExample\n\njulia> restrict(y, 0, x)\ny(0, [x[1], x[2]])\n\njulia> restrict(y, 0, [0, 0])\ny(0, [0, 0])\n\njulia> y(0, x)\ny(0, [x[1], x[2]])\n\njulia> y(0, [0, 0])\ny(0, [0, 0])\n\n\n\n\n\nrestrict(expr::JuMP.AbstractJuMPScalar, supps...)::JuMP.AbstractJuMPScalar\n\nRestrict an infinite expression expr to be enforced over infinite parameter  supports supps. This is limited to expressions only contain infinite variables  with the same kind of infinite parameter dependencies. Note that more conveniently  the expression can be treated as a function for the syntax expr(supps...). \n\nExample\n\njulia> ex = @expression(model, 3y - 2)\n3 y(t) - 2\n\njulia> restrict(ex, 0)\n3 y(0) - 2\n\njulia> ex(0)\n3 y(0) - 2\n\n\n\n\n\n","category":"function"},{"location":"manual/variable/#InfiniteOpt.VariableData","page":"Variables","title":"InfiniteOpt.VariableData","text":"VariableData{V <: JuMP.AbstractVariable} <: AbstractDataObject\n\nA mutable DataType for storing variables and their data.\n\nFields\n\nvariable::V: The scalar variable.\nname::String: The name used for printing.\nlower_bound_index::Union{InfOptConstraintIndex, Nothing}: Index of lower bound constraint.\nupper_bound_index::Union{InfOptConstraintIndex, Nothing}: Index of upper bound constraint.\nfix_index::Union{InfOptConstraintIndex, Nothing}: Index on fixing constraint.\nzero_one_index::Union{InfOptConstraintIndex, Nothing}: Index of binary constraint.\nintegrality_index::Union{InfOptConstraintIndex, Nothing}: Index of integer constraint.\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nconstraint_indices::Vector{InfOptConstraintIndex}: Indices of dependent constraints.\nin_objective::Bool: Is this used in objective?\npoint_var_indices::Vector{PointVariableIndex}: Indices of dependent point variables.\nsemi_infinite_var_indices::Vector{SemiInfiniteVariableIndex}: Indices of dependent semi-infinite variables.\nderivative_indices::Vector{DerivativeIndex}: Indices of dependent derivatives.\nderiv_constr_indices::Vector{InfOptConstraintIndex}: Indices of dependent derivative evaluation constraints.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.InfiniteVariableIndex","page":"Variables","title":"InfiniteOpt.InfiniteVariableIndex","text":"InfiniteVariableIndex <: ObjectIndex\n\nA DataType for storing the index of a InfiniteVariable.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.InfiniteVariableRef","page":"Variables","title":"InfiniteOpt.InfiniteVariableRef","text":"InfiniteVariableRef <: DispatchVariableRef\n\nA DataType for untranscripted infinite dimensional variable references (e.g., second stage variables, time dependent variables).\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::InfiniteVariableIndex: Index of the variable in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.Collections.VectorTuple","page":"Variables","title":"InfiniteOpt.Collections.VectorTuple","text":"VectorTuple{T}\n\nA collection DataType for storing a Tuple of singular elements of type T and/or Array{T, N}s in a convenient vector form that utilizes linear indexing. Here I is denotes the type of a Tuple that stores the  indices of each tuple element as given by indices. VectorTuples should be  defined from an original tuple via VectorTuple(tuple) or by listing the tuple  elements VectorTuple(items...). Note this is still an experimental type and is  primarily intended to store infinite parameter reference tuples and point  variable support value tuples. Some of the notable capabilities are exemplified  below.\n\nExample\n\njulia> julia> tuple = (3., [-2., 4.], ones(2, 2))\n(3.0, [-2.0, 4.0], [1.0 1.0; 1.0 1.0])\n\njulia> vt = VectorTuple(tuple) # make by listing items (notice everything is a vector)\n(3.0, [-2.0, 4.0], [1.0 1.0; 1.0 1.0])\n\njulia> vt[2] # linear indexing\n-2.0\n\njulia> vt[2, 2] # tuple indexing (note the second index is treated linearly)\n4.0\n\njulia> vt[6:end] # linear slicing\n2-element Array{Float64,1}:\n 1.0\n 1.0\n\njulia> vt[2:3, :] # tuple slicing\n2-element Array{Array{Float64,1},1}:\n [-2.0, 4.0]\n [1.0, 1.0, 1.0, 1.0]\n\njulia> tuple2 = Tuple(vt) # rebuild original Tuple with original indices\n(3.0, [-2.0, 4.0], [1.0 1.0; 1.0 1.0])\n\njulia> restricted_copy(vt, [true, false, true]) # make a copy with deleted elements\n(3.0, [1.0 1.0; 1.0 1.0])\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#Semi-Infinite","page":"Variables","title":"Semi-Infinite","text":"","category":"section"},{"location":"manual/variable/#InfiniteOpt.SemiInfinite","page":"Variables","title":"InfiniteOpt.SemiInfinite","text":"SemiInfinite{T} <: InfOptVariableType\n\nA DataType to assist in making semi-infinite variables. This can be passed as an  extra argument to @variable to make such a variable: \n\n@variable(model, var_expr, SemiInfinite(inf_var, parameter_values...), kwargs...)\n\nHere parameter_values must match the format of the infinite parameter  references associated with the infinite variable inf_var and can be comprised  of both real valued supports and/or infinite parameters.\n\nFields\n\ninfinite_variable_ref::GeneralVariableRef\nparameter_values::VectorTuple{T}: The infinite parameters and/or infinite   parameter support values the variable will depend on.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#JuMP.build_variable-Tuple{Function, VariableInfo, SemiInfinite}","page":"Variables","title":"JuMP.build_variable","text":"JuMP.build_variable(_error::Function, info::JuMP.VariableInfo, \n                    var_type::SemiInfinite)::SemiInfiniteVariable{GeneralVariableRef}\n\nBuild and return a semi-infinite variable based on info and var_type. Errors  if the information stored in var_type is invalid. See SemiInfinite  for more information.\n\nExample\n\njulia> y\ny(t, x)\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);\n\njulia> semi_inf_var = build_variable(error, info, SemiInfinite(y, t, 0));\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.build_variable-Tuple{Function, GeneralVariableRef, Vector{Float64}, RestrictedDomainInfo}","page":"Variables","title":"JuMP.build_variable","text":"JuMP.build_variable(\n    _error::Function, \n    ivref::GeneralVariableRef,\n    eval_support::Vector{Float64},\n    [restricted_info::RestrictedDomainInfo]; \n    [check::Bool = true]\n    )::SemiInfiniteVariable{GeneralVariableRef}\n\nExtend the JuMP.build_variable function to build a semi-infinite variable based on the infinite variable/derivative/parameter function ivref with  reduction support eval_support. Will check that input is appropriate if  check = true. Errors if ivref is not an infinite variable, eval_support  violate infinite parameter domains, or if the support dimensions don't match the  infinite parameter dimensions of ivref. This is intended an internal method for  use in evaluating measures.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.add_variable-Tuple{InfiniteModel, SemiInfiniteVariable, String}","page":"Variables","title":"JuMP.add_variable","text":"JuMP.add_variable(\n    model::InfiniteModel,\n    var::SemiInfiniteVariable,\n    [name::String = \"\"]\n)::GeneralVariableRef\n\nExtend the JuMP.add_variable function to accomodate InfiniteOpt  semi-infinite variable types. Adds var to the infinite model model and  returns a GeneralVariableRef. Primarily intended to be an internal  function used in evaluating measures.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.SemiInfiniteVariable","page":"Variables","title":"InfiniteOpt.SemiInfiniteVariable","text":"SemiInfiniteVariable{\n    I <: GeneralVariableRef,\n} <: JuMP.AbstractVariable\n\nA DataType for storing semi-infinite variables which partially support an infinite variable.\n\nFields\n\ninfo::RestrictedDomainInfo: Distinguished domain info.\ninfinite_variable_ref::I: The original infinite/derivative variable.\neval_support::Vector{Float64}: The evaluated parameter values that corresponds    to the vectorized infinite parameters of infinite_variable_ref. Any infinite    parameter not replaced by a value is represented with a NaN.\ngroup_int_idxs::Vector{Int}: The parameter group integer indices associated with the                             evaluated parameter_refs.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.RestrictedDomainInfo","page":"Variables","title":"InfiniteOpt.RestrictedDomainInfo","text":"RestrictedDomainInfo\n\nA structure for storing variable domain information of semi-infinite and point variables. By default, these variables will inherit the domain of their underlying infinite variable. This structure stores the attributes that overide the domain of the infinite variable. This not intended to be used by users directly unless they are creating a new transformation backend.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.SemiInfiniteVariableIndex","page":"Variables","title":"InfiniteOpt.SemiInfiniteVariableIndex","text":"SemiInfiniteVariableIndex <: ObjectIndex\n\nA DataType for storing the index of a SemiInfiniteVariable.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.SemiInfiniteVariableRef","page":"Variables","title":"InfiniteOpt.SemiInfiniteVariableRef","text":"SemiInfiniteVariableRef <: DispatchVariableRef\n\nA DataType for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::SemiInfiniteVariableIndex: Index of the variable in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#Point","page":"Variables","title":"Point","text":"","category":"section"},{"location":"manual/variable/#InfiniteOpt.Point","page":"Variables","title":"InfiniteOpt.Point","text":"Point{T <: Real} <: InfOptVariableType\n\nA DataType to assist in making point variables. This can be passed as an  extra argument to @variable to make such a variable: \n\n@variable(model, var_expr, Point(inf_var, parameter_values...), args..., \n          kwargs...)\n\nHere parameter_values must match the format of the infinite parameter  references associated with the infinite variable inf_var and can be comprised  of both real valued supports.\n\nFields\n\ninfinite_variable_ref::GeneralVariableRef\nparameter_values::VectorTuple{T}: The infinite parameter support values the   variable will depend on.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#JuMP.build_variable-Tuple{Function, VariableInfo, Point}","page":"Variables","title":"JuMP.build_variable","text":"JuMP.build_variable(\n    _error::Function,\n    info::JuMP.VariableInfo, \n    var_type::Point\n)::PointVariable\n\nBuild and return a point variable based on info and var_type. Errors  if the information stored in var_type is invalid. See Point  for more information. This is intended to enable the use of @variable.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.add_variable-Tuple{InfiniteModel, PointVariable, String}","page":"Variables","title":"JuMP.add_variable","text":"JuMP.add_variable(\n    model::InfiniteModel,\n    var::PointVariable,\n    [name::String = \"\"]\n)::GeneralVariableRef\n\nExtend the JuMP.add_variable function to accomodate PointVariable variable  types. Adds a variable to an infinite model model and returns a  GeneralVariableRef. Primarily intended to be an internal function of  the constructor macro @variable. However, it can be used in combination with JuMP.build_variable to add variables to an infinite model object. Errors if an invalid infinite variable reference is included in var.\n\nExample\n\njulia> @infinite_parameter(m, t in [0, 10]);\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite(t));\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, ivref, Collections.VectorTuple(0.5));\n\njulia> pvref = add_variable(m, pt_var, \"var_alias\")\nvar_alias\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.PointVariable","page":"Variables","title":"InfiniteOpt.PointVariable","text":"PointVariable{\n    I <: GeneralVariableRef\n} <: JuMP.AbstractVariable\n\nA DataType for storing point variable information. Note that the elements parameter_values field must match the format of the parameter reference tuple defined in InfiniteVariable\n\nFields\n\ninfo::RestrictedDomainInfo: Domain info.\ninfinite_variable_ref::I: The infinite variable/derivative reference   associated with the point variable.\nparameter_values::Vector{Float64}: The infinite parameter values   defining the point.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.PointVariableIndex","page":"Variables","title":"InfiniteOpt.PointVariableIndex","text":"PointVariableIndex <: ObjectIndex\n\nA DataType for storing the index of a PointVariable.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.PointVariableRef","page":"Variables","title":"InfiniteOpt.PointVariableRef","text":"PointVariableRef <: FiniteRef\n\nA DataType for variables defined at a transcipted point (e.g., second stage variable at a particular scenario, dynamic variable at a discretized time point).\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::PointVariableIndex: Index of the variable in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#Finite","page":"Variables","title":"Finite","text":"","category":"section"},{"location":"manual/variable/","page":"Variables","title":"Variables","text":"Note that finite variables simply correspond to using  JuMP.ScalarVariable  which originates from JuMP.jl as well. In other words, these are defined via  JuMP.@variable without specifying any InfOptVariableType.","category":"page"},{"location":"manual/variable/#JuMP.add_variable-Tuple{InfiniteModel, ScalarVariable, String}","page":"Variables","title":"JuMP.add_variable","text":"JuMP.add_variable(model::InfiniteModel, var::JuMP.ScalarVariable,\n                  [name::String = \"\"])::GeneralVariableRef\n\nExtend the JuMP.add_variable function to accomodate finite (scalar) variable  types. Adds a variable to an infinite model model and returns a  GeneralVariableRef. Primarily intended to be an internal function of  the constructor macro @variable. However, it can be used in combination with JuMP.build_variable to add finite variables to an infinite model object.\n\nExamples\n\njulia> f_var = build_variable(error, info);\n\njulia> fvref = add_variable(m, f_var, \"var_name\")\nvar_name\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.FiniteVariableIndex","page":"Variables","title":"InfiniteOpt.FiniteVariableIndex","text":"FiniteVariableIndex <: ObjectIndex\n\nA DataType for storing the index of a JuMP.ScalarVariable.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#InfiniteOpt.FiniteVariableRef","page":"Variables","title":"InfiniteOpt.FiniteVariableRef","text":"FiniteVariableRef <: FiniteRef\n\nA DataType for finite fixed variable references (e.g., first stage variables, steady-state variables).\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::FiniteVariableIndex: Index of the variable in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/variable/#Queries","page":"Variables","title":"Queries","text":"","category":"section"},{"location":"manual/variable/#General","page":"Variables","title":"General","text":"","category":"section"},{"location":"manual/variable/#JuMP.name-Tuple{DecisionVariableRef}","page":"Variables","title":"JuMP.name","text":"JuMP.name(vref::DecisionVariableRef)::String\n\nExtend JuMP.name to return the names of InfiniteOpt variables.\n\nExample\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.variable_by_name-Tuple{InfiniteModel, String}","page":"Variables","title":"JuMP.variable_by_name","text":"JuMP.variable_by_name(\n    model::InfiniteModel,\n    name::String\n)::Union{GeneralVariableRef, Nothing}\n\nExtend JuMP.variable_by_name for InfiniteModel objects. Return the variable  reference assoociated with a variable name. Errors if multiple variables have the  same name. Returns nothing if no such name exists.\n\nExamples\n\njulia> variable_by_name(m, \"var_name\")\nvar_name\n\njulia> variable_by_name(m, \"fake_name\")\n\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.num_variables-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.num_variables","text":"JuMP.num_variables(model::InfiniteModel, [type])::Int\n\nExtend JuMP.num_variables to return the number of InfiniteOpt variables  assigned to model. By default, the total number of infinite, semi-infinite,  point, and finite variables is returned. The amount of a particular type is  obtained by specifying the concrete variable type via type. Type options  include:\n\nInfiniteVariable: all infinite variables\nSemiInfiniteVariable: all semi-infinite variables\nPointVariable: all point variables\nFiniteVariable: all finite variables\n\nExample\n\njulia> num_variables(model)\n3\n\njulia> num_variables(model, InfiniteVariable)\n2\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.all_variables-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.all_variables","text":"JuMP.all_variables(model::InfiniteModel, [type])::Vector{GeneralVariableRef}\n\nExtend JuMP.all_variables] to return a list of all the variable references  associated with model. By default, all of the infinite, semi-infinite, point,  and finite variables is returned. Those of a particular type is obtained by  specifying the concrete variable type via type. Type options include:\n\nInfiniteVariable: all infinite variables\nSemiInfiniteVariable: all semi-infinite variables\nPointVariable: all point variables\nFiniteVariable: all finite variables\n\nExamples\n\njulia> all_variables(model)\n4-element Array{GeneralVariableRef,1}:\n y(t)\n w(t, x)\n y(0)\n z\n\njulia> all_variables(model, PointVariable)\n1-element Array{GeneralVariableRef,1}:\n y(0)\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.has_lower_bound-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::UserDecisionVariableRef)::Bool\n\nExtend JuMP.has_lower_bound to return a Bool whether an InfiniteOpt  variable has a lower bound.\n\nExample\n\njulia> has_lower_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.lower_bound-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::DecisionVariableRef)::Union{Float64, ParameterFunction}\n\nExtend JuMP.lower_bound to return the lower bound of an InfiniteOpt variable.  Errors if vref doesn't have a lower bound.\n\nExample\n\njulia> lower_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.LowerBoundRef-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::DecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.LowerBoundRef to extract a constraint reference for the lower  bound of vref.\n\nExample\n\nvar â‰¥ 0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.has_upper_bound-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::DecisionVariableRef)::Bool\n\nExtend JuMP.has_upper_bound to return a Bool whether an InfiniteOpt  variable has an upper bound.\n\nExample\n\njulia> has_upper_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.upper_bound-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::DecisionVariableRef)::Union{Float64, ParameterFunction}\n\nExtend JuMP.upper_bound to return the upper bound of an InfiniteOpt variable.  Errors if vref doesn't have a upper bound.\n\nExample\n\njulia> upper_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.UpperBoundRef-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::DecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.UpperBoundRef to extract a constraint reference for the upper  bound of vref.\n\nExample\n\njulia> cref = UpperBoundRef(vref)\nvar â‰¤ 1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.is_fixed-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::DecisionVariableRef)::Bool\n\nExtend JuMP.is_fixed to return Bool whether an InfiniteOpt variable is  fixed.\n\nExample\n\njulia> is_fixed(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.fix_value-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::DecisionVariableRef)::Union{Float64, ParameterFunction}\n\nExtend JuMP.fix_value to return the fix value of an InfiniteOpt variable.  Errors if variable is not fixed.\n\nExample\n\njulia> fix_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.FixRef-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::DecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.FixRef to return the constraint reference of the fix constraint  associated with vref. Errors vref is not fixed.\n\nExamples\n\njulia> cref = FixRef(vref)\nvar = 1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.start_value-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.start_value","text":"JuMP.start_value(vref::DecisionVariableRef)::Union{Nothing, Float64, ParameterFunction}\n\nExtend JuMP.start_value to return starting value of InfiniteOpt variable if  it has one. Returns nothing otherwise.\n\nExample\n\njulia> start_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.is_binary-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::DecisionVariableRef)::Bool\n\nExtend JuMP.is_binary to return Bool whether an InfiniteOpt variable is  binary.\n\nExample\n\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.BinaryRef-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::DecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.BinaryRef to return a constraint reference to the constraint  constrainting vref to be binary. Errors if one does not exist.\n\nExample\n\njulia> cref = BinaryRef(vref)\nvar binary\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.is_integer-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::DecisionVariableRef)::Bool\n\nExtend JuMP.is_integer to return Bool whether an InfiniteOpt variable is  integer.\n\nExample\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.IntegerRef-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::DecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.IntegerRef to return a constraint reference to the constraint  constrainting vref to be integer. Errors if one does not exist.\n\nExample\n\njulia> cref = IntegerRef(vref)\nvar integer\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.is_used-Tuple{DecisionVariableRef}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::DecisionVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.used_by_constraint-Tuple{DecisionVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(vref::DecisionVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.used_by_measure-Tuple{DecisionVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(vref::DecisionVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a measure.\n\nExample\n\njulia> used_by_measure(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.used_by_objective-Tuple{DecisionVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vref::DecisionVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by the objective.\n\nExample\n\njulia> used_by_objective(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#Infinite-2","page":"Variables","title":"Infinite","text":"","category":"section"},{"location":"manual/variable/#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::InfiniteVariableRef)::Tuple\n\nReturn the parameter references associated with the infinite variable vref. This is formatted as a Tuple of containing the parameter references as they inputted to define vref.\n\nExample\n\njulia> @variable(model, T, Infinite(t))\nT(t)\n\njulia> parameter_refs(T)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.parameter_list-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_list","text":"parameter_list(vref::InfiniteVariableRef)::Vector{GeneralVariableRef}\n\nReturn a vector of the parameter references that vref depends on. This is primarily an internal method where parameter_refs is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.raw_parameter_refs-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.raw_parameter_refs","text":"raw_parameter_refs(vref::InfiniteVariableRef)::VectorTuple{GeneralVariableRef}\n\nReturn the raw VectorTuple of the  parameter references that vref depends on. This is primarily an internal method  where parameter_refs  is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, InfiniteVariableRef}}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.used_by_derivative-Tuple{Union{DerivativeRef, InfiniteVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_derivative","text":"used_by_derivative(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool\n\nReturn a Bool indicating if vref is used by a derivative.\n\nExample\n\njulia> used_by_derivative(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.used_by_point_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_point_variable","text":"used_by_point_variable(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool\n\nReturn a Bool indicating if vref is used by a point variable.\n\nExample\n\njulia> used_by_point_variable(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.used_by_semi_infinite_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_semi_infinite_variable","text":"used_by_semi_infinite_variable(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool\n\nReturn a Bool indicating if vref is used by a semi-infinite variable.\n\nExample\n\njulia> used_by_semi_infinite_variable(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.parameter_group_int_indices-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_group_int_indices","text":"parameter_group_int_indices(vref::InfiniteVariableRef)::Vector{Int}\n\nReturn the list of infinite parameter group integer indices used by vref.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.core_object-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.core_object","text":"core_object(vref::InfiniteVariableRef)::InfiniteVariable\n\nRetrieve the underlying core InfiniteVariable object for vref.  This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#Semi-Infinite-2","page":"Variables","title":"Semi-Infinite","text":"","category":"section"},{"location":"manual/variable/#InfiniteOpt.infinite_variable_ref-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::SemiInfiniteVariableRef)::GeneralVariableRef\n\nReturn the infinite variable/derivative/parameter function reference associated  with the semi-infinite variable vref.\n\nExample\n\njulia> infinite_variable_ref(vref)\ng(t, x)\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.parameter_refs-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::SemiInfiniteVariableRef)::Tuple\n\nReturn the infinite parameter references associated with the semi-infinite variable vref. This is formatted as a Tuple of containing the parameter references as they were inputted to define the untranscripted infinite variable except, the evaluated parameters are excluded.\n\nExample\n\njulia> parameter_refs(vref)\n(t, [x[1], x[2]])\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.parameter_list-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_list","text":"parameter_list(vref::SemiInfiniteVariableRef)::Vector{GeneralVariableRef}\n\nReturn a vector of the parameter references that vref depends on. This is primarily an internal method where parameter_refs is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.raw_parameter_refs-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.raw_parameter_refs","text":"raw_parameter_refs(vref::Union{SemiInfiniteVariableRef, SemiInfiniteVariable})::VectorTuple\n\nReturn the raw VectorTuple of the  parameter references that vref depends on. This is primarily an internal method  where parameter_refs  is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.eval_support-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.eval_support","text":"eval_support(vref::SemiInfiniteVariableRef)::Vector{Float64}\n\nReturn the evaluation supports associated with the semi-infinite variable vref. Any element corresponding to an infinite parameter that is not evaluated is filled with a NaN.\n\nExample\n\njulia> supp = eval_support(vref)\n[0.0, NaN]\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.is_used-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::SemiInfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.used_by_derivative-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_derivative","text":"used_by_derivative(vref::SemiInfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a derivative.\n\nExample\n\njulia> used_by_derivative(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.parameter_group_int_indices-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_group_int_indices","text":"parameter_group_int_indices(vref::SemiInfiniteVariableRef)::Vector{Int}\n\nReturn the list of infinite parameter group integer indices used by vref.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.core_object-Tuple{SemiInfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.core_object","text":"core_object(vref::SemiInfiniteVariableRef)::SemiInfiniteVariable\n\nRetrieve the underlying core [SemiInfiniteVariable] object for vref.  This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#Point-2","page":"Variables","title":"Point","text":"","category":"section"},{"location":"manual/variable/#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::PointVariableRef)::GeneralVariableRef\n\nReturn the InfiniteVariableRef associated with the point variable vref.\n\nExample\n\njulia> @variable(model, T, Infinite(t))\nT(t)\n\njulia> @variable(model, T0, Point(T, 0))\nT0\n\njulia> infinite_variable_ref(T0)\nT(t)\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.parameter_values-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_values","text":"parameter_values(vref::PointVariableRef)::Tuple\n\nReturn the support point associated with the point variable vref.\n\nExample\n\njulia> @variable(model, T, Infinite(t))\nT(t)\n\njulia> @variable(model, T0, Point(T, 0))\nT0\n\njulia> parameter_values(T0)\n(0,)\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.raw_parameter_values-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.raw_parameter_values","text":"raw_parameter_values(vref::PointVariableRef)::Vector{Float64}\n\nReturn the raw support point values associated with the point variable vref.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#InfiniteOpt.core_object-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.core_object","text":"core_object(vref::PointVariableRef)::PointVariable\n\nRetrieve the underlying core [PointVariable] object for vref.  This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#Finite-2","page":"Variables","title":"Finite","text":"","category":"section"},{"location":"manual/variable/#InfiniteOpt.core_object-Tuple{FiniteVariableRef}","page":"Variables","title":"InfiniteOpt.core_object","text":"core_object(vref::FiniteVariableRef)::JuMP.ScalarVariable\n\nRetrieve the underlying core JuMP.ScalarVariable object for vref.  This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#Modification","page":"Variables","title":"Modification","text":"","category":"section"},{"location":"manual/variable/#General-2","page":"Variables","title":"General","text":"","category":"section"},{"location":"manual/variable/#JuMP.set_name-Tuple{DecisionVariableRef, String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing\n\nExtend JuMP.set_name to set names of decision variables.\n\nExample\n\njulia> set_name(vref, \"var_name\")\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.set_lower_bound-Tuple{UserDecisionVariableRef, Union{Function, Real}}","page":"Variables","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(vref::DecisionVariableRef, lower::Union{Real, Function})::Nothing\n\nExtend JuMP.set_lower_bound to specify the lower bound of an InfiniteOpt  variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_lower_bound(vref, -1)\n\njulia> lower_bound(vref)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.delete_lower_bound-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.delete_lower_bound","text":"JuMP.delete_lower_bound(vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.delete_lower_bound to delete lower bound of vref. Errors if it  doesn't have a lower bound.\n\nExample\n\njulia> delete_lower_bound(vref)\n\njulia> has_lower_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.set_upper_bound-Tuple{UserDecisionVariableRef, Union{Function, Real}}","page":"Variables","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(vref::DecisionVariableRef, upper::Union{Real, Function})::Nothing\n\nExtend JuMP.set_upper_bound to specify the upper bound of an InfiniteOpt  variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_upper_bound(vref, 1)\n\njulia> upper_bound(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.delete_upper_bound-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.delete_upper_bound","text":"JuMP.delete_upper_bound(vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.delete_upper_bound to delete the upper bound of vref. Errors if  it doesn't have an upper bound.\n\nExample\n\njulia> delete_upper_bound(vref)\n\njulia> has_upper_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.fix-Tuple{UserDecisionVariableRef, Union{Function, Real}}","page":"Variables","title":"JuMP.fix","text":"JuMP.fix(\n    vref::DecisionVariableRef,\n    value::Union{Real, Function};\n    force::Bool = false\n)::Nothing\n\nExtend JuMP.fix to fix the value of an InfiniteOpt variable. Errors if  variable has a lower and/or an upper bound(s) unless force = true.\n\nExamples\n\njulia> fix(vref, 3)\n\njulia> fix_value(vref)\n3.0\n\njulia> fix(vref2, 2, force = true)\n\njulia> fix_value(vref2)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.unfix-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.unfix","text":"JuMP.unfix(vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.unfix to unfix vref. Errors if it is not fixed.\n\nExample\n\njulia> unfix(vref)\n\njulia> is_fixed(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.set_start_value-Tuple{UserDecisionVariableRef, Union{Function, Real}}","page":"Variables","title":"JuMP.set_start_value","text":"JuMP.set_start_value(vref::DecisionVariableRef, value::Union{Real, Function})::Nothing\n\nExtend JuMP.set_start_value to specify the start value of InfiniteOpt  variables.\n\nExample\n\njulia> set_start_value(vref, 1)\n\njulia> start_value(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.set_binary-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.set_binary","text":"JuMP.set_binary(vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.set_binary to specify an InfiniteOpt variable as a binary  variable. Errors if vref is an integer variable.\n\nExample\n\njulia> set_binary(vref)\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.unset_binary-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.unset_binary","text":"JuMP.unset_binary(vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.unset_binary to unset vref as a binary variable. Errors if it is  not binary.\n\njulia> unset_binary(vref)\n\njulia> is_binary(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.set_integer-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.set_integer","text":"JuMP.set_integer(vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.set_integer to specify an InfiniteOpt variable as a integer  variable. Errors if vref is an binary variable.\n\nExample\n\njulia> set_integer(vref)\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.unset_integer-Tuple{UserDecisionVariableRef}","page":"Variables","title":"JuMP.unset_integer","text":"JuMP.unset_integer(vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.unset_integer to unset vref as an integer variable. Errors if it  is not an integer variable.\n\njulia> unset_integer(vref)\n\njulia> is_integer(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.relax_integrality-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.relax_integrality","text":"JuMP.relax_integrality(model::InfiniteModel)::Function\n\nModifies model to \"relax\" all binary and integrality constraints on variables. Specifically,\n\nBinary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval 0 1.\nIntegrality constraints are deleted without modifying variable bounds.\nAll other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.\n\nReturns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.\n\nExample\n\njulia> undo_relax = relax_integrality(model);\n\njulia> print(model)\nMin x + âˆ«{t âˆˆ [0, 10]}(y(t))\nSubject to\n x â‰¥ 0.0\n y(t) â‰¥ 1.0\n x â‰¤ 1.0\n y(t) â‰¤ 10.0\n\njulia> undo_relax()\n\njulia> print(model)\nMin x + âˆ«{t âˆˆ [0, 10]}(y(t))\nSubject to\n y(t) â‰¥ 1.0\n y(t) â‰¤ 10.0\n y(t) integer\n x binary\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.set_start_values-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.set_start_values","text":"JuMP.set_start_values(\n    model::InfiniteModel;\n    [degree::Interpolations.Degree = Interpolations.Linear()],\n    [kwargs...]\n)::Nothing\n\nSet the start values of all variables in model based on its optimized values. For transcription backends, this will create degree interpolation functions for infinite  variables. Note that the Interpolations.jl package must be loaded. This is useful for warmstarts. See also warmstart_backend_start_values to update backend  primal and dual start values efficiently without rebuilding the backend.\n\nExample\n\nusing Interpolations\noptimize!(model)\nset_start_values(model)\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#JuMP.delete-Tuple{InfiniteModel, DecisionVariableRef}","page":"Variables","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.delete to delete InfiniteOpt variables and their dependencies.  Errors if variable is invalid, meaning it has already been deleted or it belongs  to another model.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z â‰¥ 0.0\n g(t) + z â‰¥ 42.0, âˆ€ t âˆˆ [0, 6]\n g(0.5) = 0\n\njulia> delete(model, g)\n\njulia> print(model)\nMin measure(t) + z\nSubject to\n z â‰¥ 0.0\n z â‰¥ 42.0\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#Infinite-3","page":"Variables","title":"Infinite","text":"","category":"section"},{"location":"manual/variable/#InfiniteOpt.constant_over_collocation-Tuple{InfiniteVariableRef, GeneralVariableRef}","page":"Variables","title":"InfiniteOpt.constant_over_collocation","text":"constant_over_collocation(vref::InfiniteVariableRef, pref::GeneralVariableRef)::Nothing\n\nAdds constraints such that vref is constant over internal collocation points  generated within finite elements for pref. This is prinicipally useful for  manipulated variables in control problems that use OrthogonalCollocation. Errors if pref is not a single independent infinite parameter and/or it is not  used by vref.\n\nExample\n\n@infinite_parameter(model, t in [0, 1], deriviative_method = OrthogonalCollocation(3))\n@variable(model, y_state, Infinite(t))\n@variable(model, y_control, Infinite(t))\n@constraint(model, âˆ‚(y_state, t) == y_state^2)\n@constraint(model, y_state(0) == 0)\nconstant_over_collocation(y_control, t)\n\n\n\n\n\n","category":"method"},{"location":"manual/variable/#Semi-Infinite-3","page":"Variables","title":"Semi-Infinite","text":"","category":"section"},{"location":"manual/variable/#JuMP.set_name-Tuple{SemiInfiniteVariableRef, String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing\n\nExtend JuMP.set_name to set names of decision variables.\n\nExample\n\njulia> set_name(vref, \"var_name\")\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"develop/start_guide/#contribute_guide","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"develop/start_guide/","page":"Getting Started","title":"Getting Started","text":"InfiniteOpt is a large project with a lot of opportunity for development. As  such we warmly welcome and encourage contributions. This page serves as the guide  of how to start contributing.","category":"page"},{"location":"develop/start_guide/","page":"Getting Started","title":"Getting Started","text":"Before starting please review our  Code of Conduct.","category":"page"},{"location":"develop/start_guide/#Step-by-Step","page":"Getting Started","title":"Step-by-Step","text":"","category":"section"},{"location":"develop/start_guide/","page":"Getting Started","title":"Getting Started","text":"This section will provide a birds-eye view on how to make a contribution to this  project.","category":"page"},{"location":"develop/start_guide/","page":"Getting Started","title":"Getting Started","text":"So you want to help improve InfiniteOpt, awesome and thank you! Let's walk  through step by step how this should be done.","category":"page"},{"location":"develop/start_guide/","page":"Getting Started","title":"Getting Started","text":"Setup a GitHub account if you do not already have one. Here is the  link to do so.\nSelect a specific task to develop that is well-defined. This can as simple as  correcting/clarifying a documentation page or as involved as implementing a  more efficient data management paradigm. With a task in mind, please start a new  issue here in the  InfiniteOpt repository. Also, this is a good place to find tasks to contribute to by  browsing what open issues are (especially ones with the tag good first issue).  Note that if your proposed contribution corresponds to an existing issue please  do not make a new issue. A guide to using issues in GitHub is located  here.\nFork the InfiniteOpt repository to your GitHub account. Only core  developers have permissions to modify InfiniteOpt directly, thus others need  to fork it which essentially amounts to creating their own linked copy. This is  done by clicking the Fork button in the top left corner on the main repository  page here.\nInstall Git on your computer. Git is an open source version control program  for repositories (it is why GitHub uses the word Git). This is needed to manipulate  the repository (all the package files) locally on your computer. A simple Google  search should indicate how this should be done for your computer. I personally  prefer Git for Windows as a Windows user. \nNow you need to install your forked version of InfiniteOpt in Julia on your  computer. This needs to be done via the dev command in the package manager  so you can edit it. The syntax is as follows:\n(v1.8) pkg> dev https://github.com/username-here/InfiniteOpt.jl\nWe also recommend you install Revise.jl  which is very useful when developing packages in Julia.\nDevelop your contribution. Please follow the style guides featured in the  sections below. A programmatic contribution will involve the following parts:\nediting/adding code to the .jl files in the src (source) directory\nadding a docstring for each public function/datatype\nincluding comments that describe each internal function/datatype\nadding a unit-testing for each function in the appropriate test files in the  test directory\nadding documentation of the new functionality in the appropriate place in the  documentation by adding the files in the docs/src directory.\nThese aspects are detailed further in the sections below.\nCommit and push your changes to your forked repository. This is done via Git  using your preferred interface and one should pull, add, commit, and then push  the changes. Using a bash terminal it would look like this:\nusername@ubuntu:~$ cd repo_directory\nusername@ubuntu:~/repo_directory$ git pull origin master\nusername@ubuntu:~/repo_directory$ git add *\nusername@ubuntu:~/repo_directory$ git commit -m \"insert commit message here\"\nusername@ubuntu:~/repo_directory$ git push origin master\nWe recommend using VsCode as an editor and  as a GUI for interfacing with Git.\nCreate a pull request. Go here  to InfiniteOpt's main page and create a pull request drawing from your forked  repository. A step by step explanation is provided  here.\nMake necessary changes if the tests fail and/or we ask you to make specific  changes. The Codecov tests will ensure every new line of code is tested at least  once with the new test functions and the GitHub Actions CI will ensure that  the tests pass on a range of operating systems and Julia versions.\nThat's it. Once the new additions are ready, we will merge them into the   main repository.\nContribute more by repeating steps 2 and 6-10. Just make sure to update your  forked repository before getting started which can be done as explained  here.  Also, be sure to pull the updated repository unto your computer before getting  started.","category":"page"},{"location":"develop/style/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"","category":"section"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Below we detail the formatting, naming, and organizational styles used in  InfiniteOpt. We kindly ask developers to adhere to these practices in efforts  to foster consistency.","category":"page"},{"location":"develop/style/#File-Organization","page":"Style Guide","title":"File Organization","text":"","category":"section"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Files for InfiniteOpt are principally stored in 5 locations:","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"the base directory ./,\nthe source file directory ./src/,\nthe source code testing directory ./test/,\nthe documentation source file directory ./docs/,\nand the example scripts directory ./examples/.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"The base directory is for certain critical package files such as the README.md file and the CI (virtual testing service) configuration files. Files should NOT  be added or removed from this directory, but may be modified as needed. ","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Naturally, the source directory is where all the source code files are located.  The principal file InfiniteOpt.jl is where the main module is defined, all  source code files are included, and all methods/datatypes/macros are exported. This  file shouldn't contain any function or datatype definitions directly, but rather  should include source files containing such via include(\"file_name.jl\"). Where  possible new datatypes should be defined in datatypes.jl and new methods should  be defined in the appropriate file (e.g., a new parameter method should be  defined in parameters.jl). New files can be added as necessary to help with  organization and to prevent a particular file from becoming too long. Also, note  that any submodule (e.g., TranscriptionOpt) should be defined within its own  sub-directory named after itself.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"The test directory contains all the files in appropriate organization to test  all of the methods, datatypes, and macros defined in the source files. The file  structure here should emulate that of the ./src/ directory since each file  should by systematically tested as described be below in the Unit Tests section.  Here the principle file is runtests.jl which serves as the backbone for all the  unit testing. Again, no explicit tests should be contain in it, but rather  inclusions of test files via include(\"file_name\").","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"The documentation directory follows a particular structure as explained in the  documentation for Documenter.jl. Here the root directory ./docs/ contains  make.jl which is the script that generates the documentation via Documenter.jl.  The Project.toml includes the packages necessary to do this. The ./docs/src/  sub-directory is where source code is stored to build the documentation pages.  When building the documentation locally, a ./docs/build directory will also  appear that stores the built HTML files. However, this directory is not tracked  by Git and any changes here will be ignored.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"The example directory contains scripted use examples of InfiniteOpt. Each  example should be stored in single .jl file where possible. However, other more  complex examples that use multiple files should be stored in an appropriately  named folder.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Please note that all file/folder names should use complete names and avoid  abbreviations where possible unless the abbreviations are unambiguous and common  knowledge. Moreover, names should be lowercase and use underscores between  words: example_file_name.jl.  ","category":"page"},{"location":"develop/style/#Julia-Code","page":"Style Guide","title":"Julia Code","text":"","category":"section"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Here we detail the programmatic style used with InfiniteOpt. This is done in an  effort to make this package intuitive for new-comers and to ease development. This  style closely follows that of JuMP.jl with similar deviations from typical Julia  styles. Please refer to the   JuMP style guide as this  is the style used by InfiniteOpt.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"In addition, we adopt the following practices: ","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"All names should be meaningful and readily identifiable. This is bad:\nx = y2 - cp\nThis is good:\nnew_pizza_cost = old_pizza_cost - discount\nThis will make lines longer, but much more understandable.\nAvoid the use explicit numeric values (i.e., magic numbers): This is bad:\ntax = 0.07 * total_price\nTypically, this will employ the use of constants via const This is good:\nconst TAX_RATE = 0.07\ntax = TAX_RATE * total_price\nExceptions to this rule include the use of 1, 1.0, 0, 0.0, -1, -1.0, Inf, and -Inf.\nWhere possible use eachindex to iterate over an datatype: This is bad:\nfor i in 1:length(A)\n    A[i] = i\nend\nThis is good:\nfor i in eachindex(A)\n    A[i] = i\nend\nAll function arguments and struct elements should be typed.    This is bad:\nstruct MyNewStruct\n    thing1\n    thing2\nend\nThis is good:\nstruct MyNewStruct\n    thing1::Int\n    thing2::String\nend\nType dispatch should be used instead of conditional statements based on type: This is bad:\nfunction my_new_function(arg::AbstractType)\n  if arg isa Type1\n      temp = arg + 1\n  elseif arg isa Type2\n      temp = 0\n  end\n  # do more stuff with temp\n  return temp\nend\nThis is good:\n## Internal dispatch for my_new_function\n# Type1\nfunction _my_internal_function(arg::Type1)\n    return arg + 1\nend\n# Type2\nfunction _my_internal_function(arg::Type2)\n    return 0\nend\n# Fallback\nfunction _my_internal_function(arg::AbstractType)\n    error(\"Unrecognized type...\")\nend\n# Main method\nfunction my_new_function(arg::AbstractType)\n  temp = _my_internal_function(arg)\n  # do more stuff with temp\n  return temp\nend\nFunctions should be built in a modular manner to avoid code repetition and  excessively long function definitions.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"In addition to the above guidelines, contributions should be structured such that  extensions are readily possible without having to rewrite all of the associated  functions. The ability to easily facilitate extensions is a core goal of  InfiniteOpt and this should be kept in mind when developing contributions. ","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"TODO add example.","category":"page"},{"location":"develop/style/#Docstrings-and-Comments","page":"Style Guide","title":"Docstrings and Comments","text":"","category":"section"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Here we discuss the use of Docstrings and comments in InfiniteOpt. All public  functions, macros, and datatypes should have a Docstring. This is enables the  help query tool in Julia and is needed for inclusion in the documentation pages.  For functions and macros the format should follow the form:","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    my_new_function(arg1::Type, [arg2::Type = 0; karg1::Type = 42])::Type\n\nPrecise and concise description of what `my_new_function` does and what it\nreturns (also what will cause it will trigger errors). This is in markdown\nformat.\n\n**Example**\n```julia-repl\njulia> my_new_function(input...)\nexpected_output\n```\n\"\"\"\nfunction my_new_function(arg1::Type, arg2::Type = 0; karg1::Type = 42)\n    return arg1 + arg2 + karg1\nend","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Notice that the function is declared at the top with an ident and the optional  arguments are enclosed within square brackets. This can be spaced over several  lines if there are too many arguments to fit on one line. ","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"For datatypes Docstrings should follow the form:","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    MyNewStruct\n\nPrecise and concise description of what this is.\n\n**Fields**\n- `element1::Type` Description of what this is.\n- `element2::Type` Description of what this is.\n\"\"\"\nstruct MyNewStruct\n    element1::Type\n    element2::Type\nend","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Note that if the struct is parametric and/or has inheritance, this information  should also be shown in the header. For example, we have that  InfOptParameter{T <: AbstractInfiniteSet} <: JuMP.AbstractVariable.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"For more docstring information please visit the Julia documentation  here.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Furthermore, all internal functions and datatypes should have an appropriate  commented description of what they do above them. This should follow the  form:","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"# Description of what _my_internal_function does. Bla Bla Bla Bla Bla Bla Bla\n# Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla.\nfunction _my_internal_function(arg1::Type, arg2::Type)::Type\n    return arg1 + arg2\nend","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Finally, we encourage a healthy usage of comments throughout source code to  enhance its readability. A simple comment before a complex block of code can make  all the difference.","category":"page"},{"location":"develop/style/#Unit-Tests","page":"Style Guide","title":"Unit Tests","text":"","category":"section"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"A nice attribute of InfiniteOpt is that it is near perfect code testing  coverage. This success is due to strictly testing every method and macro rigorously  such that every line is called. This has been very advantageous in detecting  many bugs which can be difficult to anticipate given the quantity of source code.  Thus, tests must be created/updated to cover any new additions/changes in the  ./src/ directory.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"The runtests.jl file serves as the principal backbone for doing this. We use  a nested @testset structure using Test.jl. Please refer to the documentation  here to learn about the relevant  testing macros. The structure typically groups related functions together where  each function/macro/datatype is tested via a @testset that employs a number of  tests via @test that thoroughly test it. This is typically of the form:","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"@testset \"my_new_function\" begin\n    @test my_new_function(input1) == expected_output1\n    @test my_new_function(input2) == expected_output2\n    @test my_new_function(input3) == expected_output3\n    .\n    .\n    .\nend","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Thus, a function's @testset should be updated when the respective function has  been modified. Moreover, a new @testset should be added for each new  function/macro. New function tests should be implemented in an order such that  any other functions/macros they depend on are tested first.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Also, where possible please include comments to explain what is going on.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Please refer to InfiniteOpt/test/ for examples.","category":"page"},{"location":"develop/style/#Documentation-Pages","page":"Style Guide","title":"Documentation Pages","text":"","category":"section"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Documentation in InfiniteOpt is generated via  Documenter.jl. Please refer to  its documentation to learn about how to use it.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"The source markdown files stored in ./docs/src/ are what comprise the source  code for the documentation pages and are principally what should be updated. A  guide for markdown syntax is provided here.  Also, note that Documenter enables unique functionality in addition to this  general guide.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"When a new Docstring is created as described above, it should be included in the  appropriate @docs block on its corresponding manual page. Moreover, content  should be added in an appropriate section (or perhaps in a new section) in the  guide that overviews how to implement the new capabilities in an example driven  fashion. These examples should use jldoctests where possible as well to assess  whether the example code is functional.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Documentation content should be concise and use examples and lists where possible  to provide a more visual guide. Also, we ask that passive voice be avoided.","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"Be sure to test the documentation first locally by running make.jl to check  for problems which may include:","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"unrecognized docstrings\nfailed doctests\nfaulty links\nunrecognized formats\nmissing package dependencies\netc.","category":"page"},{"location":"develop/style/#Case-Study-Examples","page":"Style Guide","title":"Case Study Examples","text":"","category":"section"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"We use Literate.jl to run  the case studies in ./docs/src/examples/ and generate markdown files that are  incorporated into the documentation for the Examples sections. ","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"A new case study example can be added to an appropriate sub-folder of  ./docs/src/examples/ (a new sub-folder can be made if needed). The example file  should be .jl file that uses comments in accordance with Literate.jl's format.  This is exemplified below:","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"# # My Example Name\n# Text to introduce my example...\n\n# ## Background \n# Text that describes the problem we are trying to solve. We can also include \n# latex math like ``x^2`` and math blocks such as:\n# ```math \n# x^2 + y = 1\n# ```\n\n# ## Formulation\n# Text to introduce as needed...\nusing InfiniteOpt, HiGHS # import the needed packages\n\n## This comment type will be part of the code block\nmodel = InfiniteModel(HiGHS.Optimizer) # add side comments to code\n\n# This comment type will be Markdown again, thus breaking up the code block\n@infinite_parameter(model, t in [0, 1], num_supports = 42)\n@variable(model, y >= 0, Infinite(t))\n\noptimize!(model)\n\n## TODO add more code\n\n# ### Maintenance Tests\n# These are here to ensure this example stays up to date. \nusing Test\n@test termination_status(model) == MOI.OPTIMAL\n@test has_values(model)\n## Add more tests as appropriate","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"The above file will then be tested and incorporated into the documentation when  ./docs/make.jl is called. Notice that we also have the \"Maintenance Test\"  section at the end that will be used to run checks to ensure the example script  is working as expected (this helps ensure the documentation is up to date).","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"The above example would produce the following markdown file via Literate.jl:","category":"page"},{"location":"develop/style/","page":"Style Guide","title":"Style Guide","text":"# My Example Name\nText to introduce my example...\n\n## Background\nText that describes the problem we are trying to solve. We can also include\nlatex math like ``x^2`` and math blocks such as:\n```math\nx^2 + y = 1\n```\n\n## Formulation\nText to introduce as needed...\n\n```julia\nusing InfiniteOpt, HiGHS # import the needed packages\n\n# This comment type will be part of the code block\nmodel = InfiniteModel(HiGHS.Optimizer) # add side comments to code\n\n```\n\n```julia\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariables: 0\nDerivatives: 0\nMeasures: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: HiGHS\n```\n\nThis comment type will be Markdown again, thus breaking up the code block\n\n```julia\n@infinite_parameter(model, t in [0, 1], num_supports = 42)\n@variable(model, y >= 0, Infinite(t))\n\noptimize!(model)\n\n# TODO add more code\n```\n\n### Maintenance Tests\nThese are here to ensure this example stays up to date.\n\n```julia\nusing Test\n@test termination_status(model) == MOI.OPTIMAL\n@test has_values(model)\n# Add more tests as appropriate\n```\n\n```\nTest Passed\n```\n\n---\n\n*This page was generated using [Literate.jl](https://github.com/fredrikekre/Literate.jl).*\n\n","category":"page"},{"location":"examples/Optimal Control/consumption_savings/#Consumption-Savings-Problem","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"","category":"section"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"In this case study, a household endowed with B_0 dollars of wealth must decide how much to consume and save to maximize its utility over its finite lifecycle.","category":"page"},{"location":"examples/Optimal Control/consumption_savings/#Formulation","page":"Consumption Savings Problem","title":"Formulation","text":"","category":"section"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"The corresponding dynamic optimization problem is expressed:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"beginaligned\n\tV(B_00) = undersetc(t) B(t)textmax int_t = 0^t=T e^-rho t u(c(t)) dt \n\ttextst \n\t fracdBdt = r times B(t) - c(t)  t in 0T \n   B(0) = B_0 \n   B(T) = 0\nendaligned","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"where the household lives during time t in 0T, the state variable B(t) is the household's stock of wealth at time t, the choice variable c(t) is the household's consumption at time t, r is the interest rate, B_0 is the household's wealth endowment (initial condition), B(T) = 0 is the terminal condition, and T is the time horizon.","category":"page"},{"location":"examples/Optimal Control/consumption_savings/#Model-Definition","page":"Consumption Savings Problem","title":"Model Definition","text":"","category":"section"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Let's implement this in InfiniteOpt and first import the packages we need:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"using InfiniteOpt, Ipopt","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"We set the preference and constraint parameters:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Ï = 0.025  # discount rate\nk = 100.0  # utility bliss point\nT = 10.0   # life horizon\nr = 0.05   # interest rate\nB0 = 100.0 # endowment\nu(c; k=k) = -(c - k)^2       # utility function\ndiscount(t; Ï=Ï) = exp(-Ï*t) # discount function\nBC(B, c; r=r) = r*B - c      # budget constraint","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"BC (generic function with 1 method)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"We set the hyperparameters:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"opt = Ipopt.Optimizer   # desired solver\nns = 1_000;             # number of points in the time grid","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"We initialize the infinite model and choose the Ipopt solver:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"m = InfiniteModel(opt)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"An InfiniteOpt Model\nFeasibility problem with:\n  Finite parameters: 0\n  Infinite parameters: 0\n  Variables: 0\n  Derivatives: 0\n  Measures: 0\nTransformation backend information: \n  Backend type: TranscriptionBackend\n  Solver: Ipopt\n  Transformation built and up-to-date: false\n","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Let's specify our infinite parameter which is time t in 0 T:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"@infinite_parameter(m, t in [0, T], num_supports = ns)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"t","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Now let's specify the variables:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"@variable(m, B, Infinite(t)) ## state variables\n@variable(m, c, Infinite(t)) ## control variables","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"c(t)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Specify the objective:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"@objective(m, Max, integral(u(c), t, weight_func = discount))","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"âˆ«{t âˆˆ [0, 10]}[-c(t)Â² + 200 c(t) - 10000]","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Set the initial/terminal conditions:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"@constraint(m, B(0) == B0)\n@constraint(m, B(T) == 0)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"B(10) = 0","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Set the budget constraint:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"@constraint(m, c1, deriv(B, t) == BC(B, c; r=r))","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"c1 : d/dt[B(t)] - 0.05 B(t) + c(t) = 0, âˆ€ t âˆˆ [0, 10]","category":"page"},{"location":"examples/Optimal Control/consumption_savings/#Problem-Solution","page":"Consumption Savings Problem","title":"Problem Solution","text":"","category":"section"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Optimize the model:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"optimize!(m)\ntermination_status(m)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"LOCALLY_SOLVED::TerminationStatusCode = 4","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Extract the results:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"c_opt = value(c)\nB_opt = value(B)\nts = supports(t)\nopt_obj = objective_value(m) # V(B0, 0)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"-67025.62174598589","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Plot the results:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"using Plots\nix = 2:(length(ts)-1) # index for plotting\nplot(ts[ix],   B_opt[ix], lab = \"B: wealth balance\")\nplot!(ts[ix],  c_opt[ix], lab = \"c: consumption\")","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"<img src=\"data:image/png;base64,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\" />","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"That's it, now we have our optimal trajectory!","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"This very simple problem has a closed form solution:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Î»1 = exp((r)T)\nÎ»2 = exp(-(r-Ï)T)\nden = (Î»1-Î»2)r\nÎ©1 = (k + (r*B0-k)Î»2)/den\nÎ©2 = (k + (r*B0-k)Î»1)/den\nc0 = r*B0 + (r)Î©1 + (r-Ï)Î©2\nBB(t; k=k,r=r,Ï=Ï,Î©1=Î©1,Î©2=Î©2) = (k/r) - Î©1*exp((r)t) + Î©2*exp(-(r-Ï)t)\ncc(t; k=k,r=r,Ï=Ï,c0=c0)       = k + (c0-k)*exp(-(r-Ï)t)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"cc (generic function with 1 method)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Compare the solution given by InfiniteOpt with the closed form:","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"plot(legend=:topright);\nplot!(ts[ix], c_opt[ix], color = 1, lab = \"c: consumption, InfiniteOpt\");\nplot!(ts[ix], cc, color = 1, linestyle=:dash, lab = \"c: consumption, closed form\");\nplot!(ts[ix], B_opt[ix], color = 4, lab = \"B: wealth balance, InfiniteOpt\");\nplot!(ts[ix], BB, color = 4, linestyle=:dash, lab = \"B: wealth balance, closed form\")","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"<img src=\"data:image/png;base64,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Z2P7mQkThIcOHdq+fbvUVaS0w4cPv/baa1JXkdKOHDnyyiuvSF1FSmtra3v55ZelriKltbe3x/wQJEwQAgAAzAYEIQAApDQEIQAApLTZajV6KpxOZ3Nzc1lZ2alsHAgEXC7XKW4MswGHQHLBYNDpdOIQSCgYDDocDhwCCYVCocnJyVM/BJs3b37ggQe+ehvG+SxM7nTKOjs7T72jYSgUUqlUs1oPfDUcAsnhEEgOh0Byp3UIcnJy0tLSvnobiYMQAABAWnhGCAAAKQ1BCAAAKQ1BCAAAKQ1BCAAAKU3K7hNfRhTF559/vqmpqaKi4pZbblEqlSdus3v37u3bt+t0ui1btuTn5899kUlMFMXPP//8448/drlctbW11113nVx+/O/J3r17m5qaZl5+97vfPelhgjP29NNPT09PR5erqqrWrFlz4jY7dux44403zGbzli1bsrOz57bAJDc5OXncgIJr1qypqqo6ds2uXbtmJiEnoltuuQWT7Zy9sbGxffv2DQ0NXXDBBcf2kejr63vmmWd8Pt+1115bX19/4g8Gg8Gnnnqqp6enrq5u8+bNjLFT32k8XhHefffdDz/8cEVFxauvvrpp06YTN/jggw8uvfTSnJyciYmJ+vr68fHxuS8yiTU3N2/ZssXn8+Xl5T344INXXXXVidu8/vrrTz/9dM/fiaI493Umt+9///sHDx6M/vfa7fYTN/jLX/5y9dVXFxQU9Pf3r1ixwu12z32RSWxqamrm17u5ufn22293uVzHbfPKK688++yzM5uhBX5MnHfeef/5n/9577337tu3b2bl6OhofX29y+WyWq0XXXTRjh07TvzBjRs3vvHGGxUVFQ8++OC//Mu/nN5eeZyx2+1paWnd3d2cc7fbrdFoWltbj9vmggsu+O1vfxtdXr9+/a9+9au5rjKphUKh6enp6PLg4CAR9ff3H7fNv/7rv95zzz1zXloKUalUw8PDX7HBypUrt27dGl0+//zzf/e7381JXalo69atCxYsOHH9j3/84/vvv3/u60lu0S+fxYsXb9u2bWblv//7v1911VXR5QcffHDdunXH/VRjY6NOp/N6vZzzI0eOaDQap9N56juNuyvCPXv25ObmlpaWEpFOp1uxYsVx4c85//TTTy+66KLoy4suuuiTTz6RoNDkpVQqBeGLX4xQKMQY02g0J27W0tLyX//1Xy+++KLf75/bAlPFH//4x0ceeWTv3r0nvhUMBvfs2XPhhRdGX+IsmFVPP/30li1bTvpWY2Pjgw8+uG3btmAwOMdVJauZL59j7dix46u/83fs2LFq1aroN1V1dbXZbD72gvLrd3qm1c6W0dFRi8Uy8zIrK2t4ePjYDSYmJqampqxWa/Sl1WodGRmZ0xJTBuf8zjvvvO2220wm03FvZWVlFRYWut3uxx57bMGCBbg7HXNr1qzxeDydnZ2XXHLJv/3bvx337ujoKOd85iw48TSBWGlvbz9w4MCNN9544lu5ubl5eXlOp/Phhx9evHixw+GY+/JSxMjIyEwuWK1Wn8933LOA44LDarWe1hkRd41l5HL5TBsBIgqHw8e1wlAoFEQUiUSiLyORCJppzAbO+Q9/+EO73f7SSy+d+O6dd945s9kFF1zwyCOP/OIXv5jbApPcu+++G13YsmVLfX39D37wg2PP8+POgnA4jEG/ZsnWrVs3bNhw7H/+jHvuuSe6IIrieeed9/vf//7nP//53FaXKuRy+bHf+fT3U+DYDb46OL5a3F0R5ubmDg0NzbwcGhrKzc09dgODwaDRaGa2GRoaysnJmdMSU8NPf/rThoaGd955R6vVfsVmjLFVq1b19PTMWWGpZunSpSqVqq+v79iVWVlZMpkMZ8Fsi0QiL7zwwpfdF50hCMI555yDs2D25OXlzVzhDQ0NmUym44YPzcvLmzkdOOfDw8PHBcdXi7sgXL16dSgU+vzzz4mor6+vqanpkksuIaLh4eGZhyWXX375q6++SkTT09N//vOfN2zYIGHBSem+++776KOP3n77bYPBMLPSbrd/9tln0eVAIBBdmJqaevfdd+fPny9Blclr5r+XiD744ANRFMvLy4loYGBg//79RCSXy9etWxdt3x8Oh19//XWcBbPhzTfflMlkF1988cwam80W/XaiYw5TMBh8//33cRbMnssvv3z79u3R1umvvvrq5ZdfHl2/Z8+e0dFRIrr00ksbGhqijfs++eQTxtiKFStOYwdn3rhn1jz++ONZWVlbtmwpKir6+c9/Hl353//93wsXLowuHzp0yGKxXH/99eeee+6KFSv8fr90xSahXbt2EVFFRUXd3x04cIBz/vrrr1sslug2lZWV69atu/HGG4uLi1etWuXxeCQtOdls27atqqpq06ZNl112mU6ne+KJJ6Lrf/Ob36xcuTK6vH//frPZvHnz5pUrV65Zs2Zqakq6epPW+vXrZ76CorZt21ZQUBBdLi4uXr9+/Q033FBYWLhmzRp8EcXE97///bq6urS0tNLS0rq6un379nHOvV7v0qVL16xZc91112VlZbW3t0c3rqysfOaZZ6LL99xzT0lJyc0335yVlfX000+f1k7jdPaJ1tbW5ubmysrKurq66Jrx8fGxsbEFCxZEX05MTHz44Yd6vX7t2rV4RhhbHo+no6Pj2DVVVVVardbpdPb29tbW1hLR8PDw/v37fT5faWlpfX39afVdha8ViUSampo6Ozt1Ol1dXd3Mbc/R0VGHw1FTUxN9abPZPv74Y6PR+M1vfvPEQQ/g7DU1NZWUlBx7X2RycnJgYGDx4sVENDg4eODAAb/fX15evmzZMunKTCqdnZ3HNoSprKzU6XREFAqFPvroI6/Xe+GFFxqNxui7LS0tOTk5mZmZ0Zd79+7t7u5eunTpcUMffK04DUIAAIC5EXfPCAEAAOYSghAAAFIaghAAAFIaghAAAFIaghAAAFIaghAAAFIaghAAAFIaghAAAFIaghAAAFIaghAAAFIaghAAAFLa/wfwRXgvnBpe6QAAAABJRU5ErkJggg==\" />","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Not bad!","category":"page"},{"location":"examples/Optimal Control/consumption_savings/#Maintenance-Tests","page":"Consumption Savings Problem","title":"Maintenance Tests","text":"","category":"section"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"These are here to ensure this example stays up to date.","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"using Test\ntol = 1E-6\n@test termination_status(m) == MOI.LOCALLY_SOLVED\n@test has_values(m)\n@test B_opt isa Vector{<:Real}\n@test c_opt isa Vector{<:Real}\n@test isapprox(opt_obj, -67025.62174598589, atol=tol)\n@test isapprox(c_opt[end], -52.00096266262752, atol=tol)","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"Test Passed","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"","category":"page"},{"location":"examples/Optimal Control/consumption_savings/","page":"Consumption Savings Problem","title":"Consumption Savings Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/finite_parameter/#finite_param_manual","page":"Finite Parameters","title":"Finite Parameters","text":"","category":"section"},{"location":"manual/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"A technical manual for finite parameters in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/finite_parameter/#Definition","page":"Finite Parameters","title":"Definition","text":"","category":"section"},{"location":"manual/finite_parameter/#InfiniteOpt.@finite_parameter","page":"Finite Parameters","title":"InfiniteOpt.@finite_parameter","text":"@finite_parameter(model::InfiniteModel, value, kwargs...)\n\nDefine and add an anonymous finite parameter to model and return its parameter reference. Its value is equal to value.\n\n@finite_parameter(model::InfiniteModel, param_expr == value_expr, kwargs...)\n\nDefine and add a finite parameter(s) to model and return appropriate parameter reference(s). The parameter(s) has/have value(s) indicated by the value_expr. The expression param_expr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe expression value_expr simply expresses the value of the parameter(s). This is typically a number but could be an array indexed using an index defined in param_expr.\n\nThe recognized keyword arguments in kwargs are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\ncontainer: Specify the container type, defaults to Auto.\n\nExamples\n\njulia> par = @finite_parameter(model, 2)\nnoname\n\njulia> vals = [3, 2];\n\njulia> pars = @finite_parameter(model, [i = 1:2] == vals[i], base_name = \"par\")\n2-element Array{ParameterRef,1}:\n par[1]\n par[2]\n\njulia> @finite_parameter(model, par2 == 42)\npar2\n\n\n\n\n\n","category":"macro"},{"location":"manual/finite_parameter/#InfiniteOpt.FiniteParameter","page":"Finite Parameters","title":"InfiniteOpt.FiniteParameter","text":"FiniteParameter <: ScalarParameter\n\nA DataType for storing finite parameters meant to be nested in expressions and replaced with their values at runtime.\n\nFields\n\nvalue::Float64: The parameter value.\n\n\n\n\n\n","category":"type"},{"location":"manual/finite_parameter/#InfiniteOpt.build_parameter-Tuple{Function, Real}","page":"Finite Parameters","title":"InfiniteOpt.build_parameter","text":"build_parameter(_error::Function, value::Real)::FiniteParameter\n\nReturns a FiniteParameter given the appropriate information. This is analagous to JuMP.build_variable. This is meant to primarily serve as a helper method for @finite_parameter.\n\nExample\n\njulia> build_parameter(error, 1)\nFiniteParameter(1.0)\n\n\n\n\n\n","category":"method"},{"location":"manual/finite_parameter/#InfiniteOpt.add_parameter-Tuple{InfiniteModel, FiniteParameter, String}","page":"Finite Parameters","title":"InfiniteOpt.add_parameter","text":"add_parameter(model::InfiniteModel, p::FiniteParameter,\n              [name::String = \"\"])::GeneralVariableRef\n\nReturns a GeneralVariableRef associated with the parameter p that is  added to model. This adds a parameter to the model in a manner similar to JuMP.add_variable. This is to add parameters with the use of  @finite_parameter.  build_parameter should be used to construct p.\n\nExample\n\njulia> p = build_parameter(error, 42);\n\njulia> param_ref = add_parameter(model, p, \"name\")\nname\n\n\n\n\n\n","category":"method"},{"location":"manual/finite_parameter/#InfiniteOpt.FiniteParameterIndex","page":"Finite Parameters","title":"InfiniteOpt.FiniteParameterIndex","text":"FiniteParameterIndex <: ObjectIndex\n\nA DataType for storing the index of a FiniteParameter.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/finite_parameter/#InfiniteOpt.FiniteParameterRef","page":"Finite Parameters","title":"InfiniteOpt.FiniteParameterRef","text":"FiniteParameterRef <: FiniteRef\n\nA DataType for finite parameters references who are replaced with their values at the transcription step.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::FiniteParameterIndex: Index of the parameter in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/finite_parameter/#Methods","page":"Finite Parameters","title":"Methods","text":"","category":"section"},{"location":"manual/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Many methods are shared with independent infinite parameters since both  finite and independent infinite parameters are scalar. See the infinite  parameter technical manual for the remainder of the  methods available for finite parameters (i.e., any method typed for  ScalarParameterRefs)","category":"page"},{"location":"manual/finite_parameter/#JuMP.parameter_value-Tuple{FiniteParameterRef}","page":"Finite Parameters","title":"JuMP.parameter_value","text":"JuMP.parameter_value(pref::FiniteParameterRef)::Float64\n\nReturn the value of a finite parameter reference pref. Errors if it is an infinite parameter.\n\nExample\n\njulia> value(cost)\n42.0\n\n\n\n\n\n","category":"method"},{"location":"manual/finite_parameter/#JuMP.set_parameter_value-Tuple{FiniteParameterRef, Real}","page":"Finite Parameters","title":"JuMP.set_parameter_value","text":"JuMP.set_parameter_value(pref::FiniteParameterRef, value::Real)::Nothing\n\nSet the value of pref so long as it is a finite parameter. Errors if it is an infinite parameter. This attempts to update the transformation backend if it is in sync with the current InfiniteModel associated with pref.\n\nExample\n\njulia> set_parameter_value(cost, 27)\n\njulia> parameter_value(cost)\n27.0\n\n\n\n\n\n","category":"method"},{"location":"manual/finite_parameter/#InfiniteOpt.used_by_objective-Tuple{FiniteParameterRef}","page":"Finite Parameters","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(pref::FiniteParameterRef)::Bool\n\nReturn true if pref is used by the objective function.\n\nExample\n\n\n\n\n\n\n\n","category":"method"},{"location":"manual/finite_parameter/#InfiniteOpt.core_object-Tuple{FiniteParameterRef}","page":"Finite Parameters","title":"InfiniteOpt.core_object","text":"core_object(pref::FiniteParameterRef)::FiniteParameter\n\nRetrieve the underlying core [FiniteParameter] object for pref.  This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"guide/derivative/#deriv_docs","page":"Derivatives","title":"Derivative Operators","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"A guide for derivatives in InfiniteOpt. See the respective  technical manual for more details.","category":"page"},{"location":"guide/derivative/#Overview","page":"Derivatives","title":"Overview","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Derivative operators commonly arise in many infinite-dimensional problems,  particularly in dynamic and PDE-constrained optimization. InfiniteOpt.jl provides  a simple yet powerful interface to model these objects for derivatives of any order,  including partial derivatives. Derivatives can be used in defining measures and  constraints. ","category":"page"},{"location":"guide/derivative/#Basic-Usage","page":"Derivatives","title":"Basic Usage","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Derivative operators can be defined a few different ways in InfiniteOpt. To motivate  these, let's first define an InfiniteModel along with some parameters and variables:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> using InfiniteOpt, Distributions;\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10], \n                           derivative_method = OrthogonalCollocation(3));\n\njulia> @infinite_parameter(model, Î¾ ~ Uniform(-1, 1));\n\njulia> @infinite_parameter(model, x in [-1, 1]);\n\njulia> @variable(model, y, Infinite(t, x, Î¾));\n\njulia> @variable(model, q, Infinite(t));","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Notice that we used the derivative_method keyword argument to specify which  numerical method will be used to evaluate any derivatives that depend on that  infinite parameter t. In this case we, specified to use orthogonal collocation  over finite elements using 3 nodes. We'll come back to this just a little further  below to more fully describe the various methods we can use. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"First, let's discuss how to define derivatives in InfiniteOpt.jl. Principally,  this is accomplished via deriv which will operate on a particular  InfiniteOpt expression (containing parameters, variables, and/or measures) with  respect to infinite parameters specified with their associated orders. Behind the  scenes all the appropriate calculus will be applied, creating derivative variables  as needed. For example, we can define the following:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> d1 = deriv(y, t)\nâˆ‚/âˆ‚t[y(t, x, Î¾)]\n\njulia> d2 = âˆ‚(y, t, x)\nâˆ‚/âˆ‚x[âˆ‚/âˆ‚t[y(t, x, Î¾)]]\n\njulia> d3 = @âˆ‚(q, t^2) # the macro version allows the `t^2` syntax\ndÂ²/dtÂ²[q(t)]\n\njulia> d_expr = deriv(y * q - 2t, t)\nâˆ‚/âˆ‚t[y(t, x, Î¾)]*q(t) + d/dt[q(t)]*y(t, x, Î¾) - 2","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Thus, we can define derivatives in a variety of forms according to the problem at  hand. The last example even shows how the product rule is correctly applied.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"note: Note\nFor convenience in making more compact code we provide âˆ‚  as an alias for deriv.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"note: Note\nDerivatives taken with respect to dependent infinite parameters are not supported.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Also, notice that the appropriate symbolic calculus is applied to infinite  parameters. For example, we could also compute:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> deriv(3t^2 - 2t, t)\n6 t - 2","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Conveniently, @deriv can be called within any measure and constraint. However,  in certain cases we may need to define an initial guess (initial guess trajectory).  This can be accomplished in 2 ways:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Call set_start_value  using the individual derivative (e.g., d1 above)\nDefine the derivative using @variable with the Deriv variable type  object and use the start keyword argument.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"In either case, a single value can be given or a start value function that will generate a value in accordance with the support values (i.e., following the same  syntax as infinite variables). For example, we can specify the starting value of  d1 to 0 via the following:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> set_start_value(d1, 0)","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Now let's return to our discussion on derivative evaluation methods. These are the  methods that can/will be invoked to transcript (i.e., discretize) the derivatives  when solving the model. The methods native to InfiniteOpt are described in the  table below:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Method Type Needed Boundary Conditions Creates Supports Derivative Orders\nFiniteDifference Forward Final & optional Initial No Any\nFiniteDifference Central Initial & Final No 1, 2, 4, 6, ...\nFiniteDifference Backward Initial & optional Final No Any\nOrthogonalCollocation GaussLobatto Initial Yes 1","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Here, the default method is backward finite difference. These are enforced on an  infinite parameter basis (i.e., the parameter the differential operator is taken  with respect to). Unlike, FiniteDifference which directly handles derivatives of  any order, OrthogonalCollocation is limited to 1st order derivatives and higher  order derivatives are automatically reformulated into a system of 1st order derivatives. In the above examples, any derivatives taken with respect to t will use orthogonal collocation on  finite elements since that is what we specified as our derivative method. More  information is provided in the Derivative Methods Section below. However, we  note here that set_derivative_method can be invoked anytime after parameter  definition to specify/modify the derivative method used. More conveniently, we can call  set_all_derivative_methods:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> set_all_derivative_methods(model, FiniteDifference(Forward()))\n","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"note: Note\nWhen OrthogonalCollocation is used, additional degrees of freedom can be  artificially introduced to infinite variables that share the same infinite parameter.  For instance, this occurs with control variables in optimal control problems. To address  this, constant_over_collocation  should be called on the appropriate variables. For example:@infinite_parameter(model, t in [0, 1], derivative_method = OrthogonalCollocation(3))\n@variable(model, y_state, Infinite(t))\n@variable(model, y_control, Infinite(t))\n@constraint(model, âˆ‚(y_state, t) == y_state^2)\n@constraint(model, y_state(0) == 0)\nconstant_over_collocation(y_control, t)\n\n# output\nwhere we use constant_over_collocation to hold y_control constant over each finite  element (i.e., constant for each internal collocation point). ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"warning: Warning\nInfiniteOpt does not ensure proper boundary conditions are provided by the  user. Thus, it is imperative that the user ensure these are provided appropriately  with the derivative evaluation method that is used. We recommend specifying  such conditions via a constraint that uses Restricted Variables. For  example:@constraint(model, initial_condition, y(0) == 42)","category":"page"},{"location":"guide/derivative/#Advanced-Definition","page":"Derivatives","title":"Advanced Definition","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"This section will detail the inner-workings and more advanced details behind  defining derivatives in InfiniteOpt.","category":"page"},{"location":"guide/derivative/#Manual-Definition","page":"Derivatives","title":"Manual Definition","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"The workflow for derivative definition mirrors that of variable definition as  summarized in the following steps:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Define the variable information via a JuMP.VariableInfo.\nBuild the derivative using build_derivative.\nAdd the derivative to the model via add_derivative.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"To exemplify this process, let's first define appropriate variable information:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> info = VariableInfo(true, 0., true, 42., false, 0., false, 0., false, false);","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"More detailed information on JuMP.VariableInfo is provided in the  Variable Definition Methodology section. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"warning: Warning\nInstances of JuMP.VariableInfo used to define derivatives should have  info.binary = false and info.integer = false, since most derivative  evaluation methods require that derivatives be continuous.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Now that we have our variable information we can make a derivative using  build_derivative:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> d = build_derivative(error, info, y, x, 1);\n\njulia> d isa Derivative\ntrue","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Here the argument variable can be an infinite variable, semi-infinite variable,  derivative, or measure that depends on the infinite parameter provided. This will  error to the contrary.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Now we can add the derivative to the model via add_derivative which  will add the Derivative object and return GeneralVariableRef pointing  to it that we can use in InfiniteOpt expressions:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> dref = add_derivative(model, d)\nâˆ‚/âˆ‚x[y(t, x, Î¾)]","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"This will also create any appropriate information based constraints (e.g., lower  bounds).","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Finally, we note that higher order derivatives by changing the order argument:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> d = build_derivative(error, info, y, x, 3); # 3rd order derivative","category":"page"},{"location":"guide/derivative/#Macro-Definition","page":"Derivatives","title":"Macro Definition","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"There are two macros we provide for defining derivatives:  @variable  that uses the Deriv variable type and @deriv. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"First, @variable simply automates the process described above in a manner  inspired the by the syntax of the variable macros. As such it will support all  the same keywords and constraint syntax used with the variable macros. For  example, we can define the derivative  fracpartial^2 y(t xi)partial t^2 while enforcing a lower bound  of 1 with an initial guess of 0 and assign it to an alias  GeneralVariableRef called dydt2:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> @variable(model, dydt2 >= 1, Deriv(y, t, 2), start = 0)\ndydt2(t, x, Î¾)","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"This will also support anonymous definition and multi-dimensional definition.  Please see Macro Variable Definition for more information.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"warning: Warning\nThe same derivative should not be redefined with multiple @variable calls  and using @variable to define derivatives should be avoided on derivatives  that were already defined. This is because the latest @variable call will  overwrite any existing properties a derivative might already have. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Second, for more convenient definition we use @deriv (or @âˆ‚)  as shown in the Basic Usage section above. Unlike @variable this can handle any  InfiniteOpt expression as the argument input (except for general nonlinear  expressions). It also can build derivatives that depend on multiple infinite  parameters and/or are taken to higher orders. This is accomplished via recursive  derivative definition, handling the nesting as appropriate. For example, we can  \"define\" fracpartial^2 y(t xi)partial t^2 again:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> @deriv(d1, t) # recall `d1 = deriv(y, t)`\ndydt2(t, x, Î¾)\n\njulia> @deriv(y, t^2)\ndydt2(t, x, Î¾)","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Notice that the derivative references all point to the same derivative object we  defined up above with its alias name dydt2. This macro can also tackle complex  expressions using the appropriate calculus such as:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> @deriv(âˆ«(y, Î¾) * q, t)\nd/dt[âˆ«{Î¾ âˆˆ [-1, 1]}[y(t, x, Î¾)]]*q(t) + d/dt[q(t)]*âˆ«{Î¾ âˆˆ [-1, 1]}[y(t, x, Î¾)]","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Thus, demonstrating the convenience of using @deriv.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"With all this in mind, we recommend using @deriv as the defacto method, but  then using @variable as a convenient way to specify bounds and an initial guess  value/trajectory. ","category":"page"},{"location":"guide/derivative/#Derivative-Evaluation","page":"Derivatives","title":"Derivative Evaluation","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"In this section, we detail how derivatives are evaluated in InfiniteOpt to then  be used in reformulating the model for solution. ","category":"page"},{"location":"guide/derivative/#Theory","page":"Derivatives","title":"Theory","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"To motivate the principles behind numerical derivative evaluation/transcription,  let's first consider the initial value problem:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"fracd y(t)dt = f(t y(t))    y(t_0) = y_0","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"With a finite support set t_0 t_1 dots t_k we can numerically  approximate the value of fracd y(t_n)dt at each time point t_n via  the Euler method (i.e., forward finite difference). We thus obtain a system of  equations:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"beginaligned\n y(t_n+1) = y(t_n) + (t_n+1 - t_n) fracd y(t_n)dt  forall n = 0 dots k-1\n fracd y(t_n)dt = f(t_n y(t_n))  forall n = 0 dots k  \n y(t_0) = y_0\nendaligned","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Thus, we obtain 3 sets of equations: ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"constraint transcriptions\nauxiliary derivative equations \nboundary conditions. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"In the case above, we could reduce the number of equations by substituting out the  point derivatives in the constraint transcriptions since we have explicit  relationships in the auxiliary equations. However, this is not possible in general,  such as when we encounter more complex partial differential equations. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Thus, in InfiniteOpt derivatives are treated as variables which can be contained  implicitly in constraints and/or measures. This allows us to support implicit  dependencies and higher order derivatives. This means that when the model is  reformulated, its constraints and measures can be reformulated as normal  (treating any derivative dependencies as variables). We then can apply the  appropriate derivative evaluation technique to derive the necessary set of  auxiliary derivative equations to properly characterize the derivative variables.  This can be formalized as:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"beginaligned\n f_j(y(lambda) Dy(lambda)) leq 0  forall j in J lambda in Lambda \n h_i(y(lambda) Dy(lambda)) = 0  forall i in I lambda in Lambda \n g_k(y(hatlambda) Dy(hatlambda)) = 0  forall k in K hatlambda in hatLambda\nendaligned","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"where y(lambda) and Dy(lambda) denote all the variables and derivatives  in the problem and lambda denote all the problem's infinite parameters.  With this let the constraints f_j denote the problem constraints which can  contain any variables, parameters, derivatives, and/or measures associated with  the problem. The constraints h_i denote the auxiliary derivative equations  formed by the appropriate numerical method to implicitly define the behavior of  the derivative variables present in f_j. Finally, the necessary boundary  conditions are provided in the constraints g_k.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Note that this general paradigm captures a wide breadth of problems and  derivative evaluation techniques. Higher order derivatives are dealt with in one of  two ways:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Auxiliary equations are derived directly if the selected derivative method  supports higher orders.\nThey are reformulated into a system of 1st order derivatives and then auxiliary  equations are derived for each 1st order derivative. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"For example, consider the second-order partial derivative:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"fracpartial^2 y(t x)partial x^2","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"We can directly derive auxiliary equations using 2nd order central finite difference:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"fracpartial^2 y(t x_n)partial x^2 = fracy(t x_n+1) - 2y(t x_n) + y(t x_n-1)(x_n+1 - x_n)(x_n - x_n-1)  forall t in mathcalD_t n = 1 dots k-1","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Where possible, InfiniteOpt favors this approach. For derivative methods that do not support higher orders, we can reformulate the derivative into nested 1st derivatives:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"fracpartial^2 y(t x)partial x^2 = fracpartial partial xleft(fracpartial y(t x)partial xright)","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Then we can obtain auxiliary equations for each derivative, let's use forward finite difference for the sake of variety:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"beginaligned\n y(t x_n+1) = y(t x_n) + (x_n+1 - x_n) fracpartial y(t x_n)partial x  forall x in mathcalD_x n = 0 dots k-1\n fracpartial y(t x_n+1)partial x = fracpartial y(t x_n)partial x + (x_n+1 - x_n) fracpartial^2 y(t x_n)partial x^2  forall x in mathcalD_x n = 0 dots k-1\nendaligned","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"In the section below we detail the derivative evaluation methods that InfiniteOpt  natively implements.","category":"page"},{"location":"guide/derivative/#Derivative-Methods","page":"Derivatives","title":"Derivative Methods","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"As discussed briefly above in the Basic Usage section, we natively employ 4  derivative methods in InfiniteOpt (see the table in that section for a summary).","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"These methods are defined in association with individual infinite parameters and  will be applied to any derivatives that are taken with respect to that parameter.  These methods are specified via the derivative_method keyword argument in the  @infinite_parameter macro and can also be defined by invoking  set_derivative_method or set_all_derivative_methods:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> set_derivative_method(t, FiniteDifference(Forward()))\n","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"In this example, we set t's derivative evaluation method to use central finite  difference. This will also reset any changes that were made with the old method  (e.g., removing old collocation points). Now let's describe the ins and outs of  these methods.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"The first class of methods pertain to finite difference techniques. The syntax  for specifying these techniques is described in FiniteDifference and  exemplified here:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> FiniteDifference(Forward(), true)\nFiniteDifference{Forward}(Forward(), true)","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"where the first argument indicates the type of finite difference we wish to employ  and the second argument indicates if this method should be enforced on boundary  points. By default, we have FiniteDifference(Backward(), true) which is the default  for all infinite parameters. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Forward finite difference (i.e., explicit Euler) is exemplified by approximating first  order derivative fracd y(t)dt via ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"y(t_n+1) = y(t_n) + (t_n+1 - t_n)fracd y(t_n)dt  forall n = 0 1 dots k-1","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Note that in this case, the boundary relation corresponds to n = 0 and would  be included if we set FiniteDifference(Forward(), true) or would be excluded if we  let the second argument be false. We recommend, selecting false when an initial  condition is provided. Also, note that a terminal condition should be provided  when using this method since an auxiliary equation for the derivative at the  terminal point cannot be made. Thus, if a terminal condition is not given terminal  point derivative will be a free variable.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Central finite difference is exemplified by approximating the first order derivative  fracd y(t)dt via","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"y(t_n+1) = y(t_n-1) + (t_n+1 - t_n-1)fracd y(t_n)dt  forall n = 1 2 dots k-1","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Note that this form cannot be invoked at n = 0 or n = k and cannot have an equation at either boundary. With this in mind the syntax is FiniteDifference(Central())  where the second argument is omitted since it doesn't apply to this scheme. As a  result both initial and terminal conditions should be specified otherwise the  derivatives at those points will be free variables.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Backward finite difference (i.e., implicit Euler) is our last (and default)  finite difference method and is exemplified by approximating the first order  derivative fracd y(t)dt via","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"y(t_n) = y(t_n-1) + (t_n - t_n-1)fracd y(t_n)dt  forall n = 1 2 dots k","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Here the boundary case corresponds to n = k and would be included if we set  FiniteDifference(Backward(), true) (the default) or excluded if we set the second  argument to false. We recommend, selecting false when a terminal condition is  provided. Also, note that an initial condition should always be given otherwise  the derivative at the first point will be free.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"All the above explanations highlight using finite difference on 1st order  derivatives, but  higher orders are also supported.  Forward and Backward approaches can directly handle derivatives  of arbitrary order. Whereas, Central 1st order derivatives and higher  even orders (i.e., odd orders greater than 1 are not supported). When using  higher order derivatives, it is important to include the necessary boundary  conditions which often involve lower order derivatives.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Finally, we employ orthogonal collocation on finite elements via the  OrthogonalCollocation object (please refer to it in the manual for  complete syntax details). In general terms, this technique fits an m degree  polynomial to each finite element (i.e., sequential support pair) and this fit is  done via m+1 collocation nodes (supports) which include the finite element  supports along with m-1 additional internal collocation nodes chosen at  orthogonal points to the polynomial. The typical syntax for specifying this method  is OrthogonalCollocation(num_nodes) where num_nodes indicates the number  collocation nodes to be used for each finite element. For example, we can specify  to use 3 collocation nodes (i.e., 1 internal node per finite element) corresponding  to a 2nd degree polynomial via","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> OrthogonalCollocation(3)\nOrthogonalCollocation{GaussLobatto}(3, GaussLobatto())","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Notice that the 2nd attribute is GaussLobatto which indicates that we are using  collocation nodes selected via Lobatto quadrature. This is currently the only  supported technique employed by OrthogonalCollocation although more may be added  in future versions. Please note that an initial condition must be provided otherwise  the corresponding derivative will be free variable. For more information on  orthogonal collocation over finite elements, this  page provides a  good reference.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"note: Note\nOrthogonalCollocation only provides direct support for 1st order  derivatives. Higher order derivatives are reformulated by nesting 1st order  derivatives that are each reformulated using orthogonal collocation.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"The addition of internal collocation supports by OrthogonalCollocation will increase  the degrees of freedom for infinite variables that are not used by derivatives (e.g.,  control variables). To prevent this, we use constant_over_collocation on any  such infinite variables to hold them constant over internal collocation nodes. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Other methods can be employed via user-defined extensions. Please visit our  Extensions page for more information.","category":"page"},{"location":"guide/derivative/#User-Invoked-Evaluation","page":"Derivatives","title":"User-Invoked Evaluation","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Typically, derivative evaluation is handled when the model is reformulated in such  a way that the InfiniteModel is unmodified such that modifications and repeated  solutions can be done efficiently and seamlessly. This is also the recommended  workflow. However, we do provide user accessible derivative evaluation methods  that generate the auxiliary derivative equations and add them to the InfiniteModel. This can be useful for visualizing how these techniques work and can be helpful for  user-defined reformulation extensions (i.e., transformation backend extensions).","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"We can build these relations for a particular derivative via evaluate.  For example, let's build evaluation equations for d1:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> d1 \nâˆ‚/âˆ‚t[y(t, x, Î¾)]\n\njulia> fill_in_supports!(t, num_supports = 5) # add supports first\n\njulia> evaluate(d1)\n\njulia> derivative_constraints(d1)\n4-element Vector{InfOptConstraintRef}:\n 2.5 âˆ‚/âˆ‚t[y(t, x, Î¾)](0, x, Î¾) + y(0, x, Î¾) - y(2.5, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n 2.5 âˆ‚/âˆ‚t[y(t, x, Î¾)](2.5, x, Î¾) + y(2.5, x, Î¾) - y(5, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n 2.5 âˆ‚/âˆ‚t[y(t, x, Î¾)](5, x, Î¾) + y(5, x, Î¾) - y(7.5, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n 2.5 âˆ‚/âˆ‚t[y(t, x, Î¾)](7.5, x, Î¾) + y(7.5, x, Î¾) - y(10, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Note that we made sure t had supports first over which we could carry out the  evaluation, otherwise an error would have been thrown. Moreover, once the  evaluation was completed we were able to access the auxiliary equations via  derivative_constraints. ","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"We can also, add the necessary auxiliary equations for all the derivatives in the  model if we call evaluate_all_derivatives!:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> fill_in_supports!(x, num_supports = 4) # add supports first\n\njulia> evaluate_all_derivatives!(model)\n\njulia> derivative_constraints(dydt2)\n3-element Vector{InfOptConstraintRef}:\n 6.25 dydt2(0, x, Î¾) - y(0, x, Î¾) + 2 y(2.5, x, Î¾) - y(5, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n 6.25 dydt2(2.5, x, Î¾) - y(2.5, x, Î¾) + 2 y(5, x, Î¾) - y(7.5, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n 6.25 dydt2(5, x, Î¾) - y(5, x, Î¾) + 2 y(7.5, x, Î¾) - y(10, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Finally, we note that once derivative constraints have been added to the  InfiniteModel any changes to the respective infinite parameter sets, supports,  or derivative method will necessitate the deletion of these auxiliary constraints  and a warning will be thrown to indicate such:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> derivative_constraints(d1)\n4-element Vector{InfOptConstraintRef}:\n 2.5 âˆ‚/âˆ‚t[y(t, x, Î¾)](0, x, Î¾) + y(0, x, Î¾) - y(2.5, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n 2.5 âˆ‚/âˆ‚t[y(t, x, Î¾)](2.5, x, Î¾) + y(2.5, x, Î¾) - y(5, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n 2.5 âˆ‚/âˆ‚t[y(t, x, Î¾)](5, x, Î¾) + y(5, x, Î¾) - y(7.5, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n 2.5 âˆ‚/âˆ‚t[y(t, x, Î¾)](7.5, x, Î¾) + y(7.5, x, Î¾) - y(10, x, Î¾) = 0, âˆ€ Î¾ ~ Uniform, x âˆˆ [-1, 1]\n\njulia> add_supports(t, 0.2)\nâ”Œ Warning: Support/method changes will invalidate existing derivative evaluation constraints that have been added to the InfiniteModel. Thus, these are being deleted.\nâ”” @ InfiniteOpt ~/work/infiniteopt/InfiniteOpt.jl/src/scalar_parameters.jl:807\n\njulia> has_derivative_constraints(d1)\nfalse","category":"page"},{"location":"guide/derivative/#Query-Methods","page":"Derivatives","title":"Query Methods","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Here we describe the various query techniques that we can employ on derivatives  in InfiniteOpt.","category":"page"},{"location":"guide/derivative/#Basic-Queries","page":"Derivatives","title":"Basic Queries","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"First, let's overview the basic object inquiries: derivative_argument,  operator_parameter, derivative_order,  derivative_method, and name:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> derivative_argument(dydt2) # get the variable the derivative operates on\ny(t, x, Î¾)\n\njulia> operator_parameter(dydt2) # get the parameter the operator is taken with respect to\nt\n\njulia> derivative_order(dydt2) # get the order of the derivative\n2\n\njulia> derivative_method(dydt2) # get the numerical derivative evaluation method\nFiniteDifference{Forward}(Forward(), true)\n\njulia> name(dydt2) # get the name if there is one\n\"dydt2\"","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"These all work as exemplified above. We note that derivative_method simply  queries the derivative method associated with the operator parameter.","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Derivatives also inherit all the usage methods employed by infinite variables.  For example:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> is_used(d1)\ntrue\n\njulia> used_by_measure(dydt2)\nfalse\n\njulia> used_by_semi_infinite_variable(d2)\ntrue","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Also, since derivatives are analogous to infinite variables, they inherit many  of the same queries including parameter_refs:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> parameter_refs(d1)\n(t, x, Î¾)\n\njulia> parameter_refs(derivative_argument(d1))\n(t, x, Î¾)","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Since derivatives simply inherit their infinite parameter dependencies from the  argument variable, the above lines are equivalent.","category":"page"},{"location":"guide/derivative/#Variable-Information","page":"Derivatives","title":"Variable Information","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Again, since derivatives are essentially a special case of infinite variables, they  inherit all the same methods for querying variable information. For example,  consider the following queries:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> has_lower_bound(dydt2)\ntrue\n\njulia> lower_bound(dydt2)\n1.0\n\njulia> LowerBoundRef(dydt2)\ndydt2(t, x, Î¾) â‰¥ 1, âˆ€ t âˆˆ [0, 10], Î¾ ~ Uniform, x âˆˆ [-1, 1]\n\njulia> has_upper_bound(dydt2)\nfalse \n\njulia> func = start_value(dydt2);","category":"page"},{"location":"guide/derivative/#Model-Queries","page":"Derivatives","title":"Model Queries","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"We can also determine the number of derivatives a model contains and obtain a list  of them via num_derivatives and all_derivatives, respectively:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> num_derivatives(model)\n7\n\njulia> all_derivatives(model)\n7-element Vector{GeneralVariableRef}:\n âˆ‚/âˆ‚t[y(t, x, Î¾)]\n âˆ‚/âˆ‚x[âˆ‚/âˆ‚t[y(t, x, Î¾)]]\n dÂ²/dtÂ²[q(t)]\n d/dt[q(t)]\n âˆ‚/âˆ‚x[y(t, x, Î¾)]\n dydt2(t, x, Î¾)\n âˆ‚/âˆ‚t[âˆ«{Î¾ âˆˆ [-1, 1]}[y(t, x, Î¾)]]","category":"page"},{"location":"guide/derivative/#Modification-Methods","page":"Derivatives","title":"Modification Methods","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"In this section, we'll highlight some of the modification methods that can be  used on derivatives in InfiniteOpt.","category":"page"},{"location":"guide/derivative/#Variable-Information-2","page":"Derivatives","title":"Variable Information","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"As discussed above, derivatives inherit the same variable methods as infinite  variables. Thus, we can modify/delete bounds and starting values for derivatives  using the same methods. For example:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> set_lower_bound(dydt2, 0)\n\njulia> lower_bound(dydt2)\n0.0\n\njulia> set_upper_bound(dydt2, 2)\n\njulia> upper_bound(dydt2)\n2.0\n\njulia> fix(dydt2, 42, force = true)\n\njulia> fix_value(dydt2) \n42.0\n\njulia> set_start_value(dydt2, (t, x, xi) -> t + x+ xi)\n\njulia> unfix(dydt2)\n","category":"page"},{"location":"guide/derivative/#Deletion","page":"Derivatives","title":"Deletion","text":"","category":"section"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Finally, there are 2 deletion methods we can employ apart from deleting variable  information. First, we can employ delete_derivative_constraints to  delete any derivative evaluation constraints associated with a particular  derivative:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> delete_derivative_constraints(d2)\n\njulia> has_derivative_constraints(d2)\nfalse","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"Lastly, we can employ delete to delete a particular derivative and all its  dependencies:","category":"page"},{"location":"guide/derivative/","page":"Derivatives","title":"Derivatives","text":"julia> delete(model, d2)\n\njulia> is_valid(model, d2)\nfalse","category":"page"},{"location":"guide/optimize/#opt_docs","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"A guide for optimizing (solving) InfiniteOpt models. See the respective  technical manual for more details.","category":"page"},{"location":"guide/optimize/#Overview","page":"Optimization","title":"Overview","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"InfiniteOpt offers a general and intuitive platform to optimize infinite  optimization models. This is accomplished by applying a transformation to  build a transformation backend that can be solved. By default, this is done via a  TranscriptionBackend as described on the previous page. However, user-defined  reformulation strategies can readily be implemented as described in the  Transformation Backends section on the extensions page. ","category":"page"},{"location":"guide/optimize/#Basic-Usage","page":"Optimization","title":"Basic Usage","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"For most users, optimize! is the only  method required to optimize an InfiniteModel. This is exactly analogous  to that of any JuMP.Model and is designed to provide a similar user experience.  Let's first define an InfiniteModel with an appropriate optimizer:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> using InfiniteOpt, Ipopt;\n\njulia> model = InfiniteModel(Ipopt.Optimizer);\n\njulia> set_attribute(model, \"print_level\", 0);\n\njulia> @infinite_parameter(model, t in [0, 10], num_supports = 10);\n\njulia> @variable(model, y >= 0, Infinite(t));\n\njulia> @variable(model, z >= 0);\n\njulia> @objective(model, Min, 2z);\n\njulia> @constraint(model, c1, z >= y);\n\njulia> @constraint(model, c2, y(0) == 42);\n\njulia> print(model)\nMin 2 z\nSubject to\n y(t) â‰¥ 0, âˆ€ t âˆˆ [0, 10]\n z â‰¥ 0\n c1 : z - y(t) â‰¥ 0, âˆ€ t âˆˆ [0, 10]\n c2 : y(0) = 42","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Now we optimize the model using optimize!:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> optimize!(model);\n\njulia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Now our model has been solved, and we can query the solution. How to query the  solution is explained on the Results page.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"If no optimizer has been specified for the transformation backend, one can be provided  via set_optimizer:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_optimizer(model, Ipopt.Optimizer)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"note: Note\nFor effective resolves,  warmstart_backend_start_values provides a convenient and efficient way to update the start values used by the backend using a previous solution stored in the backend.optimize!(model)\nwarmstart_backend_start_values(model)\nset_parameter_value(p, 42)\noptimize!(model)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"A number of methods also exist to adjust the optimizer settings such as  suppressing output. This is explained below in the  Optimizer Settings section.","category":"page"},{"location":"guide/optimize/#opt_transform_backends","page":"Optimization","title":"Transformation Backends","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"As discussed previously, InfiniteModels contain a transformation backend to  store and solve a transformed version of the model. This backend typically contains a data object (that stores a mapping between the transformed model and  the infinite model). By default, a TranscriptionBackend is used which creates  a discretized JuMP.Model. This transformation backend is used to optimize the  infinite model, and it provides the information exacted by solution queries  mapped back to the infinite model using the mapping data structure.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"The process for optimizing an InfiniteModel is summarized in the following  steps:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"fully define the InfiniteModel\nbuild the transformation backend via build_transformation_backend!\noptimize the transformation_backend via optimize!.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Here, build_transformation_backend! empties any existing backend information via  empty!, creates a reformulated  of the InfiniteModel, stores it in in-place, and indicates that the transformation  backend is ready via set_transformation_backend_ready. These steps are all  automated when optimize! is invoked on the  InfiniteModel.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"The transformation_backend can be queried/extracted at any time from an InfiniteModel  via transformation_backend and its underlying model (if there is one) is extracted via transformation_model. For example,  let's extract the transformation backend from the example above in the basic usage section: ","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> backend = transformation_backend(model)\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: Ipopt\nâ”œ objective_sense: MIN_SENSE\nâ”‚ â”” objective_function_type: AffExpr\nâ”œ num_variables: 11\nâ”œ num_constraints: 22\nâ”‚ â”œ AffExpr in MOI.EqualTo{Float64}: 1\nâ”‚ â”œ AffExpr in MOI.GreaterThan{Float64}: 10\nâ”‚ â”” VariableRef in MOI.GreaterThan{Float64}: 11\nâ”” Names registered in the model: none\n\njulia> tmodel = transformation_model(model)\nA JuMP Model\nâ”œ solver: Ipopt\nâ”œ objective_sense: MIN_SENSE\nâ”‚ â”” objective_function_type: AffExpr\nâ”œ num_variables: 11\nâ”œ num_constraints: 22\nâ”‚ â”œ AffExpr in MOI.EqualTo{Float64}: 1\nâ”‚ â”œ AffExpr in MOI.GreaterThan{Float64}: 10\nâ”‚ â”” VariableRef in MOI.GreaterThan{Float64}: 11\nâ”” Names registered in the model: none","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"The JuMP variable(s) stored in the transformation backend that correspond to a  particular InfiniteOpt variable can be queried via  transformation_variable.  Thus, using the going example we get:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> transformation_variable(y) # infinite variable\n10-element Vector{VariableRef}:\n y(0.0)\n y(1.11111111111)\n y(2.22222222222)\n y(3.33333333333)\n y(4.44444444444)\n y(5.55555555556)\n y(6.66666666667)\n y(7.77777777778)\n y(8.88888888889)\n y(10.0)\n\njulia> transformation_variable(z) # finite variable\nz","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"In like manner, we get the JuMP constraints corresponding to a particular  InfiniteOpt constraint via  transformation_constraint.  Thus, using going example we get: ","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> transformation_constraint(c1) # infinite constraint\n10-element Vector{ConstraintRef}:\n c1[1] : z - y(0.0) â‰¥ 0\n c1[2] : z - y(1.11111111111) â‰¥ 0\n c1[3] : z - y(2.22222222222) â‰¥ 0\n c1[4] : z - y(3.33333333333) â‰¥ 0\n c1[5] : z - y(4.44444444444) â‰¥ 0\n c1[6] : z - y(5.55555555556) â‰¥ 0\n c1[7] : z - y(6.66666666667) â‰¥ 0\n c1[8] : z - y(7.77777777778) â‰¥ 0\n c1[9] : z - y(8.88888888889) â‰¥ 0\n c1[10] : z - y(10.0) â‰¥ 0","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"We can also query the expressions via  transformation_expression:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> transformation_expression(z - y^2 + 3) # infinite expression\n10-element Vector{Union{Real, AbstractJuMPScalar}}:\n -y(0.0)Â² + z + 3\n -y(1.11111111111)Â² + z + 3\n -y(2.22222222222)Â² + z + 3\n -y(3.33333333333)Â² + z + 3\n -y(4.44444444444)Â² + z + 3\n -y(5.55555555556)Â² + z + 3\n -y(6.66666666667)Â² + z + 3\n -y(7.77777777778)Â² + z + 3\n -y(8.88888888889)Â² + z + 3\n -y(10.0)Â² + z + 3","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"note: Note\nLike supports the transformation_[obj] methods also employ the ","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"label::Type{AbstractSupportLabel} = PublicLabel keyword argument that by     default will return variables/expressions/constraints associated with public     supports. The full set (e.g., ones corresponding to internal collocation nodes)     is obtained via label = All.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"The purpose of this transformation_backend abstraction is to readily enable user-defined  reformulation extensions (e.g., using polynomial chaos expansion theory). However,  this is all handled behind the scenes such that most users can interact with  InfiniteModels like any JuMP.Model.","category":"page"},{"location":"guide/optimize/#opt_settings","page":"Optimization","title":"Optimizer Settings","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"A few optimizer settings can be set consistently agnostic of particular  solver keywords. One such setting is that of suppressing optimizer verbose output. This is accomplished via  set_silent and  unset_silent. The syntax is  exemplified below:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_silent(model)\n\njulia> unset_silent(model)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"We can also adjust the time limit in a solver independent fashion via  set_time_limit_sec, unset_time_limit_sec, and  time_limit_sec. These methods are illustrated below:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_time_limit_sec(model, 100)\n\njulia> time_limit_sec(model)\n100.0\n\njulia> unset_time_limit_sec(model)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Other optimizer specific settings can be set via set_attribute.  For example, let's set the maximum CPU time for Ipopt:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_attribute(model, \"max_cpu_time\", 60.)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Multiple settings can be specified via set_attributes. For  example, let's specify the tolerance and the maximum number of iterations:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Finally, we can query optimizer settings via get_attribute.  For example, let's query the maximum number of iterations:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> get_attribute(model, \"max_iter\")\n100","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Note this only works if the attribute has been previously specified.","category":"page"},{"location":"manual/objective/#obj_manual","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"A technical manual for objective functions in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/objective/#Queries","page":"Objectives","title":"Queries","text":"","category":"section"},{"location":"manual/objective/#JuMP.objective_sense-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_sense","text":"JuMP.objective_sense(model::InfiniteModel)::MOI.OptimizationSense\n\nExtend JuMP.objective_sense to return the objective sense of the infinite model  model.\n\nExample\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\n\n\n\n\n","category":"method"},{"location":"manual/objective/#JuMP.objective_function_type-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_function_type","text":"JuMP.objective_function_type(model::InfiniteModel)::Type{<:JuMP.AbstractJuMPScalar}\n\nExtend JuMP.objective_function_type to return the objective function type of  infinite model model.\n\nExample\n\njulia> objective_function_type(model)\nGenericAffExpr{Float64,GeneralVariableRef}\n\n\n\n\n\n","category":"method"},{"location":"manual/objective/#JuMP.objective_function-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_function","text":"JuMP.objective_function(model::InfiniteModel)::JuMP.AbstractJuMPScalar\n\nExtend JuMP.objective_function to return the objective of infinite model  model.\n\nExample\n\njulia> objective_function(model)\n1\n\n\n\n\n\n","category":"method"},{"location":"manual/objective/#InfiniteOpt.objective_has_measures","page":"Objectives","title":"InfiniteOpt.objective_has_measures","text":"objective_has_measures(model::InfiniteModel)::Bool\n\nReturn Bool whether the objective function contains any measures.\n\n\n\n\n\n","category":"function"},{"location":"manual/objective/#Modification","page":"Objectives","title":"Modification","text":"","category":"section"},{"location":"manual/objective/#JuMP.set_objective_function-Tuple{InfiniteModel, AbstractJuMPScalar}","page":"Objectives","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(model::InfiniteModel,\n                            func::JuMP.AbstractJuMPScalar)::Nothing\n\nExtend JuMP.set_objective_function to set the objective expression of infinite model model. Errors if func contains infinite variables and/or parameters. Also errors if func contains invalid variables.\n\nExample\n\njulia> set_objective_function(model, 2x + 1)\n\njulia> objective_function(model)\n2 x + 1\n\n\n\n\n\n","category":"method"},{"location":"manual/objective/#JuMP.set_objective_function-Tuple{InfiniteModel, Real}","page":"Objectives","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(model::InfiniteModel, func::Real)::Nothing\n\nExtend JuMP.set_objective_function to set the objective expression of model with a number.\n\nExample\n\njulia> set_objective_function(model, 3)\n\njulia> objective_function(model)\n3\n\n\n\n\n\n","category":"method"},{"location":"manual/objective/#JuMP.set_objective_sense-Tuple{InfiniteModel, MathOptInterface.OptimizationSense}","page":"Objectives","title":"JuMP.set_objective_sense","text":"JuMP.set_objective_sense(model::InfiniteModel,\n                         sense::MOI.OptimizationSense)::Nothing\n\nExtend JuMP.set_objective_sense to set the objective sense of infinite model  model.\n\nExample\n\njulia> set_objective_sense(model, MOI.MIN_SENSE)\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\n\n\n\n\n","category":"method"},{"location":"manual/objective/#JuMP.set_objective-Tuple{InfiniteModel, MathOptInterface.OptimizationSense, Union{Real, AbstractJuMPScalar}}","page":"Objectives","title":"JuMP.set_objective","text":"JuMP.set_objective(model::InfiniteModel, sense::MOI.OptimizationSense,\n                   func::Union{JuMP.AbstractJuMPScalar, Real})::Nothing\n\nExtend JuMP.set_objective to set the objective of infinite model model. Errors if func contains infinite variables and/or parameters, or if it does not belong to the model.\n\nExample\n\njulia> set_objective(model, MOI.MIN_SENSE, 2x + 1)\n\njulia> objective_function(model)\n2 x + 1\n\n\n\n\n\n","category":"method"},{"location":"manual/objective/#JuMP.set_objective_coefficient-Tuple{InfiniteModel, GeneralVariableRef, Real}","page":"Objectives","title":"JuMP.set_objective_coefficient","text":"JuMP.set_objective_coefficient(model::InfiniteModel,\n                               variable::GeneralVariableRef,\n                               coefficient::Real)::Nothing\n\nExtend JuMP.set_objective_coefficient Set the linear objective coefficient  associated with variable to coefficient. Errors if the function type is  unsupported.\n\nExample\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @objective(model, x + y)\nx + y\n\njulia> set_objective_coefficient(model, y, 2)\n\njulia> objective_function(model)\nx + 2 y\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#transcription_docs","page":"Model Transcription","title":"Model Transcription","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"A guide for transcribing infinite models in InfiniteOpt. See the respective  technical manual for more details.","category":"page"},{"location":"guide/transcribe/#Overview","page":"Model Transcription","title":"Overview","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"All infinite models need to be transformed into a form that can be solved. A common approach is direct transcription (e.g., discretize-then-optimize) where  the domain of an infinite parameter is approximated by a collection of support  points. This is the idea behind TranscriptionOpt (which implements  TranscriptionBackend) which is InfiniteOpt's default transformation backend as discussed in the Infinite Models section. This page will detail the transcription models based in InfiniteOpt.TranscriptionOpt.","category":"page"},{"location":"guide/transcribe/#Basic-Usage","page":"Model Transcription","title":"Basic Usage","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Most users will not need to employ the capabilities of TranscriptionOpt directly  since they are employed implicitly with the call of  optimize! on an infinite model. This  occurs since TranscriptionBackends are the default backend. ","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"However, some users may wish to use TranscriptionOpt to extract a fully  discretized/transcribed version of an infinite model that is conveniently output  as a typical JuMP model and can then be treated as such. This is principally  accomplished via build_transformation_backend!. To illustrate how this is done,  let's first define a basic infinite model with a simple support structure for the  sake of example:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> using InfiniteOpt\n\njulia> inf_model = InfiniteModel();\n\njulia> @infinite_parameter(inf_model, t in [0, 10], supports = [0, 5, 10])\nt\n\njulia> @variable(inf_model, y >= 0, Infinite(t))\ny(t)\n\njulia> @variable(inf_model, z, Bin)\nz\n\njulia> @objective(inf_model, Min, 2z + support_sum(y, t))\n2 z + support_sum{t}[y(t)]\n\njulia> @constraint(inf_model, initial, y(0) == 1)\ninitial : y(0) = 1\n\njulia> @constraint(inf_model, constr, y^2 - z <= 42)\nconstr : y(t)Â² - z â‰¤ 42, âˆ€ t âˆˆ [0, 10]\n\njulia> print(inf_model)\nMin 2 z + support_sum{t}[y(t)]\nSubject to\n y(t) â‰¥ 0, âˆ€ t âˆˆ [0, 10]\n z binary\n initial : y(0) = 1\n constr : y(t)Â² - z â‰¤ 42, âˆ€ t âˆˆ [0, 10]","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now we can make JuMP model containing the transcribed version of inf_model  via build_transformation_backend! and then extract it via  transformation_model:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> build_transformation_backend!(inf_model)\n\njulia> trans_model = transformation_model(inf_model)\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: MIN_SENSE\nâ”‚ â”” objective_function_type: AffExpr\nâ”œ num_variables: 4\nâ”œ num_constraints: 8\nâ”‚ â”œ AffExpr in MOI.EqualTo{Float64}: 1\nâ”‚ â”œ QuadExpr in MOI.LessThan{Float64}: 3\nâ”‚ â”œ VariableRef in MOI.GreaterThan{Float64}: 3\nâ”‚ â”” VariableRef in MOI.ZeroOne: 1\nâ”” Names registered in the model: none\n\njulia> print(trans_model)\nMin 2 z + y(0.0) + y(5.0) + y(10.0)\nSubject to\n initial : y(0.0) = 1\n constr[1] : y(0.0)Â² - z â‰¤ 42\n constr[2] : y(5.0)Â² - z â‰¤ 42\n constr[3] : y(10.0)Â² - z â‰¤ 42\n y(0.0) â‰¥ 0\n y(5.0) â‰¥ 0\n y(10.0) â‰¥ 0\n z binary","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Thus, we have a transcribed JuMP model. To be precise, data on the mapping between  the transcribed variables/constraints and their infinite counterparts is also generated  as part of the TranscriptionBackend that trans_model is part of. Notice, that  multiple finite variables have been introduced to discretize y(t) at supports 0, 5, and 10 which we can can also query via supports:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> supports(y)\n3-element Vector{Tuple}:\n (0.0,)\n (5.0,)\n (10.0,)","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Also, notice how the constraints are transcribed in accordance with these supports  except the initial condition which naturally is only invoked for the first support  point. Furthermore, the transcription variable(s) of any variable associated with  the infinite model can be determined via transformation_variable:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> transformation_variable(y)\n3-element Vector{VariableRef}:\n y(0.0)\n y(5.0)\n y(10.0)\n\njulia> transformation_variable(z)\nz","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Similarly, the transcription constraints associated with infinite model constraints  can be queried via transformation_constraint and the associated supports  and infinite parameters can be found via supports and parameter_refs:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> transformation_constraint(initial)\ninitial : y(0.0) = 1\n\njulia> transformation_constraint(constr)\n3-element Vector{ConstraintRef}:\n constr[1] : y(0.0)Â² - z â‰¤ 42\n constr[2] : y(5.0)Â² - z â‰¤ 42\n constr[3] : y(10.0)Â² - z â‰¤ 42\n\njulia> supports(constr)\n3-element Vector{Tuple}:\n (0.0,)\n (5.0,)\n (10.0,)\n\njulia> parameter_refs(constr)\n(t,)","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Note the parameter reference tuple corresponds to the support tuples. ","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"note: Note\nMethods that query the transcription objects (e.g., transcformation_variable)  and the respective supports via supports also accept the keyword argument  label to specify which that transcription objects are desired in accordance  to the support labels that are inherited from and/or are equal to label. By  default, this will return any supports that are public (i.e., will hide anything  solely associated with internal supports). The full query response can always  be obtained via label = All.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now we have a transcribed JuMP model that can be optimized via traditional  JuMP compatible optimizers whose variables and constraints can be accessed using  the methods mentioned above.","category":"page"},{"location":"guide/transcribe/#Transcription-Theory","page":"Model Transcription","title":"Transcription Theory","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"A given infinite-dimensional optimization problem is parameterized according to  infinite parameters following our abstraction. In general, most solution strategies  transcribe the problem according to certain finite parameter values (supports) and  thus represent the problem in terms of these supports (e.g., using discrete time  points in dynamic optimization). This methodology can be generalized into the  following steps:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"define supports for each infinite parameter if not already defined,\nadd any additional support needed for derivative evaluation,\nexpand any measures according to their underlying numerical representation  using transcribed infinite variables as appropriate,\nreplace any remaining infinite variables/derivatives with transcribed  variables supported over each unique combination of the underlying parameter  supports,\nreplace any remaining infinite constraints with transcribed ones supported over  all the unique support combinations stemming from the infinite parameters they  depend on,\nand add on the transcribed versions of the auxiliary derivative evaluation  equations. ","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"For example, let's consider a space-time optimization problem of the form:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"beginaligned\n\tmin_y(t) g(t x)  int_0^10 y^2(t) dt \n\ttextst  y(0) = 1 \n\t int_x in -1 1^2 fracpartial g(t x)partial t dx = 42  forall t in 0 10 \n   3g(t x) + 2y^2(t) leq 2  forall t in T  x in -1 1^2 \nendaligned","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Thus, we have an optimization problem whose decision space is infinite with  respect to time t and position x. Now let's transcribe it following the  above steps. First, we need to specify the infinite parameter supports and for  simplicity let's choose the following sparse sets:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"t in 0 5 10\nx in -1 -1^T -1 1^T 1 -1^T 1 1^T.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"To handle the derivative fracpartial g(t x)partial t, we'll use    backward finite difference, so no additional supports will need to be added.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now we expand the two integrals (measures) via a finite approximation using only  the above supports and term coefficients of 1 (note this is not numerically  correct but is done for conciseness in example). Doing this, we obtain the  form:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"beginaligned\n\tmin_y(t) g(t x)  y^2(0) + y^2(5) + y^2(10) \n\ttextst  y(0) = 1 \n   g(0 x) = 0 \n\t fracpartial g(t -1 -1)partial t + fracpartial g(t -1 1)partial t + fracpartial g(t 1 -1)partial t + fracpartial g(t 1 1)partial t = 42  forall t in 0 10 \n   3g(t x) + 2y^2(t) leq 2  forall t in T  x in -1 1^2 \nendaligned","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Notice that the infinite variable y(t) in the objective measure has been  replaced with finite transcribed variables y(0), y(5), y(10). Also, the  infinite derivative fracpartial g(t x)partial t was replaced with   partially transcribed variables in the second constraint in accordance with the  measure over the positional domain x.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now we need to transcribe the remaining infinite and semi-infinite variables  with finite variables and duplicate the remaining infinite constraints accordingly.  This means that the second constraint needs to be transcribed over the time domain  and the third constraint needs to be transcribed for each unique combination  of the time and position supports. Applying this transcription yields: ","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"beginaligned\n\tmin_y(t) g(t x)  y^2(0) + y^2(5) + y^2(10) \n\ttextst  y(0) = 1 \n   g(0 -1 -1) = 0 \n   g(0 -1 1) = 0 \n   g(0 1 -1) = 0 \n   g(0 1 1) = 0 \n\t fracpartial g(0 -1 -1)partial t + fracpartial g(0 -1 1)partial t + fracpartial g(0 1 -1)partial t + fracpartial g(0 1 1)partial t = 42\n   fracpartial g(5 -1 -1)partial t + fracpartial g(5 -1 1)partial t + fracpartial g(5 1 -1)partial t + fracpartial g(5 1 1)partial t = 42\n   fracpartial g(10 -1 -1)partial t + fracpartial g(10 -1 1)partial t + fracpartial g(10 1 -1)partial t + fracpartial g(10 1 1)partial t = 42\n   3g(0 -1 -1) + 2y^2(0) leq 2 \n   3g(0 -1 1) + 2y^2(0) leq 2 \n   vdots \n   3g(10 1 1) + 2y^2(10) leq 2\nendaligned","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now that the variables and constraints are transcribed, all that remains is  to add relations to define the behavior of the transcribed partial derivatives.  We can accomplish this via backward finite difference which will just add one  infinite equation in this case this we only have 2 supports in the time domain  is then transcribed over the spatial domain to yield:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"beginaligned\n g(5 -1 -1) = g(0 -1 -1) + 5fracpartial g(5 -1 -1)partial t \n g(5 -1 1) = g(0 -1 1) + 5fracpartial g(5 -1 1)partial t \n g(5 1 -1) = g(0 1 -1) + 5fracpartial g(5 1 -1)partial t \n g(5 1 1) = g(0 1 1) + 5fracpartial g(5 1 1)partial t \n g(10 -1 -1) = g(5 -1 -1) + 5fracpartial g(10 -1 -1)partial t \n g(10 -1 1) = g(5 -1 1) + 5fracpartial g(10 -1 1)partial t \n g(10 1 -1) = g(5 1 -1) + 5fracpartial g(10 1 -1)partial t \n g(10 1 1) = g(5 1 1) + 5fracpartial g(10 1 1)partial t\nendaligned","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now the problem is fully transcribed (discretized) and can be solved as a  standard optimization problem. Note that with realistic measure evaluation  schemes more supports might be added to the support sets and these will need to  be incorporated when transcribing variables and constraints.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"It is easy to imagine how the above procedure can get quite involved to do manually,  but this is precisely what InfiniteOpt automates behind the scenes. Let's  highlight this by repeating the same example using InfiniteOpt (again using  the incorrect simple representation for the integrals for conciseness).","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"using InfiniteOpt\n\n# Initialize model\ninf_model = InfiniteModel()\n\n# Define parameters and supports\n@infinite_parameter(inf_model, t in [0, 10], supports = [0, 5, 10])\n@infinite_parameter(inf_model, x[1:2] in [-1, 1], supports = [-1, 1], independent = true)\n\n# Define variables\n@variable(inf_model, y, Infinite(t))\n@variable(inf_model, g, Infinite(t, x...))\n\n# Set the objective (using support_sum for the integral given our simple example)\n# Note: In real problems integral should be used\n@objective(inf_model, Min, support_sum(y^2, t))\n\n# Define the constraints\n@constraint(inf_model, y(0) == 1)\n@constraint(inf_model, g(0, x...) == 0)\n@constraint(inf_model, support_sum(deriv(g, t), x) == 42) # support_sum for simplicity\n@constraint(inf_model, 3g + y^2 <= 2)\n\n# Print the infinite model\nprint(inf_model)\n\n# output\nMin support_sum{t}[y(t)Â²]\nSubject to\n y(0) = 1\n g(0, x[1], x[2]) = 0, âˆ€ x[1] âˆˆ [-1, 1], x[2] âˆˆ [-1, 1]\n support_sum{x}[âˆ‚/âˆ‚t[g(t, x[1], x[2])]] = 42, âˆ€ t âˆˆ [0, 10]\n y(t)Â² + 3 g(t, x[1], x[2]) â‰¤ 2, âˆ€ t âˆˆ [0, 10], x[1] âˆˆ [-1, 1], x[2] âˆˆ [-1, 1]","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Thus, we obtain the infinite problem in InfiniteOpt. As previously noted,  transcription would be handled automatically behind the scenes when the model is  optimized. However, we can directly extract the transcribed version by building a  TranscriptionBackend:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> build_transformation_backend!(inf_model)\n\njulia> trans_model = transformation_model(inf_model);\n\njulia> print(trans_model)\nMin y(0.0)Â² + y(5.0)Â² + y(10.0)Â²\nSubject to\n y(0.0) = 1\n g(0.0, -1.0, -1.0) = 0\n g(0.0, 1.0, -1.0) = 0\n g(0.0, -1.0, 1.0) = 0\n g(0.0, 1.0, 1.0) = 0\n d/dt[g(t, x[1], x[2])](0.0, -1.0, -1.0) + d/dt[g(t, x[1], x[2])](0.0, 1.0, -1.0) + d/dt[g(t, x[1], x[2])](0.0, -1.0, 1.0) + d/dt[g(t, x[1], x[2])](0.0, 1.0, 1.0) = 42\n d/dt[g(t, x[1], x[2])](5.0, -1.0, -1.0) + d/dt[g(t, x[1], x[2])](5.0, 1.0, -1.0) + d/dt[g(t, x[1], x[2])](5.0, -1.0, 1.0) + d/dt[g(t, x[1], x[2])](5.0, 1.0, 1.0) = 42\n d/dt[g(t, x[1], x[2])](10.0, -1.0, -1.0) + d/dt[g(t, x[1], x[2])](10.0, 1.0, -1.0) + d/dt[g(t, x[1], x[2])](10.0, -1.0, 1.0) + d/dt[g(t, x[1], x[2])](10.0, 1.0, 1.0) = 42\n g(0.0, -1.0, -1.0) - g(5.0, -1.0, -1.0) + 5 d/dt[g(t, x[1], x[2])](5.0, -1.0, -1.0) = 0\n g(5.0, -1.0, -1.0) - g(10.0, -1.0, -1.0) + 5 d/dt[g(t, x[1], x[2])](10.0, -1.0, -1.0) = 0\n g(0.0, 1.0, -1.0) - g(5.0, 1.0, -1.0) + 5 d/dt[g(t, x[1], x[2])](5.0, 1.0, -1.0) = 0\n g(5.0, 1.0, -1.0) - g(10.0, 1.0, -1.0) + 5 d/dt[g(t, x[1], x[2])](10.0, 1.0, -1.0) = 0\n g(0.0, -1.0, 1.0) - g(5.0, -1.0, 1.0) + 5 d/dt[g(t, x[1], x[2])](5.0, -1.0, 1.0) = 0\n g(5.0, -1.0, 1.0) - g(10.0, -1.0, 1.0) + 5 d/dt[g(t, x[1], x[2])](10.0, -1.0, 1.0) = 0\n g(0.0, 1.0, 1.0) - g(5.0, 1.0, 1.0) + 5 d/dt[g(t, x[1], x[2])](5.0, 1.0, 1.0) = 0\n g(5.0, 1.0, 1.0) - g(10.0, 1.0, 1.0) + 5 d/dt[g(t, x[1], x[2])](10.0, 1.0, 1.0) = 0\n y(0.0)Â² + 3 g(0.0, -1.0, -1.0) â‰¤ 2\n y(5.0)Â² + 3 g(5.0, -1.0, -1.0) â‰¤ 2\n y(10.0)Â² + 3 g(10.0, -1.0, -1.0) â‰¤ 2\n y(0.0)Â² + 3 g(0.0, 1.0, -1.0) â‰¤ 2\n y(5.0)Â² + 3 g(5.0, 1.0, -1.0) â‰¤ 2\n y(10.0)Â² + 3 g(10.0, 1.0, -1.0) â‰¤ 2\n y(0.0)Â² + 3 g(0.0, -1.0, 1.0) â‰¤ 2\n y(5.0)Â² + 3 g(5.0, -1.0, 1.0) â‰¤ 2\n y(10.0)Â² + 3 g(10.0, -1.0, 1.0) â‰¤ 2\n y(0.0)Â² + 3 g(0.0, 1.0, 1.0) â‰¤ 2\n y(5.0)Â² + 3 g(5.0, 1.0, 1.0) â‰¤ 2\n y(10.0)Â² + 3 g(10.0, 1.0, 1.0) â‰¤ 2","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"This precisely matches what we found analytically. Note that the unique support  combinations are determined automatically.","category":"page"},{"location":"guide/transcribe/#TranscriptionOpt","page":"Model Transcription","title":"TranscriptionOpt","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"InfiniteOpt.TranscriptionOpt is a sub-module which principally implements  TranscriptionBackends and its related access/modification methods. Thus,  this section will detail what these are and how they work.","category":"page"},{"location":"guide/transcribe/#TranscriptionBackends","page":"Model Transcription","title":"TranscriptionBackends","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"A TranscriptionBackend is simply a JuMPBackend that uses the  Transcription AbstractJuMPTag and TranscriptionData which  acts to map the transcribed model back to the original infinite model (e.g., map the  variables and constraints). Such models are constructed via a default version of  build_transformation_backend!  which wraps build_transcription_backend!:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> backend1 = TranscriptionBackend() # make an empty backend\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none\n\njulia> build_transformation_backend!(inf_model); \n\njulia> backend2 = transformation_backend(inf_model) # generate from an InfiniteModel\nA TranscriptionBackend that uses a\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: MIN_SENSE\nâ”‚ â”” objective_function_type: AffExpr\nâ”œ num_variables: 4\nâ”œ num_constraints: 8\nâ”‚ â”œ AffExpr in MOI.EqualTo{Float64}: 1\nâ”‚ â”œ QuadExpr in MOI.LessThan{Float64}: 3\nâ”‚ â”œ VariableRef in MOI.GreaterThan{Float64}: 3\nâ”‚ â”” VariableRef in MOI.ZeroOne: 1\nâ”” Names registered in the model: none","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"The call to build_transformation_backend! is the backbone  behind infinite model transformation and is what encapsulates all the methods to  transcribe measures, variables, derivatives, and constraints. This is also the  method that enables the use of optimize!.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"note: Note\nTo support incremental updates of parameter functions for efficient resolves, set update_parameter_functions = true when defining the backend:backend = TranscriptionBackend(Ipopt.Optimizer, update_parameter_functions = true)\nmodel = InfiniteModel(backend)This setting has parameters functions mapped with JuMP parameters rather than just numerical values.","category":"page"},{"location":"guide/transcribe/#Queries","page":"Model Transcription","title":"Queries","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"In this section we highlight a number of query methods that pertain to  TranscriptionBackends and their mappings. First, we can retrieve the JuMP Model via transformation_model:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> transformation_model(inf_model)\nA JuMP Model\nâ”œ solver: none\nâ”œ objective_sense: FEASIBILITY_SENSE\nâ”œ num_variables: 0\nâ”œ num_constraints: 0\nâ”” Names registered in the model: none","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Here we observe that such a model is currently empty and hasn't been populated  yet.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Next we can retrieve the JuMP variable(s) for a particular InfiniteOpt  variable via transformation_variable. For finite variables, this will  be a one to one mapping, and for infinite variables an array will be returned that corresponds to the underlying supports. Following the initial example in  the basic usage section, this is done:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> build_transformation_backend!(inf_model); backend = transformation_backend(inf_model);\n\njulia> transformation_variable(y, backend)\n3-element Vector{VariableRef}:\n y(0.0)\n y(5.0)\n y(10.0)\n\njulia> transformation_variable(z, backend)\nz","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Note that if the TranscriptionBackend is the current backend then,  then the 2nd argument can be omitted.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Similarly, the parameter supports corresponding to the transcription variables  (in the case of transcribed infinite variables) can be queried via  supports:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> supports(y)\n3-element Vector{Tuple}:\n (0.0,)\n (5.0,)\n (10.0,)","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"note: Note\nNote that like supports, the transformation_[obj] methods also employ the  label::Type{AbstractSupportLabel} = PublicLabel keyword argument that by  default will return variables/expressions/constraints associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via label = All. ","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Likewise, transformation_constraint and  supports can be used with constraints to find their transcribed equivalents in the JuMP model and determine their supports.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"We can also do this with measures and expressions:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> meas = support_sum(y^2, t)\nsupport_sum{t}[y(t)Â²]\n\njulia> build_transformation_backend!(inf_model)\n\njulia> transformation_variable(meas)\ny(0.0)Â² + y(5.0)Â² + y(10.0)Â²\n\njulia> supports(meas)\n()\n\njulia> transformation_expression(y^2 + z - 42)\n3-element Vector{Union{Real, AbstractJuMPScalar}}:\n y(0.0)Â² + z - 42\n y(5.0)Â² + z - 42\n y(10.0)Â² + z - 42\n\njulia> supports(y^2 + z - 42)\n3-element Vector{Tuple}:\n (0.0,)\n (5.0,)\n (10.0,)\n\njulia> parameter_refs(y^2 + z - 42)\n(t,)","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"For finite parameters, we can also retrieve their corresponding JuMP parameter with transformation_variable.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> param = @finite_parameter(inf_model, p == 42)\np\n\njulia> build_transformation_backend!(inf_model)\n\njulia> transformation_variable(p)\np","category":"page"},{"location":"guide/measure/#measure_docs","page":"Measures","title":"Measure Operators","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"A guide for measure operators in InfiniteOpt. See the respective  technical manual for more details.","category":"page"},{"location":"guide/measure/#Overview","page":"Measures","title":"Overview","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Measure operators are objects that capture the evaluation of an expression with respect  to infinite parameters, which is a distinct feature of optimization problems with  infinite decision spaces. In dynamic optimization, measures typically are integral  terms such as the total cost over time, and in stochastic optimization, measures  can represent integrals over the uncertain parameters, such as expectations. In  InfiniteOpt, measures are general operators that can be uni-variate or   multi-variate. Natively we employ measure abstractions that employ discretization   schemes, which evaluate the expression at a set of points over the parameter space and  approximates the measures based on the expression values at these points. However,  we support the use of alternative measure operator paradigms.","category":"page"},{"location":"guide/measure/#measure_basic_usage","page":"Measures","title":"Basic Usage","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"First, we consider a dynamic optimization problem with the time parameter t  from 0 to 10. We also consider a state variable y(t) and a control variable  u(t) that are parameterized by t:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0, 5, 10])\nt\n\njulia> @variable(model, y, Infinite(t))\ny(t)\n\njulia> @variable(model, u, Infinite(t))\nu(t)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now suppose we want to evaluate the integral int_2^8y(t)^2 + u(t)^2 dt.  We can construct a measure to represent this integral using the  integral function","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref1 = integral(y^2 + u^2, t, 2, 8)\nâˆ«{t âˆˆ [2, 8]}[y(t)Â² + u(t)Â²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The four positional arguments of integral are the integrand expression,   the parameter of integration, the lower bound, and the upper bound, respectively.  Specifying the integrand expression and the parameter of integration is required.  If the lower and upper bounds are not specified, then the integration will  be over the entire domain, which is 0 10 in this case.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The integral function uses trapezoid rule as the default discretization scheme  for univariate parameters in finite IntervalDomains. In addition, the user can also  use quadrature methods for univariate parameters in all IntervalDomains by setting  the keyword argument eval_method as Quadrature():","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref2 = integral(y^2 + u^2, t, eval_method = Quadrature())\nâˆ«{t âˆˆ [0, 10]}[y(t)Â² + u(t)Â²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The integral function also allows for specifying other keyword arguments that  correspond to the chosen evaluation method. For example, when using  FEGaussLobatto as the evaluation method we can specify the number of  discretization points per finite element via num_nodes. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref3 = âˆ«(y^2 + u^2, t, eval_method = FEGaussLobatto(), num_nodes = 3)\nâˆ«{t âˆˆ [0, 10]}[y(t)Â² + u(t)Â²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Notice here how we used âˆ« in place of integral as a convenient wrapper.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Two other explicit measure type methods include expect for expectations  and support_sum for summing an expression over the support points of  selected infinite parameters. The syntax for these is analogous to that of integral  except that there are no lower/upper bounds. For example, we can define the following  expectation of a random expression:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> m = InfiniteModel();\n\njulia> @infinite_parameter(m, Î¾ ~ Normal(), num_supports = 100);\n\njulia> @variable(m, x, Infinite(Î¾));\n\njulia> expect_x = expect(x^2, Î¾)\nð”¼{Î¾}[x(Î¾)Â²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"note: Note\nFor integrals, expectations, and support sums involving moderate to large  expressions, the macro versions @integral, @expect, and  @support_sum should be used instead of their functional equivalents  for better performance.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"note: Note\nFor convenience in compact representation we can use âˆ«, @âˆ«,  ð”¼, and @ð”¼ as wrappers for integral,  @integral, expect, and @expect, respectively.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Other measure paradigms can be implemented via measure as described in  the sections further below.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Depending on the type of measures created, support points may be generated  at the time of creating the measures. In these cases, the new support points  will be added to the support list of the integrated parameter.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Once a measure is created, the evaluation of that measure is stored in a  measure data object. Users can query the measure data object using the  measure_data function as follows ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> meas_data = measure_data(mref2);","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Natively in InfiniteOpt, two types of measure data objects are used to store the measure  data information depending on the nature of the measures created: DiscreteMeasureData and  FunctionalDiscreteMeasureData. For more details on the measure data object,  refer to Measure Data Generation.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Similarly, one can also query the expression the measure operates on using  measure_function:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> measure_function(mref3)\ny(t)Â² + u(t)Â²","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In addition to eval_method, the integral function  also accepts weight_func as keyword argument, which dictates the weight function  of the measure. Now suppose we want to create multiple measures that share the   same keyword argument values that are different from the defaults. We don't have  to input the keyword argument values every time we construct a new measure.  Instead, we can modify the default values of measure keyword arguments, and  construct measures using the new default values. To do that, we use the functions  set_uni_integral_defaults and set_multi_integral_defaults. We  can in turn reset these via clear_uni_integral_defaults and  clear_multi_integral_defaults. Adding new keyword arguments will be  useful if users want to extend the measure functions with their custom  representation/evaluation schemes that need to take additional arguments somehow.  See Extensions for more details.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"We can also use the pdf keyword argument for [expect] over interval domains  which allows us to specify the density function we would like to use. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now we can add measures to the constraints and objective functions in our  model. For more detailed information, please review the information below.","category":"page"},{"location":"guide/measure/#Theoretical-Abstraction","page":"Measures","title":"Theoretical Abstraction","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In InfiniteOpt, measures denote operators M_ell that operate on some infinite  expression y over the infinite domain mathcalD_ell associated with  the infinite parameter ell:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"M_elly  mathcalD_-ell mapsto mathbbR^n_y","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Such a paradigm can capture a wide variety of mathematical operators commonly  encountered in infinite-dimensional programming such as integrals, expectations,  risk measures, and chance constraints.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Currently, InfiniteOpt natively contains programmatic objects for measures that  can be represented as integrals of the form:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"int_tau in mathcalT f(tau)w(tau) dtau","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"where tau is a (possibly multivariate) infinite parameter, f(tau) is an  expression parameterized by tau, w(tau) is a weight function, and  mathcalT is a subset of the domain of tau. The measures approximate  the integrals by taking a discretization scheme","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"int_tau in mathcalT f(tau)w(tau) dtau approx sum_i=1^N alpha_i f(tau_i) w(tau_i)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"where tau_i are the grid points where the expression f(tau) is  evaluated, and N is the total number of points taken (assuming the transformation  backend depends on discretization).","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"This is the abstraction behind both DiscreteMeasureData and  FunctionalDiscreteMeasureData which are the native measure data types  in InfiniteOpt. The Measure Data Generation section below details how  these can be implemented to enable schemes that fit this mathematical paradigm, but  lie out of the realm of the supported features behind integral, expect, and  support_sum.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"More complex measure paradigms can also be implemented by creating concrete  subtype of AbstractMeasureData as detailed in  Measure Data Section on our extensions page.","category":"page"},{"location":"guide/measure/#Measure-Data-Generation","page":"Measures","title":"Measure Data Generation","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The general measure function takes two arguments: the argument expression and  a measure data object that contains the details of the measure representation.  Measure data objects can be constructed using DiscreteMeasureData,  where the parameter of integration, the coefficients alpha_i, and the  support points need to be defined explicitly. For example, if we want to  evaluate a function at each integer time point between 0 and 10, we  can construct the following measure data object to record this discretization  scheme:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> md_t = DiscreteMeasureData(t, ones(10), [i for i in 1:10]);","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The arguments of DiscreteMeasureData are parameter, coefficients, and  supports. The default weight function is w(tau) = 1 for  any tau, which can be overwritten by the keyword argument weight_function.  The weight_function should take a function that returns a number for any  value that is well-defined for the integrated infinite parameter. The data type  is DiscreteMeasureData, which is a subtype of the abstract data type  AbstractMeasureData.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"With DiscreteMeasureData, a measure can be generated in a custom and  quick manner. For example, using the measure data above, we can define a measure  for y^2 as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref = measure(y^2, md_t)\nmeasure{t}[y(t)Â²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In the same way, we can define measure data for multi-variate infinite parameters.  For example, we can define a discretization scheme for a 2D position parameter  x in 0 1 times 0 1 as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> @infinite_parameter(model, x[1:2] in [0, 1])\n2-element Vector{GeneralVariableRef}:\n x[1]\n x[2]\n\njulia> md_x = DiscreteMeasureData(x, 0.25 * ones(4), [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]]);","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"where md_x cuts the domain into four 0.5-by-0.5 squares, and evaluates the  integrand on the center of these squares. Note that for multivariate parameters,   each support point should be an Array that stores the value at each dimension. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In addition to the intuitive [DiscreteMeasureData], another type of measure data   object is FunctionalDiscreteMeasureData. This type captures measure data  where the support points are not known at the time of measure data creation. Instead of   storing the specific support and coefficient values, FunctionalDiscreteMeasureData  stores the minimum number of supports required for the measure, and a coefficient function  that maps supports to coefficients. When the measure is built on a FunctionalDiscreteMeasureData   is evaluated (expanded), supports will be generated based on the functions stored in   the data object. The method of support generation is recorded as a label in the  measure object. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"For example, suppose we want to uniformly generate at least 20 Monte Carlo samples   over the interval that t is in. A build-in label UniformGrid can be used to  signify the use of this method. A FunctionalDiscreteMeasureData can be created as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> coeff_f(supports) = [(10 - 0) / length(supports) for i in supports]\ncoeff_f (generic function with 1 method)\n\njulia> fmd_t = FunctionalDiscreteMeasureData(t, coeff_f, 20, UniformGrid);","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"For more details see FunctionalDiscreteMeasureData. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Our higher-level measure methods, such as integral, do not require  explicit construction of the measure data object and instead serve as wrappers  that construct the appropriate data object and then call measure.","category":"page"},{"location":"guide/measure/#Evaluation-Methods","page":"Measures","title":"Evaluation Methods","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The integral function calls generate_integral_data under the hood  to construct the measure data object. generate_integral_data takes as  positional arguments the integrated parameter, lower bound, upper bound, and method, and returns  a measure data object of type AbstractMeasureData.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"generate_integral_data applies multiple dispatch to encode different  support generation methods depending on the input eval_method. Each dispatch is distinguished by  the method, which takes a concrete subtype of AbstractIntegralMethod.  Each dispatch of generate_integral_data implements the specified method and returns  the resulting measure data, which will be used by @integral to create the measure.  A table of available method options in our package is listed below.  Each method is limited on the dimension of parameter and/or the type of domain  that it can apply for. For the details of what each method type means, refer to the corresponding  docstrings.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Evaluation Method Uni/Multi-Variate? Weight Function Domain Type\nAutomatic() Both 1 Any\nUniTrapezoid() Both 1 IntervalDomain\nUniMCSampling() Univariate 1 Finite IntervalDomain\nUniIndepMCSampling() Univariate 1 Finite IntervalDomain\nQuadrature() Univariate 1 IntervalDomain\nGaussLegendre() Univariate 1 Finite IntervalDomain\nGaussRadau() Univariate 1 Finite IntervalDomain\nGaussJacobi(Î±, Î²) Univariate (1-x)^alpha (1+x)^beta Finite IntervalDomain\nGaussLobatto() Univariate 1 Finite IntervalDomain\nFEGaussLobatto() Univariate 1 Finite IntervalDomain\nGaussChebyshev(1) Univariate frac1sqrt1-x^2 Finite IntervalDomain\nGaussChebyshev(2) Univariate sqrt1-x^2 Finite IntervalDomain\nGaussChebyshev(3) Univariate sqrt(1+x)(1-x) Finite IntervalDomain\nGaussChebyshev(4) Univariate sqrt(1-x)(1+x) Finite IntervalDomain\nGaussLaguerre() Univariate e^-x Semi-infinite IntervalDomain\nGaussHermite() Univariate e^-x^2 Infinite IntervalDomain\nMultiMCSampling() Multivariate 1 Finite IntervalDomain\nMultiIndepMCSampling() Multivariate 1 Finite IntervalDomain","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The evaluation method FEGaussLobatto creates finite elements by decomposing over the  supports that have been added to the integral parameter and then approximates the  integral over each finite element via Lobatto quadrature using num_nodes.  All other Gauss quadrature methods do not incorporate any existing supports nor  do they decompose the integral into finite elements, but instead generate their  quadrature node points over the entire integral domain. See the  A Note on Support Management Section for more information. This method  will take in the user supports, and create generative supports along each interval  and match them with corresponding coefficients. Here is a depiction of such what  FEGaussLobatto does. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"(Image: lobatto)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"int_x_1^x_3 f(x) dx = int_x_1^x_2 f(x) dx + int_x_2^x_3 f(x) dx","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"approx sum_i=1^n alpha_ai f(tau_ai) + sum_i=1^n alpha_bi f(tau_bi)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"= sum_i=1^n (alpha_ai f(tau_ai) + alpha_bi f(tau_bi))","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"where tau_ai and tau_bi are the discrete nodes for the two intervals ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"and alpha_ai and alpha_bi are the coefficients.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref_lob = integral(y^2 + u^2, t, num_nodes = 3, eval_method = FEGaussLobatto())\nâˆ«{t âˆˆ [0, 10]}[y(t)Â² + u(t)Â²]\n\njulia> expand(mref_lob)\n0.8333333333333333 y(0)Â² + 0.8333333333333333 u(0)Â² + 3.333333333333333 y(2.5)Â² + 3.333333333333333 u(2.5)Â² + 1.6666666666666665 y(5)Â² + 1.6666666666666665 u(5)Â² + 3.333333333333333 y(7.5)Â² + 3.333333333333333 u(7.5)Â² + 0.8333333333333333 y(10)Â² + 0.8333333333333333 u(10)Â²\n","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"We set num_nodes = 3 to define the number of nodes (supports) that will be used  at each finite element for the integral approximation. Note that this is inclusive  of the finite element supports, so the number of generative (internal) supports  added to each finite element is num_nodes - 2.  ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In summary, we natively support trapezoid rule, Gaussian quadrature methods for  univariate parameters, and Monte Carlo sampling for both univariate and  multivariate infinite parameters. For extension purposes, users may define their  own generate_integral_data to encode custom evaluation methods. See  Extensions for more details.","category":"page"},{"location":"guide/measure/#A-Note-on-Support-Management","page":"Measures","title":"A Note on Support Management","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"There is a difference in how supports are considered using UniTrapezoid()/FEGaussLobatto() vs. the other schemes. Namely, the other schemes will NOT incorporate other supports  specified elsewhere in the model. Consider the following example with 3 equidistant  supports and an integral objective function that uses UniTrapezoid() (the default):","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"# Create a model, with one variable and an infinite parameter with a given number of supports\nmodel = InfiniteModel()\n@infinite_parameter(model, t in [0, 2], num_supports = 3)\n@variable(model, u, Infinite(t))\n\n# Create an objective function with the default trapezoid integration\n@objective(model, Min, integral(u^2, t))\n\n# Get the transcribed model to check how the supports are taken into account\nbuild_transformation_backend!(model)\ntmodel = transformation_model(model);","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"If we look at how many supports there are, how the variable u is transcribed,  and how the objective function of the transcribed model looks like, we notice that  the same supports are used in both the objective function and the transcribed  variable:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> supports(t) \n3-element Vector{Float64}:\n 0.0\n 1.0\n 2.0\n\njulia> transformation_variable(u)  \n3-element Vector{VariableRef}:\n u(0.0)\n u(1.0)\n u(2.0)\n\njulia> objective_function(tmodel) \n0.5 u(0.0)Â² + u(1.0)Â² + 0.5 u(2.0)Â²","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Thus, the integral incorporates the 3 supports generated outside the integral  declaration.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now let's readjust the model to use Gauss-Legendre quadrature via GaussLegendre()  that uses 2 quadrature nodes:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"# Set the new objective and update the TranscriptionModel\nset_objective_function(model, integral(u^2, t, eval_method = GaussLegendre(), num_nodes = 2))\nbuild_transformation_backend!(model)\ntrans_m = transformation_model(model);","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now let's look again at the number of supports, the transcription of u, and the  new objective function:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> supports(t) \n5-element Vector{Float64}:\n 0.0\n 0.42264973081\n 1.0\n 1.57735026919\n 2.0\n\njulia> transformation_variable(u)  \n5-element Vector{VariableRef}:\n u(0.0)\n u(0.42264973081)\n u(1.0)\n u(1.57735026919)\n u(2.0)\n\njulia> objective_function(tmodel) \nu(0.42264973081)Â² + u(1.57735026919)Â²","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The supports used in the objective function are different from the supports used  in the transcription of u. The integral objective function has been transcribed  using the 2 quadrature supports, but does not include the other supports since  they cannot be incorporated into the Gaussian quadrature approximation. Whereas,  u is defined over all the supports and thus certain realizations of u will  be excluded from the objective function which will affect the behavior of the  optimization and lead to unexpected results.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"However, this behavior is avoided if we let the integral add the supports and  not add supports elsewhere (for convenience we'll use set_uni_integral_defaults):","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"# Define a new model, parameter, and variable\nmodel = InfiniteModel()\n@infinite_parameter(model, t in [0, 2])\n@variable(model, u, Infinite(t))\n\n# Update the integral default keyword arguments for convenience \nset_uni_integral_defaults(eval_method = GaussLegendre(), num_nodes = 2)\n\n# Set the objective with our desired integral\n@objective(model, Min, integral(u^2, t))\n\n# Build the transcribed model \nbuild_transformation_backend!(model)\ntmodel = transformation_model(model);","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Then we get the supports are consistent for u and the integral:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> supports(t) \n2-element Vector{Float64}:\n 0.42264973081\n 1.57735026919\n\njulia> transformation_variable(u)  \n2-element Vector{VariableRef}:\n u(0.42264973081)\n u(1.57735026919)\n\njulia> objective_function(tmodel) \nu(0.42264973081)Â² + u(1.57735026919)Â²","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Therefore, using quadratures other than UniTrapezoid() or FEGaussLobatto()  requires careful analysis if there are user-defined supports in the problem. ","category":"page"},{"location":"guide/measure/#Expansion","page":"Measures","title":"Expansion","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In a model, each measure records the integrand expression and an evaluation  scheme that details the discretization scheme to approximate the integral.  The model will not expand the measures until the transformation stage, when  a JuMP.AbstractJuMPScalar is created for each measure to represent how  the measure is modeled in a transformed model based on the stored  discretization scheme (see Model Transcription for  details on transcription). Additional point variables will be created in the  expansion process if the measure is evaluated at infinite parameter points that  do not have corresponding point variables yet.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Sometimes for extension purposes, one might want to expand a specific measure  before reaching the transformation stage. Alternatively, one might want to use  custom reformulation instead of those natively provided by InfiniteOpt, in  which case, expanding measures will also be useful. This can be done using the expand  function, which takes a MeasureRef object and returns a JuMP.AbstractJuMPScalar  based on the AbstractMeasureData. For example, suppose we want to  integrate y^2 in t, with two supports t = 25 and t = 75.  We can set up and expand this measure as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> tdata = DiscreteMeasureData(t, [5, 5], [2.5, 7.5]);\n\njulia> mref4 = measure(y^2, tdata)\nmeasure{t}[y(t)Â²]\n\njulia> expanded_measure = expand(mref4)\n5 y(2.5)Â² + 5 y(7.5)Â²\n\njulia> typeof(expanded_measure)\nGenericQuadExpr{Float64, GeneralVariableRef}","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In the expand call, two point variables, y(2.5) and y(7.5), are created  because they are not defined in the model before the expand call. One can use  the expand_all_measures! function to expand all measures in a model,  which simply applies the expand to all measures stored in the model. ","category":"page"},{"location":"manual/domains/#infinite_domains_manual","page":"Infinite Domains","title":"Infinite Domains","text":"","category":"section"},{"location":"manual/domains/","page":"Infinite Domains","title":"Infinite Domains","text":"A technical manual for infinite domains in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/domains/#Domain-Types","page":"Infinite Domains","title":"Domain Types","text":"","category":"section"},{"location":"manual/domains/#InfiniteOpt.AbstractInfiniteDomain","page":"Infinite Domains","title":"InfiniteOpt.AbstractInfiniteDomain","text":"AbstractInfiniteDomain\n\nAn abstract type for domains that characterize infinite parameters.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.InfiniteScalarDomain","page":"Infinite Domains","title":"InfiniteOpt.InfiniteScalarDomain","text":"InfiniteScalarDomain <: AbstractInfiniteDomain\n\nAn abstract type for infinite domains that are one-dimensional.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.IntervalDomain","page":"Infinite Domains","title":"InfiniteOpt.IntervalDomain","text":"IntervalDomain <: InfiniteScalarDomain\n\nA DataType that stores the lower and upper interval bounds for infinite parameters that are continuous over a certain that interval. This is for use with a IndependentParameter.\n\nFields\n\nlower_bound::Float64 Lower bound of the infinite parameter.\nupper_bound::Float64 Upper bound of the infinite parameter.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.UniDistributionDomain","page":"Infinite Domains","title":"InfiniteOpt.UniDistributionDomain","text":"UniDistributionDomain{T <: Distributions.UnivariateDistribution} <: InfiniteScalarDomain\n\nA DataType that stores the distribution characterizing an infinite parameter that is random. This is for use with a IndependentParameter.\n\nFields\n\ndistribution::T Distribution of the random parameter.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.InfiniteArrayDomain","page":"Infinite Domains","title":"InfiniteOpt.InfiniteArrayDomain","text":"InfiniteArrayDomain <: AbstractInfiniteDomain\n\nAn abstract type for multi-dimensional infinite domains.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.MultiDistributionDomain","page":"Infinite Domains","title":"InfiniteOpt.MultiDistributionDomain","text":"MultiDistributionDomain{T <: NonUnivariateDistribution} <: InfiniteArrayDomain\n\nA DataType that stores the distribution characterizing a collection of infinite parameters that follows its form. This is for use with DependentParameters.\n\nFields\n\ndistribution::T Distribution of the random parameters.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.CollectionDomain","page":"Infinite Domains","title":"InfiniteOpt.CollectionDomain","text":"CollectionDomain{T <: InfiniteScalarDomain} <: InfiniteArrayDomain\n\nA DataType that stores a collection of InfiniteScalarDomains characterizing a collection of infinite parameters that follows its form. This is for use with DependentParameters.\n\nFields\n\ndomains::Array{T} The collection of scalar domains.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#Domain-Methods","page":"Infinite Domains","title":"Domain Methods","text":"","category":"section"},{"location":"manual/domains/#InfiniteOpt.collection_domains","page":"Infinite Domains","title":"InfiniteOpt.collection_domains","text":"collection_domains(domain::AbstractInfiniteDomain)\n\nReturn the array of domains associated with a CollectionDomain. Error if the input domain is not a CollectionDomain.\n\n\n\n\n\n","category":"function"},{"location":"manual/domains/#JuMP.has_lower_bound-Tuple{AbstractInfiniteDomain}","page":"Infinite Domains","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(domain::AbstractInfiniteDomain)::Bool\n\nReturn Bool indicating if domain has a lower bound that can be determined. This should be extended for user-defined infinite domains. It defaults to false for unrecognized domain types.\n\nExample\n\njulia> domain = IntervalDomain(0, 1);\n\njulia> has_lower_bound(domain)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/domains/#JuMP.lower_bound-Tuple{AbstractInfiniteDomain}","page":"Infinite Domains","title":"JuMP.lower_bound","text":"JuMP.lower_bound(domain::AbstractInfiniteDomain)::Union{Real, Vector{<:Real}}\n\nReturn the lower bound of domain if one exists. This should be extended for user-defined infinite domains if appropriate. Errors if JuMP.has_lower_bound returns false. Extensions are enabled by JuMP.has_lower_bound(domain) and JuMP.lower_bound(domain).\n\nExample\n\njulia> domain = IntervalDomain(0, 1);\n\njulia> lower_bound(domain)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/domains/#JuMP.set_lower_bound-Tuple{AbstractInfiniteDomain, Real}","page":"Infinite Domains","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(domain::AbstractInfiniteDomain,\n                     lower::Union{Real, Vector{<:Real}})::AbstractInfiniteDomain\n\nSet and return the lower bound of domain if such an operation makes sense. Errors if the type of domain does not support this operation or has not been extended. User-defined domain types should extend this if appropriate.\n\nExample\n\njulia> domain = IntervalDomain(0, 1);\n\njulia> set_lower_bound(domain, 0.5)\n[0.5, 1]\n\n\n\n\n\n","category":"method"},{"location":"manual/domains/#JuMP.has_upper_bound-Tuple{AbstractInfiniteDomain}","page":"Infinite Domains","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(domain::AbstractInfiniteDomain)::Bool\n\nReturn Bool indicating if domain has a upper bound that can be determined. This should be extended for user-defined infinite domains. It defaults to false for unrecognized domain types.\n\nExample\n\njulia> domain = IntervalDomain(0, 1);\n\njulia> has_upper_bound(domain)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/domains/#JuMP.upper_bound-Tuple{AbstractInfiniteDomain}","page":"Infinite Domains","title":"JuMP.upper_bound","text":"JuMP.upper_bound(domain::AbstractInfiniteDomain)::Union{Real, Vector{<:Real}}\n\nReturn the upper bound of domain if one exists. This should be extended for user-defined infinite domains if appropriate. Errors if JuMP.has_upper_bound returns false. Extensions are enabled by JuMP.has_upper_bound(domain) and JuMP.upper_bound(domain).\n\nExample\n\njulia> domain = IntervalDomain(0, 1);\n\njulia> upper_bound(domain)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/domains/#JuMP.set_upper_bound-Tuple{AbstractInfiniteDomain, Real}","page":"Infinite Domains","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(domain::AbstractInfiniteDomain,\n                     upper::Real)::AbstractInfiniteDomain\n\nSet and return the upper bound of domain if such an aoperation makes sense. Errors if the type of domain does not support this operation or has not been extended. User-defined domain types should extend this if appropriate.\n\nExample\n\njulia> domain = IntervalDomain(0, 1);\n\njulia> set_upper_bound(domain, 0.5)\n[0, 0.5]\n\n\n\n\n\n","category":"method"},{"location":"manual/domains/#InfiniteOpt.round_domain","page":"Infinite Domains","title":"InfiniteOpt.round_domain","text":"round_domain(domain::AbstractInfiniteDomain, sig_digits::Int)\n\nReturn a rounded domain of domain where its bounds use a number of  significant digits equal to sig_digs. This is intended as an internal  method and should be extended by those adding a new kind of infinite domain  that has bounds. \n\n\n\n\n\n","category":"function"},{"location":"manual/domains/#Support-Point-Labels","page":"Infinite Domains","title":"Support Point Labels","text":"","category":"section"},{"location":"manual/domains/#InfiniteOpt.AbstractSupportLabel","page":"Infinite Domains","title":"InfiniteOpt.AbstractSupportLabel","text":"AbstractSupportLabel\n\nAn abstract type for support label types. These are used to distinguish different  kinds of supports that are added to infinite parameters.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.All","page":"Infinite Domains","title":"InfiniteOpt.All","text":"All <: AbstractSupportLabel\n\nThis support label is unique in that it isn't associated with a particular set of  supports, but rather is used used to indicate that all supports should be used.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.PublicLabel","page":"Infinite Domains","title":"InfiniteOpt.PublicLabel","text":"PublicLabel <: AbstractSupportLabel\n\nAn abstract type used to denote that labels that should be given to the user by  default.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.UserDefined","page":"Infinite Domains","title":"InfiniteOpt.UserDefined","text":"UserDefined <: PublicLabel\n\nA support label for supports that are supplied by the user directly to an infinite  parameter. \n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.UniformGrid","page":"Infinite Domains","title":"InfiniteOpt.UniformGrid","text":"UniformGrid <: PublicLabel\n\nA support label for supports that are generated uniformly accross a given interval.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.SampleLabel","page":"Infinite Domains","title":"InfiniteOpt.SampleLabel","text":"SampleLabel <: PublicLabel\n\nAn abstract type for labels of supports that are generated via some sampling technique.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.MCSample","page":"Infinite Domains","title":"InfiniteOpt.MCSample","text":"MCSample <: SampleLabel\n\nA support label for supports that are generated via Monte Carlo Sampling.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.WeightedSample","page":"Infinite Domains","title":"InfiniteOpt.WeightedSample","text":"WeightedSample <: SampleLabel\n\nA support label for supports that are generated by sampling from a statistical  distribution.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.Mixture","page":"Infinite Domains","title":"InfiniteOpt.Mixture","text":"Mixture <: PublicLabel\n\nA support label for multi-dimensional supports that are generated from a variety  of methods.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.UniqueMeasure","page":"Infinite Domains","title":"InfiniteOpt.UniqueMeasure","text":"UniqueMeasure{S::Symbol} <: PublicLabel\n\nA support label for supports that are provided from the DiscreteMeasureData  associated with a measure where a unique label is generated to distinguish those  supports. This is done by invoking generate_unique_label.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.generate_unique_label","page":"Infinite Domains","title":"InfiniteOpt.generate_unique_label","text":"generate_unique_label()::Type{UniqueMeasure}\n\nGenerate and return a unique support label for measures.\n\n\n\n\n\n","category":"function"},{"location":"manual/domains/#InfiniteOpt.MeasureBound","page":"Infinite Domains","title":"InfiniteOpt.MeasureBound","text":"MeasureBound <: PublicLabel\n\nA support label for supports that are generated using the upper and lower bounds for FunctionalDiscreteMeasureData.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.InternalLabel","page":"Infinite Domains","title":"InfiniteOpt.InternalLabel","text":"InternalLabel <: AbstractSupportLabel\n\nAn abstract type for support labels that are associated with supports that should  not be reported to the user by default.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#InfiniteOpt.MeasureToolbox.InternalGaussLobatto","page":"Infinite Domains","title":"InfiniteOpt.MeasureToolbox.InternalGaussLobatto","text":"InternalGaussLobatto <: InfiniteOpt.InternalLabel\n\nA support label Gauss Lobatto points that are used as generative supports.\n\n\n\n\n\n","category":"type"},{"location":"manual/domains/#Support-Point-Methods","page":"Infinite Domains","title":"Support Point Methods","text":"","category":"section"},{"location":"manual/domains/#InfiniteOpt.supports_in_domain","page":"Infinite Domains","title":"InfiniteOpt.supports_in_domain","text":"supports_in_domain(\n    supports::Union{Real, Vector{<:Real}, Array{<:Real, 2}},\n    domain::AbstractInfiniteDomain\n    )::Bool\n\nUsed to check if supports are in the domain of domain. Returns true if supports are in domain of domain and returns false otherwise. This is primarily an internal method for performing checks but can be extended for user-defined domain types. Extending this is optional, but recommended where possible. Note by fallback, this returns true for unrecognized domain types such that an error won't be thrown.\n\n\n\n\n\n","category":"function"},{"location":"manual/domains/#InfiniteOpt.generate_supports","page":"Infinite Domains","title":"InfiniteOpt.generate_supports","text":"generate_supports(domain::AbstractInfiniteDomain\n                  [method::Type{<:AbstractSupportLabel}];\n                  [num_supports::Int = DefaultNumSupports,\n                  sig_digits::Int = DefaultSigDigits]\n                  )::Tuple{Array{<:Real}, DataType}\n\nGenerate num_supports support values with sig_digits significant digits in accordance with domain and return them along with the correct generation label(s). IntervalDomains generate supports uniformly with label UniformGrid and distribution domains generate them randomly accordingly to the underlying distribution. Moreover, method indicates the generation method that should be used. These methods correspond to parameter support labels. Current labels that can be used as generation methods include (but may not be defined for certain domain types):\n\nMCSample: Uniformly distributed Monte Carlo samples.\nWeightedSample: Monte Carlo samples that are weighted by an underlying PDF.\nUniformGrid: Samples that are generated uniformly over the domain.\n\nExtensions that employ user-defined infinite domain types and/or methods should extend generate_support_values to enable this. Errors if the domain type and /or methods are unrecognized. This is intended as an internal method to be used by methods such as generate_and_add_supports!.\n\n\n\n\n\n","category":"function"},{"location":"manual/domains/#InfiniteOpt.generate_support_values","page":"Infinite Domains","title":"InfiniteOpt.generate_support_values","text":"generate_support_values(domain::AbstractInfiniteDomain,\n                        [method::Type{MyMethod} = MyMethod];\n                        [num_supports::Int = DefaultNumSupports,\n                        sig_digits::Int = DefaultSigDigits]\n                        )::Tuple{Array{<:Real}, Symbol}\n\nA multiple dispatch method for generate_supports. This will return a tuple where the first element are the supports and the second is their label. This can be extended for user-defined infinite domains and/or generation methods. When defining a new domain type the default method dispatch should make method an optional argument (making it the default). Otherwise, other method dispatches for a given domain must ensure that method is positional argument without a default value (contrary to the definition above). Note that the  method must be a subtype of either PublicLabel or InternalLabel.\n\n\n\n\n\n","category":"function"},{"location":"manual/parameter/#inf_par_manual","page":"Infinite Parameters","title":"Infinite Parameters","text":"","category":"section"},{"location":"manual/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"A technical manual for infinite parameters in InfiniteOpt. See the respective  guide for more information.","category":"page"},{"location":"manual/parameter/#Definition","page":"Infinite Parameters","title":"Definition","text":"","category":"section"},{"location":"manual/parameter/#Macro","page":"Infinite Parameters","title":"Macro","text":"","category":"section"},{"location":"manual/parameter/#InfiniteOpt.@infinite_parameter","page":"Infinite Parameters","title":"InfiniteOpt.@infinite_parameter","text":"@infinite_parameter(model::InfiniteModel, kwargs...)\n\nAdd anonymous infinite parameter to the model model described by the keyword arguments kw_args and returns the parameter reference.\n\n@infinite_parameter(model::InfiniteModel, expr, kwargs...)\n\nAdd an infinite parameter to the model model described by the expression expr, and the keyword arguments kw_args. (Note that in the following the symbol in  can be used instead of âˆˆ) The expression expr can be of the form:\n\nparamexpr creating parameters described by paramexpr.\nparamexpr âˆˆ [lb, ub] creating parameters described by paramexpr characterized  by a continuous interval domain with lower bound lb and upper bound ub.\nparamexpr ~ dist creating parameters described by paramexpr characterized  by the Distributions.jl distribution object dist.\nparamexpr âˆˆ domain creating parameters described by paramexpr characterized  by the AbstractInfiniteDomain object domain.\n\nThe expression paramexpr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe recognized keyword arguments in kwargs are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\ndomain: The InfiniteDomain characterizing the parameters see subtypes of           AbstractInfiniteDomain.\ndistribution: Sets the Distributions.jl distribution object that   characterizes the parameters (specified instead of a domain).\nsupports: Sets the support points for the parameters.\nnum_supports: Specifies the number of supports to be automatically generated.                 Note that supports takes precedence. Defaults to 0.\nderivative_method: Specify the numerical method to evaluate derivatives that                       are taken with respect to the parameter.\nsig_digits: Specifies the number of significant digits that should be used               in automatic support generation. Defaults to DefaultSigDigits.\nindependent: Specifies if the each parameter is independent from each other or not. Defaults to false.\ncontainer: Specify the container type. Defaults to Auto\n\nExamples\n\njulia> @infinite_parameter(m, x in [0, 1])\nx\n\njulia> @infinite_parameter(m, y[i = 1:2] ~ MvNormal(ones(2)), num_supports = 10)\n2-element Array{GeneralVariableRef,1}:\n y[1]\n y[2]\n\njulia> z = @infinite_parameter(m, [[\"a\", \"b\"]], distribution = Normal(),\n                               independent = true)\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, [\"a\", \"b\"]\nAnd data, a 2-element Array{GeneralVariableRef,1}:\n noname[a]\n noname[b]\n\n\n\n\n\n","category":"macro"},{"location":"manual/parameter/#Independent-Parameters","page":"Infinite Parameters","title":"Independent Parameters","text":"","category":"section"},{"location":"manual/parameter/#InfiniteOpt.InfOptParameter","page":"Infinite Parameters","title":"InfiniteOpt.InfOptParameter","text":"InfOptParameter <: JuMP.AbstractVariable\n\nAn abstract type for all parameters used in InfiniteOpt.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.ScalarParameter","page":"Infinite Parameters","title":"InfiniteOpt.ScalarParameter","text":"ScalarParameter <: InfOptParameter\n\nAn abstract type for scalar parameters used in InfiniteOpt.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.IndependentParameter","page":"Infinite Parameters","title":"InfiniteOpt.IndependentParameter","text":"IndependentParameter{T <: InfiniteScalarDomain,\n                     M <: AbstractDerivativeMethod,\n                     I <: AbstractGenerativeInfo} <: ScalarParameter\n\nA DataType for storing independent scalar infinite parameters.\n\nFields\n\ndomain::T: The infinite domain that characterizes the parameter.\nsupports::DataStructures.SortedDict{Float64, Set{DataType}}: The support points  used to discretize the parameter and their associated type labels stored as  DataTypess which should be a subtype of AbstractSupportLabel.\nsig_digits::Int: The number of significant digits used to round the support values.\nderivative_method::M: The derivative evaluation method used for derivatives that  are conducted with respect to this parameter.\ngnerative_supp_info::I: The info associated with any generative supports that will   need to be generated for measures and/or derivatives based on existing supports. \n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.build_parameter-Tuple{Function, InfiniteScalarDomain}","page":"Infinite Parameters","title":"InfiniteOpt.build_parameter","text":"build_parameter(\n    _error::Function, domain::InfiniteScalarDomain;\n    [num_supports::Int = 0,\n    supports::Union{Vector{<:Real}, UnitRange{<:Real}, StepRange{<:Real}} = Float64[],\n    sig_digits::Int = DefaultSigDigits,\n    derivative_method::AbstractDerivativeMethod = DefaultDerivativeMethod]\n)::IndependentParameter\n\nReturns a IndependentParameter given the appropriate information. This is analagous to JuMP.build_variable. Errors if supports violate the bounds associated with domain. This is meant to primarily serve as a helper method for @infinite_parameter. Here derivative_method  specifies the numerical evalution method that will be applied to derivatives that  are taken with respect to this infinite parameter.\n\nExample\n\njulia> param = build_parameter(error, IntervalDomain(0, 3), supports = Vector(0:3));\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.add_parameter-Tuple{InfiniteModel, IndependentParameter, String}","page":"Infinite Parameters","title":"InfiniteOpt.add_parameter","text":"add_parameter(model::InfiniteModel, p::IndependentParameter,\n              [name::String = \"\"])::GeneralVariableRef\n\nReturns a GeneralVariableRef associated with the parameter p that is added  to model. This adds a parameter to the model in a manner similar to  JuMP.add_variable. This is used to add parameters with the use of  @infinite_parameter.  build_parameter  should be used to construct p.\n\nExample\n\njulia> p = build_parameter(error, IntervalDomain(0, 3), supports = Vector(0:3));\n\njulia> param_ref = add_parameter(model, p, \"name\")\nname\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.ScalarParameterData","page":"Infinite Parameters","title":"InfiniteOpt.ScalarParameterData","text":"ScalarParameterData{P <: ScalarParameter} <: AbstractDataObject\n\nA mutable DataType for storing ScalarParameters and their data.\n\nFields\n\nparameter::P: The scalar parameter.\ngroup_int_idx::Int: The location of the corresponding ObjectIndex in   InfiniteModel.param_group_indices.\nname::String: The name used for printing.\nparameter_func_indices::Vector{ParameterFunctionIndex}: Indices of dependent  infinite parameter functions.\ninfinite_var_indices::Vector{InfiniteVariableIndex}: Indices of dependent  infinite variables.\nderivative_indices::Vector{DerivativeIndex}: Indices of dependent derivatives.\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nconstraint_indices::Vector{InfOptConstraintIndex}: Indices of dependent constraints.\nin_objective::Bool: Is this used in objective? This should be true only for finite parameters.\ngenerative_measures::Vector{MeasureIndex}: Indices of measures that use parameter.generative_supp_info.\nhas_internal_supports::Bool: Does this parameter have internal supports?\nhas_generative_supports::Bool: Have any generative supports been added?\nhas_deriv_constrs::Bool: Have any derivative evaluation constraints been added                             to the infinite model associated with this parameter?\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.IndependentParameterIndex","page":"Infinite Parameters","title":"InfiniteOpt.IndependentParameterIndex","text":"IndependentParameterIndex <: ObjectIndex\n\nA DataType for storing the index of a IndependentParameter.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.IndependentParameterRef","page":"Infinite Parameters","title":"InfiniteOpt.IndependentParameterRef","text":"IndependentParameterRef <: DispatchVariableRef\n\nA DataType for independent infinite parameters references that parameterize infinite variables.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::IndependentParameterIndex: Index of the parameter in model.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#Dependent-Parameters","page":"Infinite Parameters","title":"Dependent Parameters","text":"","category":"section"},{"location":"manual/parameter/#InfiniteOpt.DependentParameters","page":"Infinite Parameters","title":"InfiniteOpt.DependentParameters","text":"DependentParameters{T <: InfiniteArrayDomain} <: InfOptParameter\n\nA DataType for storing a collection of dependent infinite parameters.\n\nFields\n\ndomain::T: The infinite domain that characterizes the parameters.\nsupports::DataStructures.OrderedDict{Vector{Float64}, Set{DataType}}: Support dictionary where keys             are supports and the values are the set of labels for each support.\nsig_digits::Int: The number of significant digits used to round the support values.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.add_parameters","page":"Infinite Parameters","title":"InfiniteOpt.add_parameters","text":"add_parameters(\n    model::InfiniteModel,\n    params::DependentParameters,\n    names::Vector{String}\n    )::Vector{GeneralVariableRef}\n\nAdd params to model and return an appropriate container of the dependent infinite parameter references. This is intended as an internal method for use with @infinite_parameter. However, if desired users can use this to add a DependentParameters object to model. Here, names denote the name  of each parameter. \n\nExample\n\njulia> using Distributions\n\njulia> dist = MvNormal(ones(3)); # 3 dimensional\n\njulia> domain = MultiDistributionDomain(dist); # 3 dimensional\n\njulia> params = DependentParameters(domain, Dict{Vector{Float64}, Set{DatatType}}(), 10);\n\njulia> prefs = add_parameters(model, params, [\"par1\", \"par2\", \"par3\"])\n3-element Array{GeneralVariableRef,1}:\n par1\n par2\n par3\n\n\n\n\n\n","category":"function"},{"location":"manual/parameter/#InfiniteOpt.MultiParameterData","page":"Infinite Parameters","title":"InfiniteOpt.MultiParameterData","text":"MultiParameterData{P <: DependentParameters} <: AbstractDataObject\n\nA mutable DataType for storing DependentParameters and their data.\n\nFields\n\nparameters::P: The parameter collection.\ngroup_int_idx::Int: The location of the corresponding ObjectIndex in  InfiniteModel.param_group_indices.\nnames::Vector{String}: The names used for printing each parameter.\nparameter_func_indices::Vector{ParameterFunctionIndex}: Indices of  dependent infinite parameter functions.\ninfinite_var_indices::Vector{InfiniteVariableIndex}: Indices of  dependent infinite variables.\nmeasure_indices::Vector{Vector{MeasureIndex}}: Indices of dependent measures.\nconstraint_indices::Vector{Vector{InfOptConstraintIndex}}: Indices of dependent constraints.\nhas_internal_supports::Bool: Does this parameter have internal supports?   associated with this parameter?\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.DependentParametersIndex","page":"Infinite Parameters","title":"InfiniteOpt.DependentParametersIndex","text":"DependentParametersIndex <: ObjectIndex\n\nA DataType for storing the index of a DependentParameters object.\n\nFields\n\nvalue::Int64: The index value.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.DependentParameterIndex","page":"Infinite Parameters","title":"InfiniteOpt.DependentParameterIndex","text":"DependentParameterIndex <: AbstractInfOptIndex\n\nA DataType for storing the index of an indiviudal parameter in a DependentParameters object.\n\nFields\n\nobject_index::DependentParametersIndex: The index of the parameter collection.\nparam_index::Int: The index of the individual parameter in the above object.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.DependentParameterRef","page":"Infinite Parameters","title":"InfiniteOpt.DependentParameterRef","text":"DependentParameterRef <: DispatchVariableRef\n\nA DataType for dependent infinite parameter references that parameterize infinite variables.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::DependentParameterIndex: Index of the dependent parameter.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#Queries","page":"Infinite Parameters","title":"Queries","text":"","category":"section"},{"location":"manual/parameter/#General","page":"Infinite Parameters","title":"General","text":"","category":"section"},{"location":"manual/parameter/#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel, String}","page":"Infinite Parameters","title":"InfiniteOpt.parameter_by_name","text":"parameter_by_name(model::InfiniteModel,\n                  name::String)::Union{GeneralVariableRef, Nothing}\n\nReturn the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.\n\nExample\n\njulia> parameter_by_name(model, \"t\")\nt\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.num_parameters","page":"Infinite Parameters","title":"InfiniteOpt.num_parameters","text":"num_parameters(model::InfiniteModel,\n               [type::Type{InfOptParameter} = InfOptParameter])::Int\n\nReturn the number of InfiniteOpt parameters assigned to model. By default, the total number of infinite and finite parameters is returned. The amount of a particular type is obtained by specifying the concrete parameter type of InfOptParameter via type. Type options include:\n\nInfOptParameter: all parameters\nScalarParameter: all scalar parameters\nInfiniteParameter: all infinite parameters\nFiniteParameter: all finite parameters\nIndependentParameter: all independent infinite parameters\nDependentParameters: all dependent infinite parameters\n\nExample\n\njulia> num_parameters(model)\n3\n\njulia> num_parameters(model, IndependentParameter)\n2\n\n\n\n\n\n","category":"function"},{"location":"manual/parameter/#InfiniteOpt.all_parameters","page":"Infinite Parameters","title":"InfiniteOpt.all_parameters","text":"all_parameters(model::InfiniteModel,\n               type::Type{InfOptParameter} = InfOptParameter\n               )::Vector{GeneralVariableRef}\n\nReturn a list of all the InfiniteOpt parameters assigned to model. By default, all of the infinite and finite parameters is returned. The search is reduced to a particular type is obtained by specifying the concrete parameter type of InfOptParameter via type. Type options include:\n\nInfOptParameter: all parameters\nScalarParameter: all scalar parameters\nInfiniteParameter: all infinite parameters\nFiniteParameter: all finite parameters\nIndependentParameter: all independent infinite parameters\nDependentParameters: all dependent infinite parameters\n\nExamples\n\njulia> all_parameters(model)\n4-element Array{GeneralVariableRef,1}:\n t\n x[1]\n x[2]\n alpha\n\njulia> all_parameters(model, FiniteParameter)\n1-element Array{GeneralVariableRef,1}:\n alpha\n\n\n\n\n\n","category":"function"},{"location":"manual/parameter/#Independent-Parameters-2","page":"Infinite Parameters","title":"Independent Parameters","text":"","category":"section"},{"location":"manual/parameter/#JuMP.name-Tuple{ScalarParameterRef}","page":"Infinite Parameters","title":"JuMP.name","text":"JuMP.name(pref::Union{IndependentParameterRef, FiniteParameterRef})::String\n\nExtend the JuMP.name function to accomodate infinite parameters. Returns the  name string associated with pref.\n\nExample\n\njulia> name(t)\n\"t\"\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.infinite_domain-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.infinite_domain","text":"infinite_domain(pref::IndependentParameterRef)::InfiniteScalarDomain\n\nReturn the infinite domain associated with pref.\n\nExample\n\njulia> infinite_domain(t)\n[0, 1]\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.has_lower_bound-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(pref::IndependentParameterRef)::Bool\n\nExtend the JuMP.has_lower_bound function to accomodate infinite parameters. Return true if the domain associated with pref has a defined lower bound or if a lower bound can be found. Extensions with user-defined infinite domain types should extend JuMP.has_lower_bound(domain::NewType).\n\nExample\n\njulia> has_lower_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.lower_bound-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.lower_bound","text":"JuMP.lower_bound(pref::IndependentParameterRef)::Real\n\nExtend the JuMP.lower_bound function to accomodate infinite parameters. Returns the lower bound associated with the infinite domain. Errors if such a bound is not well-defined.\n\nExample\n\njulia> lower_bound(t)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.has_upper_bound-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(pref::IndependentParameterRef)::Bool\n\nExtend the JuMP.has_upper_bound function to accomodate infinite parameters. Return true if the domain associated with pref has a defined upper bound or if a upper bound can be found. Extensions with user-defined domains should extend JuMP.has_upper_bound(domain::NewType).\n\nExample\n\njulia> has_upper_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.upper_bound-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.upper_bound","text":"JuMP.upper_bound(pref::IndependentParameterRef)::Real\n\nExtend the JuMP.upper_bound function to accomodate infinite parameters. Returns the upper bound associated with the infinite domain. Errors if such a bound is not well-defined. Extensions with user-defined domain types should extend JuMP.has_upper_bound(domain::NewType) and JuMP.upper_bound(domain::NewType) if appropriate.\n\nExample\n\njulia> upper_bound(t)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.has_supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.has_supports","text":"has_supports(pref::IndependentParameterRef)::Bool\n\nReturn true if pref has supports or false otherwise.\n\nExample\n\njulia> has_supports(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.num_supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.num_supports","text":"num_supports(\n    pref::IndependentParameterRef; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel]\n    )::Int\n\nReturn the number of support points associated with pref. By default, only the  number of public supports are counted. The full amount can be determined by setting  label = All. Moreover, the amount of labels that satisfy label is obtained  using an AbstractSupportLabel.\n\nExample\n\njulia> num_supports(t)\n2\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(\n    pref::IndependentParameterRef; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel]\n    )::Vector{Float64}\n\nReturn the support points associated with pref. Errors if there are no supports. Users can query just support points generated by a certain method using the keyword argument label. By default, the function returns all public support points regardless of the associated label. The full collection is given by setting  label = All. Moreover, the amount of labels that satisfy label is obtained  using an AbstractSupportLabel.\n\nExample\n\njulia> supports(t)\n2-element Array{Float64,1}:\n 0.0\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.has_internal_supports-Tuple{Union{DependentParameterRef, IndependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.has_internal_supports","text":"has_internal_supports(pref::Union{IndependentParameterRef, DependentParameterRef})::Bool\n\nIndicate if pref has internal supports that will be hidden from the user by  default. \n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.significant_digits-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.significant_digits","text":"significant_digits(pref::IndependentParameterRef)::Int\n\nReturn the number of significant digits enforced on the supports of pref.\n\nExample\n\njulia> significant_digits(t)\n12\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.derivative_method-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.derivative_method","text":"derivative_method(pref::IndependentParameterRef)::AbstractDerivativeMethod\n\nReturns the numerical derivative evaluation method employed with pref when it  is used as an operator parameter in a derivative.\n\nExample\n\njulia> derivative_method(pref) \nFiniteDifference(Backward, true)\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.is_used-Tuple{ScalarParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.is_used","text":"is_used(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool\n\nReturn true if pref is used in the model or false otherwise.\n\nExample\n\njulia> is_used(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_infinite_variable-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_infinite_variable","text":"used_by_infinite_variable(pref::IndependentParameterRef)::Bool\n\nReturn true if pref is used by an infinite variable or false otherwise.\n\nExample\n\njulia> used_by_infinite_variable(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_parameter_function-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_parameter_function","text":"used_by_parameter_function(pref::IndependentParameterRef)::Bool\n\nReturn true if pref is used by an infinite parameter function or false otherwise.\n\nExample\n\njulia> used_by_parameter_function(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_derivative-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_derivative","text":"used_by_derivative(pref::IndependentParameterRef)::Bool\n\nReturn true if pref is used by a derivative or false otherwise.\n\nExample\n\njulia> used_by_derivative(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_measure-Tuple{ScalarParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool\n\nReturn true if pref is used by a measure or false otherwise.\n\nExample\n\njulia> used_by_measure(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_constraint-Tuple{ScalarParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool\n\nReturn true if pref is used by a constraint or false otherwise.\n\nExample\n\njulia> used_by_constraint(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.parameter_group_int_index-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.parameter_group_int_index","text":"`parameter_group_int_index(pref::IndependentParameterRef)::Int\n\nReturn the infinite parameter group integer index corresponding to pref.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.core_object-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.core_object","text":"core_object(pref::IndependentParameterRef)::IndependentParameter\n\nRetrieve the underlying core [IndependentParameter] object for pref.  This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#Dependent-Parameters-2","page":"Infinite Parameters","title":"Dependent Parameters","text":"","category":"section"},{"location":"manual/parameter/#JuMP.name-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.name","text":"JuMP.name(pref::DependentParameterRef)::String\n\nExtend JuMP.name to return the names of infinite dependent parameters.\n\nExample\n\njulia> name(pref)\n\"par_name\"\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.infinite_domain-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.infinite_domain","text":"infinite_domain(pref::DependentParameterRef)::InfiniteScalarDomain\n\nReturn the infinite domain associated with the particular infinite dependent parameter pref if valid. Errors if the underlying DependentParameters object does not use a CollectionDomain.\n\nExample\n\njulia> infinite_domain(x[1])\n[-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.infinite_domain-Tuple{Array{<:DependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.infinite_domain","text":"infinite_domain(prefs::Array{<:DependentParameterRef})::InfiniteArrayDomain\n\nReturn the infinite domain associated with the container of infinite dependent parameters prefs. Errors if the container prefs is incomplete.\n\nExample\n\njulia> infinite_domain(x)\nZeroMeanDiagNormal(\ndim: 2\nÎ¼: [0.0, 0.0]\nÎ£: [1.0 0.0; 0.0 1.0]\n)\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.has_lower_bound-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(pref::DependentParameterRef)::Bool\n\nExtend the JuMP.has_lower_bound function to accomodate a single dependent infinite parameter. Return true if the domain associated with pref has a defined lower bound or if a lower bound can be found. Extensions with user-defined scalar infinite domain types should extend JuMP.has_lower_bound(domain::NewType).\n\nExample\n\njulia> has_lower_bound(x[1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.lower_bound-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.lower_bound","text":"JuMP.lower_bound(pref::DependentParameterRef)::Number\n\nExtend the JuMP.lower_bound function to accomodate a single dependent infinite parameter. Returns the lower bound associated with the infinite domain. Errors if such a bound is not well-defined.\n\nExample\n\njulia> lower_bound(x[1])\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.has_upper_bound-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(pref::DependentParameterRef)::Bool\n\nExtend the JuMP.has_upper_bound function to accomodate a single dependent infinite parameter. Return true if the domain associated with pref has a defined upper bound or if a upper bound can be found. Extensions with user-defined scalar infinite domain types should extend JuMP.has_upper_bound(domain::NewType).\n\nExample\n\njulia> has_upper_bound(x[1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.upper_bound-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.upper_bound","text":"JuMP.upper_bound(pref::DependentParameterRef)::Number\n\nExtend the JuMP.upper_bound function to accomodate a single dependent infinite parameter. Returns the upper bound associated with the infinite domain. Errors if such a bound is not well-defined.\n\nExample\n\njulia> upper_bound(x[1])\n0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.has_supports-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.has_supports","text":"has_supports(pref::DependentParameterRef)::Bool\n\nReturn true if pref has supports or false otherwise.\n\nExample\n\njulia> has_supports(x[1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.has_supports-Tuple{Array{<:DependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.has_supports","text":"has_supports(prefs::Array{<:DependentParameterRef})::Bool\n\nReturn true if prefs have supports or false otherwise. Errors if not all of the infinite dependent parameters are from the same object.\n\nExample\n\njulia> has_supports(x)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.num_supports-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.num_supports","text":"num_supports(\n    pref::DependentParameterRef; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel]\n    )::Int\n\nReturn the number of support points associated with a single dependent infinite parameter pref. Specify a subset of supports via label to only count the supports with label. By default only the amount of public supports are given, but  the full amount is obtained via label == All.\n\nExample\n\njulia> num_supports(x[1])\n2\n\njulia> num_supports(x[1], label = MCSample)\n0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.num_supports-Tuple{Array{<:DependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.num_supports","text":"num_supports(\n    prefs::Array{<:DependentParameterRef};\n    [label::Type{<:AbstractSupportLabel} = PublicLabel]\n    )::Int\n\nReturn the number of support points associated with dependent infinite parameters prefs. Errors if not all from the same underlying object. Specify a subset of supports via label to only count the supports with label. By default only the amount of public supports are given, but the full amount is  obtained via label == All.\n\nExample\n\njulia> num_supports(x)\n2\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.supports-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(\n    pref::DependentParameterRef; \n    [label::Type{<:AbstractSupportLabel} = PublicLabel]\n    )::Vector{Float64}\n\nReturn the support points associated with pref. A subset of supports can be returned via label to return just the supports associated with label. By  default only the public supports are given, but the full set is  obtained via label == All.\n\nExample\n\njulia> supports(x[1])\n2-element Array{Float64,1}:\n 0.0\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.supports-Tuple{Array{<:DependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(\n    prefs::Array{<:DependentParameterRef};\n    [label::Type{<:AbstractSupportLabel} = PublicLabel]\n    )::Union{Vector{<:AbstractArray{<:Real}}, Array{Float64, 2}}\n\nReturn the support points associated with prefs. Errors if not all of the infinite dependent parameters are from the same object. This will return a matrix if prefs is Vector, otherwise a vector of arrays is returned where each  array is a support point matching the format of prefs. A subset of supports can be returned via label to return just the supports associated with label. By  default only the public supports are given, but the full set is  obtained via  label == All.\n\nExample\n\njulia> supports(x) # columns are supports\n2Ã—2 Array{Float64,2}:\n 0.0  1.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.significant_digits-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.significant_digits","text":"significant_digits(pref::DependentParameterRef)::Int\n\nReturn the number of significant digits enforced on the supports of pref.\n\nExample\n\njulia> significant_digits(x[1])\n12\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.is_used-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.is_used","text":"is_used(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used in the model.\n\nExample\n\njulia> is_used(pref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_infinite_variable-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_infinite_variable","text":"used_by_infinite_variable(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used by an infinite variable.\n\nExample\n\njulia> used_by_infinite_variable(pref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_parameter_function-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_parameter_function","text":"used_by_parameter_function(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used by an infinite parameter function.\n\nExample\n\njulia> used_by_parameter_function(pref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_measure-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used by a measure.\n\nExample\n\njulia> used_by_measure(pref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.used_by_constraint-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(pref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.parameter_group_int_index-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.parameter_group_int_index","text":"parameter_group_int_index(pref::DependentParameterRef)::Int\n\nReturn the infinite parameter group integer index that corresponds to pref.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.core_object-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.core_object","text":"core_object(pref::DependentParameterRef)::DependentParameters\n\nRetrieve the underlying core DependentParameters object for pref. Note that this object applies to pref and the other infinite parameters it is coupled with. This is intended as an advanced method for developers.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#Modification","page":"Infinite Parameters","title":"Modification","text":"","category":"section"},{"location":"manual/parameter/#General-2","page":"Infinite Parameters","title":"General","text":"","category":"section"},{"location":"manual/parameter/#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}","page":"Infinite Parameters","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(model::InfiniteModel; [num_supports::Int = DefaultNumSupports,\n                  modify::Bool = true])::Nothing\n\nAutomatically generate support points for all infinite parameters in model. This calls fill_in_supports! for each parameter in the model. See fill_in_supports! for more information. Errors if one of the infinite domain types is unrecognized. Note that no supports will be added to a particular parameter if it already has some and modify = false.\n\nExample\n\njulia> fill_in_supports!(model, num_supports = 4)\n\njulia> supports(t)\n4-element Array{Float64,1}:\n 0.0\n 0.333\n 0.667\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#Independent-Parameters-3","page":"Infinite Parameters","title":"Independent Parameters","text":"","category":"section"},{"location":"manual/parameter/#JuMP.set_name-Tuple{ScalarParameterRef, String}","page":"Infinite Parameters","title":"JuMP.set_name","text":"JuMP.set_name(pref::ScalarParameterRef, name::String)\n\nExtend the JuMP.set_name function to accomodate infinite parameters. Set a new  base name to be associated with pref.\n\nExample\n\njulia> set_name(t, \"time\")\n\njulia> name(t)\n\"time\"\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.set_infinite_domain-Tuple{IndependentParameterRef, InfiniteScalarDomain}","page":"Infinite Parameters","title":"InfiniteOpt.set_infinite_domain","text":"set_infinite_domain(pref::IndependentParameterRef,\n                 domain::InfiniteScalarDomain)::Nothing\n\nReset the infinite domain of pref with another InfiniteScalarDomain. An error will  be thrown if pref is being used by some measure.\n\nExample\n\njulia> set_infinite_domain(t, IntervalDomain(0, 2))\n\njulia> infinite_domain(t)\n[0, 2]\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.set_lower_bound-Tuple{IndependentParameterRef, Real}","page":"Infinite Parameters","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(pref::IndependentParameterRef, lower::Real)::Nothing\n\nExtend the JuMP.set_lower_bound function to accomodate infinite parameters. Updates the infinite domain lower bound if such an operation is supported. Set extensions that seek to employ this should extend JuMP.set_lower_bound(domain::NewType, lower::Number).\n\nExample\n\njulia> set_lower_bound(t, -1)\n\njulia> lower_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.set_upper_bound-Tuple{IndependentParameterRef, Real}","page":"Infinite Parameters","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(pref::IndependentParameterRef, lower::Real)::Nothing\n\nExtend the JuMP.set_upper_bound function to accomodate infinite parameters. Updates the infinite domain upper bound if and only if it is an IntervalDomain. Errors otherwise. Extensions with user-defined infinite domains should extend JuMP.set_upper_bound(domain::NewType, upper::Number) if appropriate.\n\nExample\n\njulia> set_upper_bound(t, 2)\n\njulia> upper_bound(t)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.add_supports-Tuple{IndependentParameterRef, Union{Real, Vector{<:Real}}}","page":"Infinite Parameters","title":"InfiniteOpt.add_supports","text":"add_supports(\n    pref::IndependentParameterRef,\n    supports::Union{Real, Vector{<:Real}, UnitRange{<:Real}, StepRange{<:Real}, NTuple, Base.Generator};\n    [label::Type{<:AbstractSupportLabel} = UserDefined]\n    )::Nothing\n\nAdd additional support points for pref with identifying label label.\n\nExample\n\njulia> add_supports(t, 0.5)\n\njulia> supports(t)\n3-element Array{Float64,1}:\n 0.0\n 0.5\n 1.0\n\njulia> add_supports(t, [0.25, 1])\n\njulia> supports(t)\n4-element Array{Float64,1}:\n 0.0\n 0.25\n 0.5\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.set_supports-Tuple{IndependentParameterRef, Vector{<:Real}}","page":"Infinite Parameters","title":"InfiniteOpt.set_supports","text":"set_supports(\n    pref::IndependentParameterRef,\n    supports::Union{Vector{<:Real}, UnitRange{<:Real}, StepRange{<:Real}, NTuple, Base.Generator};\n    [force::Bool = false,\n    label::Type{<:AbstractSupportLabel} = UserDefined]\n    )::Nothing\n\nSpecify the support points for pref. Errors if the supports violate the bounds associated with the infinite domain. Warns if the points are not unique. If force this will overwrite exisiting supports otherwise it will error if there are existing supports.\n\nExample\n\njulia> set_supports(t, [0, 1])\n\njulia> supports(t)\n2-element Array{Int64,1}:\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.delete_supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.delete_supports","text":"delete_supports(\n    pref::IndependentParameterRef; \n    [label::Type{<:AbstractSupportLabel} = All]\n    )::Nothing\n\nDelete the support points for pref. If label != All then delete label and  any supports that solely depend on it.\n\nExample\n\njulia> delete_supports(t)\n\njulia> supports(t)\nERROR: Parameter t does not have supports.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef, AbstractInfiniteDomain}","page":"Infinite Parameters","title":"InfiniteOpt.generate_and_add_supports!","text":"generate_and_add_supports!(\n    pref::IndependentParameterRef,\n    domain::AbstractInfiniteDomain,\n    [method::Type{<:AbstractSupportLabel}];\n    [num_supports::Int = DefaultNumSupports]\n    )::Nothing\n\nGenerate supports for independent parameter pref via generate_support_values and add them to pref. This is intended as an extendable internal method for fill_in_supports!. Most extensions that empoy user-defined infinite domains can typically enable this by extending generate_support_values. Errors if the infinite domain type is not recognized.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(\n    pref::IndependentParameterRef;\n    [num_supports::Int = DefaultNumSupports]\n    )::Nothing\n\nAutomatically generate support points for a particular independent parameter pref. Generating num_supports for the parameter. The supports are generated uniformly if the underlying infinite domain is an IntervalDomain or they are generating randomly accordingly to the distribution if the domain is a UniDistributionDomain. Will add nothing if there are supports and modify = false. Extensions that use user defined domain types should extend generate_and_add_supports! and/or generate_support_values as needed. Errors if the infinite domain type is not recognized.\n\nExample\n\njulia> fill_in_supports!(x, num_supports = 4)\n\njulia> supports(x)\n4-element Array{Number,1}:\n 0.0\n 0.333\n 0.667\n 1.0\n\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.delete-Tuple{InfiniteModel, IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, pref::ScalarParameterRef)::Nothing\n\nExtend JuMP.delete to delete scalar parameters and their dependencies. All variables, constraints, and measure functions that depend on pref are updated to exclude it. Errors if the parameter is used by an infinite variable or if it is contained in an  AbstractMeasureData DataType that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that parameter_refs needs to be extended to allow deletion of parameters when custom AbstractMeasureData datatypes are used.\n\nExample\n\njulia> delete(model, x)\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#Dependent-Parameters-3","page":"Infinite Parameters","title":"Dependent Parameters","text":"","category":"section"},{"location":"manual/parameter/#JuMP.set_name-Tuple{DependentParameterRef, String}","page":"Infinite Parameters","title":"JuMP.set_name","text":"JuMP.set_name(pref::DependentParameterRef, name::String)::Nothing\n\nExtend JuMP.set_name to set names of dependent infinite parameters.\n\nExample\n\njulia> set_name(vref, \"par_name\")\n\njulia> name(vref)\n\"para_name\"\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.set_infinite_domain-Tuple{DependentParameterRef, InfiniteScalarDomain}","page":"Infinite Parameters","title":"InfiniteOpt.set_infinite_domain","text":"set_infinite_domain(pref::DependentParameterRef,\n                 domain::InfiniteScalarDomain)::Nothing\n\nSpecify the scalar infinite domain of the dependent infinite parameter pref to domain if pref is part of a CollectionDomain, otherwise an error is thrown. Note this will reset/delete all the supports contained in the underlying DependentParameters object. Also, errors if pref is used by a measure.\n\nExample\n\njulia> set_infinite_domain(x[1], IntervalDomain(0, 2))\n\njulia> infinite_domain(x[1])\n[0, 2]\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.set_infinite_domain-Tuple{Array{<:DependentParameterRef}, InfiniteArrayDomain}","page":"Infinite Parameters","title":"InfiniteOpt.set_infinite_domain","text":"set_infinite_domain(prefs::Array{<:DependentParameterRef},\n                 domain::InfiniteArrayDomain)::Nothing\n\nSpecify the multi-dimensional infinite domain of the dependent infinite parameters prefs to domain. Note this will reset/delete all the supports contained in the underlying DependentParameters object. This will error if the not all of the dependent infinite parameters are included, if any of them are used by measures.\n\nExample\n\njulia> set_infinite_domain(x, CollectionDomain([IntervalDomain(0, 1), IntervalDomain(0, 2)]))\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.set_lower_bound-Tuple{DependentParameterRef, Real}","page":"Infinite Parameters","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(pref::DependentParameterRef, lower::Real)::Nothing\n\nExtend the JuMP.set_lower_bound function to accomodate a single dependent infinite parameter. Updates the infinite domain lower bound if such an operation is supported. Infinite scalar domain extensions that seek to employ this should extend JuMP.set_lower_bound(domain::NewType, lower::Number). This will call set_infinite_domain and will error if this is not well-defined. Note that existing supports will be deleted.\n\nExample\n\njulia> set_lower_bound(t, -1)\n\njulia> lower_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.set_upper_bound-Tuple{DependentParameterRef, Real}","page":"Infinite Parameters","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(pref::DependentParameterRef, upper::Real)::Nothing\n\nExtend the JuMP.set_upper_bound function to accomodate a single dependent infinite parameter. Updates the infinite domain upper bound if such an operation is supported. Infinite scalar domain extensions that seek to employ this should extend JuMP.set_upper_bound(domain::NewType, upper::Number). This will call set_infinite_domain and will error if this is not well-defined. Note that existing supports will be deleted.\n\nExample\n\njulia> set_upper_bound(t, -1)\n\njulia> upper_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.add_supports-Tuple{Array{<:DependentParameterRef}, Vector{<:Array{<:Real}}}","page":"Infinite Parameters","title":"InfiniteOpt.add_supports","text":"add_supports(\n    prefs::Array{<:DependentParameterRef},\n    supports::Vector{<:Array{<:Real}};\n    [label::Type{<:AbstractSupportLabel} = UserDefined]\n    )::Nothing\n\nAdd additional support points for prefs. Errors if the supports violate the domain of the infinite domain, if the dimensions don't match up properly, if prefs and supports have different indices, or not all of the prefs are from the same dependent infinite parameter container.\n\n    add_supports(\n        prefs::Vector{DependentParameterRef},\n        supports::Array{<:Real, 2};\n        [label::Type{<:AbstractSupportLabel} = UserDefined]\n        )::Nothing\n\nSpecify the supports for a vector prefs of dependent infinite parameters. Here rows of supports correspond to prefs and the columns correspond to the supports. This is more efficient than the above method and will error for the same reasons.\n\nExample\n\njulia> add_supports(x, [[1], [1]])\n\njulia> supports(x)\n2Ã—2 Array{Float64,2}:\n 0.0  1.0\n 0.0  1.0\n\njulia> add_supports(x, ones(2, 1) * 0.5)\n\njulia> supports(t)\n2Ã—3 Array{Float64,2}:\n 0.0  1.0  0.5\n 0.0  1.0  0.5\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.set_supports-Tuple{Array{<:DependentParameterRef}, Vector{<:Array{<:Real}}}","page":"Infinite Parameters","title":"InfiniteOpt.set_supports","text":"set_supports(\n    prefs::Array{<:DependentParameterRef},\n    supports::Vector{<:Array{<:Real}};\n    [force::Bool = false,\n    label::Type{<:AbstractSupportLabel} = UserDefined]\n    )::Nothing\n\nSpecify the support points for prefs. Errors if the supports violate the domain of the infinite domain, if the dimensions don't match up properly, if prefs and supports have different indices, not all of the prefs are from the same dependent infinite parameter container, there are existing supports and force = false. Note that it is strongly preferred to use add_supports if possible to avoid destroying measure dependencies.\n\n    set_supports(\n        prefs::Vector{DependentParameterRef},\n        supports::Array{<:Real, 2};\n        [force::Bool = false,\n        label::Type{<:AbstractSupportLabel} = UserDefined]\n        )::Nothing\n\nSpecify the supports for a vector prefs of dependent infinite parameters. Here rows of supports correspond to prefs and the columns correspond to the supports. This is more efficient than the above method and will error for the same reasons.\n\nExample\n\njulia> set_supports(y, [[0, 1], [0, 1]])\n\njulia> set_supports(x, [0 1; 0 1])\n\njulia> supports(x)\n2Ã—2 Array{Float64,2}:\n 0.0  1.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.delete_supports-Tuple{Array{<:DependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.delete_supports","text":"delete_supports(\n    prefs::Array{<:DependentParameterRef};\n    [label::Type{<:AbstractSupportLabel} = All]\n    )::Nothing\n\nDelete the support points for prefs. Errors if any of the parameters are used by a measure or if not all belong to the same set of dependent parameters. If label != All then that label is removed along with any supports that solely  contain that label.\n\nExample\n\njulia> delete_supports(w)\n\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.generate_and_add_supports!-Tuple{Array{<:DependentParameterRef}, InfiniteArrayDomain}","page":"Infinite Parameters","title":"InfiniteOpt.generate_and_add_supports!","text":"generate_and_add_supports!(prefs::Array{<:DependentParameterRef},\n                           domain::InfiniteArrayDomain,\n                           [method::Type{<:AbstractSupportLabel}];\n                           [num_supports::Int = DefaultNumSupports])::Nothing\n\nGenerate supports for prefs via generate_support_values and add them to pref. This is intended as an extendable internal method for fill_in_supports!. Most extensions that employ user-defined infinite domains can typically enable this by extending generate_support_values. However, in some cases it may be necessary to extend this when more complex operations need to take place then just adding supports to a set of infinite parameters. Errors if the infinite domain type is not recognized.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.fill_in_supports!-Tuple{Array{<:DependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(prefs::Array{<:DependentParameterRef};\n                  [num_supports::Int = DefaultNumSupports,\n                   modify::Bool = true])::Nothing\n\nAutomatically generate support points for a container of dependent infinite parameters prefs. Generating up to num_supports for the parameters in accordance with generate_and_add_supports!. Will add nothing if there are supports and modify = false. Extensions that use user defined domain types should extend generate_and_add_supports! and/or generate_support_values as needed. Errors if the infinite domain type is not recognized.\n\nExample\n\njulia> fill_in_supports!(x, num_supports = 4)\n\njulia> supports(x)\n2Ã—4 Array{Float64,2}:\n 0.0  0.333  0.667  1.0\n 0.0  0.333  0.667  1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#JuMP.delete-Tuple{InfiniteModel, Array{<:DependentParameterRef}}","page":"Infinite Parameters","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, prefs::Array{<:DependentParameterRef})::Nothing\n\nExtend JuMP.delete to delete dependent infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on prefs are updated to exclude them. Errors if the parameters are contained in an AbstractMeasureData datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that parameter_refs needs to be extended to allow deletion of parameters when custom AbstractMeasureData datatypes are used.\n\nExample\n\njulia> print(model)\nMin measure(g(t, x)*t + x) + z\nSubject to\n z â‰¥ 0.0\n g(t, x) + z â‰¥ 42.0, âˆ€ t âˆˆ [0, 6], x[1] âˆˆ [-1, 1], x[2] âˆˆ [-1, 1]\n g(0.5, x) = 0, x[1] âˆˆ [-1, 1], x[2] âˆˆ [-1, 1]\n\njulia> delete(model, x)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n g(t) + z â‰¥ 42.0, âˆ€ t âˆˆ [0, 6]\n g(0.5) = 0\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#Generative-Supports","page":"Infinite Parameters","title":"Generative Supports","text":"","category":"section"},{"location":"manual/parameter/#InfiniteOpt.AbstractGenerativeInfo","page":"Infinite Parameters","title":"InfiniteOpt.AbstractGenerativeInfo","text":"AbstractGenerativeInfo\n\nAn abstract type for storing information about generating supports that are made  based on existing supports as required by certain measures and/or derivatives  that depend on a certain independent infinite parameter. Such as the case with  internal collocation supports.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.NoGenerativeSupports","page":"Infinite Parameters","title":"InfiniteOpt.NoGenerativeSupports","text":"NoGenerativeSupports <: AbstractGenerativeInfo\n\nA DataType to signify that no generative supports will be generated for the  measures and/or the derivatives. Has no fields.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.UniformGenerativeInfo","page":"Infinite Parameters","title":"InfiniteOpt.UniformGenerativeInfo","text":"UniformGenerativeInfo <: AbstractGenerativeInfo\n\nA DataType for generative supports that will be generated in a uniform manner  over finite elements (i.e., in between the existing supports). These generative  supports are described by the support_basis which lie in a nominal domain [0, 1].  The constructor is of the form:\n\n    UniformGenerativeInfo(support_basis::Vector{<:Real}, label::DataType, \n                          [lb::Real = 0, ub::Real = 1])\n\nwhere the support_basis is defined over [lb, ub].\n\nFields\n\nsupport_basis::Vector{Float64}: The basis of generative supports defined in   [0, 1] that will be transformed for each finite element.\nlabel::DataType: The unique label to be given to each generative support.\n\n\n\n\n\n","category":"type"},{"location":"manual/parameter/#InfiniteOpt.has_generative_supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.has_generative_supports","text":"has_generative_supports(pref::IndependentParameterRef)::Bool\n\nReturn whether generative supports have been added to pref in accordance  with its generative support info.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.support_label-Tuple{AbstractGenerativeInfo}","page":"Infinite Parameters","title":"InfiniteOpt.support_label","text":"support_label(info::AbstractGenerativeInfo)::DataType\n\nReturn the support label to be associated with generative supports produced in  accordance with info. This is intended an internal method that should be  extended for user defined types of AbstractGenerativeInfo.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.generative_support_info-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.generative_support_info","text":"generative_support_info(pref::IndependentParameterRef)::AbstractGenerativeInfo\n\nReturn the generative support information associated with pref.\n\n\n\n\n\n","category":"method"},{"location":"manual/parameter/#InfiniteOpt.make_generative_supports","page":"Infinite Parameters","title":"InfiniteOpt.make_generative_supports","text":"make_generative_supports(info::AbstractGenerativeInfo,\n                         pref::IndependentParameterRef,\n                         existing_supps::Vector{Float64}\n                         )::Vector{Float64}\n\nGenerate the generative supports for pref in accordance with info and the  existing_supps that pref has. The returned supports should not include  existing_supps. This is intended as internal method to enable  add_generative_supports and should be extended for any user defined  info types that are created to enable new measure and/or derivative evaluation  techniques that require the creation of generative supports.\n\n\n\n\n\n","category":"function"},{"location":"manual/parameter/#InfiniteOpt.add_generative_supports","page":"Infinite Parameters","title":"InfiniteOpt.add_generative_supports","text":"add_generative_supports(pref::IndependentParameterRef)::Nothing\n\nCreate generative supports for pref if needed in accordance with its  generative support info using make_generative_supports and add them to  pref. This is intended as an internal function, but can be useful user defined  transformation backend extensions that utlize our support system.\n\n\n\n\n\nadd_generative_supports(prefs; [kwargs...])\n\nDefine add_generative_supports for general variable references. It relies on add_generative_supports being defined for the underlying DispatchVariableRef, otherwise an ArgumentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"function"},{"location":"examples/Stochastic Optimization/farmer/#Two-Stage-Stochastic-Program","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"","category":"section"},{"location":"examples/Stochastic Optimization/farmer/#Introduction","page":"Two-Stage Stochastic Program","title":"Introduction","text":"","category":"section"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"First let's consider a standard two-stage stochastic program. Such problems consider 1st stage variables x in X subseteq mathbbR^n_x which denote upfront (here-and-now) decisions made before any realization of the random parameters xi in mathbbR^n_xi is observed, and 2nd stage variables y(xi) in mathbbR^n_y which denote recourse (wait-and-see) decisions that are made in response to realizations of xi. Moreover, the objective seeks to optimize 1st stage costs f_1(x) and second stage costs f_2(x y(xi)) which are evaluated over the uncertain domain via a risk measure R_xicdot (e.g., the expectation mathbbE_xicdot). Putting this together, we obtain the two-stage stochastic program:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"beginaligned\n    min_x y(xi)  f_1(x) + R_xif_2(x y(xi)) \n    textst   g_i(x y(xi)) = 0  i in I\n     h_j(x y(xi)) leq 0  j in J\n      x in X\nendaligned","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"where g_i(x y(xi))  i in I denote 2nd stage equality constraints, h_j(x y(xi))  j in J are 2nd stage inequality constraints, and X denotes the set of feasible 1st stage decisions.","category":"page"},{"location":"examples/Stochastic Optimization/farmer/#Formulation","page":"Two-Stage Stochastic Program","title":"Formulation","text":"","category":"section"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"For an example, we consider the classic farmer problem. Here the farmer must allocate farmland x_c for each crop c in C with random yields per acre xi_c such that he minimizes expenses (i.e., maximizes profit) while fulfilling contractual demand d_c. If needed he can purchase crops from other farmers to satisfy his contracts. He can also sell extra crop yield that exceeds his contractual obligations. Thus, here we have 1st stage variables x_c and 2nd stage variables of crops sold w_c(xi) and crops purchased y_c(xi). Putting this together using the expectation mathbbE_xicdot as our risk measure we obtain:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"beginaligned\n    undersetx y(xi) w(xi)textmin  sum_c in C alpha_c x_c + mathbbE_xileftsum_c in Cbeta_c y_c(xi) - lambda_c w_c(xi)right \n    textst   sum_c in C x_c leq barx\n     xi_c x_c + y_c(xi) - w_c(xi) geq d_c  c in C \n     0 leq x_c leq barx  c in C \n     0 leq y_c(xi) leq bary_c  c in C \n     0 leq w_c(xi) leq barw_c  c in C \n     xi_c in Xi_c  c in C\nendaligned","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"where alpha_c are production costs, beta_c are the purchase prices, lambda_c are the selling prices, barx is the total acreage, bary_c are purchases limits, barw_c are selling limits, and Xi_c are the underlying distributions.","category":"page"},{"location":"examples/Stochastic Optimization/farmer/#Problem-Setup","page":"Two-Stage Stochastic Program","title":"Problem Setup","text":"","category":"section"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"First let's import the necessary packages:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"using InfiniteOpt, Distributions, Ipopt","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Next let's specify the problem data:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"num_scenarios = 10 # small amount for example\nC = 1:3\nÎ± = [150, 230, 260] # land cost\nÎ² = [238, 210, 0]   # purchasing cost\nÎ» = [170, 150, 36]  # selling price\nd = [200, 240, 0]   # contract demand\nxbar = 500          # total land\nwbar3 = 6000        # no upper bound on the other crops\nybar3 = 0           # no upper bound on the other crops\nÎž = [Uniform(0, 5), Uniform(0, 5), Uniform(10, 30)]; # the distributions","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"note: Note\nWe only use 10 scenarios here to minimize the overhead in building the documentation. In practice, many scenarios should be used (e.g., 1,000 or more).","category":"page"},{"location":"examples/Stochastic Optimization/farmer/#Problem-Definition","page":"Two-Stage Stochastic Program","title":"Problem Definition","text":"","category":"section"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Let's start by setting up the infinite model that uses Ipopt as the optimizer that will ultimately be used to solve the transcribed variant:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"model = InfiniteModel(Ipopt.Optimizer)\nset_optimizer_attribute(model, \"print_level\", 0);","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Now let's define the infinite parameters using @infinite_parameter:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"@infinite_parameter(model, Î¾[c in C] ~ Îž[c], num_supports = num_scenarios, container = Array)","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"3-element Vector{GeneralVariableRef}:\n Î¾[1]\n Î¾[2]\n Î¾[3]","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"note: Note\nBehind the scenes, an amount of random samples equal to num_scenarios will be generated. This means that each time the problem is solved different samples may be drawn. To make reproducible behavior, invoke Random.seed! before creating the infinite parameter.","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Now let's define all of the decision variables using @variables:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"@variables(model, begin\n    # 1st stage variables\n    0 <= x[C] <= xbar\n    # 2nd stage variables\n    0 <= y[C], Infinite(Î¾)\n    0 <= w[C], Infinite(Î¾)\nend)","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"(1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:3\nAnd data, a 3-element Vector{GeneralVariableRef}:\n x[1]\n x[2]\n x[3], 1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:3\nAnd data, a 3-element Vector{GeneralVariableRef}:\n y[1](Î¾)\n y[2](Î¾)\n y[3](Î¾), 1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:3\nAnd data, a 3-element Vector{GeneralVariableRef}:\n w[1](Î¾)\n w[2](Î¾)\n w[3](Î¾))","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Next, the objective is defined using @objective and ð”¼:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"@objective(model, Min, sum(Î±[c] * x[c] for c in C) +\n                       ð”¼(sum(Î²[c] * y[c] - Î»[c] * w[c] for c in C), Î¾))","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"150 x[1] + 230 x[2] + 260 x[3] + ð”¼{Î¾}[238 y[1](Î¾) - 170 w[1](Î¾) + 210 y[2](Î¾) - 150 w[2](Î¾) - 36 w[3](Î¾)]","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Finally, all we need to do is define the constraints using @constraints:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"@constraints(model, begin\n    # capacity constraint\n    sum(x[c] for c in C) <= xbar\n    # balances\n    [c in C], Î¾[c] * x[c] + y[c] - w[c] >= d[c]\n    # crop limits\n    w[3] <= wbar3\n    y[3] <= ybar3\nend)","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"(x[1] + x[2] + x[3] â‰¤ 500, 1-dimensional DenseAxisArray{InfOptConstraintRef,1,...} with index sets:\n    Dimension 1, 1:3\nAnd data, a 3-element Vector{InfOptConstraintRef}:\n Î¾[1]*x[1] + y[1](Î¾) - w[1](Î¾) â‰¥ 200, âˆ€ Î¾[1] ~ Uniform, Î¾[2] ~ Uniform, Î¾[3] ~ Uniform\n Î¾[2]*x[2] + y[2](Î¾) - w[2](Î¾) â‰¥ 240, âˆ€ Î¾[1] ~ Uniform, Î¾[2] ~ Uniform, Î¾[3] ~ Uniform\n Î¾[3]*x[3] + y[3](Î¾) - w[3](Î¾) â‰¥ 0, âˆ€ Î¾[1] ~ Uniform, Î¾[2] ~ Uniform, Î¾[3] ~ Uniform, w[3](Î¾) â‰¤ 6000, âˆ€ Î¾[1] ~ Uniform, Î¾[2] ~ Uniform, Î¾[3] ~ Uniform, y[3](Î¾) â‰¤ 0, âˆ€ Î¾[1] ~ Uniform, Î¾[2] ~ Uniform, Î¾[3] ~ Uniform)","category":"page"},{"location":"examples/Stochastic Optimization/farmer/#Problem-Solution","page":"Two-Stage Stochastic Program","title":"Problem Solution","text":"","category":"section"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"With the model defined, let's optimize and get the results","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"optimize!(model)\nx_opt = value.(x)\nprofit = -objective_value(model)\n\nprintln(\"Land Allocations: \", [round(x_opt[k], digits = 2) for k in keys(x_opt)])\nprintln(\"Expected Profit: \\$\", round(profit, digits = 2))","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Land Allocations: [246.43, -0.0, 253.57]\nExpected Profit: $118554.09\n","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"We did it! Note, you will likely get a different answer by running the above code on your own since we only only used 10 scenarios and the random generation is not seeded as per the comments above.","category":"page"},{"location":"examples/Stochastic Optimization/farmer/#CVaR-Objective","page":"Two-Stage Stochastic Program","title":"CVaR Objective","text":"","category":"section"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"An interesting modification to the above problem would be to use a CVaR risk measure instead of an expectation. This also can be readily achieved via InfiniteOpt. The CVaR measure is defined:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"CVaR_epsilon(X) = undersett in mathbbRtextinfleftt + frac11-epsilon mathbbEtextmax(0 X - t) right","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"where epsilon is the confidence level. Inserting this into the formulation, we now obtain:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"beginaligned\n    undersetx y(xi) w(xi) t q(xi)textmin  sum_c in C alpha_c x_c + t + frac11-epsilon mathbbE_xiq(xi) \n    textst  sum_c in C x_c leq barx\n     xi_c x_c + y_c(xi) - w_c(xi) geq d_c  c in C \n     0 leq x_c leq barx  c in C \n     0 leq y_c(xi) leq bary_c  c in C \n     0 leq w_c(xi) leq barw_c  c in C \n     xi_c in Xi_c  c in C \n     q(xi) geq sum_c in Cbeta_c y_c(xi) - lambda_c w_c(xi) - t \n     q(xi) geq 0\nendaligned","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"where q(xi) is introduced to handle the max operator. Let's update and resolve our InfiniteOpt model using epsilon = 095:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Define the additional variables:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"@variables(model, begin\n    t\n    q >= 0, Infinite(Î¾)\nend)","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"(t, q(Î¾))","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Redefine the objective:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"@objective(model, Min, sum(Î±[c] * x[c] for c in C) + t + 1 / (1 - 0.95) * ð”¼(q, Î¾))","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"150 x[1] + 230 x[2] + 260 x[3] + t + 19.999999999999982 ð”¼{Î¾}[q(Î¾)]","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Add the max constraint:","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"@constraint(model, q >= sum(Î²[c] * y[c] - Î»[c] * w[c] for c in C) - t)","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"q(Î¾) - 238 y[1](Î¾) + 170 w[1](Î¾) - 210 y[2](Î¾) + 150 w[2](Î¾) + 36 w[3](Î¾) + t â‰¥ 0, âˆ€ Î¾[1] ~ Uniform, Î¾[2] ~ Uniform, Î¾[3] ~ Uniform","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Optimize and get the results","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"optimize!(model)\nx_opt = value.(x)\ny_opt = value.(y)\nw_opt = value.(w)\nprofit = -sum(Î±[c] * x_opt[c] for c in C) - 1 / num_scenarios *\n            sum(Î²[c] * y_opt[c][k] - Î»[c] * w_opt[c][k] for c in C, k in 1:num_scenarios)\n\nprintln(\"Land Allocations: \", [round(x_opt[k], digits = 2) for k in keys(x_opt)])\nprintln(\"Expected Profit: \\$\", round(profit, digits = 2))","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Land Allocations: [224.21, 11.25, 264.54]\nExpected Profit: $40966.32\n","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"That's it! Note, you will likely get a different answer by running the above code on your own since we only only used 10 scenarios and the random generation is not seeded as per the comments above.","category":"page"},{"location":"examples/Stochastic Optimization/farmer/#Maintenance-Tests","page":"Two-Stage Stochastic Program","title":"Maintenance Tests","text":"","category":"section"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"These are here to ensure this example stays up to date.","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"using Test\n@test termination_status(model) == MOI.LOCALLY_SOLVED\n@test x_opt isa JuMPC.DenseAxisArray{<:Real}\n@test profit isa Real","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"Test Passed","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"","category":"page"},{"location":"examples/Stochastic Optimization/farmer/","page":"Two-Stage Stochastic Program","title":"Two-Stage Stochastic Program","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img class=\"display-light-only\" src=\"assets/full_logo.png\" alt=\"InfiniteOpt logo\"/>\n<img class=\"display-dark-only\" src=\"assets/full_logo-dark.png\" alt=\"InfiniteOpt logo\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"A JuMP extension for expressing and solving infinite-dimensional optimization  problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nInfiniteOpt v0.6 introduces quite a few new features and makes some  breaking changes to the underlying data structures. The core API remains  largely the same.","category":"page"},{"location":"#What-is-InfiniteOpt?","page":"Home","title":"What is InfiniteOpt?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt.jl provides a general mathematical abstraction to express and solve  infinite-dimensional optimization problems (i.e., problems with decision  functions). Such problems stem from areas such as space-time programming and  stochastic programming. InfiniteOpt is meant to facilitate intuitive model  definition, automatic transcription into solvable models, permit a wide range  of user-defined extensions/behavior, and more. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It builds upon JuMP to add support for many complex modeling objects which  include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Infinite parameters (e.g., time, space, uncertainty, etc.)\nFinite parameters (similar to ParameterJuMP)\nInfinite variables (e.g., y(t x))\nDerivatives (e.g., fracpartial y(t x)partial t)\nMeasures (e.g., int_t in mathcalD_ty(tx) dt, mathbbEy(xi))\nMore","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nInfiniteOpt is intended to be used for infinite-dimensional optimization  problems. Finite problems (e.g., directly modeling a discrete time model)  should instead be modeled using JuMP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Moreover, InfiniteOpt decouples the infinite-dimensional formulations from the  finite transformations typically used to solve them. This readily enables diverse  techniques be used to solve these types of problems. By default, we employ  direct transcription (i.e., discretization) transformations whose features  include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Efficient implementations that scale linearly!\nDiverse integral approximations (e.g., quadratures, sampling)\nDiverse derivative approximations (e.g., finite difference, orthogonal  collocation)\nSophisticated support point management system\nCompatible with all JuMP-supported solvers","category":"page"},{"location":"","page":"Home","title":"Home","text":"Accepted infinite/finite problem forms currently include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Variables\nContinuous and semi-continuous\nBinary\nInteger and semi-integer\nSemi-definite\nDerivatives\nOrdinary derivative operators (of any order)\nPartial derivative operators (of any order)\nMeasures\nUnivariate and multivariate integrals \nUnivariate and multivariate expectations \nArbitrary measure operators (via general measure API)\nObjectives\nLinear\nQuadratic (convex and non-convex)\nGeneral nonlinear\nConstraints\nLinear\nQuadratic (convex and non-convex)\nGeneral nonlinear\nConic\nSemi-definite\nIndicator\nAnything else supported by JuMP","category":"page"},{"location":"#Infinite-Dimensional-Optimization-with-InfiniteOpt.jl","page":"Home","title":"Infinite-Dimensional Optimization with InfiniteOpt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See our YouTube overview of infinite-dimensional programming and InfiniteOpt.jl's  capabilities from JuliaCon 2021 (note that nonlinear support has since been added):  (Image: youtube)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt.jl is a registered Julia package and can be added simply by  inputting the following in the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.12) pkg> add InfiniteOpt","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please visit our Installation Guide for more details and information on how to get started.","category":"page"},{"location":"#First-Steps","page":"Home","title":"First Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt is extension of JuMP, thus new users should start by  familiarizing themselves with how to use JuMP first. See  JuMP's documentation to learn more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once you're familiar with JuMP check out our Quick Start Guide to get  started. From there we provide extensive documentation to help you along, please  see How to Use the Documentation for more info.","category":"page"},{"location":"#How-to-Use-the-Documentation","page":"Home","title":"How to Use the Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt is intended to serve both as a high-level interface for  infinite-dimensional optimization and as a highly customizable/extendable  platform for implementing advanced techniques. With this in mind, we provide the  User Guide sections to walk through the ins and outs of InfiniteOpt. Each  page in the User Guide typically contains the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Overview section describing the purpose of the page.\nA Basic Usage section to guide using InfiniteOpt at a high level.\nOther sections offering more in-depth information/guidance beyond basic usage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We also provide a technical manual in the API Manual sections which are  comprised of the docstrings of all the public methods and types that comprise  InfiniteOpt. These detail the technical aspects of each function, method, macro,  and composite type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Details, instructions, templates, and tutorials on how to write user-defined  extensions in InfiniteOpt are provided on the Extensions page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, case study examples are provided in the Examples sections.","category":"page"},{"location":"#Questions","page":"Home","title":"Questions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For additional help please visit and post in our  Discussion Forum.","category":"page"},{"location":"#Contribution","page":"Home","title":"Contribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt is a powerful tool with a broad scope lending to a large realm of  possible feature additions and enhancements. So, we are thrilled to support  anyone who would like to contribute to this project in any way big or small.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For small documentation fixes (such as typos or wording clarifications) please  do the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Click on Edit on GitHub at the top of the documentation page\nMake the desired changes\nSubmit a pull request","category":"page"},{"location":"","page":"Home","title":"Home","text":"For other contributions, please visit our  Developers Guide for step-by-step instructions and to  review our style guide.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: DOI)  (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use InfiniteOpt.jl in your research, we would greatly appreciate your  citing it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{pulsipher2022unifying,\n      title = {A unifying modeling abstraction for infinite-dimensional optimization},\n      journal = {Computers & Chemical Engineering},\n      volume = {156},\n      year = {2022},\n      issn = {0098-1354},\n      doi = {https://doi.org/10.1016/j.compchemeng.2021.107567},\n      url = {https://www.sciencedirect.com/science/article/pii/S0098135421003458},\n      author = {Joshua L. Pulsipher and Weiqi Zhang and Tyler J. Hongisto and Victor M. Zavala},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"A pre-print version is freely available though arXiv.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We acknowledge previous support from the Department of Energy under grant  DE-SC0014114.","category":"page"},{"location":"manual/result/#result_manual","page":"Results","title":"Results","text":"","category":"section"},{"location":"manual/result/","page":"Results","title":"Results","text":"A technical manual for querying optimized InfiniteOpt models. See the  respective guide for more information.","category":"page"},{"location":"manual/result/#Statuses","page":"Results","title":"Statuses","text":"","category":"section"},{"location":"manual/result/#JuMP.termination_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.termination_status","text":"JuMP.termination_status(model::InfiniteModel)\n\nExtend JuMP.termination_status  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.raw_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.raw_status","text":"JuMP.raw_status(model::InfiniteModel)\n\nExtend JuMP.raw_status  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.primal_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.primal_status","text":"JuMP.primal_status(model::InfiniteModel; result::Int = 1)\n\nExtend JuMP.primal_status  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if the  transformation backend hasn't be solved. Accepts keyword result to access the solution index of interest (if the solver/backend supports  multiple solutions).\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.dual_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.dual_status","text":"JuMP.dual_status(model::InfiniteModel; result::Int = 1)\n\nExtend JuMP.dual_status  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if the  transformation backend hasn't be solved. Accepts keyword result to access the solution index of interest (if the solver/backend supports  multiple solutions).\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.is_solved_and_feasible-Tuple{InfiniteModel}","page":"Results","title":"JuMP.is_solved_and_feasible","text":"JuMP.is_solved_and_feasible(\n    model::InfiniteModel;\n    [dual::Bool = false,\n    allow_local::Bool = true,\n    allow_almost::Bool = false,\n    result::Int = 1]\n    )::Bool\n\nExtend JuMP.is_solved_and_feasible) for model. See the JuMP docs details.  For new transformation backend types, this relies on JuMP.termination_status, JuMP.primal_status, and JuMP.dual_status.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#General","page":"Results","title":"General","text":"","category":"section"},{"location":"manual/result/#JuMP.solve_time-Tuple{InfiniteModel}","page":"Results","title":"JuMP.solve_time","text":"JuMP.solve_time(model::InfiniteModel)\n\nExtend JuMP.solve_time  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.relative_gap-Tuple{InfiniteModel}","page":"Results","title":"JuMP.relative_gap","text":"JuMP.relative_gap(model::InfiniteModel)\n\nExtend JuMP.relative_gap  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.simplex_iterations-Tuple{InfiniteModel}","page":"Results","title":"JuMP.simplex_iterations","text":"JuMP.simplex_iterations(model::InfiniteModel)\n\nExtend JuMP.simplex_iterations  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.barrier_iterations-Tuple{InfiniteModel}","page":"Results","title":"JuMP.barrier_iterations","text":"JuMP.barrier_iterations(model::InfiniteModel)\n\nExtend JuMP.barrier_iterations  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.node_count-Tuple{InfiniteModel}","page":"Results","title":"JuMP.node_count","text":"JuMP.node_count(model::InfiniteModel)\n\nExtend JuMP.node_count  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.result_count-Tuple{InfiniteModel}","page":"Results","title":"JuMP.result_count","text":"JuMP.result_count(model::InfiniteModel)\n\nExtend JuMP.result_count  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#Objective","page":"Results","title":"Objective","text":"","category":"section"},{"location":"manual/result/#JuMP.objective_bound-Tuple{InfiniteModel}","page":"Results","title":"JuMP.objective_bound","text":"JuMP.objective_bound(model::InfiniteModel)\n\nExtend JuMP.objective_bound  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if  the transformation backend hasn't been solved.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.objective_value-Tuple{InfiniteModel}","page":"Results","title":"JuMP.objective_value","text":"JuMP.objective_value(model::InfiniteModel; result::Int = 1)\n\nExtend JuMP.objective_value  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if the  transformation backend hasn't be solved. Accepts keyword result to access the solution index of interest (if the solver/backend supports  multiple solutions).\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.dual_objective_value-Tuple{InfiniteModel}","page":"Results","title":"JuMP.dual_objective_value","text":"JuMP.dual_objective_value(model::InfiniteModel; result::Int = 1)\n\nExtend JuMP.dual_objective_value  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if the  transformation backend hasn't be solved. Accepts keyword result to access the solution index of interest (if the solver/backend supports  multiple solutions).\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#Variables","page":"Results","title":"Variables","text":"","category":"section"},{"location":"manual/result/#JuMP.has_values-Tuple{InfiniteModel}","page":"Results","title":"JuMP.has_values","text":"JuMP.has_values(model::InfiniteModel; result::Int = 1)\n\nExtend JuMP.has_values  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if the  transformation backend hasn't be solved. Accepts keyword result to access the solution index of interest (if the solver/backend supports  multiple solutions).\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.value-Tuple{GeneralVariableRef}","page":"Results","title":"JuMP.value","text":"JuMP.value(vref::GeneralVariableRef; [kwargs...])\n\nExtend JuMP.value to return the value(s) of vref in accordance with its  reformulation variable(s) stored in the transformation backend. Use JuMP.has_values to check whether a result exists before checking the values. \n\nThw keyword arguments kwargs depend on the transformation backend that is  being used. The default backend TranscriptionOpt uses the keyword  arguments:\n\nresult::Int = 1: indexes the solution result to be queried\nlabel::Type{<:AbstractSupportLabel} = PublicLabel: the label of supports to be returned\n\nBy default only the values associated with public supports (i.e., PublicLabels)  are returned, the full set can be accessed via label = All. Where possible, all the  values are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters they depend on.\n\nTo provide context for the values, it may be helpful to also query the variable's  parameter_refs and supports which will have a one-to-one correspondence with  the value(s). It may also be helpful to query via transformation_variable  to retrieve the variables(s) that these values are based on. These functions should  all be called with the same keyword arguments for consistency.\n\nFor extensions, this only works if  transformation_variable has been extended correctly and/or  map_value has been extended for variables.\n\nExample\n\njulia> value(z)\n42.0\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.reduced_cost-Tuple{GeneralVariableRef}","page":"Results","title":"JuMP.reduced_cost","text":"JuMP.reduced_cost(ref::GeneralVariableRef; [kwargs...])\n\nExtend JuMP.reduced_cost for refs in InfiniteModel. The exact format of output will depend  on the transformation backend that is being used.\n\nThw keyword arguments kwargs depend on the transformation backend that is  being used. The default backend TranscriptionOpt uses the keyword  arguments:\n\nlabel::Type{<:AbstractSupportLabel} = PublicLabel: the label of supports to be returned\n\nBy default only the values associated with public supports (i.e., PublicLabels)  are returned, the full set can be accessed via label = All. Where possible, all the values of infinite objects are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters they depend on.\n\nTo provide context for the values, it may be helpful to also query the parameter_refs and supports which will have a one-to-one correspondence with  the output(s) of this function. These functions should  all be called with the same keyword arguments for consistency.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.optimizer_index-Tuple{GeneralVariableRef}","page":"Results","title":"JuMP.optimizer_index","text":"JuMP.optimizer_index(ref::GeneralVariableRef; [kwargs...])\n\nExtend JuMP.optimizer_index for refs in InfiniteModel. The exact format of output will depend  on the transformation backend that is being used.\n\nThw keyword arguments kwargs depend on the transformation backend that is  being used. The default backend TranscriptionOpt uses the keyword  arguments:\n\nlabel::Type{<:AbstractSupportLabel} = PublicLabel: the label of supports to be returned\n\nBy default only the values associated with public supports (i.e., PublicLabels)  are returned, the full set can be accessed via label = All. Where possible, all the values of infinite objects are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters they depend on.\n\nTo provide context for the values, it may be helpful to also query the parameter_refs and supports which will have a one-to-one correspondence with  the output(s) of this function. These functions should  all be called with the same keyword arguments for consistency.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#Constraints","page":"Results","title":"Constraints","text":"","category":"section"},{"location":"manual/result/#JuMP.has_duals-Tuple{InfiniteModel}","page":"Results","title":"JuMP.has_duals","text":"JuMP.has_duals(model::InfiniteModel; result::Int = 1)\n\nExtend JuMP.has_duals  for InfiniteModels in accordance with that reported by its  transformation backend. Errors if such a query is not supported or if the  transformation backend hasn't be solved. Accepts keyword result to access the solution index of interest (if the solver/backend supports  multiple solutions).\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.value-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.value","text":"JuMP.value(cref::InfOptConstraintRef; [kwargs...])\n\nExtend JuMP.value to return the value(s) of cref in accordance with its  reformulation constraint(s) stored in the transformation backend. Use JuMP.has_values to check whether a result exists before checking the values. \n\nThw keyword arguments kwargs depend on the transformation backend that is  being used. The default backend TranscriptionOpt uses the keyword  arguments:\n\nresult::Int = 1: indexes the solution result to be queried\nlabel::Type{<:AbstractSupportLabel} = PublicLabel: the label of supports to be returned\n\nBy default only the values associated with public supports (i.e., PublicLabels)  are returned, the full set can be accessed via label = All. Where possible, all the values of infinite constraints are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters they depend on.\n\nTo provide context for the values, it may be helpful to also query the constraint's  parameter_refs and supports which will have a one-to-one correspondence with  the value(s). It may also be helpful to query via transformation_constraint  to retrieve the constraint(s) that these values are based on. These functions should  all be called with the same keyword arguments for consistency.\n\nFor extensions, this only works if  transformation_constraint has been extended correctly and/or  map_value has been extended for constraints.\n\nExample\n\njulia> value(c1)\n4-element Array{Float64,1}:\n -0.0\n 20.9\n 20.9\n 20.9\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.optimizer_index-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.optimizer_index","text":"JuMP.optimizer_index(ref::InfOptConstraintRef; [kwargs...])\n\nExtend JuMP.optimizer_index for refs in InfiniteModel. The exact format of output will depend  on the transformation backend that is being used.\n\nThw keyword arguments kwargs depend on the transformation backend that is  being used. The default backend TranscriptionOpt uses the keyword  arguments:\n\nlabel::Type{<:AbstractSupportLabel} = PublicLabel: the label of supports to be returned\n\nBy default only the values associated with public supports (i.e., PublicLabels)  are returned, the full set can be accessed via label = All. Where possible, all the values of infinite objects are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters they depend on.\n\nTo provide context for the values, it may be helpful to also query the parameter_refs and supports which will have a one-to-one correspondence with  the output(s) of this function. These functions should  all be called with the same keyword arguments for consistency.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.dual-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.dual","text":"JuMP.dual(cref::InfOptConstraintRef; [kwargs...])\n\nExtend JuMP.dual to return the dual(s) of cref in accordance with its  reformulation constraint(s) stored in the transformation backend. Use JuMP.has_duals to check whether a result exists before checking the duals. \n\nThw keyword arguments kwargs depend on the transformation backend that is  being used. The default backend TranscriptionOpt uses the keyword  arguments:\n\nresult::Int = 1: indexes the solution result to be queried\nlabel::Type{<:AbstractSupportLabel} = PublicLabel: the label of supports to be returned\n\nBy default only the values associated with public supports (i.e., PublicLabels)  are returned, the full set can be accessed via label = All. Where possible, all the duals of infinite cosntraints are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters they depend on.\n\nTo provide context for the duals, it may be helpful to also query the constraint's  parameter_refs and supports which will have a one-to-one correspondence with  the value(s). It may also be helpful to query via transformation_constraint  to retrieve the constraint(s) that these values are based on. These functions should  all be called with the same keyword arguments for consistency.\n\nFor extensions, this only works if  transformation_constraint has been extended correctly and/or  map_dual has been extended for constraints.\n\nExample\n\njulia> dual(c1)\n4-element Array{Float64,1}:\n -42.0\n -42.0\n 32.3\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.shadow_price-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.shadow_price","text":"JuMP.shadow_price(ref::InfOptConstraintRef; [kwargs...])\n\nExtend JuMP.shadow_price for refs in InfiniteModel. The exact format of output will depend  on the transformation backend that is being used.\n\nThw keyword arguments kwargs depend on the transformation backend that is  being used. The default backend TranscriptionOpt uses the keyword  arguments:\n\nlabel::Type{<:AbstractSupportLabel} = PublicLabel: the label of supports to be returned\n\nBy default only the values associated with public supports (i.e., PublicLabels)  are returned, the full set can be accessed via label = All. Where possible, all the values of infinite objects are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters they depend on.\n\nTo provide context for the values, it may be helpful to also query the parameter_refs and supports which will have a one-to-one correspondence with  the output(s) of this function. These functions should  all be called with the same keyword arguments for consistency.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#Expressions","page":"Results","title":"Expressions","text":"","category":"section"},{"location":"manual/result/#JuMP.value-Tuple{Union{GenericAffExpr{Float64, GeneralVariableRef}, GenericNonlinearExpr{GeneralVariableRef}, GenericQuadExpr{Float64, GeneralVariableRef}}}","page":"Results","title":"JuMP.value","text":"JuMP.value(expr::JuMP.AbstractJuMPScalar; [kwargs...])\n\nExtend JuMP.value to return the value(s) of vref in accordance with its  reformulation expression(s) stored in the transformation backend. Use JuMP.has_values to check whether a result exists before checking the values. \n\nThw keyword arguments kwargs depend on the transformation backend that is  being used. The default backend TranscriptionOpt uses the keyword  arguments:\n\nresult::Int = 1: indexes the solution result to be queried\nlabel::Type{<:AbstractSupportLabel} = PublicLabel: the label of supports to be returned\n\nBy default only the values associated with public supports (i.e., PublicLabels)  are returned, the full set can be accessed via label = All. Where possible, all the values of infinite expressions are returned as an n-dimensional array  where each dimension is determined by the each independent group of infinite parameters they depend on.\n\nTo provide context for the values, it may be helpful to also query the expression's  parameter_refs and supports which will have a one-to-one correspondence with  the value(s). It may also be helpful to query via transformation_expression  to retrieve the expression(s) that these values are based on. These functions should  all be called with the same keyword arguments for consistency.\n\nFor extensions, this only works if  transformation_expression has been extended correctly and/or  map_value has been extended for expressions.\n\nExample\n\njulia> value(my_finite_expr)\n23.34\n\njulia> value(my_infinite_expr)\n4-element Array{Float64,1}:\n -0.0\n 20.9\n 20.9\n 20.9\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#LP-Sensitivity","page":"Results","title":"LP Sensitivity","text":"","category":"section"},{"location":"manual/result/#JuMP.lp_sensitivity_report-Tuple{InfiniteModel}","page":"Results","title":"JuMP.lp_sensitivity_report","text":"JuMP.lp_sensitivity_report(\n    model::InfiniteModel;\n    [atol::Float64 = 1e-8]\n    )::InfOptSensitivityReport\n\nExtends JuMP.lp_sensitivity_report to generate and return an LP sensitivity  report in accordance with the transformation backend. See  InfOptSensitivityReport for syntax details on how to query it. atol  denotes the optimality tolerance and should match that used by the solver to  compute the basis. Please refer to JuMP's documentation for more technical  information on interpretting the output of the report.\n\nExample\n\njulia> report = lp_sensitivity_report(model);\n\njulia> report[x]\n(0.0, 0.5)\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#InfiniteOpt.InfOptSensitivityReport","page":"Results","title":"InfiniteOpt.InfOptSensitivityReport","text":"InfOptSensitivityReport\n\nA wrapper DataType for JuMP.SensitivityReports in InfiniteOpt.  These are generated based on the transformation backend and should be made via  the use of lp_sensitivity_report.  Once made these can be indexed to get the sensitivies with respect to variables and/or  constraints. The indexing syntax for these is: \n\nreport[ref::[GeneralVariableRef/InfOptConstraintRef]; \n       [label::Type{<:AbstractSupportLabel} = PublicLabel,\n       kwargs...]]\n\nThis is enabled for new transformation backends by appropriately  extending transformation_variable and  transformation_constraint.\n\nFields\n\nopt_report::JuMP.SensitivityReport: The LP sensitivity captured from the backend.\n\n\n\n\n\n","category":"type"},{"location":"manual/result/#Warmstarts","page":"Results","title":"Warmstarts","text":"","category":"section"},{"location":"manual/result/#InfiniteOpt.warmstart_backend_start_values-Tuple{InfiniteModel}","page":"Results","title":"InfiniteOpt.warmstart_backend_start_values","text":"warmstart_backend_start_values(model::InfiniteModel; [kwargs...])\n\nUse the previous solution values (primals and duals) stored in the transformation  backend of model to warmstart the start values to be used for the next  optimize! call. For JuMPBackends (like TranscriptionBackend) this calls  JuMP.set_start_values on the underlying JuMP model. Note that only start values in the backend model are updated, the start values stored in model remain unchanged.\n\n**Example*\n\njulia> optimize!(model)\n\njulia> warmstart_backend_start_values(model) # call before making model updates\n\njulia> set_parameter_value(p, 42)\n\njulia> optimize!(model)\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#Transformation-Backend-Extension-API","page":"Results","title":"Transformation Backend Extension API","text":"","category":"section"},{"location":"manual/result/#InfiniteOpt.map_value-Tuple{Any, AbstractTransformationBackend}","page":"Results","title":"InfiniteOpt.map_value","text":"map_value([ref/expr], backend::AbstractTransformationBackend; [kwargs...])\n\nMap the value(s) of ref to its counterpart in the backend. Here ref need refer to methods for both variable references and constraint references. No extension is needed for JuMPBackends that support transformation_variable, transformation_expression, and  transformation_constraint. In this case, transformation_variable,  transformation_expression, and transformation_constraint are  used to make these mappings by default where kwargs are passed on these functions.  For mapping the values of infinite parameters, refer to  map_infinite_parameter_value.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#InfiniteOpt.map_infinite_parameter_value","page":"Results","title":"InfiniteOpt.map_infinite_parameter_value","text":"map_infinite_parameter_value(\n    pref::GeneralVariableRef, \n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nReturn the mapped value of the infinite parameter pref according to the  backend. This serves as an optional extension point for new type of  backends that do not rely on using supports. Otherwise, this defaults  to:\n\nmap_infinite_parameter_value(pref; [label = PublicLabel]) = supports(pref, label = label)\n\n\n\n\n\n","category":"function"},{"location":"manual/result/#InfiniteOpt.map_reduced_cost-Tuple{GeneralVariableRef, AbstractTransformationBackend}","page":"Results","title":"InfiniteOpt.map_reduced_cost","text":"map_reduced_cost(\n    ref::GeneralVariableRef,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nMap JuMP.reduced_cost of ref to its counterpart in the backend. No extension is needed for JuMPBackends that support transformation_variable, in which case, transformation_variable is used to make these  mappings using kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#InfiniteOpt.map_optimizer_index-Tuple{GeneralVariableRef, AbstractTransformationBackend}","page":"Results","title":"InfiniteOpt.map_optimizer_index","text":"map_optimizer_index(\n    ref::GeneralVariableRef,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nMap JuMP.optimizer_index of ref to its counterpart in the backend. No extension is needed for JuMPBackends that support transformation_variable, in which case, transformation_variable is used to make these  mappings using kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#InfiniteOpt.map_dual-Tuple{InfOptConstraintRef, AbstractTransformationBackend}","page":"Results","title":"InfiniteOpt.map_dual","text":"map_dual(\n    cref::InfOptConstraintRef,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nMap the dual(s) of cref to its counterpart in the backend. No extension is needed for JuMPBackends that support transformation_constraint. In this case, transformation_constraint  are used to make these mappings by default where kwargs are passed on these  functions.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#InfiniteOpt.map_shadow_price-Tuple{InfOptConstraintRef, AbstractTransformationBackend}","page":"Results","title":"InfiniteOpt.map_shadow_price","text":"map_shadow_price(\n    ref::InfOptConstraintRef,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nMap JuMP.shadow_price of ref to its counterpart in the backend. No extension is needed for JuMPBackends that support transformation_constraint, in which case, transformation_constraint is used to make these  mappings using kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#InfiniteOpt.map_optimizer_index-Tuple{InfOptConstraintRef, AbstractTransformationBackend}","page":"Results","title":"InfiniteOpt.map_optimizer_index","text":"map_optimizer_index(\n    ref::InfOptConstraintRef,\n    backend::AbstractTransformationBackend;\n    [kwargs...]\n    )\n\nMap JuMP.optimizer_index of ref to its counterpart in the backend. No extension is needed for JuMPBackends that support transformation_constraint, in which case, transformation_constraint is used to make these  mappings using kwargs.\n\n\n\n\n\n","category":"method"},{"location":"manual/result/#JuMP.lp_sensitivity_report-Tuple{AbstractTransformationBackend}","page":"Results","title":"JuMP.lp_sensitivity_report","text":"JuMP.lp_sensitivity_report(\n    backend::AbstractTransformationBackend;\n    [atol::Float64 = 1e-8]\n    )::InfOptSensitivityReport\n\nExtend JuMP.lp_sensitivity_report as appropriate for backend. This is intended as an extension point. For JuMPBackends, this simply  calls JuMP.lp_sensitivity_report on the underlying JuMP model. \n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#var_docs","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"A guide for variables in InfiniteOpt. See the respective  technical manual for more details.","category":"page"},{"location":"guide/variable/#Overview","page":"Variables","title":"Overview","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Decision variables are at the very core of InfiniteOpt as its name alludes to mathematical programs that entail infinite decision spaces (i.e., contain infinite decision variables). Principally, 4 variable types are employed: infinite, semi-infinite, point, and finite. Infinite variables encompass any  decision variable that is parameterized by an infinite parameter(s) (e.g.,  space-time variables and stochastic recourse variables). Semi-infinite variables  denote infinite variables where certain infinite parameters are restricted to  point values. Point variables are infinite variables at a particular point.  Finally, finite variables are decisions that are made irrespective of the  infinite domain (e.g., first stage variables and design variables).","category":"page"},{"location":"guide/variable/#Basic-Usage","page":"Variables","title":"Basic Usage","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Infinite, semi-infinite, point, and finite variables are summarized in the  following table:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Name Variable Type Object Description Example\nInfinite Infinite decision functions y(t x xi)\nSemi-Infinite SemiInfinite partially evaluated decision functions y(t_0 x xi)\nPoint Point fully evaluated decision functions y(t_0 x_0 xi_k)\nFinite NA classical decision variables z","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Infinite, semi-infinite, point, and finite variables are defined via  @variable  (inherited from JuMP) with their respective variable type  object arguments: Infinite, SemiInfinite, and Point  (finite variables don't use a variable type object).","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Let's first set up a simple space-time model with infinite parameters time t and spatial position x:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> using InfiniteOpt\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_parameter(model, x[1:2] in [-1, 1], independent = true)\n2-element Vector{GeneralVariableRef}:\n x[1]\n x[2]","category":"page"},{"location":"guide/variable/#Infinite-Variables","page":"Variables","title":"Infinite Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now let's define a time dependent infinite variable y(t) with a lower bound of 0:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, y >= 0, Infinite(t))\ny(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This creates a Julia variable y that points to the decision variable y(t) that is stored in model which is added to include a lower bound of 0. Another useful case is that of defining an array of variables w that depend on both position and time:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, w[i = 1:3], Infinite(t, x...), start = [0, 2, 1][i])\n3-element Vector{GeneralVariableRef}:\n w[1](t, x[1], x[2])\n w[2](t, x[1], x[2])\n w[3](t, x[1], x[2])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, we create a Julia array variable w whose elements w[i] point to their respective infinite variables w[i](t, x) stored in model. Note that the i used in the array definition can be used to index attributes assigned to each variable in the array. In this case, we used i to assign different initial guess values for each variable via the start keyword argument. Also note that we use Infinite(t, x...) instead of Infinite(t, x) since each scalar independent infinite parameter must be in its own argument.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"note: Note\nPrevious versions of InfiniteOpt supported arrays of independent infinite parameters for infinite variables (e.g., Infinite(x) where x is an array of independent infinite parameters). Now each independent infinite parameter must be an individual argument. This can be readily accomplished by splatting the infinite parameters (e.g., Infinite(x...)).","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Moreover, infinite variables can uses functions to define the start values and bounds over a range of support points (e.g., a trajectory). This is discussed further below in the Macro Definition section.","category":"page"},{"location":"guide/variable/#Semi-Infinite-Variables","page":"Variables","title":"Semi-Infinite Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now let's restrict the above infinite variables w[i](t, x) to a particular  time via semi-infinite variables:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> [w[i](0, x...) for i in 1:3]\n3-element Vector{GeneralVariableRef}:\n w[1](0, x[1], x[2])\n w[2](0, x[1], x[2])\n w[3](0, x[1], x[2])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, we create a Julia array of semi-infinite variables w[i](0, x) stored in  model that inherit all properties from the corresponding infinite variables.  This functional syntax is the recommended method for defining semi-infinite variables. See Restricted Variables to learn more. Alternatively,  we can make a semi-infinite variable via @variable:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, w0[i = 1:3] <= 3, SemiInfinite(w[i], 0, x...))\n3-element Vector{GeneralVariableRef}:\n w0[1]\n w0[2]\n w0[3]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This syntax will always overwrite the lower bound, upper bound, fix value, and  start value (or lack their of), so it should be used carefully and purposefully.","category":"page"},{"location":"guide/variable/#Point-Variables","page":"Variables","title":"Point Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now let's add some point variables. These allow us to consider an infinite variable evaluated at a certain infinite parameter point. For example, let's define a point variable for y(0):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> y0 = y(0)\ny(0)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we create a Julia variable y0 which points to the point variable y(0). Again, this inherits all properties (e.g., bounds and start values) from y(t). Again, this is the recommended syntax, see Restricted Variables to learn more. To overwrite all properties, we can instead define a point variable using @variable:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, y0 == 0, Point(y, 0))\ny0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"In this case the lower bound inherited from y(t) is overwritten by instead fixing y(0) to a value of 0.  ","category":"page"},{"location":"guide/variable/#Finite-Variables","page":"Variables","title":"Finite Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, we can add finite variables to our model. These denote variables that hold a single value over the infinite domain or some portion of it (e.g., design variables, first stage variables, etc.). Let's add a finite variable 0 leq d leq 42 that is an integer variable and defined over all infinite domains (i.e., time and space):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, 0 <= d <= 42, Int)\nd","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This creates a Julia variable d that points to the finite variable d which has a lower bound of 0, an upper bound of 42, and is an integer variable. Thus, finite  variables are equivalent to those employed in JuMP.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now we have defined variables that we can use in the objective, measures, and constraints. Please note that the above tutorial only shows a small portion of the capabilities and options available in defining variables. A full description is provided in the documentation below.","category":"page"},{"location":"guide/variable/#Variable-Definition-Methodology","page":"Variables","title":"Variable Definition Methodology","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Defining/initializing a variable (what happens behind the scenes of the variable  macros) principally involves the following steps:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Define the variable information pertaining to JuMP.VariableInfo (e.g.,  bounds, indicate if it is integer, etc.)\nConstruct a concrete subtype of InfOptVariableType to specify the  desired type and its required additional information if appropriate\nBuild the variable object via JuMP.build_variable\nAdd the variable object to an InfiniteModel and assign a name via  JuMP.add_variable\nCreate a GeneralVariableRef that points to the variable object  stored in the model","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"note: Note\nThis methodology is presented for those wanting to learn more about the ins  and outs of variable definition. We recommend that all variables be created  via @variable. See Macro Variable Definition.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The JuMP.VariableInfo data structure stores the following variable information:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"has_lb::Bool: Specifies a Bool it has a lower bound\nlower_bound::Union{Real, Function}: Specifies lower bound value\nhas_ub::Bool: Specifies a Bool it has a upper bound\nupper_bound::Union{Real, Function}: Specifies upper bound value\nhas_fix::Bool: Specifies a Bool it is fixed\nfixed_value::Union{Real, Function}: Specifies the fixed value\nhas_start::Bool: Specifies a Bool it has a start value\nstart::Union{Real, Function}: Specifies the start guess value, this can be a                                 function for infinite variables that intakes a                                 support and maps it to a guess value (allowing                                 to specify guess trajectories)\nbinary: Specifies Bool if it is binary\ninteger: Specifies Bool if it is integer.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, the user specifies this information to prepare such an object:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> info = VariableInfo(true, 0., true, 42., false, 0., false, 0., false, true);","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we specified a lower bound of 0, an upper bound of 42, and that it is integer valued.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The variable type objects (InfOptVariableType subtypes) are used with  build_variable to specify the desired variable type along with any additional  information needed for that type. For example, let's build an infinite variable  y(t) that has an lower bound of 0, an upper bound of 42, and is integer valued:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> info = VariableInfo(true, 0, true, 42, false, 0, false, 0, false, true);\n\njulia> inf_var = build_variable(error, info, Infinite(t));","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, we create an InfiniteVariable object with the desired properties.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Once a variable has been built, it needs to be added to our model and a Julia variable should be defined to reference it. Variables are added via add_variable which adds a variable object to the model, assigns a name to the variable, adds any constraints associated with the JuMP.VariableInfo, and returns an appropriate variable reference variable (a GeneralVariableRef). For example, let's add inf_var to model:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> var_ref = add_variable(model, inf_var, \"y\")\ny(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, we have added an infinite variable y that is parameterized by t with the variable information mentioned above and now have a GeneralVariableRef called var_ref that can be used in defining our infinite model.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Note that the use of GeneralVariableRefs and the corresponding concrete subtypes of DispatchVariableRefs is discussed on the Expressions page.","category":"page"},{"location":"guide/variable/#Macro-Variable-Definition","page":"Variables","title":"Macro Variable Definition","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The @variable  macro automates the variable definition process discussed above in the  Variable Definition Methodology section via a straightforward symbolic  syntax. The only key difference is that non-anonymous macro calls will register  variable names to ensure they are not repeated. Anonymous macro calls forgo this  step and exactly follow the process described above. This section will highlight  the details of using this macro which is the recommended way to define variables.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"tip: Tip\nJuMP's documentation on variables  is a good place to start since InfiniteOpt simply extends JuMP to  accommodate our additional variable types.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We directly build upon  JuMP.@variable  to create all of our decision variable types. To illustrate this via example,  let's setup a model with a variety of infinite parameters t in 010,  x in -1 1^3, and xi in mathcalN(0 1):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> using InfiniteOpt, Distributions\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @infinite_parameter(model, x[1:3] in [-1, 1], independent = true);\n\njulia> @infinite_parameter(model, Î¾ ~ Normal());","category":"page"},{"location":"guide/variable/#Variable-Types","page":"Variables","title":"Variable Types","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We specify the variable type by providing a subtype of InfOptVariableType  as an extra positional argument:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, y, Infinite(t, x..., Î¾)) # explicit infinite variable\ny(t, x[1], x[2], x[3], Î¾)\n\njulia> @variable(model, ys, SemiInfinite(y, 0, x..., Î¾)) # explicit semi-infinite variable\nys\n\njulia> @variable(model, yp, Point(y, 0, [1, 1, 1]..., 0)) # explicit point variable\nyp\n\njulia> @variable(model, z) # explicit finite variable\nz","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For anonymous definition, we use the variable_type keyword argument instead:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia>  y = @variable(model, variable_type = Infinite(t, x..., Î¾)) # anon infinite variable\nnoname(t, x[1], x[2], x[3], Î¾)\n\njulia> ys = @variable(model, variable_type = SemiInfinite(y, 0, x..., Î¾)) # anon semi-infinite variable\nnoname(0, x[1], x[2], x[3], Î¾)\n\njulia> yp = @variable(model, variable_type = Point(y, 0, [1, 1, 1]..., 0)) # anon point variable\nnoname(0, 1, 1, 1, 0)\n\njulia> z = @variable(model) # anon finite variable\nnoname","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Please refer to Infinite, SemiInfinite, and Point  for more information.","category":"page"},{"location":"guide/variable/#Variable-Names","page":"Variables","title":"Variable Names","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Variable inherit their names from the symbolic literal given with explicit  definitions:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, myname, Infinite(t))\nmyname(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This creates an infinite variable with name \"myname\" that is added to model  and creates a Julia variable myname that stores a GeneralVariableRef  which points to the infinite variable in model.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We can overwrite the inherited name using the base_name keyword argument:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, myjlvar, Infinite(t), base_name = \"myname\")\nmyname(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This creates an infinite variable with name \"myname\" that is added to model  and creates a Julia variable myjlvar that stores a GeneralVariableRef  which points to the infinite variable in model.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This syntax is particularly useful for anonymous variables to have meaningful  names:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> myjlvar = @variable(model, variable_type = Infinite(t), base_name = \"myname\")\nmyname(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"See the Queries and Modification sections further below for more information on  how to query/modify variable names.","category":"page"},{"location":"guide/variable/#Variable-Bounds","page":"Variables","title":"Variable Bounds","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We can specify variable bounds in like manner to JuMP variables. Let's  demonstrate this with infinite variables (which accept scalars or functions): ","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, y_lb >= (a, b, c, d) -> a + b + c + d, Infinite(t, x...)) # add w/ lower bound\ny_lb(t, x[1], x[2], x[3])\n\njulia> @variable(model, y_ub <= 10, Infinite(t, x...)) # add w/ upper bound\ny_ub(t, x[1], x[2], x[3])\n\njulia> @variable(model, 0 <= y_bd <= 10, Infinite(t, x...)) # add w/ bounds\ny_bd(t, x[1], x[2], x[3])\n\njulia> @variable(model, y_fix == 42, Infinite(t, x...)) # add w/ fixed value \ny_fix(t, x[1], x[2], x[3])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"warning: Warning\nWhen creating a variable with only a single bound and the value of the bound  is not an explicit numeric literal, the name of the variable must appear on  the left-hand side. Otherwise, the macro will error.@variable(model, 0 <= y, Infinite(t)) # okay\n\na = 0\n@variable(model, a <= y, Infinite(t)) # bad \n@variable(model, y >= a, Infinite(t)) # okay","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For anonymous definition, we use the lower_bound and upper_bound. Let's use  finite variables for example:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> z_lb = @variable(model, lower_bound = 0, base_name = \"z_lb\") # add w/ lower bound\nz_lb\n\njulia> z_ub = @variable(model, upper_bound = 10, base_name = \"z_ub\") # add w/ upper bound\nz_ub\n\njulia> z_bd = @variable(model, lower_bound = 0, upper_bound = 10, \n                        base_name = \"z_bd\") # add w/ bounds\nz_bd\n\njulia> z_fix = @variable(model, lower_bound = 10, upper_bound = 10, \n                         base_name = \"z_fix\") # ~add w/ fixed value \nz_fix","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Note that there isn't a keyword for fixing variables. Instead,  fix should be used. ","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"See the Queries and Modification sections further below for more information on  how to query/modify variable bounds.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"note: Note\nSemi-infinite and point variables defined via @variable overwrite the bounds  of their respective infinite variables:@variable(model, y >= 0, Infinite(t, x...)) # has lower bound\n@variable(model, yp == 0, Point(w, 0, 0, 0, 0)) # forces the point to be fixed","category":"page"},{"location":"guide/variable/#Variable-Integrality","page":"Variables","title":"Variable Integrality","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We can constrain the integrality of decision variables in like manner to JuMP  using the Bin and Int positional arguments for explicit macro definition:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, y_bin, Infinite(t, x...), Bin) # add as binary variable\ny_bin(t, x[1], x[2], x[3])\n\njulia> @variable(model, y_int, Infinite(t, x...), Int) # add as integer variable\ny_int(t, x[1], x[2], x[3])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For anonymous definition, we use the binary and integer keyword arguments:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> y_bin = @variable(model, variable_type = Infinite(t, x...), binary = true)\nnoname(t, x[1], x[2], x[3])\n\njulia> y_int = @variable(model, variable_type = Infinite(t, x...), integer = true)\nnoname(t, x[1], x[2], x[3])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Moreover, we can add bounds as needed to constrain the domain of integer variables:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, 0 <= y_int2 <= 10, Infinite(t, x...), Int)\ny_int2(t, x[1], x[2], x[3])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"See the Queries and Modification sections further below for more information on  how to query/modify variable integralities.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"note: Note\nSemi-infinite and point variables inherit the integrality of their respective infinite variables and these cannot be overwritten.","category":"page"},{"location":"guide/variable/#Variable-Start-Values","page":"Variables","title":"Variable Start Values","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Optimization solvers often benefit from giving initial guesses for the optimal  decision variable values. Following JuMP vernacular, these are called start  values. We use the keyword start to specify these at variable creation:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, z_start, start = 42)\nz_start","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Moreover, infinite variables can accept a function that specifies the start  value of over the range of its infinite parameters (e.g., a function that provides  an initial guess trajectory). For example, consider the difference between these  two infinite variables:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, y_uniform, Infinite(t), start = 0) # start with y(t) = 0\ny_uniform(t)\n\njulia> @variable(model, y_sin, Infinite(t), start = sin) # start with y(t) = sin(t)\ny_sin(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Note that such start functions must be able to accept parameter values as  arguments that exactly match the format of the infinite parameters given in  Infinite(params...).","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"See the Queries and Modification sections further below for more information on  how to query/modify variable names.","category":"page"},{"location":"guide/variable/#Variable-Containers","page":"Variables","title":"Variable Containers","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Optimization problems often involve multi-dimensional decision variables. Luckily,  JuMP provides a versatile syntax for specifying collections (i.e., containers)  of variables. See  JuMP's container documentation  for a thorough tutorial on the syntax. It uses Arrays, DenseAxisArrays, and  SparseAxisArrays to contain the variable references created. Here  DenseAxisArrays and SparseAxisArrays allow the use of nontraditional indices  (i.e., can use indices that are not sequential integers).","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"To illustrate what this means, consider the two equivalent ways to define  a 3-dimensional vector of variables with indices [1, 2, 3]:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> s = [0, 2, 1];\n\njulia> var_refs = @variable(model, [i = 1:3], start = s[i], base_name = \"z\")\n3-element Vector{GeneralVariableRef}:\n z[1]\n z[2]\n z[3]\n\njulia> var_refs = Vector{GeneralVariableRef}(undef, 3);\n\njulia> for i in eachindex(var_refs)\n          var_refs[i] = @variable(model, start = s[i], base_name = \"z\")\n       end","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Moreover, here are a few illustrative examples:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, z_dense[2:4])\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 2:4\nAnd data, a 3-element Vector{GeneralVariableRef}:\n z_dense[2]\n z_dense[3]\n z_dense[4]\n\njulia> @variable(model, z_named[[:A, :C, :Z]])\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, [:A, :C, :Z]\nAnd data, a 3-element Vector{GeneralVariableRef}:\n z_named[A]\n z_named[C]\n z_named[Z]\n\njulia> @variable(model, z_sparse[i = 1:2, j = 1:2; i + j <= 3])\nJuMP.Containers.SparseAxisArray{GeneralVariableRef, 2, Tuple{Int64, Int64}} with 3 entries:\n  [1, 1]  =  z_sparse[1,1]\n  [1, 2]  =  z_sparse[1,2]\n  [2, 1]  =  z_sparse[2,1]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The variable macro will by default automatically detect which container type  should be used. However, the user can specify a particular container type using  the container keyword. For example, if we want to use indices a:b where  a = 1 and b = 3, a DenseAxisArray will be used by default, but we can  force it to be a regular Array:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> a = 1; b = 3;\n\njulia> var_refs1 = @variable(model, [a:b], base_name = \"z\")\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:3\nAnd data, a 3-element Vector{GeneralVariableRef}:\n z[1]\n z[2]\n z[3]\n\njulia> var_refs2 = @variable(model, [a:b], base_name = \"z\", container = Array)\n3-element Vector{GeneralVariableRef}:\n z[1]\n z[2]\n z[3]","category":"page"},{"location":"guide/variable/#Variable-Sets","page":"Variables","title":"Variable Sets","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Like JuMP variables, we can constrain variables on creation to lie in  particular sets. This allows us to make semi-definite variables, cone constrained  variables, and more. ","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For example:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, z_psd[1:2, 1:2], PSD) # positive semi-definite variable matrix\n2Ã—2 LinearAlgebra.Symmetric{GeneralVariableRef, Matrix{GeneralVariableRef}}:\n z_psd[1,1]  z_psd[1,2]\n z_psd[1,2]  z_psd[2,2]\n\njulia> @variable(model, z_cone[1:3] in SecondOrderCone()) # 2nd order cone variables\n3-element Vector{GeneralVariableRef}:\n z_cone[1]\n z_cone[2]\n z_cone[3]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Typically, variable sets can be defined symbolically using the syntax  var in set. For anonymous variables, the set keyword argument must be used:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> z_cone = @variable(model, [1:3], set = SecondOrderCone())\n3-element Vector{GeneralVariableRef}:\n noname\n noname\n noname","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For a more thorough tutorial please see  JuMP's semi-definite documentation  and/or JuMP's variables constrained on creation documentation.","category":"page"},{"location":"guide/variable/#Anonymous-Variables","page":"Variables","title":"Anonymous Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Above we talked showed the syntax for both explicit and anonymous variable  creation. Anonymous creation is typically helpful in the following situations:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"defining multiple variables with the same name\ncreating variables in user defined extensions\nusing nontraditional naming","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For anonymous variables, the only accepted positional arguments are the model  and the container expression [indices...]. Everything else must be specified  via keyword arguments kwargs... as shown in the subsections above.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"@variable(model, [indices...], kwargs...)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For more information, see  JuMP's anonymous variable documentation.","category":"page"},{"location":"guide/variable/#The-@variables-Macro","page":"Variables","title":"The @variables Macro","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"When using many @variable calls, we can instead use  @variables to  enhance the readability:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variables(model, begin\n           y1, Infinite(t, x...)\n           y2[i=1:2] >= i, Infinite(t), (start = i, base_name = \"Y_$i\")\n           z2, Bin\n       end)\n(y1(t, x[1], x[2], x[3]), GeneralVariableRef[Y_1[1](t), Y_2[2](t)], z2)","category":"page"},{"location":"guide/variable/#Restricted-Variables","page":"Variables","title":"Restricted Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"To define point and semi-infinite variables, we can also use restrict  for convenient inline definitions.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For example, let's consider restricting the infinite variable y(t, x):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 1]);\n\njulia> @infinite_parameter(model, x[1:2] in [-1, 1]);\n\njulia> @variable(model, y, Infinite(t, x))\ny(t, x)\n\njulia> pt = restrict(y, 0, [-1, 1]) # make point variable y(0, [-1, 1])\ny(0, [-1, 1])\n\njulia> semi = restrict(y, 0, x) # make semi-infinite variable y(0, x)\ny(0, [x[1], x[2]])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We can also, even more conveniently, treat the infinite variable as a function  to accomplish this in a more intuitive syntax:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> pt = y(0, [-1, 1]) # make point variable y(0, [-1, 1])\ny(0, [-1, 1])\n\njulia> semi = y(0, x) # make semi-infinite variable y(0, x)\ny(0, [x[1], x[2]])","category":"page"},{"location":"guide/variable/#Parameters","page":"Variables","title":"Parameters","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Like JuMP, InfiniteOpt supports the use of MOI.Parameter. For instance,  consider making a finite variable as a parameter:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, param in Parameter(42))\nparam","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"which simply produces a finite parameter (i.e., is equivalent to  @finite_parameter(model, param == 42)). For infinite variables, the use  of MOI.Parameter simply produces a parameter function:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @variable(model, pfunc in Parameter(sin), Infinite(t))\npfunc(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"which is equivalent to @parameter_function(model, pfunc == sin(t)). All parameters can be updated via set_parameter_value, see Finite Parameters and Parameter Function to learn more.","category":"page"},{"location":"guide/variable/#Queries","page":"Variables","title":"Queries","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfiniteOpt contains a large suite of methods to query information about variables. This suite comprises extensions to all current JuMP query methods and many more that are specific to InfiniteOpt. A number of the more commonly used ones are explained in this section, but all the available methods are explained in the technical manual.","category":"page"},{"location":"guide/variable/#General-Information","page":"Variables","title":"General Information","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we describe some methods used to query general variable information such as the name. Variable names can be extracted via name which returns the name of a variable. The index of a variable (where it is stored  in the infinite model) is accessed via  index and the infinite model it  belongs to is given by  owner_model. These methods are demonstrated below:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> name(y)\n\"y\"\n\njulia> index(y)\nInfiniteVariableIndex(2)\n\njulia> model_where_stored = owner_model(y);","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Also, num_variables is useful in returning the total number of decision variables currently stored in an infinite model:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> num_variables(model)\n61\n\njulia> num_variables(model, PointVariable)\n2","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Similarly, all_variables returns a list of all the variables currently added to the model.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, variable_by_name can be employed to return the appropriate GeneralVariableRef based off  of the variable name if it is unique. Returns nothing if such a name cannot be  found and errors if it is not unique. For example, we can request the reference  associated with \"y_ub\":","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> variable_by_name(model, \"y_ub\")\ny_ub(t, x[1], x[2], x[3])","category":"page"},{"location":"guide/variable/#Variable-Constraint-Info","page":"Variables","title":"Variable Constraint Info","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"As described above, variables in InfiniteOpt can have constraints associated with them like JuMP variables. These constraints include:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"lower bounds\nupper bounds\nfixed values\nbinary valued\ninteger valued.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, a number of methods exist to query information about these constraints.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"First, the [has/is]_[variable constraint type] methods indicate whether  a variable has that particular constraint type. For example, to query if a  variable y_lb has a lower bound we can use has_lower_bound:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> has_lower_bound(y_bd)\ntrue","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, y_bd does have a lower bound. The other methods are has_upper_bound, is_fixed, is_binary, and is_integer.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Next, the [ConstraintType]Ref methods return an appropriate explicit type InfOptConstraintRef that points to the constraint (errors if no such constraint exists). For example, the upper bound constraint of y_bd can be obtained via UpperBoundRef:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> UpperBoundRef(y_bd)\ny_bd(t, x[1], x[2], x[3]) â‰¤ 10, âˆ€ t âˆˆ [0, 10], x[1] âˆˆ [-1, 1], x[2] âˆˆ [-1, 1], x[3] âˆˆ [-1, 1]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The other methods are LowerBoundRef, FixRef, BinaryRef, and IntegerRef.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, variable constraints that entail values (i.e., lower bounds, upper bounds, and fixed values) have their values queried via the appropriate method. For example, the lower bound value of y_bd is obtained via lower_bound:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> lower_bound(y_bd)\n0.0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Note these methods error when no such constraint is associated with the variable. The other methods are upper_bound and fix_value.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The start value can also be queried via  start_value where nothing  is returned if not start value is specified:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> start_value(var_refs[1])\n0.0\n\njulia> start_value(yp)","category":"page"},{"location":"guide/variable/#Variable-Use","page":"Variables","title":"Variable Use","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfiniteOpt defines a number of methods to track if and how variables are used in an infinite model. For example, used_by_constraint is used to determine if a variable is used by a constraint. For example, let's see if y_bd is used by a constraint:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> used_by_constraint(y_bd)\ntrue","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Other methods include used_by_measure and used_by_objective. For infinite variables, used_by_point_variable can also be used similarly.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, in general is_used can be used to determine if a variable is used at all in the infinite model or not. For  example, if we check yp using is_used we find that it isn't:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> is_used(yp)\nfalse","category":"page"},{"location":"guide/variable/#Type-Specific","page":"Variables","title":"Type Specific","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfiniteOpt also employs a few methods for specific variable types that return information pertaining to that particular variable type. For infinite variables  and semi-infinite variables, parameter_refs returns the tuple of infinite parameters that the variable depends on. For example, consider y(t, x):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> parameter_refs(y)\n(t, x[1], x[2], x[3], Î¾)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For point variables, infinite_variable_ref and parameter_values return the infinite variable it depends on and the infinite parameter point values, respectively. For example, consider the point variable yp:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> infinite_variable_ref(yp)\ny(t, x[1], x[2], x[3], Î¾)\n\njulia> parameter_values(yp)\n(0.0, 1.0, 1.0, 1.0, 0.0)","category":"page"},{"location":"guide/variable/#Modification","page":"Variables","title":"Modification","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfiniteOpt employs a wide variety of methods to modify/delete variables. These are comprised of JuMP extensions and methods native only to InfiniteOpt. This section will highlight some of the more commonly used ones. All the methods/macros are detailed in the technical manual.","category":"page"},{"location":"guide/variable/#Deletion","page":"Variables","title":"Deletion","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Like JuMP v0.19+, InfiniteOpt fully supports deletion throughout its data types. Any variable and its dependencies can be deleted via delete. Thus, when  delete is invoked any bound/type constraints associated with the variable will  be removed and it will be removed from any other constraints, measures, and/or  objectives. For example, if we delete y(t, x, Î¾) it will be removed along with  its  bounds and the point variable yp will also be removed since it is a  dependent:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> delete(model, y)\n\njulia> is_valid(model, yp)\nfalse","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Another class of deletion methods correspond to variable constraints. For example, delete_lower_bound is used to delete a lower bound associated with a variable if it has one. Let's illustrate this by deleting the lower bound of y_bd:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> delete_lower_bound(y_bd)\n\njulia> has_lower_bound(y_bd)\nfalse","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Other similar methods are delete_upper_bound, unfix, unset_binary, and unset_integer.","category":"page"},{"location":"guide/variable/#Variable-Constraints","page":"Variables","title":"Variable Constraints","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Another class of methods seek to add/modify variable constraints such as bounds. For example, set_lower_bound specifies the lower bound of a variable. We can add a lower bound of 0 to z by:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> set_lower_bound(z, 0)\n\njulia> lower_bound(z)\n0.0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, adding a lower bound to z. Furthermore, we can later modify the lower bound using the same method:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> set_lower_bound(z, -2)\n\njulia> lower_bound(z)\n-2.0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Other similar methods are set_upper_bound, fix, set_binary, and set_integer.","category":"page"},{"location":"guide/variable/#Start-Values","page":"Variables","title":"Start Values","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We can update the start value of a variable using  set_start_value. For example:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> set_start_value(z, 0)\n\njulia> start_value(z)\n0.0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"If the model is optimized, we can also set the start values for all variables based on the previous solution via set_start_values, but this requires that Interpolations be imported.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"note: Note\nFor effective resolves,  warmstart_backend_start_values provides a convenient and efficient way to update the start values used by the backend using a previous solution stored in the backend.optimize!(model)\nwarmstart_backend_start_values(model)\nset_parameter_value(p, 42)\noptimize!(model)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"A number of other techniques exist for the various variable types can be found in  the manual.","category":"page"}]
}
