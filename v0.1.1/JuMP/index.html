<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JuMP Docs · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../guide/install/">Installation</a></li><li><a class="tocitem" href="../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../guide/sets/">Infinite Sets</a></li><li><a class="tocitem" href="../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../guide/variable/">Variables</a></li><li><a class="tocitem" href="../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../guide/measure/">Measures</a></li><li><a class="tocitem" href="../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../guide/result/">Results</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li><li><a class="tocitem" href="../develop/">Development</a></li><li><a class="tocitem" href="../library/">Library</a></li><li class="is-active"><a class="tocitem" href>JuMP Docs</a><ul class="internal"><li><a class="tocitem" href="#Model-1"><span>Model</span></a></li><li><a class="tocitem" href="#Variables-1"><span>Variables</span></a></li><li><a class="tocitem" href="#Expressions-1"><span>Expressions</span></a></li><li><a class="tocitem" href="#Objectives-1"><span>Objectives</span></a></li><li><a class="tocitem" href="#jump_constrs-1"><span>Constraints</span></a></li><li><a class="tocitem" href="#Optimization-1"><span>Optimization</span></a></li><li><a class="tocitem" href="#Queries-1"><span>Queries</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>JuMP Docs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>JuMP Docs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/JuMP.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JuMP-Documentation-1"><a class="docs-heading-anchor" href="#JuMP-Documentation-1">JuMP Documentation</a><a class="docs-heading-anchor-permalink" href="#JuMP-Documentation-1" title="Permalink"></a></h1><h2 id="Model-1"><a class="docs-heading-anchor" href="#Model-1">Model</a><a class="docs-heading-anchor-permalink" href="#Model-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.Model" href="#JuMP.Model"><code>JuMP.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Model</code></pre><p>A mathematical model of an optimization problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.Model-Tuple{}" href="#JuMP.Model-Tuple{}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC)</code></pre><p>Return a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the <code>CachingOptimizer</code> storing this cache is <code>caching_mode</code>. Use <a href="../guide/optimize/#JuMP.set_optimizer-Tuple{InfiniteModel,Any}"><code>set_optimizer</code></a> to set the optimizer before calling <a href="#JuMP.optimize!-Tuple{Model,Any}"><code>optimize!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.Model-Tuple{Any}" href="#JuMP.Model-Tuple{Any}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Model(optimizer_factory;
      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
      bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model with the provided optimizer and bridge settings. This function is equivalent to:</p><pre><code class="language-julia">    model = Model()
    set_optimizer(model, optimizer_factory,
                  bridge_constraints=bridge_constraints)
    return model</code></pre><p>See <a href="../guide/optimize/#JuMP.set_optimizer-Tuple{InfiniteModel,Any}"><code>set_optimizer</code></a> for the description of the <code>optimizer_factory</code> and <code>bridge_constraints</code> arguments.</p><p><strong>Examples</strong></p><p>The following creates a model with the optimizer set to <code>Ipopt</code>:</p><pre><code class="language-julia">model = Model(Ipopt.Optimizer)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.NoOptimizer" href="#JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NoOptimizer &lt;: Exception end</code></pre><p>No optimizer is set. The optimizer can be provided to the <a href="#JuMP.Model"><code>Model</code></a> constructor or by calling <a href="../guide/optimize/#JuMP.set_optimizer-Tuple{InfiniteModel,Any}"><code>set_optimizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_with_attributes-Tuple{Any,Pair}" href="#JuMP.optimizer_with_attributes-Tuple{Any,Pair}"><code>JuMP.optimizer_with_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizer_with_attributes(optimizer_constructor, attrs::Pair...)</code></pre><p>Groups an optimizer constructor with the list of attributes <code>attrs</code>. Note that it is equivalent to <code>MOI.OptimizerWithAttributes</code>.</p><p>When provided to the <code>Model</code> constructor or to <a href="../guide/optimize/#JuMP.set_optimizer-Tuple{InfiniteModel,Any}"><code>set_optimizer</code></a>, it creates an optimizer by calling <code>optimizer_constructor()</code>, and then sets the attributes using <a href="#JuMP.set_optimizer_attribute-Tuple{Model,String,Any}"><code>set_optimizer_attribute</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model(
    optimizer_with_attributes(
        Gurobi.Optimizer, &quot;Presolve&quot; =&gt; 0, &quot;OutputFlag&quot; =&gt; 1
    )
)</code></pre><p>is equivalent to:</p><pre><code class="language-julia">model = Model(Gurobi.Optimizer)
set_optimizer_attribute(model, &quot;Presolve&quot;, 0)
set_optimizer_attribute(model, &quot;OutputFlag&quot;, 1)</code></pre><p><strong>Note</strong></p><p>The string names of the attributes are specific to each solver. One should consult the solver&#39;s documentation to find the attributes of interest.</p><p>See also: <a href="#JuMP.set_optimizer_attribute-Tuple{Model,String,Any}"><code>set_optimizer_attribute</code></a>, <a href="#JuMP.set_optimizer_attributes-Tuple{Model,Pair}"><code>set_optimizer_attributes</code></a>, <a href="#JuMP.get_optimizer_attribute-Tuple{Model,String}"><code>get_optimizer_attribute</code></a>.</p></div></section></article><h2 id="Variables-1"><a class="docs-heading-anchor" href="#Variables-1">Variables</a><a class="docs-heading-anchor-permalink" href="#Variables-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.AbstractVariableRef" href="#JuMP.AbstractVariableRef"><code>JuMP.AbstractVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractVariableRef</code></pre><p>Variable returned by <a href="#JuMP.add_variable"><code>add_variable</code></a>. Affine (resp. quadratic) operations with variables of type <code>V&lt;:AbstractVariableRef</code> and coefficients of type <code>T</code>     create a <code>GenericAffExpr{T,V}</code> (resp. <code>GenericQuadExpr{T,V}</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_variable" href="#JuMP.add_variable"><code>JuMP.add_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_variable(m::Model, v::AbstractVariable, name::String=&quot;&quot;)</code></pre><p>Add a variable <code>v</code> to <code>Model m</code> and sets its name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.@variable" href="#JuMP.@variable"><code>JuMP.@variable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@variable(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable.</p><pre><code class="language-none">@variable(model, expr, args..., kw_args...)</code></pre><p>Add a variable to the model <code>model</code> described by the expression <code>expr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. The expression <code>expr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>)</p><ul><li>of the form <code>varexpr</code> creating variables described by <code>varexpr</code>;</li><li>of the form <code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>);</li><li>of the form <code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values given by <code>value</code>; or</li><li>of the form <code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code>.</li><li>of the form <code>varexpr in set</code> creating variables described by <code>varexpr</code> constrained to belong to <code>set</code>, see <a href="@ref">Variables constrained on creation</a>.</li></ul><p>The expression <code>varexpr</code> can either be</p><ul><li>of the form <code>varname</code> creating a scalar real variable of name <code>varname</code>;</li><li>of the form <code>varname[...]</code> or <code>[...]</code> creating a container of variables (see <a href="@ref">Containers in macros</a>).</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li><li><code>Symmetric</code>: Only available when creating a square matrix of variables, i.e. when <code>varexpr</code> is of the form <code>varname[1:n,1:n]</code> or <code>varname[i=1:n,j=1:n]</code>. It creates a symmetric matrix of variable, that is, it only creates a new variable for <code>varname[i,j]</code> with <code>i ≤ j</code> and sets <code>varname[j,i]</code> to the same variable as <code>varname[i,j]</code>. It is equivalent to using <code>varexpr in SymMatrixSpace()</code> as <code>expr</code>.</li><li><code>PSD</code>: The square matrix of variable is both <code>Symmetric</code> and constrained to be positive semidefinite. It is equivalent to using <code>varexpr in PSDCone()</code> as <code>expr</code>.</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>variable_type</code>: See the &quot;Note for extending the variable macro&quot; section below.</li><li><code>set</code>: Equivalent to using <code>varexpr in value</code> as <code>expr</code> where <code>value</code> is the value of the keyword argument.</li><li><code>container</code>: Specify the container type, see <a href="@ref">Containers in macros</a>.</li></ul><p><strong>Examples</strong></p><p>The following are equivalent ways of creating a variable <code>x</code> of name <code>x</code> with lower bound 0:</p><pre><code class="language-julia"># Specify everything in `expr`
@variable(model, x &gt;= 0)
# Specify the lower bound using a keyword argument
@variable(model, x, lower_bound=0)
# Specify everything in `kw_args`
x = @variable(model, base_name=&quot;x&quot;, lower_bound=0)</code></pre><p>The following are equivalent ways of creating a <code>DenseAxisArray</code> of index set <code>[:a, :b]</code> and with respective upper bounds 2 and 3 and names <code>x[a]</code> and <code>x[b]</code>. The upper bound can either be specified in <code>expr</code>:</p><pre><code class="language-julia">ub = Dict(:a =&gt; 2, :b =&gt; 3)
@variable(model, x[i=keys(ub)] &lt;= ub[i])

# output
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, Symbol[:a, :b]
And data, a 2-element Array{VariableRef,1}:
 x[a]
 x[b]</code></pre><p>or it can be specified with the <code>upper_bound</code> keyword argument:</p><pre><code class="language-julia">@variable(model, y[i=keys(ub)], upper_bound=ub[i])

# output
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, Symbol[:a, :b]
And data, a 2-element Array{VariableRef,1}:
 y[a]
 y[b]</code></pre><p><strong>Note for extending the variable macro</strong></p><p>The single scalar variable or each scalar variable of the container are created using <code>add_variable(model, build_variable(_error, info, extra_args...; extra_kw_args...))</code> where</p><ul><li><code>model</code> is the model passed to the <code>@variable</code> macro;</li><li><code>_error</code> is an error function with a single <code>String</code> argument showing the <code>@variable</code> call in addition to the error message given as argument;</li><li><code>info</code> is the <code>VariableInfo</code> struct containing the information gathered in <code>expr</code>, the recognized keyword arguments (except <code>base_name</code> and <code>variable_type</code>) and the recognized positional arguments (except <code>Symmetric</code> and <code>PSD</code>);</li><li><code>extra_args</code> are the unrecognized positional arguments of <code>args</code> plus the value of the <code>variable_type</code> keyword argument if present. The <code>variable_type</code> keyword argument allows the user to pass a position argument to <code>build_variable</code> without the need to give a positional argument to <code>@variable</code>. In particular, this allows the user to give a positional argument to the <code>build_variable</code> call when using the anonymous single variable syntax <code>@variable(model, kw_args...)</code>; and</li><li><code>extra_kw_args</code> are the unrecognized keyword argument of <code>kw_args</code>.</li></ul><p><strong>Examples</strong></p><p>The following creates a variable <code>x</code> of name <code>x</code> with <code>lower_bound</code> 0 as with the first example above but does it without using the <code>@variable</code> macro</p><pre><code class="language-julia">info = VariableInfo(true, 0, false, NaN, false, NaN, false, NaN, false, false)
JuMP.add_variable(model, JuMP.build_variable(error, info), &quot;x&quot;)</code></pre><p>The following creates a <code>DenseAxisArray</code> of index set <code>[:a, :b]</code> and with respective upper bounds 2 and 3 and names <code>x[a]</code> and <code>x[b]</code> as with the second example above but does it without using the <code>@variable</code> macro</p><pre><code class="language-julia"># Without the `@variable` macro
x = JuMP.Containers.container(i -&gt; begin
        info = VariableInfo(false, NaN, true, ub[i], false, NaN, false, NaN, false, false)
        x[i] = JuMP.add_variable(model, JuMP.build_variable(error, info), &quot;x[$i]&quot;)
    end, JuMP.Containers.vectorized_product(keys(ub)))

# output
1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:
    Dimension 1, Symbol[:a, :b]
And data, a 2-element Array{VariableRef,1}:
 x[a]
 x[b]</code></pre><p>The following are equivalent ways of creating a <code>Matrix</code> of size <code>N x N</code> with variables custom variables created with a JuMP extension using the <code>Poly(X)</code> positional argument to specify its variables:</p><pre><code class="language-julia"># Using the `@variable` macro
@variable(model, x[1:N,1:N], Symmetric, Poly(X))
# Without the `@variable` macro
x = Matrix{JuMP.variable_type(model, Poly(X))}(N, N)
info = VariableInfo(false, NaN, false, NaN, false, NaN, false, NaN, false, false)
for i in 1:N, j in i:N
    x[i,j] = x[j,i] = JuMP.add_variable(model, build_variable(error, info, Poly(X)), &quot;x[$i,$j]&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{Model,VariableRef}" href="#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete(model::Model, variable_ref::VariableRef)</code></pre><p>Delete the variable associated with <code>variable_ref</code> from the model <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{Model,VariableRef}" href="#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_valid(model::Model, variable_ref::VariableRef)</code></pre><p>Return <code>true</code> if <code>variable</code> refers to a valid variable in <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{VariableRef,String}" href="#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_name(v::VariableRef, s::AbstractString)</code></pre><p>Set a variable&#39;s name attribute.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.owner_model-Tuple{AbstractVariableRef}" href="#JuMP.owner_model-Tuple{AbstractVariableRef}"><code>JuMP.owner_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">owner_model(v::AbstractVariableRef)</code></pre><p>Returns the model to which <code>v</code> belongs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; model = Model()

julia&gt; x = @variable(model)

julia&gt; owner_model(x) === model
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.index-Tuple{VariableRef}" href="#JuMP.index-Tuple{VariableRef}"><code>JuMP.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index(v::VariableRef)::MOI.VariableIndex</code></pre><p>Return the index of the variable that corresponds to <code>v</code> in the MOI backend.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_variables-Tuple{Model}" href="#JuMP.num_variables-Tuple{Model}"><code>JuMP.num_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_variables(model::Model)::Int64</code></pre><p>Returns number of variables in <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{VariableRef}" href="#JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">name(v::VariableRef)::String</code></pre><p>Get a variable&#39;s name attribute.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.variable_by_name-Tuple{Model,String}" href="#JuMP.variable_by_name-Tuple{Model,String}"><code>JuMP.variable_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">variable_by_name(model::AbstractModel,
                 name::String)::Union{AbstractVariableRef, Nothing}</code></pre><p>Returns the reference of the variable with name attribute <code>name</code> or <code>Nothing</code> if no variable has this name attribute. Throws an error if several variables have <code>name</code> as their name attribute.</p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; variable_by_name(model, &quot;x&quot;)
x

julia&gt; @variable(model, base_name=&quot;x&quot;)
x

julia&gt; variable_by_name(model, &quot;x&quot;)
ERROR: Multiple variables have the name x.
Stacktrace:
 [1] error(::String) at ./error.jl:33
 [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222
 [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]
 [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490
 [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268
 [6] top-level scope at none:0

julia&gt; var = @variable(model, base_name=&quot;y&quot;)
y

julia&gt; variable_by_name(model, &quot;y&quot;)
y

julia&gt; set_name(var, &quot;z&quot;)

julia&gt; variable_by_name(model, &quot;y&quot;)

julia&gt; variable_by_name(model, &quot;z&quot;)
z

julia&gt; @variable(model, u[1:2])
2-element Array{VariableRef,1}:
 u[1]
 u[2]

julia&gt; variable_by_name(model, &quot;u[2]&quot;)
u[2]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_variables-Tuple{Model}" href="#JuMP.all_variables-Tuple{Model}"><code>JuMP.all_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all_variables(model::Model)::Vector{VariableRef}</code></pre><p>Returns a list of all variables currently in the model. The variables are ordered by creation time.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model()
@variable(model, x)
@variable(model, y)
all_variables(model)

# output

2-element Array{VariableRef,1}:
 x
 y</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{VariableRef}" href="#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_lower_bound(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> has a lower bound. If <code>true</code>, the lower bound can be queried with <a href="#JuMP.lower_bound-Tuple{VariableRef}"><code>lower_bound</code></a>. See also <a href="#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>LowerBoundRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{VariableRef}" href="#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lower_bound(v::VariableRef)</code></pre><p>Return the lower bound of a variable. Error if one does not exist. See also <a href="#JuMP.has_lower_bound-Tuple{VariableRef}"><code>has_lower_bound</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{VariableRef,Number}" href="#JuMP.set_lower_bound-Tuple{VariableRef,Number}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_lower_bound(v::VariableRef, lower::Number)</code></pre><p>Set the lower bound of a variable. If one does not exist, create a new lower bound constraint. See also <a href="#JuMP.delete_lower_bound-Tuple{VariableRef}"><code>delete_lower_bound</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{VariableRef}" href="#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LowerBoundRef(v::VariableRef)</code></pre><p>Return a constraint reference to the lower bound constraint of <code>v</code>. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete_lower_bound-Tuple{VariableRef}" href="#JuMP.delete_lower_bound-Tuple{VariableRef}"><code>JuMP.delete_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_lower_bound(v::VariableRef)</code></pre><p>Delete the lower bound constraint of a variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{VariableRef}" href="#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_upper_bound(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> has a upper bound. If <code>true</code>, the upper bound can be queried with <a href="#JuMP.upper_bound-Tuple{VariableRef}"><code>upper_bound</code></a>. See also <a href="#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>UpperBoundRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{VariableRef}" href="#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_bound(v::VariableRef)</code></pre><p>Return the upper bound of a variable. Error if one does not exist. See also <a href="#JuMP.has_upper_bound-Tuple{VariableRef}"><code>has_upper_bound</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{VariableRef,Number}" href="#JuMP.set_upper_bound-Tuple{VariableRef,Number}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_upper_bound(v::VariableRef,upper::Number)</code></pre><p>Set the upper bound of a variable. If one does not exist, create an upper bound constraint. See also <a href="#JuMP.delete_upper_bound-Tuple{VariableRef}"><code>delete_upper_bound</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{VariableRef}" href="#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UpperBoundRef(v::VariableRef)</code></pre><p>Return a constraint reference to the upper bound constraint of <code>v</code>. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete_upper_bound-Tuple{VariableRef}" href="#JuMP.delete_upper_bound-Tuple{VariableRef}"><code>JuMP.delete_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_upper_bound(v::VariableRef)</code></pre><p>Delete the upper bound constraint of a variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{VariableRef}" href="#JuMP.is_fixed-Tuple{VariableRef}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_fixed(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is a fixed variable. If <code>true</code>, the fixed value can be queried with <a href="#JuMP.fix_value-Tuple{VariableRef}"><code>fix_value</code></a>. See also <a href="#JuMP.FixRef-Tuple{VariableRef}"><code>FixRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{VariableRef}" href="#JuMP.fix_value-Tuple{VariableRef}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fix_value(v::VariableRef)</code></pre><p>Return the value to which a variable is fixed. Error if one does not exist. See also <a href="#JuMP.is_fixed-Tuple{VariableRef}"><code>is_fixed</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix-Tuple{VariableRef,Number}" href="#JuMP.fix-Tuple{VariableRef,Number}"><code>JuMP.fix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fix(v::VariableRef, value::Number; force::Bool = false)</code></pre><p>Fix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one. See also <a href="#JuMP.unfix-Tuple{VariableRef}"><code>unfix</code></a>.</p><p>If the variable already has variable bounds and <code>force=false</code>, calling <code>fix</code> will throw an error. If <code>force=true</code>, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to <a href="#JuMP.unfix-Tuple{VariableRef}"><code>unfix</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{VariableRef}" href="#JuMP.FixRef-Tuple{VariableRef}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FixRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint fixing the value of <code>v</code>. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unfix-Tuple{VariableRef}" href="#JuMP.unfix-Tuple{VariableRef}"><code>JuMP.unfix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unfix(v::VariableRef)</code></pre><p>Delete the fixing constraint of a variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.start_value-Tuple{VariableRef}" href="#JuMP.start_value-Tuple{VariableRef}"><code>JuMP.start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_value(v::VariableRef)</code></pre><p>Return the start value (MOI attribute <code>VariablePrimalStart</code>) of the variable <code>v</code>. See also <a href="#JuMP.set_start_value-Tuple{VariableRef,Number}"><code>set_start_value</code></a>.</p><p>Note: <code>VariablePrimalStart</code>s are sometimes called &quot;MIP-starts&quot; or &quot;warmstarts&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_start_value-Tuple{VariableRef,Number}" href="#JuMP.set_start_value-Tuple{VariableRef,Number}"><code>JuMP.set_start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_start_value(variable::VariableRef, value::Number)</code></pre><p>Set the start value (MOI attribute <code>VariablePrimalStart</code>) of the variable <code>v</code> to <code>value</code>. See also <a href="#JuMP.start_value-Tuple{VariableRef}"><code>start_value</code></a>.</p><p>Note: <code>VariablePrimalStart</code>s are sometimes called &quot;MIP-starts&quot; or &quot;warmstarts&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{VariableRef}" href="#JuMP.is_binary-Tuple{VariableRef}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_binary(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is constrained to be binary. See also <a href="#JuMP.BinaryRef-Tuple{VariableRef}"><code>BinaryRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_binary-Tuple{VariableRef}" href="#JuMP.set_binary-Tuple{VariableRef}"><code>JuMP.set_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_binary(v::VariableRef)</code></pre><p>Add a constraint on the variable <code>v</code> that it must take values in the set <span>$\{0,1\}$</span>. See also <a href="#JuMP.unset_binary-Tuple{VariableRef}"><code>unset_binary</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{VariableRef}" href="#JuMP.BinaryRef-Tuple{VariableRef}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BinaryRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint constrainting <code>v</code> to be binary. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_binary-Tuple{VariableRef}" href="#JuMP.unset_binary-Tuple{VariableRef}"><code>JuMP.unset_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unset_binary(variable_ref::VariableRef)</code></pre><p>Remove the binary constraint on the variable <code>variable_ref</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{VariableRef}" href="#JuMP.is_integer-Tuple{VariableRef}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_integer(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is constrained to be integer. See also <a href="#JuMP.IntegerRef-Tuple{VariableRef}"><code>IntegerRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_integer-Tuple{VariableRef}" href="#JuMP.set_integer-Tuple{VariableRef}"><code>JuMP.set_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_integer(variable_ref::VariableRef)</code></pre><p>Add an integrality constraint on the variable <code>variable_ref</code>. See also <a href="#JuMP.unset_integer-Tuple{VariableRef}"><code>unset_integer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{VariableRef}" href="#JuMP.IntegerRef-Tuple{VariableRef}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">IntegerRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint constrainting <code>v</code> to be integer. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_integer-Tuple{VariableRef}" href="#JuMP.unset_integer-Tuple{VariableRef}"><code>JuMP.unset_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unset_integer(variable_ref::VariableRef)</code></pre><p>Remove the integrality constraint on the variable <code>variable_ref</code>.</p></div></section></article><h2 id="Expressions-1"><a class="docs-heading-anchor" href="#Expressions-1">Expressions</a><a class="docs-heading-anchor-permalink" href="#Expressions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.@expression" href="#JuMP.@expression"><code>JuMP.@expression</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@expression(args...)</code></pre><p>Efficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:</p><pre><code class="language-julia">@expression(m, shared, sum(i*x[i] for i=1:5))
@constraint(m, shared + y &gt;= 5)
@constraint(m, shared + z &lt;= 10)</code></pre><p>The <code>ref</code> accepts index sets in the same way as <code>@variable</code>, and those indices can be used in the construction of the expressions:</p><pre><code class="language-julia">@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))</code></pre><p>Anonymous syntax is also supported:</p><pre><code class="language-julia">expr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_to_expression!" href="#JuMP.add_to_expression!"><code>JuMP.add_to_expression!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_to_expression!(expression, terms...)</code></pre><p>Updates <code>expression</code> <em>in place</em> to <code>expression + (*)(terms...)</code>. This is typically much more efficient than <code>expression += (*)(terms...)</code>. For example, <code>add_to_expression!(expression, a, b)</code> produces the same result as <code>expression += a*b</code>, and <code>add_to_expression!(expression, a)</code> produces the same result as <code>expression += a</code>.</p><p>Only a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) <code>expression</code> is capable of storing the result. For example, <code>add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef)</code> is not defined because a <code>GenericAffExpr</code> cannot store the product of two variables.</p></div></section></article><h2 id="Objectives-1"><a class="docs-heading-anchor" href="#Objectives-1">Objectives</a><a class="docs-heading-anchor-permalink" href="#Objectives-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.@objective" href="#JuMP.@objective"><code>JuMP.@objective</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@objective(model::Model, sense, func)</code></pre><p>Set the objective sense to <code>sense</code> and objective function to <code>func</code>. The objective sense can be either <code>Min</code>, <code>Max</code>, <code>MathOptInterface.MIN_SENSE</code>, <code>MathOptInterface.MAX_SENSE</code> or <code>MathOptInterface.FEASIBILITY_SENSE</code>; see <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.8/apireference.html#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a>. In order to set the sense programatically, i.e., when <code>sense</code> is a Julia variable whose value is the sense, one of the three <code>MathOptInterface.ObjectiveSense</code> values should be used. The function <code>func</code> can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.</p><p><strong>Examples</strong></p><p>To minimize the value of the variable <code>x</code>, do as follows:</p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; @objective(model, Min, x)
x</code></pre><p>To maximize the value of the affine expression <code>2x - 1</code>, do as follows:</p><pre><code class="language-julia-repl">julia&gt; @objective(model, Max, 2x - 1)
2 x - 1</code></pre><p>To set a quadratic objective and set the objective sense programatically, do as follows:</p><pre><code class="language-julia-repl">julia&gt; sense = MOI.MIN_SENSE
MIN_SENSE::OptimizationSense = 0

julia&gt; @objective(model, sense, x^2 - 2x + 1)
x² - 2 x + 1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_objective_function" href="#JuMP.set_objective_function"><code>JuMP.set_objective_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_objective_function(
    model::Model,
    func::Union{AbstractJuMPScalar, MathOptInterface.AbstractScalarFunction})</code></pre><p>Sets the objective function of the model to the given function. See <a href="#JuMP.set_objective_sense-Tuple{Model,MathOptInterface.OptimizationSense}"><code>set_objective_sense</code></a> to set the objective sense. These are low-level functions; the recommended way to set the objective is with the <a href="#JuMP.@objective"><code>@objective</code></a> macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_objective_sense-Tuple{Model,MathOptInterface.OptimizationSense}" href="#JuMP.set_objective_sense-Tuple{Model,MathOptInterface.OptimizationSense}"><code>JuMP.set_objective_sense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_objective_sense(model::Model, sense::MathOptInterface.OptimizationSense)</code></pre><p>Sets the objective sense of the model to the given sense. See <a href="#JuMP.set_objective_function"><code>set_objective_function</code></a> to set the objective function. These are low-level functions; the recommended way to set the objective is with the <a href="#JuMP.@objective"><code>@objective</code></a> macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_function-Tuple{Model}" href="#JuMP.objective_function-Tuple{Model}"><code>JuMP.objective_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">objective_function(model::Model,
               T::Type{&lt;:AbstractJuMPScalar}=objective_function_type(model))</code></pre><p>Return an object of type <code>T</code> representing the objective function. Error if the objective is not convertible to type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; @objective(model, Min, 2x + 1)
2 x + 1

julia&gt; objective_function(model, AffExpr)
2 x + 1

julia&gt; objective_function(model, QuadExpr)
2 x + 1

julia&gt; typeof(objective_function(model, QuadExpr))
GenericQuadExpr{Float64,VariableRef}</code></pre><p>We see with the last two commands that even if the objective function is affine, as it is convertible to a quadratic function, it can be queried as a quadratic function and the result is quadratic.</p><p>However, it is not convertible to a variable.</p><pre><code class="language-julia-repl">julia&gt; objective_function(model, VariableRef)
ERROR: InexactError: convert(MathOptInterface.SingleVariable, MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 1.0))
[...]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_function_type-Tuple{Model}" href="#JuMP.objective_function_type-Tuple{Model}"><code>JuMP.objective_function_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">objective_function_type(model::Model)::AbstractJuMPScalar</code></pre><p>Return the type of the objective function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_sense-Tuple{Model}" href="#JuMP.objective_sense-Tuple{Model}"><code>JuMP.objective_sense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">objective_sense(model::Model)::MathOptInterface.OptimizationSense</code></pre><p>Return the objective sense.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_objective_coefficient-Tuple{Model,VariableRef,Real}" href="#JuMP.set_objective_coefficient-Tuple{Model,VariableRef,Real}"><code>JuMP.set_objective_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_objective_coefficient(model::Model, variable::VariableRef, coefficient::Real)</code></pre><p>Set the linear objective coefficient associated with <code>Variable</code> to <code>coefficient</code>.</p><p>Note: this function will throw an error if a nonlinear objective is set.</p></div></section></article><h2 id="jump_constrs-1"><a class="docs-heading-anchor" href="#jump_constrs-1">Constraints</a><a class="docs-heading-anchor-permalink" href="#jump_constrs-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.ScalarConstraint" href="#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ScalarConstraint</code></pre><p>The data for a scalar constraint. The <code>func</code> field containts a JuMP object representing the function and the <code>set</code> field contains the MOI set. See also the <a href="../library/#Constraints-1">documentation</a> on JuMP&#39;s representation of constraints for more background.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_constraint-Tuple{Model,AbstractConstraint,String}" href="#JuMP.add_constraint-Tuple{Model,AbstractConstraint,String}"><code>JuMP.add_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_constraint(model::Model, con::AbstractConstraint, name::String=&quot;&quot;)</code></pre><p>Add a constraint <code>con</code> to <code>Model model</code> and sets its name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.@constraint" href="#JuMP.@constraint"><code>JuMP.@constraint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@constraint(m::Model, expr)</code></pre><p>Add a constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@constraint(m::Model, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The expression <code>expr</code> can either be</p><ul><li>of the form <code>func in set</code> constraining the function <code>func</code> to belong to the set <code>set</code> which is either a <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference.html#Sets-1"><code>MathOptInterface.AbstractSet</code></a> or one of the JuMP shortcuts <a href="#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a>, <a href="#JuMP.RotatedSecondOrderCone"><code>RotatedSecondOrderCone</code></a> and <a href="#JuMP.PSDCone"><code>PSDCone</code></a>, e.g. <code>@constraint(model, [1, x-1, y-2] in SecondOrderCone())</code> constrains the norm of <code>[x-1, y-2]</code> be less than 1;</li><li>of the form <code>a sign b</code>, where <code>sign</code> is one of <code>==</code>, <code>≥</code>, <code>&gt;=</code>, <code>≤</code> and <code>&lt;=</code> building the single constraint enforcing the comparison to hold for the expression <code>a</code> and <code>b</code>, e.g. <code>@constraint(m, x^2 + y^2 == 1)</code> constrains <code>x</code> and <code>y</code> to lie on the unit circle;</li><li>of the form <code>a ≤ b ≤ c</code> or <code>a ≥ b ≥ c</code> (where <code>≤</code> and <code>&lt;=</code> (resp. <code>≥</code> and <code>&gt;=</code>) can be used interchangeably) constraining the paired the expression <code>b</code> to lie between <code>a</code> and <code>c</code>;</li><li>of the forms <code>@constraint(m, a .sign b)</code> or <code>@constraint(m, a .sign b .sign c)</code> which broadcast the constraint creation to each element of the vectors.</li></ul><p><strong>Note for extending the constraint macro</strong></p><p>Each constraint will be created using <code>add_constraint(m, build_constraint(_error, func, set))</code> where</p><ul><li><code>_error</code> is an error function showing the constraint call in addition to the error message given as argument,</li><li><code>func</code> is the expression that is constrained</li><li>and <code>set</code> is the set in which it is constrained to belong.</li></ul><p>For <code>expr</code> of the first type (i.e. <code>@constraint(m, func in set)</code>), <code>func</code> and <code>set</code> are passed unchanged to <code>build_constraint</code> but for the other types, they are determined from the expressions and signs. For instance, <code>@constraint(m, x^2 + y^2 == 1)</code> is transformed into <code>add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0)))</code>.</p><p>To extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to <code>build_constraint</code>. Note that this will likely mean that either <code>func</code> or <code>set</code> will be some custom type, rather than e.g. a <code>Symbol</code>, since we will likely want to dispatch on the type of the function or set appearing in the constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.owner_model-Tuple{ConstraintRef}" href="#JuMP.owner_model-Tuple{ConstraintRef}"><code>JuMP.owner_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">owner_model(con_ref::ConstraintRef)</code></pre><p>Returns the model to which <code>con_ref</code> belongs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.index-Tuple{ConstraintRef}" href="#JuMP.index-Tuple{ConstraintRef}"><code>JuMP.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index(cr::ConstraintRef)::MOI.ConstraintIndex</code></pre><p>Return the index of the constraint that corresponds to <code>cr</code> in the MOI backend.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{Model,ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}" href="#JuMP.delete-Tuple{Model,ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete(model::Model, con_ref::ConstraintRef)</code></pre><p>Delete the constraint associated with <code>constraint_ref</code> from the model <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{Model,ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}" href="#JuMP.is_valid-Tuple{Model,ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_valid(model::Model, con_ref::ConstraintRef{Model})</code></pre><p>Return <code>true</code> if <code>constraint_ref</code> refers to a valid constraint in <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.constraint_object" href="#JuMP.constraint_object"><code>JuMP.constraint_object</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">constraint_object(con_ref::ConstraintRef)</code></pre><p>Return the underlying constraint data for the constraint referenced by <code>ref</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}" href="#JuMP.name-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">name(con_ref::ConstraintRef)</code></pre><p>Get a constraint&#39;s name attribute.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex,String}" href="#JuMP.set_name-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_name(con_ref::ConstraintRef, s::AbstractString)</code></pre><p>Set a constraint&#39;s name attribute.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.constraint_by_name" href="#JuMP.constraint_by_name"><code>JuMP.constraint_by_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">constraint_by_name(model::AbstractModel,
                   name::String)::Union{ConstraintRef, Nothing}</code></pre><p>Returns the reference of the constraint with name attribute <code>name</code> or <code>Nothing</code> if no constraint has this name attribute. Throws an error if several constraints have <code>name</code> as their name attribute.</p><pre><code class="language-none">constraint_by_name(model::AbstractModel,
                   name::String,
                   F::Type{&lt;:Union{AbstractJuMPScalar,
                                   Vector{&lt;:AbstractJuMPScalar},
                                   MOI.AbstactFunction}},
                   S::Type{&lt;:MOI.AbstractSet})::Union{ConstraintRef, Nothing}</code></pre><p>Similar to the method above, except that it throws an error if the constraint is not an <code>F</code>-in-<code>S</code> contraint where <code>F</code> is either the JuMP or MOI type of the function, and <code>S</code> is the MOI type of the set. This method is recommended if you know the type of the function and set since its returned type can be inferred while for the method above (i.e. without <code>F</code> and <code>S</code>), the exact return type of the constraint index cannot be inferred.</p><pre><code class="language-julia-repl">julia&gt; using JuMP

julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, con, x^2 == 1)
con : x² = 1.0

julia&gt; constraint_by_name(model, &quot;kon&quot;)

julia&gt; constraint_by_name(model, &quot;con&quot;)
con : x² = 1.0

julia&gt; constraint_by_name(model, &quot;con&quot;, AffExpr, MOI.EqualTo{Float64})

julia&gt; constraint_by_name(model, &quot;con&quot;, QuadExpr, MOI.EqualTo{Float64})
con : x² = 1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_constraints-Tuple{Model,Type{#s478} where #s478&lt;:Union{AbstractJuMPScalar, Array{#s477,1} where #s477&lt;:AbstractJuMPScalar},Type{#s476} where #s476&lt;:MathOptInterface.AbstractSet}" href="#JuMP.num_constraints-Tuple{Model,Type{#s478} where #s478&lt;:Union{AbstractJuMPScalar, Array{#s477,1} where #s477&lt;:AbstractJuMPScalar},Type{#s476} where #s476&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_constraints(model::Model, function_type, set_type)::Int64</code></pre><p>Return the number of constraints currently in the model where the function has type <code>function_type</code> and the set has type <code>set_type</code>.</p><p>See also <a href="#JuMP.list_of_constraint_types-Tuple{Model}"><code>list_of_constraint_types</code></a> and <a href="#JuMP.all_constraints-Tuple{Model,Type{#s478} where #s478&lt;:Union{AbstractJuMPScalar, Array{#s477,1} where #s477&lt;:AbstractJuMPScalar},Type{#s476} where #s476&lt;:MathOptInterface.AbstractSet}"><code>all_constraints</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x &gt;= 0, Bin);

julia&gt; @variable(model, y);

julia&gt; @constraint(model, y in MOI.GreaterThan(1.0));

julia&gt; @constraint(model, y &lt;= 1.0);

julia&gt; @constraint(model, 2x &lt;= 1);

julia&gt; num_constraints(model, VariableRef, MOI.GreaterThan{Float64})
2

julia&gt; num_constraints(model, VariableRef, MOI.ZeroOne)
1

julia&gt; num_constraints(model, AffExpr, MOI.LessThan{Float64})
2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_constraints-Tuple{Model,Type{#s478} where #s478&lt;:Union{AbstractJuMPScalar, Array{#s477,1} where #s477&lt;:AbstractJuMPScalar},Type{#s476} where #s476&lt;:MathOptInterface.AbstractSet}" href="#JuMP.all_constraints-Tuple{Model,Type{#s478} where #s478&lt;:Union{AbstractJuMPScalar, Array{#s477,1} where #s477&lt;:AbstractJuMPScalar},Type{#s476} where #s476&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all_constraints(model::Model, function_type, set_type)::Vector{&lt;:ConstraintRef}</code></pre><p>Return a list of all constraints currently in the model where the function has type <code>function_type</code> and the set has type <code>set_type</code>. The constraints are ordered by creation time.</p><p>See also <a href="#JuMP.list_of_constraint_types-Tuple{Model}"><code>list_of_constraint_types</code></a> and <a href="#JuMP.num_constraints-Tuple{Model,Type{#s478} where #s478&lt;:Union{AbstractJuMPScalar, Array{#s477,1} where #s477&lt;:AbstractJuMPScalar},Type{#s476} where #s476&lt;:MathOptInterface.AbstractSet}"><code>num_constraints</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x &gt;= 0, Bin);

julia&gt; @constraint(model, 2x &lt;= 1);

julia&gt; all_constraints(model, VariableRef, MOI.GreaterThan{Float64})
1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:
 x ≥ 0.0

julia&gt; all_constraints(model, VariableRef, MOI.ZeroOne)
1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.ZeroOne},ScalarShape},1}:
 x binary

julia&gt; all_constraints(model, AffExpr, MOI.LessThan{Float64})
1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:
 2 x ≤ 1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.list_of_constraint_types-Tuple{Model}" href="#JuMP.list_of_constraint_types-Tuple{Model}"><code>JuMP.list_of_constraint_types</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list_of_constraint_types(model::Model)</code></pre><p>Return a list of tuples of the form <code>(F, S)</code> where <code>F</code> is a JuMP function type and <code>S</code> is an MOI set type such that <code>all_constraints(model, F, S)</code> returns a nonempty list.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x &gt;= 0, Bin);

julia&gt; @constraint(model, 2x &lt;= 1);

julia&gt; list_of_constraint_types(model)
3-element Array{Tuple{DataType,DataType},1}:
 (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})
 (VariableRef, MathOptInterface.GreaterThan{Float64})
 (VariableRef, MathOptInterface.ZeroOne)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.SecondOrderCone" href="#JuMP.SecondOrderCone"><code>JuMP.SecondOrderCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SecondOrderCone</code></pre><p>Second order cone object that can be used to constrain the euclidean norm of a vector <code>x</code> to be less than or equal to a nonnegative scalar <code>t</code>. This is a shortcut for the <code>MathOptInterface.SecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le t$</span> and <span>$t \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x-1, x-2] in SecondOrderCone())
[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.RotatedSecondOrderCone" href="#JuMP.RotatedSecondOrderCone"><code>JuMP.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RotatedSecondOrderCone</code></pre><p>Rotated second order cone object that can be used to constrain the square of the euclidean norm of a vector <code>x</code> to be less than or equal to <span>$2tu$</span> where <code>t</code> and <code>u</code> are nonnegative scalars. This is a shortcut for the <code>MathOptInterface.RotatedSecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le 2tx$</span> and <span>$t, x \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())
[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.PSDCone" href="#JuMP.PSDCone"><code>JuMP.PSDCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSDCone</code></pre><p>Positive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the <a href="#JuMP.@constraint"><code>@constraint</code></a> macro. If the matrix has type <code>Symmetric</code> then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the <code>MOI.PositiveSemidefiniteConeTriangle</code> set, otherwise its column vectorization is constrained to belong to the <code>MOI.PositiveSemidefiniteConeSquare</code> set.</p><p><strong>Examples</strong></p><p>Consider the following example:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; a = [ x 2x
            2x  x];

julia&gt; b = [1 2
            2 4];

julia&gt; cref = @SDconstraint(model, a ⪰ b)
[x - 1    2 x - 2;
 2 x - 2  x - 4  ] ∈ PSDCone()

julia&gt; jump_function(constraint_object(cref))
4-element Array{GenericAffExpr{Float64,VariableRef},1}:
 x - 1
 2 x - 2
 2 x - 2
 x - 4

julia&gt; moi_set(constraint_object(cref))
MathOptInterface.PositiveSemidefiniteConeSquare(2)</code></pre><p>We see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra # For Symmetric

julia&gt; cref = @constraint(model, Symmetric(a - b) in PSDCone())
[x - 1    2 x - 2;
 2 x - 2  x - 4  ] ∈ PSDCone()

julia&gt; jump_function(constraint_object(cref))
3-element Array{GenericAffExpr{Float64,VariableRef},1}:
 x - 1
 2 x - 2
 x - 4

julia&gt; moi_set(constraint_object(cref))
MathOptInterface.PositiveSemidefiniteConeTriangle(2)</code></pre><p>As we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p></div></section></article><h2 id="Optimization-1"><a class="docs-heading-anchor" href="#Optimization-1">Optimization</a><a class="docs-heading-anchor-permalink" href="#Optimization-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimize!-Tuple{Model,Any}" href="#JuMP.optimize!-Tuple{Model,Any}"><code>JuMP.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimize!(model::Model;
          ignore_optimize_hook=(model.optimize_hook === nothing),
          kwargs...)</code></pre><p>Optimize the model. If an optimizer has not been set yet (see <a href="../guide/optimize/#JuMP.set_optimizer-Tuple{InfiniteModel,Any}"><code>set_optimizer</code></a>), a <a href="#JuMP.NoOptimizer"><code>NoOptimizer</code></a> error is thrown.</p><p>Keyword arguments <code>kwargs</code> are passed to the <code>optimize_hook</code>. An error is thrown if <code>optimize_hook</code> is <code>nothing</code> and keyword arguments are provided. ```</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_silent-Tuple{Model}" href="#JuMP.set_silent-Tuple{Model}"><code>JuMP.set_silent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_silent(model::Model)</code></pre><p>Takes precedence over any other attribute controlling verbosity and requires the solver to produce no output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_silent-Tuple{Model}" href="#JuMP.unset_silent-Tuple{Model}"><code>JuMP.unset_silent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unset_silent(model::Model)</code></pre><p>Neutralize the effect of the <code>set_silent</code> function and let the solver attributes control the verbosity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_time_limit_sec-Tuple{Model,Any}" href="#JuMP.set_time_limit_sec-Tuple{Model,Any}"><code>JuMP.set_time_limit_sec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_time_limit_sec(model::Model, limit)</code></pre><p>Sets the time limit (in seconds) of the solver. Can be unset using <code>unset_time_limit_sec</code> or with <code>limit</code> set to <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_time_limit_sec-Tuple{Model}" href="#JuMP.unset_time_limit_sec-Tuple{Model}"><code>JuMP.unset_time_limit_sec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unset_time_limit_sec(model::Model)</code></pre><p>Unsets the time limit of the solver. Can be set using <code>set_time_limit_sec</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.time_limit_sec-Tuple{Model}" href="#JuMP.time_limit_sec-Tuple{Model}"><code>JuMP.time_limit_sec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">time_limit_sec(model::Model)</code></pre><p>Gets the time limit (in seconds) of the model (<code>nothing</code> if unset). Can be set using <code>set_time_limit_sec</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.bridge_constraints-Tuple{Model}" href="#JuMP.bridge_constraints-Tuple{Model}"><code>JuMP.bridge_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bridge_constraints(model::Model)</code></pre><p>When in direct mode, return <code>false</code>. When in manual or automatic mode, return a <code>Bool</code> indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_bridge-Tuple{Model,Type{#s478} where #s478&lt;:MathOptInterface.Bridges.AbstractBridge}" href="#JuMP.add_bridge-Tuple{Model,Type{#s478} where #s478&lt;:MathOptInterface.Bridges.AbstractBridge}"><code>JuMP.add_bridge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> add_bridge(model::Model,
            BridgeType::Type{&lt;:MOI.Bridges.AbstractBridge})</code></pre><p>Add <code>BridgeType</code> to the list of bridges that can be used to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.backend-Tuple{Model}" href="#JuMP.backend-Tuple{Model}"><code>JuMP.backend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">backend(model::Model)</code></pre><p>Return the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (manual, automatic, or direct), and whether there are any bridges in the model.</p><p>If JuMP is in direct mode (i.e., the model was created using <a href="@ref"><code>direct_model</code></a>), the backend with be the optimizer passed to <code>direct_model</code>. If JuMP is in manual or automatic mode, the backend is a <code>MOI.Utilities.CachingOptimizer</code>.</p><p>This function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.mode-Tuple{Model}" href="#JuMP.mode-Tuple{Model}"><code>JuMP.mode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mode(model::Model)</code></pre><p>Return mode (DIRECT, AUTOMATIC, MANUAL) of model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solver_name-Tuple{Model}" href="#JuMP.solver_name-Tuple{Model}"><code>JuMP.solver_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solver_name(model::Model)</code></pre><p>If available, returns the <code>SolverName</code> property of the underlying optimizer. Returns <code>&quot;No optimizer attached&quot;</code> in <code>AUTOMATIC</code> or <code>MANUAL</code> modes when no optimizer is attached. Returns &quot;SolverName() attribute not implemented by the optimizer.&quot; if the attribute is not implemented.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer_attribute-Tuple{Model,String,Any}" href="#JuMP.set_optimizer_attribute-Tuple{Model,String,Any}"><code>JuMP.set_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_optimizer_attribute(model::Model, name::String, value)</code></pre><p>Sets solver-specific attribute identified by <code>name</code> to <code>value</code>.</p><p>Note that this is equivalent to <code>set_optimizer_attribute(model, MOI.RawParameter(name), value)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">set_optimizer_attribute(model, &quot;SolverSpecificAttributeName&quot;, true)</code></pre><p>See also: <a href="#JuMP.set_optimizer_attributes-Tuple{Model,Pair}"><code>set_optimizer_attributes</code></a>, <a href="#JuMP.get_optimizer_attribute-Tuple{Model,String}"><code>get_optimizer_attribute</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer_attribute-Tuple{Model,MathOptInterface.AbstractOptimizerAttribute,Any}" href="#JuMP.set_optimizer_attribute-Tuple{Model,MathOptInterface.AbstractOptimizerAttribute,Any}"><code>JuMP.set_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_optimizer_attribute(
    model::Model, attr::MOI.AbstractOptimizerAttribute, value
)</code></pre><p>Set the solver-specific attribute <code>attr</code> in <code>model</code> to <code>value</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">set_optimizer_attribute(model, MOI.Silent(), true)</code></pre><p>See also: <a href="#JuMP.set_optimizer_attributes-Tuple{Model,Pair}"><code>set_optimizer_attributes</code></a>, <a href="#JuMP.get_optimizer_attribute-Tuple{Model,String}"><code>get_optimizer_attribute</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer_attributes-Tuple{Model,Pair}" href="#JuMP.set_optimizer_attributes-Tuple{Model,Pair}"><code>JuMP.set_optimizer_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_optimizer_attributes(model::Model, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs, calls <code>set_optimizer_attribute(model, attribute, value)</code> for each pair.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model(Ipopt.Optimizer)
set_optimizer_attributes(model, &quot;tol&quot; =&gt; 1e-4, &quot;max_iter&quot; =&gt; 100)</code></pre><p>is equivalent to:</p><pre><code class="language-julia">model = Model(Ipopt.Optimizer)
set_optimizer_attribute(model, &quot;tol&quot;, 1e-4)
set_optimizer_attribute(model, &quot;max_iter&quot;, 100)</code></pre><p>See also: <a href="#JuMP.set_optimizer_attribute-Tuple{Model,String,Any}"><code>set_optimizer_attribute</code></a>, <a href="#JuMP.get_optimizer_attribute-Tuple{Model,String}"><code>get_optimizer_attribute</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.get_optimizer_attribute-Tuple{Model,String}" href="#JuMP.get_optimizer_attribute-Tuple{Model,String}"><code>JuMP.get_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_optimizer_attribute(model, name::String)</code></pre><p>Return the value associated with the solver-specific attribute named <code>name</code>.</p><p>Note that this is equivalent to <code>get_optimizer_attribute(model, MOI.RawParameter(name))</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">get_optimizer_attribute(model, &quot;SolverSpecificAttributeName&quot;)</code></pre><p>See also: <a href="#JuMP.set_optimizer_attribute-Tuple{Model,String,Any}"><code>set_optimizer_attribute</code></a>, <a href="#JuMP.set_optimizer_attributes-Tuple{Model,Pair}"><code>set_optimizer_attributes</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.get_optimizer_attribute-Tuple{Model,MathOptInterface.AbstractOptimizerAttribute}" href="#JuMP.get_optimizer_attribute-Tuple{Model,MathOptInterface.AbstractOptimizerAttribute}"><code>JuMP.get_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_optimizer_attribute(
    model::Model, attr::MOI.AbstractOptimizerAttribute
)</code></pre><p>Return the value of the solver-specific attribute <code>attr</code> in <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">get_optimizer_attribute(model, MOI.Silent())</code></pre><p>See also: <a href="#JuMP.set_optimizer_attribute-Tuple{Model,String,Any}"><code>set_optimizer_attribute</code></a>, <a href="#JuMP.set_optimizer_attributes-Tuple{Model,Pair}"><code>set_optimizer_attributes</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.result_count-Tuple{Model}" href="#JuMP.result_count-Tuple{Model}"><code>JuMP.result_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">result_count(model::Model)</code></pre><p>Return the number of results available to query after a call to <a href="#JuMP.optimize!-Tuple{Model,Any}"><code>optimize!</code></a>.</p></div></section></article><h2 id="Queries-1"><a class="docs-heading-anchor" href="#Queries-1">Queries</a><a class="docs-heading-anchor-permalink" href="#Queries-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.termination_status-Tuple{Model}" href="#JuMP.termination_status-Tuple{Model}"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">termination_status(model::Model)</code></pre><p>Return the reason why the solver stopped (i.e., the MathOptInterface model attribute <code>TerminationStatus</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.raw_status-Tuple{Model}" href="#JuMP.raw_status-Tuple{Model}"><code>JuMP.raw_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_status(model::Model)</code></pre><p>Return the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute <code>RawStatusString</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.primal_status-Tuple{Model}" href="#JuMP.primal_status-Tuple{Model}"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primal_status(model::Model; result::Int = 1)</code></pre><p>Return the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute <code>PrimalStatus</code>) associated with the result index <code>result</code>.</p><p>See also: <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_status-Tuple{Model}" href="#JuMP.dual_status-Tuple{Model}"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dual_status(model::Model; result::Int = 1)</code></pre><p>Return the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute <code>DualStatus</code>) associated with the result index <code>result</code>.</p><p>See also: <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solve_time-Tuple{Model}" href="#JuMP.solve_time-Tuple{Model}"><code>JuMP.solve_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve_time(model::Model)</code></pre><p>If available, returns the solve time reported by the solver. Returns &quot;ArgumentError: ModelLike of type <code>Solver.Optimizer</code> does not support accessing the attribute MathOptInterface.SolveTime()&quot; if the attribute is not implemented.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_values-Tuple{Model}" href="#JuMP.has_values-Tuple{Model}"><code>JuMP.has_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_values(model::Model; result::Int = 1)</code></pre><p>Return <code>true</code> if the solver has a primal solution in result index <code>result</code> available to query, otherwise return <code>false</code>.</p><p>See also <a href="#JuMP.value-Tuple{VariableRef}"><code>value</code></a> and <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_duals-Tuple{Model}" href="#JuMP.has_duals-Tuple{Model}"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_duals(model::Model; result::Int = 1)</code></pre><p>Return <code>true</code> if the solver has a dual solution in result index <code>result</code> available to query, otherwise return <code>false</code>.</p><p>See also <a href="#JuMP.dual-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>dual</code></a>, <a href="#JuMP.shadow_price-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>shadow_price</code></a>, and <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_bound-Tuple{Model}" href="#JuMP.objective_bound-Tuple{Model}"><code>JuMP.objective_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">objective_bound(model::Model)</code></pre><p>Return the best known bound on the optimal objective value after a call to <code>optimize!(model)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_value-Tuple{Model}" href="#JuMP.objective_value-Tuple{Model}"><code>JuMP.objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">objective_value(model::Model; result::Int = 1)</code></pre><p>Return the objective value associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>See also: <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_objective_value-Tuple{Model}" href="#JuMP.dual_objective_value-Tuple{Model}"><code>JuMP.dual_objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dual_objective_value(model::Model; result::Int = 1)</code></pre><p>Return the value of the objective of the dual problem associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Throws <code>MOI.UnsupportedAttribute{MOI.DualObjectiveValue}</code> if the solver does not support this attribute.</p><p>See also: <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{VariableRef}" href="#JuMP.value-Tuple{VariableRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">value(v::VariableRef; result = 1)</code></pre><p>Return the value of variable <code>v</code> associated with result index <code>result</code> of the most-recent returned by the solver.</p><p>Use<a href="#JuMP.has_values-Tuple{Model}"><code>has_values</code></a> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}" href="#JuMP.value-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">value(con_ref::ConstraintRef; result::Int = 1)</code></pre><p>Return the primal value of constraint <code>con_ref</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>That is, if <code>con_ref</code> is the reference of a constraint <code>func</code>-in-<code>set</code>, it returns the value of <code>func</code> evaluated at the value of the variables (given by <a href="#JuMP.value-Tuple{VariableRef}"><code>value(::VariableRef)</code></a>).</p><p>Use <a href="#JuMP.has_values-Tuple{Model}"><code>has_values</code></a> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>.</p><p><strong>Note</strong></p><p>For scalar contraints, the constant is moved to the <code>set</code> so it is not taken into account in the primal value of the constraint. For instance, the constraint <code>@constraint(model, 2x + 3y + 1 == 5)</code> is transformed into <code>2x + 3y</code>-in-<code>MOI.EqualTo(4)</code> so the value returned by this function is the evaluation of <code>2x + 3y</code>. ```</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}" href="#JuMP.dual-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dual(con_ref::ConstraintRef; result::Int = 1)</code></pre><p>Return the dual value of constraint <code>con_ref</code> associated with result index <code>result</code> of the most-recent solution returned by the solver.</p><p>Use <code>has_dual</code> to check if a result exists before asking for values.</p><p>See also: <a href="#JuMP.result_count-Tuple{Model}"><code>result_count</code></a>, <a href="#JuMP.shadow_price-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>shadow_price</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.shadow_price-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}" href="#JuMP.shadow_price-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.shadow_price</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shadow_price(con_ref::ConstraintRef)</code></pre><p>Return the change in the objective from an infinitesimal relaxation of the constraint.</p><p>This value is computed from <a href="#JuMP.dual-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>dual</code></a> and can be queried only when <code>has_duals</code> is <code>true</code> and the objective sense is <code>MIN_SENSE</code> or <code>MAX_SENSE</code> (not <code>FEASIBILITY_SENSE</code>). For linear constraints, the shadow prices differ at most in sign from the <code>dual</code> value depending on the objective sense.</p><p><strong>Notes</strong></p><ul><li>The function simply translates signs from <code>dual</code> and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.</li><li>The computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.</li><li>Relaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{VariableRef}" href="#JuMP.optimizer_index-Tuple{VariableRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizer_index(v::VariableRef)::MOI.VariableIndex</code></pre><p>Return the index of the variable that corresponds to <code>v</code> in the optimizer model. It throws <a href="#JuMP.NoOptimizer"><code>NoOptimizer</code></a> if no optimizer is set and throws an <code>ErrorException</code> if the optimizer is set but is not attached.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}" href="#JuMP.optimizer_index-Tuple{ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizer_index(cr::ConstraintRef{Model})::MOI.ConstraintIndex</code></pre><p>Return the index of the constraint that corresponds to <code>cr</code> in the optimizer model. It throws <a href="#JuMP.NoOptimizer"><code>NoOptimizer</code></a> if no optimizer is set and throws an <code>ErrorException</code> if the optimizer is set but is not attached or if the constraint is bridged.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_rhs_perturbation_range-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}" href="#JuMP.lp_rhs_perturbation_range-Tuple{ConstraintRef{Model,#s478,Shape} where Shape&lt;:AbstractShape where #s478&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.lp_rhs_perturbation_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lp_rhs_perturbation_range(constraint::ConstraintRef;
                          feasibility_tolerance::Float64)
                          ::Tuple{Float64, Float64}</code></pre><p>Gives the range by which the rhs coefficient can change and the current LP basis remains feasible, i.e., where the shadow prices apply.</p><p><strong>Notes</strong></p><ul><li>The rhs coefficient is the value right of the relation, i.e., b for the constraint when of the form a*x □ b, where □ is ≤, =, or ≥.</li><li>The range denotes valid changes, e.g., for a*x &lt;= b + Δ, the LP basis remains feasible for all Δ ∈ [l, u].</li><li><code>feasibility_tolerance</code> is the primal feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. &quot;Computational Techniques of the Simplex Method&quot; by István Maros, section 9.3.4).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_objective_perturbation_range-Tuple{VariableRef}" href="#JuMP.lp_objective_perturbation_range-Tuple{VariableRef}"><code>JuMP.lp_objective_perturbation_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lp_objective_perturbation_range(var::VariableRef;
                                optimality_tolerance::Float64)
                                ::Tuple{Float64, Float64}</code></pre><p>Gives the range by which the cost coefficient can change and the current LP basis remains optimal, i.e., the reduced costs remain valid.</p><p><strong>Notes</strong></p><ul><li>The range denotes valid changes, Δ ∈ [l, u], for which cost[var] += Δ do not violate the current optimality conditions.</li><li><code>optimality_tolerance</code> is the dual feasibility tolerance, this should preferably match the tolerance used by the solver. The defualt tolerance should however apply in most situations (c.f. &quot;Computational Techniques of the Simplex Method&quot; by István Maros, section 9.3.4).</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">« Library</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 April 2020 19:31">Wednesday 8 April 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
