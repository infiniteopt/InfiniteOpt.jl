<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measures · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li class="is-active"><a class="tocitem" href>Measures</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#measure_basic_usage-1"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Theoretical-Abstraction-1"><span>Theoretical Abstraction</span></a></li><li><a class="tocitem" href="#Measure-Data-Generation-1"><span>Measure Data Generation</span></a></li><li><a class="tocitem" href="#Evaluation-Methods-1"><span>Evaluation Methods</span></a></li><li><a class="tocitem" href="#Expansion-1"><span>Expansion</span></a></li><li><a class="tocitem" href="#Reduced-Infinite-Variables-1"><span>Reduced Infinite Variables</span></a></li><li><a class="tocitem" href="#Datatypes-1"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li><li><a class="tocitem" href="#MeasureEvalMethods-Methods-1"><span>MeasureEvalMethods Methods</span></a></li></ul></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Measures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/measure.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Measures-1"><a class="docs-heading-anchor" href="#Measures-1">Measures</a><a class="docs-heading-anchor-permalink" href="#Measures-1" title="Permalink"></a></h1><p>A guide and manual for the definition and use of measures in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>Measures are objects that capture the integration of an expression with respect to parameters, which is a distinct feature of optimization problems with infinite decision spaces. In dynamic optimization measures can represent integral terms such as the total cost over time, and in stochastic optimization measures can represent integrals over the uncertain parameters, such as expectation. In <code>InfiniteOpt</code>, measures are evaluated by some discretization scheme, which evaluates the expression at a set of points over the parameter space and approximates the measures based on the expression values at these points.</p><h2 id="measure_basic_usage-1"><a class="docs-heading-anchor" href="#measure_basic_usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#measure_basic_usage-1" title="Permalink"></a></h2><p>First, we consider a dynamic optimization problem with the time parameter <code>t</code> from 0 to 10. We also consider a state variable <code>y(t)</code> and a control variable <code>u(t)</code> that are parameterized by <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_variable(model, y(t))
y(t)

julia&gt; @infinite_variable(model, u(t))
u(t)</code></pre><p>Now suppose we want to evaluate the integral <span>$\int_{2}^{8}y(t)^2 + u(t)^2 dt$</span>. We can construct a measure to represent this integral using the <a href="#InfiniteOpt.integral"><code>integral</code></a> function</p><pre><code class="language-julia-repl">julia&gt; mref1 = integral(y^2 + u^2, t, 2, 8)
integral(y(t)² + u(t)²)</code></pre><p>The four positional arguments of <a href="#InfiniteOpt.integral"><code>integral</code></a> are the integrand expression, the parameter of integration, the lower bound, and the upper bound. If the lower and upper bounds are not specified, then the integration will be over the entire domain, which is [0, 10] in this case. In addition, if the parameter of integration is not specified, the measure will search for the parameter in the expression and choose that as the measure of integration. Specifying the parameter of integration is required if the expression contains multiple groups of infinite parameters.</p><p>The measure function uses Monte Carlo (MC) sampling method as the default discretization scheme. However, for integration over univariate parameter, the user can also use quadrature methods by setting the keyword argument <code>eval_method</code> as <code>quadrature</code>:</p><pre><code class="language-julia-repl">julia&gt; mref2 = integral(y^2 + u^2, eval_method = quadrature)
integral(y(t)² + u(t)²)</code></pre><p>The measure function also for specifying the number of points for the discretization scheme using the keyword argument <code>num_supports</code>. The default value of <code>num_supports</code> is 50.</p><pre><code class="language-julia-repl">julia&gt; mref3 = integral(y^2 + u^2, num_supports = 10)
integral(y(t)² + u(t)²)</code></pre><p>Every time a measure function is called for an infinite parameter, the points at which the integral is evaluated will be added to the list of supports of the relevant infinite parameter. The use can choose to evaluate a new integral over points that already exist in the support list by setting the keyword argument <code>use_existing_supports</code> as <code>true</code>:</p><pre><code class="language-julia-repl">julia&gt; mref4 = integral(y^2 + u^2, use_existing_supports = true)
integral(y(t)² + u(t)²)</code></pre><p>Note that by setting <code>use_existing_supports = true</code>, the measure function will ignore the values of <code>eval_method</code> and <code>num_supports</code>.</p><p>Once a measure is created, the evaluation of that measure is stored in a measure data object. Users can query the measure data object using the <a href="#InfiniteOpt.measure_data"><code>measure_data</code></a> function as follows</p><pre><code class="language-julia-repl">julia&gt; measure_data(mref3)
DiscreteMeasureData(t, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [5.85812, 5.39289, 2.60036, 9.10047, 1.67036, 6.55448, 5.75887, 8.68279, 9.678, 7.6769], &quot;integral&quot;, InfiniteOpt.default_weight)</code></pre><p>For more details on the measure data object, refer to <a href="#Measure-Data-Generation-1">Measure Data Generation</a>.</p><p>Similarly, one can also query the integrand function using <a href="#InfiniteOpt.measure_function"><code>measure_function</code></a>:</p><pre><code class="language-julia-repl">julia&gt; measure_function(mref3)
y(t)² + u(t)²</code></pre><p>Now suppose we want to create multiple measures for the same model that share the same keyword argument values. We don&#39;t have to input the keyword argument values every time we construct a new measure. Instead, we can modify the default values of measure keyword arguments for that model, and construct measures using the new default values. To do that, we use the functions <a href="#InfiniteOpt.set_integral_defaults"><code>set_integral_defaults</code></a> and <a href="#InfiniteOpt.integral_defaults"><code>integral_defaults</code></a>. For example, suppose we want to change the default number of supports to 10, and for some reason we want to add a new keyword argument called <code>a</code> to the measure function, with value of 1. Then we can do the following:</p><pre><code class="language-julia-repl">julia&gt; integral_defaults(model)
Dict{Symbol,Any} with 5 entries:
  :num_supports          =&gt; 10
  :eval_method           =&gt; :sampling
  :name                  =&gt; &quot;integral&quot;
  :weight_func           =&gt; default_weight
  :use_existing_supports =&gt; false

julia&gt; set_integral_defaults(model, num_supports = 20, a = 1)

julia&gt; integral_defaults(model)
Dict{Symbol,Any} with 6 entries:
  :a                     =&gt; 1
  :num_supports          =&gt; 20
  :eval_method           =&gt; :sampling
  :name                  =&gt; &quot;integral&quot;
  :weight_func           =&gt; default_weight
  :use_existing_supports =&gt; false</code></pre><p><a href="#InfiniteOpt.integral_defaults"><code>integral_defaults</code></a> returns the current default keyword argument values for measures for the model, and <a href="#InfiniteOpt.set_integral_defaults"><code>set_integral_defaults</code></a> set new keyword argument values. The first <a href="#InfiniteOpt.integral_defaults"><code>integral_defaults</code></a> call above shows the default values at model initialization. Note that <a href="#InfiniteOpt.set_integral_defaults"><code>set_integral_defaults</code></a> can not only modify values of existing keyword arguments, but also add new keyword arguments with a specified value. This is very useful if users want to extend the measure functions with their custom discretization/evaluation schemes that take additional arguments. See the extension page for more details.</p><p>Now that we change the default number of supports to 20, all measures created later will have 20 supports by default. The users can still overwrite the default for specific measures as follows, shown as follows:</p><pre><code class="language-julia-repl">julia&gt; mref1 = integral(y^2)
integral(y(t)²)

julia&gt; length(measure_data(mref1).supports)
20

julia&gt; mref2 = integral(y^2, num_supports = 5)
integral(y(t)²)

julia&gt; length(measure_data(mref2).supports)
5</code></pre><p>Now we can add integrals to the constraints and objective functions in our model using these measures. For more detailed information, please review the information below.</p><h2 id="Theoretical-Abstraction-1"><a class="docs-heading-anchor" href="#Theoretical-Abstraction-1">Theoretical Abstraction</a><a class="docs-heading-anchor-permalink" href="#Theoretical-Abstraction-1" title="Permalink"></a></h2><p>In <code>InfiniteOpt</code>, measures represent integrals of the form</p><div>\[\int_{\tau \in \mathcal{T}} f(\tau)w(\tau) d\tau\]</div><p>where <span>$\tau$</span> is a (possibly multivariate) infinite parameter, <span>$f(\tau)$</span> is an expression parameterized by <span>$\tau$</span>, <span>$w(\tau)$</span> is a weight function, and <span>$\mathcal{T}$</span> is a subset of the domain of <span>$\tau$</span>. The measures approximate the integrals by taking a discretization scheme</p><div>\[\int_{\tau \in \mathcal{T}} f(\tau)w(\tau) d\tau \approx \sum_{i=1}^N \alpha_i f(\tau_i) w(\tau_i)\]</div><p>where <span>$\tau_i$</span> are the grid points where the expression <span>$f(\tau)$</span> is evaluated, and <span>$N$</span> is the total number of points taken.</p><h2 id="Measure-Data-Generation-1"><a class="docs-heading-anchor" href="#Measure-Data-Generation-1">Measure Data Generation</a><a class="docs-heading-anchor-permalink" href="#Measure-Data-Generation-1" title="Permalink"></a></h2><p>The most general form of <a href="#InfiniteOpt.measure"><code>measure</code></a> takes two arguments: the expression to integrate and a measure data object that contains the details of the discretization scheme. Measure data objects can be constructed using <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, where the parameter of integration, the coefficients <span>$\alpha_i$</span>, and the support points need to be defined explicitly. For example, if we want to evaluate a function at each integer time point between 0 and 10, we can construct the following measure data object to record this discretization scheme:</p><pre><code class="language-julia-repl">julia&gt; md_t = DiscreteMeasureData(t, ones(10), [i for i in 1:10])
DiscreteMeasureData(t, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0], &quot;measure&quot;, InfiniteOpt.default_weight)</code></pre><p>The arguments of <a href="#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s478,1} where #s478&lt;:Real,Array{#s477,1} where #s477&lt;:Real}"><code>DiscreteMeasureData</code></a> are parameter, coefficients, and supports. Users can define a name for the measure data object using the <code>name</code> keyword argument. The default weight function is <span>$w(\tau) = 1$</span> for any <span>$\tau$</span>, which can be overwritten by the keyword argument <code>weight_function</code>. The <code>weight_function</code> should take a function that returns a number for any value that is well defined for the integrated infinite parameter. The data type is <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, which is a subtype of the abstract data type <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><p>With <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, a measure can be generated in a custom and quick manner. For example, using the measure data above, we can define a measure for <span>$y^2$</span> as follows:</p><pre><code class="language-julia-repl">julia&gt; mref = measure(y^2, md_t)
measure(y(t)²)</code></pre><p>In the same way, we can define measure data for multivariate infinite parameter. For example, we can define a discretization scheme for a 2D position parameter <span>$x \in [0, 1] \times [0, 1]$</span> as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:2] in [0, 1])
2-element Array{ParameterRef,1}:
 x[1]
 x[2]

julia&gt; md_x = DiscreteMeasureData(x, 0.25 * ones(4), [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]])
MultiDiscreteMeasureData(ParameterRef[x[1], x[2]], [0.25, 0.25, 0.25, 0.25], [0.25 0.25 0.75 0.75; 0.25 0.75 0.25 0.75], &quot;measure&quot;, InfiniteOpt.default_weight)</code></pre><p>where <code>md_x</code> cuts the domain into four 0.5-by-0.5 squares, and evaluates the integrand on the center of these squares.</p><p>Note that for multivariate parameters, each support should be an <code>AbstractArray</code> that records the value at each dimension, and the measure data type is <a href="#InfiniteOpt.MultiDiscreteMeasureData"><code>MultiDiscreteMeasureData</code></a>, again a subtype of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> that&#39;s specifically for multivariate parameters.</p><p>The <a href="#InfiniteOpt.integral"><code>integral</code></a> function called in <a href="#measure_basic_usage-1">Basic Usage</a> above is calls the <a href="#InfiniteOpt.measure"><code>measure</code></a> function which does not require explicit construction of the measure data object. Instead, the function constructs the appropriate measure data object according to the values of the positional and keyword arguments.</p><h2 id="Evaluation-Methods-1"><a class="docs-heading-anchor" href="#Evaluation-Methods-1">Evaluation Methods</a><a class="docs-heading-anchor-permalink" href="#Evaluation-Methods-1" title="Permalink"></a></h2><p>The <a href="#InfiniteOpt.integral"><code>integral</code></a> function calls <a href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>generate_measure_data</code></a> under the hood to construct the measure data object. <a href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>generate_measure_data</code></a> takes as positional arguments the integrated parameter, number of supports, lower bound and upper bound, and returns a measure data object of type <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><p><a href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>generate_measure_data</code></a> calls integral evaluation methods that are encoded in this package, which is specified through the <code>eval_method</code> keyword argument in measure function calls. The evaluation methods are encoded in various dispatches of <a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs"><code>generate_supports_and_coeffs</code></a> for different parameter set types and evaluation methods. Each <a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs"><code>generate_supports_and_coeffs</code></a> implements the specified <code>eval_method</code> and returns a tuple containing the supports and coefficients, which will be used by <a href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>generate_measure_data</code></a> to construct the measure data object. A table of available <code>eval_method</code> options in our package is listed below. Each method is limited on the dimension of parameter and/or the type of set that it can apply for.</p><table><tr><th style="text-align: right"><code>eval_method</code></th><th style="text-align: right">Uni/multi-variate?</th><th style="text-align: right">Type of set</th></tr><tr><td style="text-align: right"><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,Union{ParameterRef, AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef},Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:mc_sampling}}"><code>mc_sampling</code></a></td><td style="text-align: right">Both</td><td style="text-align: right"><a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: right"><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{DistributionSet,Union{ParameterRef, AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef},Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:mc_sampling}}"><code>mc_sampling</code></a></td><td style="text-align: right">Both</td><td style="text-align: right"><a href="../sets/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a></td></tr><tr><td style="text-align: right"><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_legendre}}"><code>gauss_legendre</code></a></td><td style="text-align: right">Univariate</td><td style="text-align: right">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: right"><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_laguerre}}"><code>gauss_laguerre</code></a></td><td style="text-align: right">Univariate</td><td style="text-align: right">Semi-infinite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: right"><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_hermite}}"><code>gauss_hermite</code></a></td><td style="text-align: right">Univariate</td><td style="text-align: right">Infinite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: right"><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:trapezoid}}"><code>trapezoid</code></a></td><td style="text-align: right">Univariate</td><td style="text-align: right">Infinite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr></table><p>The default evaluation method is MC sampling. If the integrated parameter is defined on a finite interval set (using <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>), the MC sampling method will draw samples from a uniform distribution over that interval. For (semi-)infinite domains, the MC sampling method will map the domain into a finite domain and do uniform sampling on that finite domain. The mapping is based on a change of variable that preserves the same integral value as follows, which is encoded in the <a href="#InfiniteOpt.MeasureEvalMethods.infinite_transform"><code>infinite_transform</code></a> function:</p><div>\[\int_{-\infty}^{\infty} f(x) dx = \int_{-1}^{1}f\left(\frac{t}{1-t^2}\right)\frac{1+t^2}{(1-t^2)^2}dt \\
\int_{a}^{\infty} f(x) dx = \int_{0}^{1}f\left(a + \frac{t}{1-t}\right)\frac{dt}{(1-t)^2} \\
\int_{-\infty}^{a} f(x) dx = \int_{0}^{1}f\left(a - \frac{1-t}{t}\right)\frac{dt}{t^2} \\\]</div><p>If the integrated infinite parameter is a random variable defined in a <a href="../sets/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a>, then MC sampling will draw samples from the underlying distribution.</p><p>For univariate infinite parameters, this package also supports basic Gaussian quadrature schemes and trapezoid rule. Specifically, <code>gauss_legendre</code> generates supports and coefficients based on Gauss-Legendre quadrature method for parameters in finite interval. <code>gauss_laguerre</code> generates supports and coefficients based on Gauss-Laguerre quadrature method for parameters in semi-infinite interval. <code>gauss_hermite</code> generates supports and coefficients based on Gauss-Hermite quadrature method for parameters infinite interval. For an introduction to the mathematics of Gaussian quadrature methods, see <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature">here</a>.</p><p>For extension purposes, users may define their own <a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs"><code>generate_supports_and_coeffs</code></a> to encode custom evaluation methods. See <a href="../../extensions/#Extensions-1">Extensions</a> for more details.</p><h2 id="Expansion-1"><a class="docs-heading-anchor" href="#Expansion-1">Expansion</a><a class="docs-heading-anchor-permalink" href="#Expansion-1" title="Permalink"></a></h2><p>In a model, each measure records the integrand expression and an evaluation scheme that details the discretization scheme to approximate the integral. The model will not expand the measures until the transcription stage, at which a <code>JuMP.AbstractJuMPScalar</code> is created for each measure to represent how the measure is modeled in a transcription model based on the stored discretization scheme (see <a href="../transcribe/#transcription_docs-1">Model Transcription</a> for details on transcription). Additional point variables will be created in the expansion process if the measure is evaluated at infinite parameter points that do not have corresponding point variables yet.</p><p>Sometimes for extension purposes, one might want to expand a specific measure before reaching the transcription stage. Alternatively, one might want to use custom reformulation instead of the transcription encoded in this package, in which expanding measures will also be useful. This can be done using the <a href="#InfiniteOpt.expand"><code>expand</code></a> function, which takes a <a href="#InfiniteOpt.MeasureRef"><code>MeasureRef</code></a> object and returns a <code>JuMP.AbstractJuMPScalar</code> based on the <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>. For example, suppose we want to integrate <span>$y^2$</span> in <span>$t$</span>, with two supports <span>$t = 2.5$</span> and <span>$t = 7.5$</span>. We can set up and expand this measure as follows:</p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [5, 5], [2.5, 7.5])
DiscreteMeasureData(t, [5.0, 5.0], [2.5, 7.5], &quot;measure&quot;, InfiniteOpt.default_weight)

julia&gt; mref3 = measure(y^2, tdata)
measure(y(t)²)

julia&gt; expanded_measure = expand(mref3)
5 y(2.5)² + 5 y(7.5)²

julia&gt; typeof(expanded_measure)
GenericQuadExpr{Float64,PointVariableRef}</code></pre><p>In the expand call, two point variables, <code>y(2.5)</code> and <code>y(7.5)</code>, are created because they are not defined in the model before the expand call. One can use the <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a> function to expand all measures in a model, which simply applies the <a href="#InfiniteOpt.expand"><code>expand</code></a> to all measures stored in the model.</p><h2 id="Reduced-Infinite-Variables-1"><a class="docs-heading-anchor" href="#Reduced-Infinite-Variables-1">Reduced Infinite Variables</a><a class="docs-heading-anchor-permalink" href="#Reduced-Infinite-Variables-1" title="Permalink"></a></h2><p>Expanding partial integrals will introduce reduced infinite variables to the model. To see what this means, suppose we have an infinite variable that is parameterized by multiple infinite parameters defined as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, T(x, t))
T(x, t)</code></pre><p>Now say we want to integrate <code>T</code> over <code>t</code>. We can define a measure for the integral similar to how we have defined other measures:</p><pre><code class="language-julia-repl">julia&gt; mref4 = measure(T, tdata)
measure(T(x, t))</code></pre><p>Now if we expand this measure, the measure data object <code>tdata</code> records the supports for <code>t</code>, but no supports for <code>x</code> because <code>T</code> is not integrated over <code>x</code> in this measure. Therefore, point variables cannot be defined in the measure expansion.</p><p>Instead of point variables, each new variable in the measure expansion will be represented using reduced infinite variables. Reduced infinite variables are &quot;reduced&quot; from their original infinite variables in that they are parameterized by less infinite parameters. In the example above, in the expansion each reduced infinite variable for <code>T</code> should only be parameterized by <code>x</code> since the value of <code>t</code> is fixed. The expanded measure now looks like this:</p><pre><code class="language-julia-repl">julia&gt; expanded_measure = expand(mref4)
5 T([x[1], x[2]], 2.5) + 5 T([x[1], x[2]], 7.5)</code></pre><p>where the expanded measure is a <code>JuMP.GenericAffExpr</code> that takes <a href="#InfiniteOpt.ReducedInfiniteVariableRef"><code>ReducedInfiniteVariableRef</code></a> in its terms. <a href="#InfiniteOpt.ReducedInfiniteVariableRef"><code>ReducedInfiniteVariableRef</code></a> refers to the information of the reduced infinite variable stored in its model, in the type of <a href="#InfiniteOpt.ReducedInfiniteInfo"><code>ReducedInfiniteInfo</code></a>. Each <a href="#InfiniteOpt.ReducedInfiniteInfo"><code>ReducedInfiniteInfo</code></a> records a reference for its original infinite variable, and the value of the fixed infinite parameter. One can query this information using <a href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}"><code>infinite_variable_ref</code></a> and <a href="#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}"><code>eval_supports</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; T1 = first(keys(expanded_measure.terms))
T([x[1], x[2]], 2.5)

julia&gt; typeof(T1)
ReducedInfiniteVariableRef

julia&gt; infinite_variable_ref(T1)
T(x, t)

julia&gt; eval_supports(T1)
Dict{Int64,Float64} with 1 entry:
  3 =&gt; 2.5</code></pre><p>All the <code>JuMP</code> functions extended for infinite variables are also extended for reduced infinite variables, e.g. <a href="#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound</code></a>.</p><h2 id="Datatypes-1"><a class="docs-heading-anchor" href="#Datatypes-1">Datatypes</a><a class="docs-heading-anchor-permalink" href="#Datatypes-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a></li><li><a href="#InfiniteOpt.AbstractReducedInfo"><code>InfiniteOpt.AbstractReducedInfo</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef,Array{#s477,1} where #s477&lt;:Real,Array{#s476,1} where #s476&lt;:(AbstractArray{#s475,N} where N where #s475&lt;:Real)}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s478,1} where #s478&lt;:Real,Array{#s477,1} where #s477&lt;:Real}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a></li><li><a href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a></li><li><a href="#InfiniteOpt.MultiDiscreteMeasureData"><code>InfiniteOpt.MultiDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.ReducedInfiniteInfo"><code>InfiniteOpt.ReducedInfiniteInfo</code></a></li><li><a href="#InfiniteOpt.ReducedInfiniteVariableRef"><code>InfiniteOpt.ReducedInfiniteVariableRef</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractMeasureData" href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractMeasureData</code></pre><p>An abstract type to define data for measures to define the behavior of <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/datatypes.jl#LL40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData" href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData &lt;: AbstractMeasureData</code></pre><p>A DataType for one dimensional measure abstraction data where the measure abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>.</p><p><strong>Fields</strong></p><ul><li><code>parameter_ref::ParameterRef</code> The infinite parameter over which the                               integration occurs.</li><li><code>coefficients::Vector{Float64}</code> Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Vector{Float64}</code> Support points <span>$\tau_i$</span> for the above                              measure abstraction.</li><li><code>name::String</code> Name of the measure that will be implemented.</li><li><code>weight_function::Function</code> Weighting function <span>$w$</span> must map support value                             input value of type <code>Number</code> to a scalar value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/datatypes.jl#LL609-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MultiDiscreteMeasureData" href="#InfiniteOpt.MultiDiscreteMeasureData"><code>InfiniteOpt.MultiDiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiDiscreteMeasureData &lt;: AbstractMeasureData</code></pre><p>A DataType for multi-dimensional measure abstraction data where the measure abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>.</p><p><strong>Fields</strong></p><ul><li><code>parameter_refs::Vector{ParameterRef}</code> The infinite  parameters over which the integration occurs.</li><li><code>coefficients::Vector{Float64}</code> Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Array{Float64, 2}</code> Support points (column-wise) <span>$\tau_i$</span> for the                               above measure abstraction.</li><li><code>name::String</code> Name of the measure that will be implemented.</li><li><code>weight_function::Function</code> Weighting function <span>$w$</span> must map a numerical                             support of type <code>JuMP.Containers.SparseAxisArray</code>                             to a scalar value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/datatypes.jl#LL635-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Measure" href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Measure{T &lt;: JuMP.AbstractJuMPScalar, V &lt;: AbstractMeasureData}</code></pre><p>A DataType for measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>func::T</code> Infinite variable expression.</li><li><code>data::V</code> Data of the abstraction as described in a <code>AbstractMeasureData</code>           subtype.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/datatypes.jl#LL48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureRef" href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureRef &lt;: FiniteVariableRef</code></pre><p>A DataType for referring to measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/datatypes.jl#LL411-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractReducedInfo" href="#InfiniteOpt.AbstractReducedInfo"><code>InfiniteOpt.AbstractReducedInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractReducedInfo</code></pre><p>An abstract type reduced variable information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/datatypes.jl#LL33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ReducedInfiniteInfo" href="#InfiniteOpt.ReducedInfiniteInfo"><code>InfiniteOpt.ReducedInfiniteInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReducedInfiniteInfo &lt;: AbstractReducedInfo</code></pre><p>A DataType for storing reduced infinite variable information.</p><p><strong>Fields</strong></p><ul><li><code>infinite_variable_ref::InfiniteVariableRef</code> The original infinite variable.</li><li><code>eval_supports::Dict{Int, Float64}</code> The original parameter tuple linear indices                                    to the evaluation supports.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/datatypes.jl#LL574-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ReducedInfiniteVariableRef" href="#InfiniteOpt.ReducedInfiniteVariableRef"><code>InfiniteOpt.ReducedInfiniteVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReducedInfiniteVariableRef &lt;: GeneralVariableRef</code></pre><p>A DataType for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/datatypes.jl#LL380-L390">source</a></section></article><h2 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a></li><li><a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.add_measure_variable</code></a></li><li><a href="#InfiniteOpt.coefficients"><code>InfiniteOpt.coefficients</code></a></li><li><a href="#InfiniteOpt.default_weight"><code>InfiniteOpt.default_weight</code></a></li><li><a href="#InfiniteOpt.delete_internal_reduced_variable"><code>InfiniteOpt.delete_internal_reduced_variable</code></a></li><li><a href="#InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.delete_reduced_variable</code></a></li><li><a href="#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a></li><li><a href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a></li><li><a href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a></li><li><a href="#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a></li><li><a href="#InfiniteOpt.expand_measures"><code>InfiniteOpt.expand_measures</code></a></li><li><a href="#InfiniteOpt.expect"><code>InfiniteOpt.expect</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.integral"><code>InfiniteOpt.integral</code></a></li><li><a href="#InfiniteOpt.integral_defaults"><code>InfiniteOpt.integral_defaults</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.make_point_variable_ref"><code>InfiniteOpt.make_point_variable_ref</code></a></li><li><a href="#InfiniteOpt.make_reduced_variable_ref"><code>InfiniteOpt.make_reduced_variable_ref</code></a></li><li><a href="#InfiniteOpt.measure"><code>InfiniteOpt.measure</code></a></li><li><a href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a></li><li><a href="#InfiniteOpt.measure_data_in_hold_bounds"><code>InfiniteOpt.measure_data_in_hold_bounds</code></a></li><li><a href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a></li><li><a href="#InfiniteOpt.measure_name"><code>InfiniteOpt.measure_name</code></a></li><li><a href="#InfiniteOpt.parameter_list-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.raw_parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a></li><li><a href="#InfiniteOpt.reduction_info-Tuple{ReducedInfiniteVariableRef,Any}"><code>InfiniteOpt.reduction_info</code></a></li><li><a href="#InfiniteOpt.set_integral_defaults"><code>InfiniteOpt.set_integral_defaults</code></a></li><li><a href="#InfiniteOpt.support_sum"><code>InfiniteOpt.support_sum</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#InfiniteOpt.weight_function"><code>InfiniteOpt.weight_function</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.name-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a></li><li><a href="#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expect" href="#InfiniteOpt.expect"><code>InfiniteOpt.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expect(expr::JuMP.AbstractJuMPScalar,
       [params::Union{ParameterRef, AbstractArray{&lt;:ParameterRef},
                      Nothing} = nothing];
       [num_supports::Int = 10,
        use_existing_supports::Bool = false])::MeasureRef</code></pre><p>Creates a measure that represents the expected value of an expression in a random parameter involved in the expression. Return the <a href="#InfiniteOpt.MeasureRef"><code>MeasureRef</code></a> of the created measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in Normal(0., 1.))
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = expect(f, num_supports = 2)
expect(f(x))

julia&gt; expand(meas)
0.5 f(0.6791074260357777) + 0.5 f(0.8284134829000359)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL899-L924">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_sum" href="#InfiniteOpt.support_sum"><code>InfiniteOpt.support_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support_sum(expr::JuMP.AbstractJuMPScalar,
            [params::Union{ParameterRef, AbstractArray{&lt;:ParameterRef},
                           Nothing} = nothing])::MeasureRef</code></pre><p>Creates a measure that represents the sum of the expression over a parameter using its existing supports. Return the <a href="#InfiniteOpt.MeasureRef"><code>MeasureRef</code></a> of the created measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1], supports = [0.3, 0.7])
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = support_sum(f)
sum(f(x))

julia&gt; expand(meas)
f(0.3) + f(0.7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL935-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.integral" href="#InfiniteOpt.integral"><code>InfiniteOpt.integral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">integral(expr::JuMP.AbstractJuMPScalar,
         [params::Union{ParameterRef, AbstractArray{&lt;:ParameterRef},
                        Nothing} = nothing,
         lb::Union{Number, AbstractArray{&lt;:Number}, Nothing} = nothing,
         ub::Union{Number, AbstractArray{&lt;:Number}, Nothing} = nothing];
         [eval_method::Symbol = sampling,
         num_supports::Int = 10,
         weight_func::Function = [`default_weight`](@ref),
         name = &quot;integral&quot;,
         use_existing_supports::Bool = false,
         kwargs...])::MeasureRef</code></pre><p>Returns a measure reference that evaluates the integral of <code>expr</code> with respect to infinite parameter(s) from <code>lb</code> to <code>ub</code>. This thus considers integrals of the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter (scalar or vector) and <span>$w$</span> is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs a <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> via <code>eval_method</code> that is used to call <a href="#InfiniteOpt.measure"><code>measure</code></a>.</p><p>The arugments are as follows:</p><ul><li><code>params</code>: the integral infinite parameter(s) in <span>$dp$</span></li><li><code>lb</code> &amp; <code>ub</code>: integral upper and lower bounds (defaults to entire parameter domain)</li></ul><p>Note that <code>params</code> is required if <code>expr</code> contains multiple parameters.</p><p>The keyword arguments are as follows:</p><ul><li><code>eval_method</code>: method tha generates the supports and coefficients<ul><li><code>sampling</code> –&gt; dispatch to appropriate sampling method (default)</li><li><code>quadrature</code> –&gt; dispatch to appropriate quadrature method</li><li><code>mc_sampling</code> –&gt; Monte Carlo sampling</li><li><code>gauss_hermite</code> –&gt; Gaussian Hermite quadrature (infinite interval)</li><li><code>gauss_legendre</code> –&gt; Gaussian Legendre quadrature (finite interval)</li><li><code>gauss_laguerre</code> –&gt; Gaussian Laguerre quadrature (semi-infinite interval)</li><li><code>trapezoid</code> –&gt; trapezoidal quadrature (finite interval)</li></ul></li><li><code>num_supports</code>: The number of supports to be generated</li><li><code>weight_func</code>: <span>$w(p)$</span> above with parameter value inputs and scalar output</li><li><code>name</code>: the name used in printing</li><li><code>use_existing_supports</code>: Use all supports currently stored in <code>params</code></li></ul><p>Note that <code>mc_sampling</code> samples from the parameter interval for <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>s, and from the underlying distribution for <a href="../sets/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a>s. Also, <code>use_existing_supports</code> is useful for subsequent integral calls when using <code>mc_sampling</code> such that all the measures use the same supports.</p><p>See <a href="#InfiniteOpt.set_integral_defaults"><code>set_integral_defaults</code></a> to update the default keyword argument values for all integral calls.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0., 1.])
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; int = integral(f, num_supports = 5)
(f(x))

julia&gt; expand(int)
0.2 f(0.8236475079774124) + 0.2 f(0.9103565379264364) + 0.2 f(0.16456579813368521) + 0.2 f(0.17732884646626457) + 0.2 f(0.278880109331201)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL599-L660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.integral_defaults" href="#InfiniteOpt.integral_defaults"><code>InfiniteOpt.integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">integral_defaults(model::InfiniteModel)</code></pre><p>Get the default keyword argument values for defining integrals in <code>model</code>.</p><pre><code class="language-julia-repl">julia&gt; integral_defaults(model)
Dict{Symbol,Any} with 6 entries:
  :num_supports          =&gt; 10
  :eval_method           =&gt; nothing
  :name                  =&gt; &quot;integral&quot;
  :weight_func           =&gt; default_weight
  :use_existing_supports =&gt; false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL842-L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_integral_defaults" href="#InfiniteOpt.set_integral_defaults"><code>InfiniteOpt.set_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_integral_defaults(model::InfiniteModel; kwargs...)</code></pre><p>Set the default keyword argument settings for integrals of the specified model. The keyword arguments of this function will be recorded in the default keyword argument values of the model. If the keyword argument has been defined in the model default, it will be overwritten with the new keyword argument value. Otherwise, the default will record the new keyword argument and its value for measures. The default values will be used by integrals constructed from <a href="#InfiniteOpt.integral"><code>integral</code></a> calls.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; integral_defaults(model)
Dict{Symbol,Any} with 6 entries:
  :num_supports          =&gt; 10
  :eval_method           =&gt; nothing
  :name                  =&gt; &quot;integral&quot;
  :weight_func           =&gt; default_weight
  :use_existing_supports =&gt; false

julia&gt; set_integral_default(m, num_supports = 5, eval_method = quadrature, new_kwarg = true)

julia&gt; integral_defaults(m)
Dict{Symbol,Any} with 6 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; :quadrature
  :name                  =&gt; &quot;integral&quot;
  :weight_func           =&gt; default_weight
  :use_existing_supports =&gt; false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL861-L893">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.default_weight" href="#InfiniteOpt.default_weight"><code>InfiniteOpt.default_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_weight(t)</code></pre><p>Default weight function for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> and <a href="#InfiniteOpt.MultiDiscreteMeasureData"><code>MultiDiscreteMeasureData</code></a>. Returns 1 regardless of the input value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s478,1} where #s478&lt;:Real,Array{#s477,1} where #s477&lt;:Real}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s478,1} where #s478&lt;:Real,Array{#s477,1} where #s477&lt;:Real}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData(parameter_ref::ParameterRef,
                    coefficients::Vector{&lt;:Real},
                    supports::Vector{&lt;:Real}; name::String = &quot;measure&quot;,
                    weight_function::Function = [`default_weight`](@ref))::DiscreteMeasureData</code></pre><p>Returns a <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for a scalar (single) parameter. Note that <code>name</code> is used for printing purposes and a description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds or an unequal number of supports and coefficients are given.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2], name = &quot;example&quot;)
DiscreteMeasureData(pref, [0.5, 0.5], [1.0, 2.0], &quot;example&quot;, default_weight)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL59-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef,Array{#s477,1} where #s477&lt;:Real,Array{#s476,1} where #s476&lt;:(AbstractArray{#s475,N} where N where #s475&lt;:Real)}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef,Array{#s477,1} where #s477&lt;:Real,Array{#s476,1} where #s476&lt;:(AbstractArray{#s475,N} where N where #s475&lt;:Real)}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData(parameter_refs::AbstractArray{&lt;:ParameterRef},
                    coefficients::Vector{&lt;:Real},
                    supports::Vector{&lt;:AbstractArray{&lt;:Real}};
                    name::String = &quot;measure&quot;,
                    weight_function::Function = [`default_weight`](@ref)
                    )::MultiDiscreteMeasureData</code></pre><p>Returns a <code>MultiDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for <code>parameter_refs</code>. Note that <code>name</code> is used for printing purposes and a description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.MultiDiscreteMeasureData"><code>MultiDiscreteMeasureData</code></a>. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or the parameters have different group IDs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]], name = &quot;example&quot;);

julia&gt; typeof(data)
MultiDiscreteMeasureData</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL126-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure" href="#InfiniteOpt.measure"><code>InfiniteOpt.measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure(expr::JuMP.AbstractJuMPScalar, data::AbstractMeasureData)::MeasureRef</code></pre><p>Return a measure reference that evaluates <code>expr</code> using according to <code>data</code>. This is the preferred method for implementing measures which follow the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter (scalar or vector) and <span>$w$</span> is the weight function. The measure data <code>data</code> determines how the measure is to be evaluated. Typically, the <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> constructor can be used to for <code>data</code>. The variable expression <code>expr</code> can contain <code>InfiniteOpt</code> variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Errors if <code>expr</code> does not contain infinite variables, infinite parameters, or measure references. Also errors if the measure parameter specified in <code>data</code> is not in <code>expr</code> and is not in any the nested measure references. Typically, this is called inside of <a href="../../JuMP/#JuMP.@expression"><code>JuMP.@expression</code></a>, <a href="../../JuMP/#JuMP.@objective"><code>JuMP.@objective</code></a>, and <a href="../../JuMP/#JuMP.@constraint"><code>JuMP.@constraint</code></a> in a manner similar to <code>sum</code>. Note measures are not explicitly evaluated until <a href="../optimize/#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>build_optimizer_model!</code></a> is called or unless they are expanded via <a href="#InfiniteOpt.expand"><code>expand</code></a> or <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2], name = &quot;name1&quot;);

julia&gt; xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]],
                                   name = &quot;name2&quot;);

julia&gt; constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)
name1(g(t) - s + 2) + s²

julia&gt; @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))
name1(g(t) - 1 + name2(T(t, x)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL549-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure" href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_measure(model::InfiniteModel, meas::Measure)::MeasureRef</code></pre><p>Add a measure to <code>model</code> and return the corresponding measure reference. This operates in a manner similar to <a href="../../JuMP/#JuMP.add_variable"><code>JuMP.add_variable</code></a>. Note this intended as an internal method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL379-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_function" href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return the function associated with <code>mref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL407-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_data" href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_data(mref::MeasureRef)::AbstractMeasureData</code></pre><p>Return the measure data associated with <code>mref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL416-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(mref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL967-L977">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL982-L992">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_objective(vmref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_objective(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL997-L1007">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{MeasureRef}" href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL1012-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, mref::MeasureRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> to return <code>Bool</code> whether <code>mref</code> is valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,MeasureRef}" href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, mref::MeasureRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z &gt;= 0.0
 measure(g(t)) == 0
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 t in [0, 6]

julia&gt; delete(model, meas)

julia&gt; print(model)
Min z
Subject to
 z &gt;= 0.0
 0 == 0
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 t in [0, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL1027-L1055">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{MeasureRef}" href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(mref::MeasureRef)::String</code></pre><p>Extend <a href="../../JuMP/#JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> to return the name associated with a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{MeasureRef,String}" href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(mref::MeasureRef, name::String)</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> to specify the name of a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand" href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return a JuMP scalar function containing the explicit expansion of the measure <code>mref</code>. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with <a href="#InfiniteOpt.measure"><code>measure</code></a> to expand measures on the fly.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])

julia&gt; expr = expand(measure(g + z + T - h - 2, tdata))
0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL581-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_all_measures!" href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_all_measures!(model::InfiniteModel)</code></pre><p>Expand all of the measures used in the objective and/or constraints of <code>model</code>. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. Also errors if the expanded objective function is not finite.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before <code>model</code> is translated into the new model. This method can also be extended to handle custom measure data types by extending <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. Note that this method leverages <code>expand_measure</code> via <a href="#InfiniteOpt.expand_measures"><code>expand_measures</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 T(t, xi) &gt;= 0.0
 z &gt;= 0.0
 g(t) + z &gt;= 42.0
 measure(T(t, xi)) &gt;= 0.0, for all xi in [-1, 1]
 t in [0, 6]
 xi in Normal(μ=0.0, σ=1.0)

julia&gt; expand_all_measures!(model)

julia&gt; print(model)
Min 3 g(6) + z
Subject to
 T(t, xi) &gt;= 0.0
 z &gt;= 0.0
 g(t) + z &gt;= 42.0
 0.5 T(0, xi) + 0.5 T(6, xi) &gt;= 0.0, for all xi in [-1, 1]
 t in [0, 6]
 xi in Normal(μ=0.0, σ=1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL668-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_name" href="#InfiniteOpt.measure_name"><code>InfiniteOpt.measure_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_name(data::AbstractMeasureData)::String</code></pre><p>Return the measure name string stored in <code>data</code>. This is intended as an internal function to be used with measure addition. User-defined measure data types will need to extend this function otherwise the measure names default to <code>&quot;measure&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL182-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}" href="#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(data::AbstractMeasureData)::Union{ParameterRef,
                                                 AbstractArray{&lt;:ParameterRef}}</code></pre><p>Return the infinite parameter reference(s) in <code>data</code>. This is intended as an internal function to be used with measure addition. User-defined measure data types will need to extend this function otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL198-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(data::AbstractMeasureData)::Vector</code></pre><p>Return the supports stored in <code>data</code> associated with its infinite parameters. This is intended as en internal method for measure creation and ensures any new supports are added to parameters. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL220-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.coefficients" href="#InfiniteOpt.coefficients"><code>InfiniteOpt.coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coefficients(data::AbstractMeasureData)::Vector</code></pre><p>Return the coefficients stored in <code>data</code> associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL242-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.weight_function" href="#InfiniteOpt.weight_function"><code>InfiniteOpt.weight_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">weight_function(data::AbstractMeasureData)::Function</code></pre><p>Return the weight function stored in <code>data</code> associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise the default function <a href="#InfiniteOpt.default_weight"><code>default_weight</code></a> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL260-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_data_in_hold_bounds" href="#InfiniteOpt.measure_data_in_hold_bounds"><code>InfiniteOpt.measure_data_in_hold_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_data_in_hold_bounds(data::AbstractMeasureData,
                            bounds::ParameterBounds)::Bool</code></pre><p>Return a <code>Bool</code> whether the domain of <code>data</code> is valid in accordance with <code>bounds</code>. This is intended as an internal method and is used to check hold variables used in measures. User-defined measure data types will need to extend this function to enable this error checking, otherwise it is skipped and a warning is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measures.jl#LL481-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_measure" href="#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_measure(expr, data::AbstractMeasureData,
               write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Return the finite reformulation of a measure containing a variable/parameter expression <code>expr</code> with measure data <code>data</code>. Here <code>write_model</code> is the target model where this expanded expression will be used. Thus, any variables that need to be created will be added to <code>write_model</code>. The methods <a href="#InfiniteOpt.make_point_variable_ref"><code>make_point_variable_ref</code></a> and <a href="#InfiniteOpt.make_reduced_variable_ref"><code>make_reduced_variable_ref</code></a> should be used as appropriate to create these variables. Developers might also choose to use <a href="#InfiniteOpt.delete_internal_reduced_variable"><code>delete_internal_reduced_variable</code></a> in order to remove reduced variables once they are no longer needed. Note this is intended as an internal function, but will need to be extended for unsupported <code>expr</code> types and for user-defined measure data types. Principally, this is leveraged to enable the user methods <a href="#InfiniteOpt.expand"><code>expand</code></a> and <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL152-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_measures" href="#InfiniteOpt.expand_measures"><code>InfiniteOpt.expand_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_measures(expr, write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Expand all <code>MeasureRef</code>s in <code>expr</code> in-place via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a> and return the expanded expression. This is an internal method used by <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a> and <code>TranscriptionOpt</code> but can be useful for user-defined optimizer model extensions that add implement <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> in combination with <code>expand_measure</code>. <code>write_model</code> is the model that the measure variables are added to as described in <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL611-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_point_variable_ref" href="#InfiniteOpt.make_point_variable_ref"><code>InfiniteOpt.make_point_variable_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_point_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},
                        ivref::InfiniteVariableRef,
                        support::Union{Tuple, VectorTuple{Float64}}
                        )::PointVariableRef</code></pre><p>Make a point variable for infinite variable <code>ivref</code> at <code>support</code>, add it to the <code>write_model</code>, and return the <code>PointVariableRef</code>. This is an internal method for point variables produced by expanding measures via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the <code>InfiniteModel</code>. In such cases, <code>write_model</code> should be the optimizer model and <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> should be extended appropriately for point variables. Errors if <code>write_model</code> is an optimizer model and <code>add_measure_variable</code> is not properly extended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_reduced_variable_ref" href="#InfiniteOpt.make_reduced_variable_ref"><code>InfiniteOpt.make_reduced_variable_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_reduced_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},
                          ivref::InfiniteVariableRef,
                          indices::Vector{Int},
                          values::Vector{Float64}
                          )::ReducedInfiniteVariableRef</code></pre><p>Make a reduced variable for infinite variable <code>ivref</code> at <code>support</code>, add it to the <code>write_model</code>, and return the <code>ReducedInfiniteVariableRef</code>. This is an internal method for reduced variables produced by expanding measures via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the <code>InfiniteModel</code>. In such cases, <code>write_model</code> should be the optimizer model and <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> should be extended appropriately for reduced variables. Errors if <code>write_model</code> is an optimizer model and <code>add_measure_variable</code> is not properly extended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL64-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}" href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.add_measure_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_measure_variable(model::JuMP.Model, var,
                     key::Val{:ext_key_name})::GeneralVariableRef</code></pre><p>Add a measure variable <code>var</code> to the optimizer model <code>model</code> (with <code>key</code>) and return the correct <code>InfiniteOpt</code> variable reference. This is an internal method used by <a href="#InfiniteOpt.make_point_variable_ref"><code>make_point_variable_ref</code></a> and <a href="#InfiniteOpt.make_reduced_variable_ref"><code>make_reduced_variable_ref</code></a> to make point variables and reduced variables when the <code>write_model</code> is an optimizer model. This is useful for extensions that wish to expand measures, but without changing the original <code>InfiniteModel</code>. Thus, this should be extended for adding <code>PointVariable</code>s and <code>ReducedInfiniteVariable</code>s for such extensions. Otherwise, an error is thrown for unextended variable and/or optimizer model types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_internal_reduced_variable" href="#InfiniteOpt.delete_internal_reduced_variable"><code>InfiniteOpt.delete_internal_reduced_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete_internal_reduced_variable(write_model::Union{InfiniteModel, JuMP.Model},
                                 rvref::ReducedInfiniteVariableRef)</code></pre><p>Delete the variable associated with <code>rvref</code> from <code>write_model</code> if it is purely an internal variable only used for measure expansion and is no longer needed. For <code>write_model</code>s that are an optimizer model, <a href="#InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}"><code>delete_reduced_variable</code></a> will need to be extended for this this to work. Otherwise, a warning will be thrown. Note that this is intended as an internal method to assist with extensions to <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}" href="#InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.delete_reduced_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_reduced_variable(model::JuMP.Model, vref, key::Val{:ext_key_name})</code></pre><p>Delete the reduced variable associated with <code>vref</code> from the optimizer model <code>model</code> with associated extension key <code>:ext_key_name</code>. A warning is thrown if this is not properly extended. This is intended as a helper function for <a href="#InfiniteOpt.delete_internal_reduced_variable"><code>delete_internal_reduced_variable</code></a> which is used by <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/measure_expansions.jl#LL128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.reduction_info-Tuple{ReducedInfiniteVariableRef,Any}" href="#InfiniteOpt.reduction_info-Tuple{ReducedInfiniteVariableRef,Any}"><code>InfiniteOpt.reduction_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduction_info(vref::ReducedInfiniteVariableRef,
               key::Val{:my_ext_key}
               )::ReducedInfiniteInfo)</code></pre><p>Return the reduction info of <code>vref</code> that is stored in the optimizer model with key <code>:my_ext_key</code> if it is in fact stored there. This is an internal method that should be extended in combination with an extension of <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_variable_ref(vref::ReducedInfiniteVariableRef)::InfiniteVariableRef</code></pre><p>Return the <code>InfiniteVariableRef</code> associated with the reduced infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_variable_ref(vref)
g(t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_supports(vref::ReducedInfiniteVariableRef)::Dict</code></pre><p>Return the evaluation supports associated with the reduced infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; eval_supports(vref)
Dict{Int64,Float64} with 1 entry:
  1 =&gt; 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL44-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(vref::ReducedInfiniteVariableRef)::Tuple</code></pre><p>Return the <code>ParameterRef</code>(s) associated with the reduced infinite variable <code>vref</code>. This is formatted as a Tuple of containing the parameter references as they were inputted to define the untranscripted infinite variable except, the evaluated parameters are excluded.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(vref)
(t, [x[1], x[2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.parameter_list-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(vref::ReducedInfiniteVariableRef)::Vector{ParameterRef}</code></pre><p>Return a vector of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(vref::ReducedInfiniteVariableRef)::VectorTuple{ParameterRef}</code></pre><p>Return the raw <a href="../variable/#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.name-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(vref::ReducedInfiniteVariableRef)::String</code></pre><p>Extend <code>JuMP.name</code> to return name of reduced infinite variable references. This is used when displaying measure expansions that contain such variables.</p><p><strong>Exanple</strong></p><pre><code class="language-julia-repl">julia&gt; name(rvref)
g(1.25, [x[1], x[2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL137-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(vref::ReducedInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a> to return the lower bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL153-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>JuMP.LowerBoundRef</code></a> to extract a constraint reference for the lower bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = LowerBoundRef(vref)
var &gt;= 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL181-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL197-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(vref::ReducedInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> to return the upper bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>JuMP.UpperBoundRef</code></a> to extract a constraint reference for the upper bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = UpperBoundRef(vref)
var &lt;= 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL241-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_fixed(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_fixed-Tuple{VariableRef}"><code>JuMP.is_fixed</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_fixed(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL257-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix_value(vref::ReducedInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.fix_value-Tuple{VariableRef}"><code>JuMP.fix_value</code></a> to return the fix value of the original infinite variable of <code>vref</code>. Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fix_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL273-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.FixRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.FixRef-Tuple{VariableRef}"><code>JuMP.FixRef</code></a> to return the constraint reference of the fix constraint associated with the original infinite variable of <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cref = FixRef(vref)
var == 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL301-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.start_value-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.start_value(vref::ReducedInfiniteVariableRef)::Union{Nothing, Float64}</code></pre><p>Extend <a href="../../JuMP/#JuMP.start_value-Tuple{VariableRef}"><code>JuMP.start_value</code></a> to return starting value of the original infinite variable of <code>vref</code> if it has one. Returns <code>nothing</code> otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; start_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL318-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_binary(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_binary-Tuple{VariableRef}"><code>JuMP.is_binary</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is binary.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_binary(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL334-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.BinaryRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.BinaryRef-Tuple{VariableRef}"><code>JuMP.BinaryRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL359-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_integer(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_integer-Tuple{VariableRef}"><code>JuMP.is_integer</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is integer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL376-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.IntegerRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.IntegerRef-Tuple{VariableRef}"><code>JuMP.IntegerRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL401-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL418-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL433-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> to accomodate reduced infinite variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_valid(model, vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL448-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}" href="#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, vref::ReducedInfiniteVariableRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete reduced infinite variables and its dependencies. Errors if <code>vref</code> is invalid, meaning it has already been deleted or it belongs to another model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(0, t)*t + g(1, t)*t) + z
Subject to
 z &gt;= 0.0
 g(0, t) + g(1, t) == 0
 g(x, t) + z &gt;= 42.0
 g(0.5, 0.5) == 0
 t in [0, 6]
 x in [0, 1]

julia&gt; delete(model, rvref1)

julia&gt; print(model)
Min measure(t + g(1, t)*t) + z
Subject to
 z &gt;= 0.0
 g(1, t) == 0
 g(x, t) + z &gt;= 42.0
 g(0.5, 0.5) == 0
 t in [0, 6]
 x in [0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/reduced_variables.jl#LL464-L495">source</a></section></article><h2 id="MeasureEvalMethods-Methods-1"><a class="docs-heading-anchor" href="#MeasureEvalMethods-Methods-1">MeasureEvalMethods Methods</a><a class="docs-heading-anchor-permalink" href="#MeasureEvalMethods-Methods-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>InfiniteOpt.MeasureEvalMethods.generate_measure_data</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_laguerre}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{DistributionSet,Union{ParameterRef, AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef},Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:mc_sampling}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:trapezoid}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,Union{ParameterRef, AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef},Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:mc_sampling}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_hermite}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_legendre}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.infinite_transform"><code>InfiniteOpt.MeasureEvalMethods.infinite_transform</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_measure_data" href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>InfiniteOpt.MeasureEvalMethods.generate_measure_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_measure_data(params::Union{InfiniteOpt.ParameterRef,
                      AbstractArray{&lt;:InfiniteOpt.ParameterRef}},
                      num_supports::Int,
                      lb::Union{Number, JuMPC.SparseAxisArray, Nothing} = nothing,
                      ub::Union{Number, JuMPC.SparseAxisArray, Nothing} = nothing;
                      eval_method::Symbol = mc_sampling,
                      name::String = &quot;measure&quot;,
                      weight_func::Function = InfiniteOpt.default_weight,
                      kwargs...)::InfiniteOpt.AbstractMeasureData</code></pre><p>Generate an <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> object that automatically generate supports based on a set of given information. The information is required to include parameters and number of supports. Other optional information to input includes lower and upper bounds, measure name, support generation method, and weight functions. The users could supply extra keyword arguments if necessary for their custom support generation methods.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, x in [0., 1.]);

julia&gt; measure_data = generate_measure_data(x, 3, 0.3, 0.7, method = gauss_legendre)
DiscreteMeasureData(x, [0.1111111111111111, 0.17777777777777776, 0.1111111111111111], [0.3450806661517033, 0.5, 0.6549193338482967], &quot;&quot;, InfiniteOpt.default_weight)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL7-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs" href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_supports_and_coeffs(set::InfiniteOpt.AbstractInfiniteSet,
                             params::Union{InfiniteOpt.ParameterRef,
                             AbstractArray{&lt;:InfiniteOpt.ParameterRef}},
                             num_supports::Int,
                             lb::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             ub::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             method::Val{eval_method}; [kwargs...])::Tuple</code></pre><p>Generate supports and coefficients using the arguments and <code>kwargs</code> as appropriate. This will dispatch to <code>eval_method</code> in accordance with the type of <code>set</code>. This is intended as an internal method for <a href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>generate_measure_data</code></a> and will need to be extended for user-defined infinite set types. The output tuple should consists of two data objects, the first being the supports and the second being the coefficients. Supports must be a <code>Vector</code> of <code>Number</code> or of <code>AbstractArray{&lt;:Number}</code>, and coefficients must be a <code>Vector</code> of <code>Number</code>. Extensions will be needed to implement their own version of function <code>generate_supports_and_coeffs(set::AbstractInfiniteSet, params, num_supports, lb, ub, method::Val{my_method};kwargs...)</code>. Refer to the other dispatches of <code>generate_supports_and_coeffs</code> for details of specific evaluation method implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL58-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,Union{ParameterRef, AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef},Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:mc_sampling}}" href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,Union{ParameterRef, AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef},Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:mc_sampling}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_supports_and_coeffs(set::InfiniteOpt.IntervalSet,
                             params::Union{InfiniteOpt.ParameterRef,
                             AbstractArray{&lt;:InfiniteOpt.ParameterRef}},
                             num_supports::Int,
                             lb::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             ub::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             method::Val{mc_sampling})::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated by Monte Carlo sampling from a uniform distribution between the lower and upper bounds provided.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0., 1.]);

julia&gt; (supps, coeffs) = generate_supports_and_coeffs(IntervalSet(0,1), t, 5, 0., 1., Val(mc_sampling))
([0.8236475079774124, 0.9103565379264364, 0.16456579813368521, 0.17732884646626457, 0.278880109331201], [0.2, 0.2, 0.2, 0.2, 0.2])

julia&gt; supps
5-element Array{Float64,1}:
 0.8236475079774124
 0.9103565379264364
 0.16456579813368521
 0.17732884646626457
 0.278880109331201</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL95-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{DistributionSet,Union{ParameterRef, AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef},Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:mc_sampling}}" href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{DistributionSet,Union{ParameterRef, AbstractArray{#s478,N} where N where #s478&lt;:ParameterRef},Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:mc_sampling}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_supports_and_coeffs(set::InfiniteOpt.DistributionSet,
                             params::Union{InfiniteOpt.ParameterRef,
                             AbstractArray{&lt;:InfiniteOpt.ParameterRef}},
                             num_supports::Int,
                             lb::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             ub::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             method::Val{mc_sampling})::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated by Monte Carlo sampling from a given distribution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dist = Normal(0., 1.)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; @infinite_parameter(model, x in dist)
x

julia&gt; (supps, coeffs) = generate_supports_and_coeffs(DistributionSet(dist), x, 10, nothing, nothing, Val(mc_sampling))
([0.6791074260357777, 0.8284134829000359, -0.3530074003005963, -0.13485387193052173, 0.5866170746331097, 0.29733585084941616, 0.06494754854834232, -0.10901738508171745, -0.514210390833322, 1.5743302021369892], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL140-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:trapezoid}}" href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:trapezoid}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_supports_and_coeffs(set::InfiniteOpt.IntervalSet,
                             params::InfiniteOpt.ParameterRef,
                             num_supports::Int,
                             lb::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             ub::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             method::Val{trapezoid})::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated a uniform trapezoid rule. This is useful for both univariate parameter in a bounded interval. For multivariate parameters, <code>num_supports</code> will be the number of grid points on one dimension.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 1])
t

julia&gt; (supps, coeffs) = generate_supports_and_coeffs(IntervalSet(0,1), t, 3, 0, 1, Val(trapezoid))
([0.0, 0.5, 1.0], [0.25, 0.5, 0.25])

julia&gt; supps
3-element Array{Float64,1}:
 0.0
 0.5
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL331-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_legendre}}" href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_legendre}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_supports_and_coeffs(set::InfiniteOpt.IntervalSet,
                             params::InfiniteOpt.ParameterRef,
                             num_supports::Int,
                             lb::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             ub::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             method::Val{gauss_legendre})::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated using Gauss-Legendre quadrature method. This is useful for univariate parameter in a finite interval.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 1])
t

julia&gt; (supps, coeffs) = generate_supports_and_coeffs(IntervalSet(0,1), t, 5, 0., 1., Val(gauss_legendre))
([0.04691007703066802, 0.23076534494715845, 0.5, 0.7692346550528415, 0.9530899229693319], [0.11846344252809454, 0.23931433524968324, 0.28444444444444444, 0.23931433524968324, 0.11846344252809454])

julia&gt; supps
5-element Array{Float64,1}:
 0.04691007703066802
 0.23076534494715845
 0.5
 0.7692346550528415
 0.9530899229693319</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL186-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_hermite}}" href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_hermite}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_supports_and_coeffs(set::InfiniteOpt.IntervalSet,
                             params::InfiniteOpt.ParameterRef,
                             num_supports::Int,
                             lb::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             ub::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             method::Val{gauss_hermite})::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated using Gauss-Hermite quadrature method. This is useful for univariate parameter in an infinite interval.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [-Inf, Inf])
t

julia&gt; (supps, coeffs) = generate_supports_and_coeffs(IntervalSet(-Inf,Inf), t, 5, -Inf, Inf, Val(gauss_hermite))
([-2.0201828704560856, -0.9585724646138196, -8.881784197001252e-16, 0.9585724646138196, 2.0201828704560856], [1.1814886255359844, 0.986580996751429, 0.9453087204829428, 0.986580996751429, 1.1814886255359844])

julia&gt; supps
5-element Array{Float64,1}:
 -2.0201828704560856
 -0.9585724646138196
 -8.881784197001252e-16
  0.9585724646138196
  2.0201828704560856</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL229-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_laguerre}}" href="#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs-Tuple{IntervalSet,ParameterRef,Int64,Union{Nothing, Number, SparseAxisArray},Union{Nothing, Number, SparseAxisArray},Val{:gauss_laguerre}}"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_supports_and_coeffs(set::InfiniteOpt.IntervalSet,
                             params::InfiniteOpt.ParameterRef,
                             num_supports::Int,
                             lb::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             ub::Union{Number, JuMPC.SparseAxisArray, Nothing},
                             method::Val{gauss_laguerre})::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated using Gauss-Laguerre quadrature method. This is useful for univariate parameter in a semi-infinite interval.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [-Inf, 0])
t

julia&gt; (supps, coeffs) = generate_supports_and_coeffs(IntervalSet(-Inf,0), t, 5, -Inf, 0, Val(gauss_laguerre))
([-0.2635603197181408, -1.413403059106515, -3.596425771040715, -7.08581000585883, -12.640800844275773], [0.6790940422077494, 1.638487873602747, 2.7694432423708255, 4.3156569009208585, 7.219186354354335])

julia&gt; supps
5-element Array{Float64,1}:
  -0.2635603197181408
  -1.413403059106515
  -3.596425771040715
  -7.08581000585883
 -12.640800844275773</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL275-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.infinite_transform" href="#InfiniteOpt.MeasureEvalMethods.infinite_transform"><code>InfiniteOpt.MeasureEvalMethods.infinite_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">infinite_transform(lb::Number, ub::Number, num_supports::Int;
                   [sub_method::Function = mc_sampling,
                   transform_x::Function = _default_x,
                   transform_dx::Function = _default_dx,
                   t_lb::Number = -convert(Number, lb == -Inf &amp;&amp; ub == Inf),
                   t_ub::Number = 1., kwargs...])::Tuple</code></pre><p>Returns a tuple that contains supports and coefficients generated for a parameter in an infinite or semi-infinite interval. It works by transforming the original unbounded interval to a finite interval, on which a support generation method for finite intervals is applied. Then, the generated supports are transformed back to the original interval. The user is allowed to specify the support generation method for finite intevals to use, as well as the transform function. The default transform function is <span>$t \in [-\infty, \infty] \rightarrow x \in [-1, 1]: t(x) = \frac{t}{1-t^2}$</span> <span>$t \in [a, \infty] \rightarrow x \in [0, 1]: t(x) = a + \frac{t}{1-t}$</span> <span>$t \in [-\infty, a] \rightarrow x \in [0, 1]: t(x) = a - \frac{1-t}{t}$</span></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; (supps, coeffs) = infinite_transform(-Inf, Inf, 5, sub_method = gauss_legendre)
([-5.06704059565454, -0.7583532171678754, 0.0, 0.7583532171678754, 5.06704059565454], [13.490960583398396, 1.2245949721571516, 0.5688888888888889, 1.2245949721571516, 13.490960583398396])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/MeasureEvalMethods/methods.jl#LL433-L457">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../expression/">« Expressions</a><a class="docs-footer-nextpage" href="../objective/">Objectives »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 April 2020 19:31">Wednesday 8 April 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
