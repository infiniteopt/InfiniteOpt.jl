<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li class="is-active"><a class="tocitem" href>Optimization</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage-1"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Optimizer-Models-1"><span>Optimizer Models</span></a></li><li><a class="tocitem" href="#Optimizer-Settings-1"><span>Optimizer Settings</span></a></li><li><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Optimization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/optimize.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimization-1"><a class="docs-heading-anchor" href="#Optimization-1">Optimization</a><a class="docs-heading-anchor-permalink" href="#Optimization-1" title="Permalink"></a></h1><p>A guide and manual for optimizing (solving) <code>InfiniteOpt</code> models. The Methods section at the end comprise the manual, and the above sections comprise the guide.</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>Fundamentally, we seek to optimize a given infinite optimization model that we have defined and this is the very reason why <code>InfiniteOpt</code> was created. Thus, <code>InfiniteOpt</code> offers a general and intuitive platform to do just this. This is made up of transforming the <code>InfiniteModel</code> into a standard optimization problem stored as a <code>JuMP.Model</code> (referred to as the <code>optimizer_model</code>) that is then optimized via a compatible optimizer. By default this is done via a <code>TranscriptionModel</code> as described on the previous page. However, user-defined reformulation strategies can readily be implemented as described in the <a href="../../extensions/#extend_optimizer_model-1">Optimizer Models</a> section on the extensions page.</p><h2 id="Basic-Usage-1"><a class="docs-heading-anchor" href="#Basic-Usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-1" title="Permalink"></a></h2><p>For most users, <a href="#JuMP.optimize!-Tuple{InfiniteModel}"><code>optimize!</code></a> is the only method required to optimize an <code>InfiniteModel</code>. This is exactly analogous to that of any <code>JuMP.Model</code> and is designed to provide a similar user experience. Let&#39;s first define an <code>InfiniteModel</code> with an appropriate optimizer:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP, Ipopt;

julia&gt; model = InfiniteModel(Ipopt.Optimizer);

julia&gt; set_optimizer_attribute(model, &quot;print_level&quot;, 0);

julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10);

julia&gt; @infinite_variable(model, x(t) &gt;= 0);

julia&gt; @hold_variable(model, z &gt;= 0);

julia&gt; @objective(model, Min, 2z);

julia&gt; @constraint(model, c1, z &gt;= x);

julia&gt; @BDconstraint(model, c2(t == 0), x == 42);

julia&gt; print(model)
Min 2 z
Subject to
 x(t) ≥ 0.0
 z ≥ 0.0
 z - x(t) ≥ 0.0
 x(t) = 42.0, ∀ t = 0
 t ∈ [0, 10]</code></pre><p>Now we optimize the model using <code>optimize!</code>:</p><pre><code class="language-julia-repl">julia&gt; optimize!(model)

julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4</code></pre><p>Now our model has been solved and we can query the solution. How to query the solution is explained on the <a href="../result/#Results-1">Results</a> page.</p><p>If no optimizer has been specified for the <code>InfiniteModel</code>, one can be provided via <a href="#JuMP.set_optimizer-Tuple{InfiniteModel,Any}"><code>set_optimizer</code></a>:</p><pre><code class="language-julia-repl">julia&gt; set_optimizer(model, Ipopt.Optimizer)</code></pre><p>A number of methods also exist to adjust the optimizer settings such as suppressing output. This is explained below in the <a href="#Optimizer-Settings-1">Optimizer Settings</a> section.</p><h2 id="Optimizer-Models-1"><a class="docs-heading-anchor" href="#Optimizer-Models-1">Optimizer Models</a><a class="docs-heading-anchor-permalink" href="#Optimizer-Models-1" title="Permalink"></a></h2><p>As discussed previously, <code>InfiniteModel</code>s contain an <code>optimizer_model</code> field which stores a transformed finite version of the model in a <code>JuMP.Model</code> that contains a data struct (that stores a mapping between the transformed model and the infinite model) in the <code>Model.ext</code> dictionary with an associated key. By default a <code>JuMP.Model</code> using <a href="../transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>TranscriptionData</code></a> stored under the key <code>:TransData</code> is used and is referred to as a <code>TranscriptionModel</code>. The optimizer model is then what is used to optimize the infinite model and it provides the information exacted by solution queries mapped backed back to the infinite model using the mapping data structure.</p><p>The process for optimizing an <code>InfiniteModel</code> is summarized in the following steps:</p><ul><li>fully define the <code>InfiniteModel</code></li><li>build the optimizer model via <a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>build_optimizer_model!</code></a></li><li>optimize the <code>optimizer_model</code> via <a href="../../JuMP/#JuMP.optimize!-Tuple{Model,Any}"><code>optimize!</code></a>.</li></ul><p>Here <code>build_optimizer_model!</code> creates a reformulated finite version of the <code>InfiniteModel</code>, stores it in <code>InfiniteModel.optimizer_model</code> via <a href="#InfiniteOpt.set_optimizer_model"><code>set_optimizer_model</code></a>, and indicates that the optimizer model is ready via <a href="#InfiniteOpt.set_optimizer_model_ready"><code>set_optimizer_model_ready</code></a>. These steps are all automated when <a href="#JuMP.optimize!-Tuple{InfiniteModel}"><code>optimize!</code></a> is invoked on the <code>InfiniteModel</code>.</p><p>The <code>optimizer_model</code> can be queried/extracted at any time from an <code>InfiniteModel</code> via <a href="#InfiniteOpt.optimizer_model"><code>optimizer_model</code></a>. For example, let&#39;s extract the optimizer model from the example above in the basic usage section:</p><pre><code class="language-julia-repl">julia&gt; trans_model = optimizer_model(model)
A JuMP Model
Minimization problem with:
Variables: 11
Objective function type: GenericAffExpr{Float64,VariableRef}
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.GreaterThan{Float64}`: 10 constraints
`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 11 constraints
Model mode: AUTOMATIC
CachingOptimizer state: ATTACHED_OPTIMIZER
Solver name: Ipopt</code></pre><p>The <code>JuMP</code> variable(s) stored in the optimizer model that correspond to a particular <code>InfiniteOpt</code> variable can be queried via <a href="#InfiniteOpt.optimizer_model_variable-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>optimizer_model_variable</code></a>. Using a <code>TranscriptionModel</code> this equivalent to calling <a href="../transcribe/#InfiniteOpt.TranscriptionOpt.transcription_variable"><code>transcription_variable</code></a>. Thus, using going example we get:</p><pre><code class="language-julia-repl">julia&gt; optimizer_model_variable(x) # infinite variable
10-element Array{VariableRef,1}:
 x(support: 1)
 x(support: 2)
 x(support: 3)
 x(support: 4)
 x(support: 5)
 x(support: 6)
 x(support: 7)
 x(support: 8)
 x(support: 9)
 x(support: 10)

julia&gt; optimizer_model_variable(z) # hold variable
z</code></pre><p>In like manner, we get the <code>JuMP</code> constraints corresponding to a particular <code>InfiniteOpt</code> constraint via <a href="#InfiniteOpt.optimizer_model_constraint-Tuple{GeneralConstraintRef}"><code>optimizer_model_constraint</code></a>. Using a <code>TranscriptionModel</code> this equivalent to calling <a href="../transcribe/#InfiniteOpt.TranscriptionOpt.transcription_constraint"><code>transcription_constraint</code></a>. Thus, using going example we get:</p><pre><code class="language-julia-repl">julia&gt; optimizer_model_constraint(c1) # infinite constraint
10-element Array{ConstraintRef,1}:
 c1(Support: 1) : z - x(support: 1) ≥ 0.0
 c1(Support: 2) : z - x(support: 2) ≥ 0.0
 c1(Support: 3) : z - x(support: 3) ≥ 0.0
 c1(Support: 4) : z - x(support: 4) ≥ 0.0
 c1(Support: 5) : z - x(support: 5) ≥ 0.0
 c1(Support: 6) : z - x(support: 6) ≥ 0.0
 c1(Support: 7) : z - x(support: 7) ≥ 0.0
 c1(Support: 8) : z - x(support: 8) ≥ 0.0
 c1(Support: 9) : z - x(support: 9) ≥ 0.0
 c1(Support: 10) : z - x(support: 10) ≥ 0.0</code></pre><p>The purpose of this <code>optimizer_model</code> structure is to readily enable user-defined reformulation extensions (e.g., using polynomial chaos expansion theory). However, this is all handled behind the scenes such that most users can interact with <code>InfiniteModel</code>s like any <code>JuMP.Model</code>.</p><h2 id="Optimizer-Settings-1"><a class="docs-heading-anchor" href="#Optimizer-Settings-1">Optimizer Settings</a><a class="docs-heading-anchor-permalink" href="#Optimizer-Settings-1" title="Permalink"></a></h2><p>A few optimizer settings can be set in a consistent way agnostic of particular solver keywords. One such setting is that of suppressing and unsuppressing optimizer verbose output. This is accomplished via <a href="#JuMP.set_silent-Tuple{InfiniteModel}"><code>set_silent</code></a> and <a href="#JuMP.unset_silent-Tuple{InfiniteModel}"><code>unset_silent</code></a>. The syntax is exemplified below:</p><pre><code class="language-julia-repl">julia&gt; set_silent(model)
true

julia&gt; unset_silent(model)
false</code></pre><p>We can also adjust the time limit in a solver independent fashion via <a href="#JuMP.set_time_limit_sec-Tuple{InfiniteModel,Any}"><code>set_time_limit_sec</code></a>, <a href="#JuMP.unset_time_limit_sec-Tuple{InfiniteModel}"><code>unset_time_limit_sec</code></a>, and <a href="#JuMP.time_limit_sec-Tuple{InfiniteModel}"><code>time_limit_sec</code></a>. These methods are illustrated below:</p><pre><code class="language-julia-repl">julia&gt; set_time_limit_sec(model, 100)
100

julia&gt; time_limit_sec(model)
100.0

julia&gt; unset_time_limit_sec(model)</code></pre><p>Other optimizer specific settings can be set via <a href="#JuMP.set_optimizer_attribute-Tuple{InfiniteModel,String,Any}"><code>set_optimizer_attribute</code></a>. For example, let&#39;s set the maximum CPU time for Ipopt:</p><pre><code class="language-julia-repl">julia&gt; set_optimizer_attribute(model, &quot;max_cpu_time&quot;, 60.)
60.0</code></pre><p>Multiple settings  can be specified via <a href="#JuMP.set_optimizer_attributes-Tuple{InfiniteModel,Pair}"><code>set_optimizer_attributes</code></a>. For example, let&#39;s specify the tolerance and the maximum number of iterations:</p><pre><code class="language-julia-repl">julia&gt; set_optimizer_attributes(model, &quot;tol&quot; =&gt; 1e-4, &quot;max_iter&quot; =&gt; 100)</code></pre><p>Finally, we can query optimizer settings via <a href="#JuMP.get_optimizer_attribute-Tuple{InfiniteModel,String}"><code>get_optimizer_attribute</code></a>. For example, let&#39;s query the maximum number of iterations:</p><pre><code class="language-julia-repl">julia&gt; get_optimizer_attribute(model, &quot;max_iter&quot;)
100</code></pre><p>Note this only works if the attribute has been previously specified.</p><h2 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.add_infinite_model_optimizer"><code>InfiniteOpt.add_infinite_model_optimizer</code></a></li><li><a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>InfiniteOpt.build_optimizer_model!</code></a></li><li><a href="#InfiniteOpt.clear_optimizer_model_build!-Tuple{InfiniteModel}"><code>InfiniteOpt.clear_optimizer_model_build!</code></a></li><li><a href="#InfiniteOpt.clear_optimizer_model_build!-Tuple{Model}"><code>InfiniteOpt.clear_optimizer_model_build!</code></a></li><li><a href="#InfiniteOpt.constraint_parameter_refs"><code>InfiniteOpt.constraint_parameter_refs</code></a></li><li><a href="#InfiniteOpt.constraint_supports"><code>InfiniteOpt.constraint_supports</code></a></li><li><a href="#InfiniteOpt.optimizer_model"><code>InfiniteOpt.optimizer_model</code></a></li><li><a href="#InfiniteOpt.optimizer_model_constraint"><code>InfiniteOpt.optimizer_model_constraint</code></a></li><li><a href="#InfiniteOpt.optimizer_model_constraint-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.optimizer_model_constraint</code></a></li><li><a href="#InfiniteOpt.optimizer_model_key-Tuple{Model}"><code>InfiniteOpt.optimizer_model_key</code></a></li><li><a href="#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}"><code>InfiniteOpt.optimizer_model_key</code></a></li><li><a href="#InfiniteOpt.optimizer_model_ready"><code>InfiniteOpt.optimizer_model_ready</code></a></li><li><a href="#InfiniteOpt.optimizer_model_variable-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.optimizer_model_variable</code></a></li><li><a href="#InfiniteOpt.optimizer_model_variable"><code>InfiniteOpt.optimizer_model_variable</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.set_optimizer_model"><code>InfiniteOpt.set_optimizer_model</code></a></li><li><a href="#InfiniteOpt.set_optimizer_model_ready"><code>InfiniteOpt.set_optimizer_model_ready</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.variable_supports"><code>InfiniteOpt.variable_supports</code></a></li><li><a href="#JuMP.add_bridge-Tuple{InfiniteModel,Type{#s478} where #s478&lt;:MathOptInterface.Bridges.AbstractBridge}"><code>JuMP.add_bridge</code></a></li><li><a href="#JuMP.backend-Tuple{InfiniteModel}"><code>JuMP.backend</code></a></li><li><a href="#JuMP.bridge_constraints-Tuple{InfiniteModel}"><code>JuMP.bridge_constraints</code></a></li><li><a href="#JuMP.get_optimizer_attribute-Tuple{InfiniteModel,String}"><code>JuMP.get_optimizer_attribute</code></a></li><li><a href="#JuMP.get_optimizer_attribute-Tuple{InfiniteModel,MathOptInterface.AbstractOptimizerAttribute}"><code>JuMP.get_optimizer_attribute</code></a></li><li><a href="#JuMP.mode-Tuple{InfiniteModel}"><code>JuMP.mode</code></a></li><li><a href="#JuMP.optimize!-Tuple{InfiniteModel}"><code>JuMP.optimize!</code></a></li><li><a href="#JuMP.set_optimizer-Tuple{InfiniteModel,Any}"><code>JuMP.set_optimizer</code></a></li><li><a href="#JuMP.set_optimizer_attribute-Tuple{InfiniteModel,MathOptInterface.AbstractOptimizerAttribute,Any}"><code>JuMP.set_optimizer_attribute</code></a></li><li><a href="#JuMP.set_optimizer_attribute-Tuple{InfiniteModel,String,Any}"><code>JuMP.set_optimizer_attribute</code></a></li><li><a href="#JuMP.set_optimizer_attributes-Tuple{InfiniteModel,Pair}"><code>JuMP.set_optimizer_attributes</code></a></li><li><a href="#JuMP.set_silent-Tuple{InfiniteModel}"><code>JuMP.set_silent</code></a></li><li><a href="#JuMP.set_time_limit_sec-Tuple{InfiniteModel,Any}"><code>JuMP.set_time_limit_sec</code></a></li><li><a href="#JuMP.solver_name-Tuple{InfiniteModel}"><code>JuMP.solver_name</code></a></li><li><a href="#JuMP.time_limit_sec-Tuple{InfiniteModel}"><code>JuMP.time_limit_sec</code></a></li><li><a href="#JuMP.unset_silent-Tuple{InfiniteModel}"><code>JuMP.unset_silent</code></a></li><li><a href="#JuMP.unset_time_limit_sec-Tuple{InfiniteModel}"><code>JuMP.unset_time_limit_sec</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimize!-Tuple{InfiniteModel}" href="#JuMP.optimize!-Tuple{InfiniteModel}"><code>JuMP.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimize!(model::InfiniteModel;
               bridge_constraints::Bool=true, kwargs...])</code></pre><p>Extend <a href="../../JuMP/#JuMP.optimize!-Tuple{Model,Any}"><code>JuMP.optimize!</code></a> to optimize infinite models using the internal optimizer model. Will call <a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>build_optimizer_model!</code></a> if the optimizer model isn&#39;t up to date. The <code>kwargs</code> correspond to keyword arguments passed to <a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>build_optimizer_model!</code></a> if any are defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimize!(model)

julia&gt; has_values(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL717-L734">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer-Tuple{InfiniteModel,Any}" href="#JuMP.set_optimizer-Tuple{InfiniteModel,Any}"><code>JuMP.set_optimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_optimizer(model::InfiniteModel,
                   [optimizer_constructor;
                   bridge_constraints::Bool = true])</code></pre><p>Extend <code>JuMP.set_optimizer</code> to set optimizer of infinite models. Specifically, the optimizer of the optimizer model is modified.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_optimizer(model, Clp.Optimizer)

julia&gt; optimizer_model(model)
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: EMPTY_OPTIMIZER
Solver name: SolverName() attribute not implemented by the optimizer.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL143-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_silent-Tuple{InfiniteModel}" href="#JuMP.set_silent-Tuple{InfiniteModel}"><code>JuMP.set_silent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_silent(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_silent-Tuple{Model}"><code>JuMP.set_silent</code></a> for infinite models to take precedence over any other attribute controlling verbosity and requires the solver to produce no output.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_silent(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL173-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_silent-Tuple{InfiniteModel}" href="#JuMP.unset_silent-Tuple{InfiniteModel}"><code>JuMP.unset_silent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.unset_silent(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.unset_silent-Tuple{Model}"><code>JuMP.unset_silent</code></a> for infinite models to neutralize the effect of the <code>set_silent</code> function and let the solver attributes control the verbosity.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; unset_silent(model)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL190-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_time_limit_sec-Tuple{InfiniteModel,Any}" href="#JuMP.set_time_limit_sec-Tuple{InfiniteModel,Any}"><code>JuMP.set_time_limit_sec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_time_limit_sec(model::InfiniteModel, limit)</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_time_limit_sec-Tuple{Model,Any}"><code>set_time_limit_sec</code></a> to set the time limit (in seconds) of the solver. Can be unset using <code>unset_time_limit_sec</code> or with <code>limit</code> set to <code>nothing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_time_limit_sec(model, 100)
100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL207-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_time_limit_sec-Tuple{InfiniteModel}" href="#JuMP.unset_time_limit_sec-Tuple{InfiniteModel}"><code>JuMP.unset_time_limit_sec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.unset_time_limit_sec(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.unset_time_limit_sec-Tuple{Model}"><code>unset_time_limit_sec</code></a> to unset the time limit of the solver. Can be set using <code>set_time_limit_sec</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; unset_time_limit_sec(model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL224-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.time_limit_sec-Tuple{InfiniteModel}" href="#JuMP.time_limit_sec-Tuple{InfiniteModel}"><code>JuMP.time_limit_sec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.time_limit_sec(model::InfiniteModel)</code></pre><p>Extend [<code>time_limit_sec</code>](@ref JuMP.time<em>limit</em>sec(::JuMP.Model) to get the time limit (in seconds) of the solve used by the optimizer model (<code>nothing</code> if unset). Can be set using <code>set_time_limit_sec</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; time_limit_sec(model)
100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL239-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer_attribute-Tuple{InfiniteModel,String,Any}" href="#JuMP.set_optimizer_attribute-Tuple{InfiniteModel,String,Any}"><code>JuMP.set_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_optimizer_attribute(model::InfiniteModel, name::String, value)</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_optimizer_attribute-Tuple{Model,String,Any}"><code>set_optimizer_attribute</code></a> to specify a solver-specific attribute identified by <code>name</code> to <code>value</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_optimizer_attribute(model, &quot;SolverSpecificAttributeName&quot;, true)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL256-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer_attribute-Tuple{InfiniteModel,MathOptInterface.AbstractOptimizerAttribute,Any}" href="#JuMP.set_optimizer_attribute-Tuple{InfiniteModel,MathOptInterface.AbstractOptimizerAttribute,Any}"><code>JuMP.set_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_optimizer_attribute(model::InfiniteModel,
                             attr::MOI.AbstractOptimizerAttribute,
                             value)</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_optimizer_attribute-Tuple{Model,MathOptInterface.AbstractOptimizerAttribute,Any}"><code>set_optimizer_attribute</code></a> to set the solver-specific attribute <code>attr</code> in <code>model</code> to <code>value</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_optimizer_attribute(model, MOI.Silent(), true)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL272-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_optimizer_attributes-Tuple{InfiniteModel,Pair}" href="#JuMP.set_optimizer_attributes-Tuple{InfiniteModel,Pair}"><code>JuMP.set_optimizer_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_optimizer_attributes(model::InfiniteModel, pairs::Pair...)</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_optimizer_attributes-Tuple{Model,Pair}"><code>set_optimizer_attributes</code></a> to set multiple solver attributes given a list of <code>attribute =&gt; value</code> pairs. Calls <code>set_optimizer_attribute(model, attribute, value)</code> for each pair.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; model = Model(Ipopt.Optimizer);

julia&gt; set_optimizer_attributes(model, &quot;tol&quot; =&gt; 1e-4, &quot;max_iter&quot; =&gt; 100)</code></pre><p>is equivalent to:</p><pre><code class="language-julia-repl">julia&gt; set_optimizer_attribute(model, &quot;tol&quot;, 1e-4);

julia&gt; set_optimizer_attribute(model, &quot;max_iter&quot;, 100);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL292-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.get_optimizer_attribute-Tuple{InfiniteModel,String}" href="#JuMP.get_optimizer_attribute-Tuple{InfiniteModel,String}"><code>JuMP.get_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.get_optimizer_attribute(model::InfiniteModel, name::String)</code></pre><p>Extend <a href="../../JuMP/#JuMP.get_optimizer_attribute-Tuple{Model,String}"><code>get_optimizer_attribute</code></a> to return the value associated with the solver-specific attribute named <code>name</code>.</p><p><strong>Example</strong> <code>julia-repl julia&gt; get_optimizer_attribute(model, &quot;tol&quot;) 0.0001</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL319-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.get_optimizer_attribute-Tuple{InfiniteModel,MathOptInterface.AbstractOptimizerAttribute}" href="#JuMP.get_optimizer_attribute-Tuple{InfiniteModel,MathOptInterface.AbstractOptimizerAttribute}"><code>JuMP.get_optimizer_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.get_optimizer_attribute(model::InfiniteModel,
                             attr::MOI.AbstractOptimizerAttribute)</code></pre><p>Extend <a href="../../JuMP/#JuMP.get_optimizer_attribute-Tuple{Model,MathOptInterface.AbstractOptimizerAttribute}"><code>get_optimizer_attribute</code></a> to return the value of the solver-specific attribute <code>attr</code> in <code>model</code>.</p><p><strong>Example</strong> <code>julia-repl julia&gt; get_optimizer_attribute(model, MOI.Silent()) true</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL335-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solver_name-Tuple{InfiniteModel}" href="#JuMP.solver_name-Tuple{InfiniteModel}"><code>JuMP.solver_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.solver_name(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.solver_name-Tuple{Model}"><code>solver_name</code></a> to return the name of the solver being used if there is an optimizer selected and it has a name attribute. Otherwise, an error is thrown.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; solver_name(model)
&quot;Gurobi&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL668-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.backend-Tuple{InfiniteModel}" href="#JuMP.backend-Tuple{InfiniteModel}"><code>JuMP.backend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.backend(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.backend-Tuple{Model}"><code>backend</code></a> to return the <code>MathOptInterface</code> backend associated with the optimizer model. Note this will be empty if the optimizer model has not been build yet.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; moi_model = backend(model);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL685-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.mode-Tuple{InfiniteModel}" href="#JuMP.mode-Tuple{InfiniteModel}"><code>JuMP.mode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.mode(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.mode-Tuple{Model}"><code>mode</code></a> to return the <code>MathOptInterface</code> mode the optimizer model is in.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mode(model)
AUTOMATIC::ModelMode = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL701-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model" href="#InfiniteOpt.optimizer_model"><code>InfiniteOpt.optimizer_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimizer_model(model::InfiniteModel)::JuMP.Model</code></pre><p>Return the JuMP model stored in <code>model</code> that is used to solve it.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; opt_model = optimizer_model(model)
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_optimizer_model" href="#InfiniteOpt.set_optimizer_model"><code>InfiniteOpt.set_optimizer_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_optimizer_model(inf_model::InfiniteModel, opt_model::JuMP.Model;
                    inherit_optimizer::Bool = true)</code></pre><p>Specify the JuMP model that is used to solve <code>inf_model</code>. This is intended for internal use and extensions. Note that <code>opt_model</code> should contain extension data to allow it to map to <code>inf_model</code> in a manner similar to <a href="../transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{}"><code>TranscriptionModel</code></a>. <code>inherit_optimizer</code> indicates whether <a href="#InfiniteOpt.add_infinite_model_optimizer"><code>add_infinite_model_optimizer</code></a> should be invoked on the new optimizer mode to inherit the optimizer constuctor and attributes currently stored in <code>inf_model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_optimizer_model(model, TranscriptionModel())

julia&gt; optimizer_model(model)
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL108-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}" href="#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}"><code>InfiniteOpt.optimizer_model_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizer_model_key(model::InfiniteModel)::Any</code></pre><p>Return the extension key used in the optimizer model of <code>model</code>. Errors if <code>optimizer_model.ext</code> contains more than one key. This is intended for internal use and extensions. For extensions this is used to dispatch to the appropriate optmizer model functions such as extensions to <a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>build_optimizer_model!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_model_key(model)
:TransData</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL375-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_key-Tuple{Model}" href="#InfiniteOpt.optimizer_model_key-Tuple{Model}"><code>InfiniteOpt.optimizer_model_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizer_model_key(model::JuMP.Model)::Any</code></pre><p>Return the extension key used in the optimizer model <code>model</code>. Errors if <code>model.ext</code> contains more than one key. This is intended for internal use and extensions. For extensions this is used to dispatch to the appropriate optmizer model functions such as extensions to <a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>build_optimizer_model!</code></a>. This is intended as an internal method. See <a href="#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}"><code>optimizer_model_key</code></a> for the public method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL356-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}" href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>InfiniteOpt.build_optimizer_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_optimizer_model!(model::InfiniteModel; [kwargs...])</code></pre><p>Build the optimizer model stored in <code>model</code> such that it can be treated as a normal JuMP model. Specifically, translate the variables and constraints stored in <code>model</code> into ones that are stored in the optimizer model and can be solved. This is provided generally to accomodate extensions that use custom optimizer model types in accordance with <a href="#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}"><code>optimizer_model_key</code></a>. However, it may be useful in certain applications when the user desires to force a build without calling <code>optimize!</code>. Extensions will need to implement their own version of the function <code>build_optimizer_model!(model::InfiniteModel, key::Val{ext_key_name}; kwargs...)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; build_optimizer_model!(model)

julia&gt; optimizer_model_ready(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL439-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.clear_optimizer_model_build!-Tuple{InfiniteModel}" href="#InfiniteOpt.clear_optimizer_model_build!-Tuple{InfiniteModel}"><code>InfiniteOpt.clear_optimizer_model_build!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_optimizer_model_build!(model::InfiniteModel)::JuMP.Model</code></pre><p>Empty the optimizer model using appropriate calls of <code>Base.empty!</code>. This effectively resets <code>model.optimizer_model</code> except the optimizer, its attributes, and an an emptied optimizer model data struct are maintained. This is intended as an internal method for use by <a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>build_optimizer_model!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL427-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.clear_optimizer_model_build!-Tuple{Model}" href="#InfiniteOpt.clear_optimizer_model_build!-Tuple{Model}"><code>InfiniteOpt.clear_optimizer_model_build!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_optimizer_model_build!(model::JuMP.Model)::JuMP.Model</code></pre><p>Empty the optimizer model using appropriate calls of <code>Base.empty!</code>. This effectively resets <code>model</code> except the optimizer, its attributes, and an an emptied optimizer model data struct are maintained. This is intended as an internal method for use by <a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>build_optimizer_model!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL408-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_infinite_model_optimizer" href="#InfiniteOpt.add_infinite_model_optimizer"><code>InfiniteOpt.add_infinite_model_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_infinite_model_optimizer(opt_model::JuMP.Model, inf_model::InfiniteModel)</code></pre><p>Parse the current optimizer and its attributes associated with <code>model</code> and load them into <code>opt_model</code>. This is intended to be used as an internal method for <a href="#InfiniteOpt.set_optimizer_model"><code>set_optimizer_model</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_variable-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#InfiniteOpt.optimizer_model_variable-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.optimizer_model_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizer_model_variable(vref::InfOptVariableRef; [kwargs...])</code></pre><p>Return the reformulation variable(s) stored in the optimizer model that correspond to <code>vref</code>. By default, no keyword arguments <code>kwargs</code> are employed by <code>TranscriptionOpt</code>, but extensions may employ <code>kwargs</code> in accordance with their implementation of <a href="#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a>. Errors if such an extension has not been written. Also errors if no such variable can be found in the optimizer model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_model_variable(x) # infinite variable
2-element Array{VariableRef,1}:
 x(support: 1)
 x(support: 2)

julia&gt; optimizer_model_variable(z) # hold variable
z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL483-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_variable" href="#InfiniteOpt.optimizer_model_variable"><code>InfiniteOpt.optimizer_model_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimizer_model_variable(vref::InfOptVariableRef, key::Val{ext_key_name};
                         [kwargs...])</code></pre><p>Return the reformulation variable(s) stored in the optimizer model that correspond to <code>vref</code>. This needs to be defined for extensions that implement a custom optimizer model type. Principally, this is accomplished by typed the <code>key</code> argument to <code>Val{ext_key_name}</code>. Keyword arguments can be added as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL466-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.supports-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(vref::InfiniteVariableRef; [kwargs...])::Vector</code></pre><p>Return the supports associated with <code>vref</code> in the optimizer model. Errors if <a href="#InfiniteOpt.variable_supports"><code>variable_supports</code></a> has not been extended for the optimizer model type or if <code>vref</code> is not be reformulated in the optimizer model. By default, keyword arugments are not used, but may employed by extensions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(vref)
Dict{Int64,Tuple{Float64}} with 2 entries:
  2 =&gt; (1.0,)
  1 =&gt; (0.0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL526-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.variable_supports" href="#InfiniteOpt.variable_supports"><code>InfiniteOpt.variable_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">variable_supports(optimizer_model::JuMP.Model, vref::InfiniteVariableRef,
                  key::Val{ext_key_name}; [kwargs...])::Vector</code></pre><p>Return the supports associated with the mappings of <code>vref</code> in <code>optimizer_model</code>. This dispatches off of <code>key</code> which permits optimizer model extensions. This should throw an error if <code>vref</code> is not associated with the variable mappings stored in <code>optimizer_model</code>. Keyword arguments can be added as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL509-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_constraint-Tuple{GeneralConstraintRef}" href="#InfiniteOpt.optimizer_model_constraint-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.optimizer_model_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimizer_model_constraint(cref::GeneralConstraintRef; [kwargs...])</code></pre><p>Return the reformulation constraint(s) stored in the optimizer model that correspond to <code>cref</code>. By default, no keyword arguments <code>kwargs</code> are employed by <code>TranscriptionOpt</code>, but extensions may employ <code>kwargs</code> in accordance with their implementation of <a href="#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a>. Errors if such an extension has not been written. Also errors if no such constraint can be found in the optimizer model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_model_constraint(c1) # finite constraint
c1 : x(support: 1) - y &lt;= 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL565-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_constraint" href="#InfiniteOpt.optimizer_model_constraint"><code>InfiniteOpt.optimizer_model_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimizer_model_constraint(cref::GeneralConstraintRef,
                           key::Val{ext_key_name}; [kwargs...])</code></pre><p>Return the reformulation constraint(s) stored in the optimizer model that correspond to <code>cref</code>. This needs to be defined for extensions that implement a custom optimizer model type. Principally, this is accomplished by typed the <code>key</code> argument to <code>Val{ext_key_name}</code>. Keyword arguments can be added as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL548-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{GeneralConstraintRef}" href="#InfiniteOpt.supports-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(cref::GeneralConstraintRef; [kwargs...])::Vector</code></pre><p>Return the support associated with <code>cref</code>. Errors if <code>cref</code> is not associated with the constraint mappings stored in <code>optimizer_model</code> or if <a href="#InfiniteOpt.constraint_supports"><code>constraint_supports</code></a> has not been extended. By default, no keyword arguments are accepted, but extensions may employ some.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(cref)
Dict{Int64,Tuple{Float64}} with 2 entries:
  2 =&gt; (1.0,)
  1 =&gt; (0.0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL605-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.constraint_supports" href="#InfiniteOpt.constraint_supports"><code>InfiniteOpt.constraint_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">constraint_supports(optimizer_model::JuMP.Model, cref::GeneralConstraintRef,
                    key::Val{ext_key_name}; [kwargs...])::Vector</code></pre><p>Return the supports associated with the mappings of <code>cref</code> in <code>optimizer_model</code>. This dispatches off of <code>key</code> which permits optimizer model extensions. This should throw an error if <code>cref</code> is not associated with the variable mappings stored in <code>optimizer_model</code>. Keyword arguments can be added as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL586-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{GeneralConstraintRef}" href="#InfiniteOpt.parameter_refs-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(cref::GeneralConstraintRef; [kwargs...])::Tuple</code></pre><p>Return the infinite parameters associated with <code>cref</code>. Errors if <code>cref</code> is not associated with the constraint mappings stored in <code>optimizer_model</code> or if <a href="#InfiniteOpt.constraint_parameter_refs"><code>constraint_parameter_refs</code></a> has not been extended. By default, no keyword arguments are accepted, but extensions may employ some.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(cref)
(t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL648-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.constraint_parameter_refs" href="#InfiniteOpt.constraint_parameter_refs"><code>InfiniteOpt.constraint_parameter_refs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">constraint_parameter_refs(optimizer_model::JuMP.Model,
                          cref::GeneralConstraintRef,
                          key::Val{ext_key_name}; [kwargs...])::Tuple</code></pre><p>Return the infinite parameter references associated with the mappings of <code>cref</code> in <code>optimizer_model</code>. This dispatches off of <code>key</code> which permits optimizer model extensions. This should throw an error if <code>cref</code> is not associated with the variable mappings stored in <code>optimizer_model</code>. Keyword arguments can be added as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL627-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_ready" href="#InfiniteOpt.optimizer_model_ready"><code>InfiniteOpt.optimizer_model_ready</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimizer_model_ready(model::InfiniteModel)::Bool</code></pre><p>Return <code>Bool</code> if the optimizer model is up to date with <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_model_ready(model)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_optimizer_model_ready" href="#InfiniteOpt.set_optimizer_model_ready"><code>InfiniteOpt.set_optimizer_model_ready</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_optimizer_model_ready(model::InfiniteModel, status::Bool)</code></pre><p>Set the status of the optimizer model to whether it is up to date or not. Note is more intended as an internal function, but is useful for extensions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_optimizer_model_ready(model, true)

julia&gt; optimizer_model_ready(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL66-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.bridge_constraints-Tuple{InfiniteModel}" href="#JuMP.bridge_constraints-Tuple{InfiniteModel}"><code>JuMP.bridge_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.bridge_constraints(model::InfiniteModel)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.bridge_constraints-Tuple{Model}"><code>JuMP.bridge_constraints</code></a> to return if an infinite model <code>model</code> has an optimizer model where the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; bridge_constraints(model)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_bridge-Tuple{InfiniteModel,Type{#s478} where #s478&lt;:MathOptInterface.Bridges.AbstractBridge}" href="#JuMP.add_bridge-Tuple{InfiniteModel,Type{#s478} where #s478&lt;:MathOptInterface.Bridges.AbstractBridge}"><code>JuMP.add_bridge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_bridge(model::InfiniteModel,
                BridgeType::Type{&lt;:MOI.Bridges.AbstractBridge})</code></pre><p>Extend <a href="../../JuMP/#JuMP.add_bridge-Tuple{Model,Type{#s478} where #s478&lt;:MathOptInterface.Bridges.AbstractBridge}"><code>JuMP.add_bridge</code></a> to add <code>BridgeType</code> to the list of bridges that can be used by the optimizer model to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/ab7e56a4183abd10e001ca30b2fbd9dc996c26f0/src/optimize.jl#LL38-L46">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../transcribe/">« Model Transcription</a><a class="docs-footer-nextpage" href="../result/">Results »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 April 2020 19:31">Wednesday 8 April 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
