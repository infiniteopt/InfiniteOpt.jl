<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Expressions · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li class="is-active"><a class="tocitem" href>Expressions</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Datatype-Hierarchy-1"><span>Datatype Hierarchy</span></a></li><li><a class="tocitem" href="#Affine-Expressions-1"><span>Affine Expressions</span></a></li><li><a class="tocitem" href="#Quadratic-Expressions-1"><span>Quadratic Expressions</span></a></li><li><a class="tocitem" href="#Nonlinear-Expressions-1"><span>Nonlinear Expressions</span></a></li></ul></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Expressions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Expressions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/expression.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="expr_page-1"><a class="docs-heading-anchor" href="#expr_page-1">Expressions</a><a class="docs-heading-anchor-permalink" href="#expr_page-1" title="Permalink"></a></h1><p>A guide for the defining and understanding the variable expressions used in <code>InfiniteOpt</code>.</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>Expressions in <code>InfiniteOpt</code> (also called functions) refer to mathematical statements involving variables and numbers. Thus, these comprise the mathematical expressions used that are used in measures, objectives, and constraints. Programmatically, <code>InfiniteOpt</code> simply extends <code>JuMP</code> expression types and methods principally pertaining to affine and quadratic mathematical expressions. An natively supported abstraction for general nonlinear expressions is currently under development since that of <code>JuMP</code> is not readily extendable.</p><h2 id="Datatype-Hierarchy-1"><a class="docs-heading-anchor" href="#Datatype-Hierarchy-1">Datatype Hierarchy</a><a class="docs-heading-anchor-permalink" href="#Datatype-Hierarchy-1" title="Permalink"></a></h2><p>Expressions employ variable reference types inherited from <a href="../../JuMP/#JuMP.AbstractVariableRef"><code>JuMP.AbstractVariableRef</code></a> to form expression objects. <code>InfiniteOpt</code> uses a hierarchy of such types to organize the complexities associated with modeling infinite dimensional programs. The figure below summarizes this hierarchy of variable reference types where the abstract types are depicted in green and the concrete types are shown blue.</p><p><img src="../../assets/variable_tree.png" alt="tree"/></p><p>Following <code>JuMP</code>, expression objects are parameterized by the variable reference type that is present in the expression. In <code>InfiniteOpt</code> expressions automatically, select the most specific variable reference type possible in accordance with the above figure. For instance, an expression that only contains hold variables will be classified as a <a href="../variable/#InfiniteOpt.HoldVariableRef"><code>HoldVariableRef</code></a> expression object, whereas an expression containing hold variables and a measure would be classified as a <a href="../variable/#InfiniteOpt.MeasureFiniteVariableRef"><code>MeasureFiniteVariableRef</code></a> expression object. This hierarchical classification becomes convenient to guide infinite program reformulation schemes in how to treat different expressions. The default transcription methodology employed by <code>InfiniteOpt.TranscriptionOpt</code> uses these classifications to efficiently differentiate between finite and infinite expressions.</p><h2 id="Affine-Expressions-1"><a class="docs-heading-anchor" href="#Affine-Expressions-1">Affine Expressions</a><a class="docs-heading-anchor-permalink" href="#Affine-Expressions-1" title="Permalink"></a></h2><p>An affine expression pertains to a mathematical function of the form:</p><div>\[f_a(x) = a_1x_1 + ... + a_nx_n + b\]</div><p>where <span>$x \in \mathbb{R}^n$</span> denote variables, <span>$a \in \mathbb{R}^n$</span> denote coefficients, and <span>$b \in \mathbb{R}$</span> denotes a constant value. Such expressions, are prevalent in any problem than involves linear constraints and/or objectives.</p><p>In <code>InfiniteOpt</code>, affine expressions can be defined directly using <code>Julia</code>&#39;s arithmetic operators (i.e., <code>+</code>, <code>-</code>, <code>*</code>, etc.) or using <a href="../../JuMP/#JuMP.@expression"><code>@expression</code></a>.  For example, let&#39;s define the expression <span>$2y(t) + z - 3t$</span> noting that the following methods are equivalent:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_variable(model, y(t))
y(t)

julia&gt; @hold_variable(model, z)
z

julia&gt; expr = 2y + z - 3t
2 y(t) + z - 3 t

julia&gt; expr = 2 * y + z - 3 * t
2 y(t) + z - 3 t

julia&gt; expr = @expression(model, 2y + z - 3t)
2 y(t) + z - 3 t

julia&gt; typeof(expr)
GenericAffExpr{Float64,GeneralVariableRef}</code></pre><p>Notice that coefficients to variables can simply be put alongside variables without having to use the <code>*</code> operator. Also, note that all of these expressions are stored in a container referred to as a <code>GenericAffExpr</code> which is a <code>JuMP</code> object for storing affine expressions. Furthermore, this object is parameterized by <a href="../variable/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> since it is the lowest common variable reference type in common between hold variables and infinite variables.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Where possible, it is preferable to use <a href="../../JuMP/#JuMP.@expression"><code>@expression</code></a> for defining expressions as it is much more efficient than explicitly using the standard operators.</p></div></div><p><code>GenericAffExpr</code> objects contain 2 fields which are:</p><ul><li><code>constant::CoefType</code> The constant value of the affine expression.</li><li><code>terms::OrderDict{VarType, CoefType}</code> A dictionary mapping variables to coefficients.</li></ul><p>For example, let&#39;s see what these fields look like in the above example:</p><pre><code class="language-julia-repl">julia&gt; expr.terms
OrderedCollections.OrderedDict{GeneralVariableRef,Float64} with 3 entries:
  y(t) =&gt; 2.0
  z    =&gt; 1.0
  t    =&gt; -3.0

julia&gt; expr.constant
0.0</code></pre><p>Notice that the ordered dictionary preserves the order in which the variables appear in the expression.</p><p>More information can be found in the documentation for affine expressions in <a href="http://www.juliaopt.org/JuMP.jl/stable/expressions/#Affine-expressions-1"><code>JuMP</code></a>.</p><h2 id="Quadratic-Expressions-1"><a class="docs-heading-anchor" href="#Quadratic-Expressions-1">Quadratic Expressions</a><a class="docs-heading-anchor-permalink" href="#Quadratic-Expressions-1" title="Permalink"></a></h2><p>A quadratic function pertains to a mathematical function of the form:</p><div>\[f_q(x) = a_1x_1^2 + a_2 x_1 x_2 + ... + a_m x_n^2 + f_a(x)\]</div><p>where <span>$x \in \mathbb{R}^n$</span> are the variables, <span>$f_a(x): \mathbb{R}^n \mapsto \mathbb{R}$</span> is an affine function, and <span>$m = n(n+1)/2$</span> is the number of unique combinations of variables <span>$x$</span>. Like affine expressions, quadratic expressions can be defined via <code>Julia</code>&#39;s arithmetic operators or via <a href="../../JuMP/#JuMP.@expression"><code>@expression</code></a>. For example, let&#39;s define <span>$2y^2(t) - zy(t) + 42t - 3$</span> using the following equivalent methods:</p><pre><code class="language-julia-repl">julia&gt; expr = 2y^2 - z * y + 42t - 3
2 y(t)² - z*y(t) + 42 t - 3

julia&gt; expr = @expression(model, 2y^2 - z * y + 42t - 3)
2 y(t)² - z*y(t) + 42 t - 3

julia&gt; typeof(expr)
GenericQuadExpr{Float64,GeneralVariableRef}</code></pre><p>Again, notice that coefficients need not employ <code>*</code>. Also, the object used to store the expression is a <code>GenericQuadExpr</code> which is a <code>JuMP</code> object used for storing quadratic expressions. Again, this expression container is parameterized by <a href="../variable/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> since that is the common variable reference type between the hold variable <code>z</code> and the infinite variable <code>y(t)</code>.</p><p><code>GenericQuadExpr</code> object contains 2 data fields which are:</p><ul><li><code>aff::GenericAffExpr{CoefType,VarType}</code> An affine expression</li><li><code>terms::OrderedDict{UnorderedPair{VarType}, CoefType}</code> A dictionary mapping quadratic variable pairs to coefficients.</li></ul><p>Here the <code>UnorderedPair</code> type is unique to <code>JuMP</code> and contains the fields:</p><ul><li><code>a::AbstractVariableRef</code> One variable in a quadratic pair</li><li><code>b::AbstractVariableRef</code> The other variable in a quadratic pair.</li></ul><p>Thus, this form can be used to store arbitrary quadratic expressions. For example, let&#39;s look at what these fields look like in the above example:</p><pre><code class="language-julia-repl">julia&gt; expr.aff
42 t - 3

julia&gt; typeof(expr.aff)
GenericAffExpr{Float64,GeneralVariableRef}

julia&gt; expr.terms
OrderedCollections.OrderedDict{UnorderedPair{GeneralVariableRef},Float64} with 2 entries:
  UnorderedPair{GeneralVariableRef}(y(t), y(t)) =&gt; 2.0
  UnorderedPair{GeneralVariableRef}(z, y(t))    =&gt; -1.0</code></pre><p>Notice again that the ordered dictionary preserves the order.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Polynomial expressions can be represented by introducing dumby variables and nested quadratic/affine expressions. For instance, <span>$z^3 + 2$</span> can be expressed by introducing a dumby variable <span>$x = z^2$</span>:</p><pre><code class="language-julia-repl">julia&gt; @hold_variable(model, x)
x

julia&gt; @constraint(model, x == z^2)
-z² + x = 0.0

julia&gt; expr = @expression(model, z * x + 2)
z*x + 2</code></pre></div></div><p>More information can be found in the documentation for quadratic expressions in <a href="http://www.juliaopt.org/JuMP.jl/stable/expressions/#Quadratic-expressions-1"><code>JuMP</code></a>.</p><h2 id="Nonlinear-Expressions-1"><a class="docs-heading-anchor" href="#Nonlinear-Expressions-1">Nonlinear Expressions</a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Expressions-1" title="Permalink"></a></h2><p>General nonlinear expressions as generated via <code>@NLexpression</code> and similar methods in <code>JuMP</code> are not yet extended for <code>InfiniteOpt</code>. This is because <code>JuMP</code> no longer readily supports nonlinear extensions, but a native nonlinear implementation is currently under development and should be released in the near future.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variable/">« Variables</a><a class="docs-footer-nextpage" href="../measure/">Measures »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 April 2020 19:31">Wednesday 8 April 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
