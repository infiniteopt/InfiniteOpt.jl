<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li class="is-active"><a class="tocitem" href>Constraints</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage-1"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Data-Structure-1"><span>Data Structure</span></a></li><li><a class="tocitem" href="#Definition-1"><span>Definition</span></a></li><li><a class="tocitem" href="#Queries-1"><span>Queries</span></a></li><li><a class="tocitem" href="#Modification-1"><span>Modification</span></a></li><li><a class="tocitem" href="#Datatypes-1"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods/Macros-1"><span>Methods/Macros</span></a></li></ul></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constraints</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/constraint.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="constr_page-1"><a class="docs-heading-anchor" href="#constr_page-1">Constraints</a><a class="docs-heading-anchor-permalink" href="#constr_page-1" title="Permalink"></a></h1><p>A guide and manual for defining and manipulating constraints in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>Constraints are an integral part of infinite dimensional problems and serve as a fundamental utility of <code>InfiniteOpt</code>. In particular, <code>InfiniteOpt</code> supports finite constraints that entail finite variables and/or measures that fully any infinite parameter dependencies (e.g., first stage constraints), infinite constraints that are enforced over the entire domain of its infinite parameter dependencies (e.g., path constraints), and bounded infinite constraints which are enforced over some specified sub-domain of its infinite parameter dependencies (e.g., initial conditions). This page will highlight how to implement these types of constraints in <code>InfiniteOpt</code>.</p><h2 id="Basic-Usage-1"><a class="docs-heading-anchor" href="#Basic-Usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-1" title="Permalink"></a></h2><p>Principally, the <a href="../../JuMP/#JuMP.@constraint"><code>@constraint</code></a> and <a href="#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a> macros should be employed to specify constraints. Here <code>@constraint</code> is used to specify typical finite and infinite constraints and <code>@BDconstraint</code> is used to specify bounded constraints (i.e., infinite constraints with a constrained sub-domain of its full infinite sub-domain). First, let&#39;s setup an infinite model with variables that we can add constraints to:</p><pre><code class="language-julia-repl">julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @infinite_parameter(model, x[1:2] in Normal());

julia&gt; @infinite_variable(model, T(t, x));

julia&gt; @infinite_variable(model, g(t));

julia&gt; @hold_variable(model, z[1:2]);

julia&gt; @hold_variable(model, w, parameter_bounds = (t in [0, 5]));</code></pre><h3 id="Unbounded-Constraints-1"><a class="docs-heading-anchor" href="#Unbounded-Constraints-1">Unbounded Constraints</a><a class="docs-heading-anchor-permalink" href="#Unbounded-Constraints-1" title="Permalink"></a></h3><p>Unbounded constraints don&#39;t entail user-defined curtailing of dependent infinite parameter domains and are defined using <a href="../../JuMP/#JuMP.@constraint"><code>@constraint</code></a>. This is done following typical <code>JuMP</code> syntax. Anonymous constraints (constraints without associated register names) are defined via 2 arguments where the first is the infinite model and the second is the constraint expression. For example, let&#39;s define the constraint <span>$2T(t, x) + ||z||^2 \leq 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; cref = @constraint(model, 2T + sum(z[i]^2 for i = 1:2) &lt;= 0)
z[1]² + z[2]² + 2 T(t, x) ≤ 0.0</code></pre><p>Thus, we added an infinite constraint (which infinite with respect to <code>t</code> and <code>x</code>) to <code>model</code> and stored the corresponding constraint reference to <code>cref</code>. The allowed constraint operators are <code>==</code>, <code>&lt;=</code>, <code>≤</code>, <code>&gt;=</code>, and <code>≥</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, <code>InfiniteOpt</code> only supports scalar constraint expressions. Other types such as vector constraints are not currently extended.</p></div></div><p>Similarly, we can define an array of constraints with varied indexes by including an additional argument before the constraint expression. For example, let&#39;s define <span>$3z[i] - 14 == 0, \forall i \in \{1,2\}$</span>:</p><pre><code class="language-julia-repl">julia&gt; crefs = @constraint(model, [i = 1:2], 3z[i] - 14 == 0)
2-element Array{FiniteConstraintRef{ScalarShape},1}:
 3 z[1] = 14.0
 3 z[2] = 14.0</code></pre><p>Thus, we added two constraints to <code>model</code> and stored a vector of the corresponding constraint references to the <code>Julia</code> variable <code>crefs</code>.</p><p>Named constraints are defined by including a name as part of the second argument. For example, let&#39;s add the constraint <span>$\int_0^10 g(t) dt == 4$</span>:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, measure_constr, integral(g, t) == 4)
measure_constr : integral(g(t)) = 4.0</code></pre><p>Thus, we added another constraint named <code>measure_constr</code> and created a <code>Julia</code> variable <code>measure_constr</code> that contains a reference to that constraint.</p><h3 id="Bounded-Constraints-1"><a class="docs-heading-anchor" href="#Bounded-Constraints-1">Bounded Constraints</a><a class="docs-heading-anchor-permalink" href="#Bounded-Constraints-1" title="Permalink"></a></h3><p>Bounded constraints denote constraints with a particular sub-domain of an infinite domain. Such constraints might pertain to point constraints evaluated at a particular infinite parameter values, constraints limited to a certain range of infinite parameter values, and/or entail bounded hold variables whose sub-domains are also taken into consideration. These types of constraints are defined using <a href="#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a>. For example, let&#39;s add the initial condition <span>$g(0) == 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; @BDconstraint(model, initial(t == 0), g == 0)
initial : g(t) = 0.0, ∀ t = 0</code></pre><p>Thus, we have added a constraint to <code>model</code> defined over the sub-domain <span>$t = 0$</span> in accordance with the initial condition. This is referred to as a bounded constraint named <code>initial</code> where a <code>Julia</code> variable <code>initial</code> has been defined to store a reference to that constraint.</p><p>More complex sub-domains can be specified by simply adding more conditions in the second argument. To illustrate this, let&#39;s define an anonymous constraint for <span>$2T^2(t, x) + w \geq 3, \ \forall t = 0, \ x \in [-1, 1]^2$</span>:</p><pre><code class="language-julia-repl">julia&gt; cref = @BDconstraint(model, (t == 0, x in [-1, 1]), 2T^2 + w &gt;= 3)
2 T(t, x)² + w ≥ 3.0, ∀ x[2] ∈ [-1, 1], x[1] ∈ [-1, 1], t = 0</code></pre><p>where <code>cref</code> contains the corresponding constraint reference.</p><p>Now we have added constraints to our model and it is ready to be transcribed!</p><h2 id="Data-Structure-1"><a class="docs-heading-anchor" href="#Data-Structure-1">Data Structure</a><a class="docs-heading-anchor-permalink" href="#Data-Structure-1" title="Permalink"></a></h2><p>Here we detail the data structures used to store constraints in <code>InfiniteOpt</code>. In general, constraints in <code>JuMP</code> are of the form: <code>[function] in [set]</code> where <code>function</code> corresponds to a <code>JuMP</code> expression and <code>set</code> corresponds to a <code>MOI</code> set. Since <code>InfiniteOpt</code> only supports scalar constraints currently, expressions must be inherited from <code>JuMP.AbstractJuMPScalar</code> and the supported <code>MOI</code> sets are <code>MOI.EqualTo</code>, <code>MOI.LessThan</code>, and <code>MOI.GreaterThan</code>.  </p><p>Furthermore, constraints in the form mentioned above are stored in appropriate constraint object inherited from <code>JuMP.AbstractConstraint</code>. Typical scalar constraints use <a href="../../JuMP/#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a> which has the fields:</p><ul><li><code>func::JuMP.AbstractJuMPScalar</code> The constraint expression</li><li><code>set::MOI.AbstractScalarSet</code> The MOI set.</li></ul><p>Similarly, bounded constraints are stored in <a href="#InfiniteOpt.BoundedScalarConstraint"><code>BoundedScalarConstraint</code></a> which has <code>bounds</code> and <code>orig_bounds</code> fields in addition to <code>func</code> and <code>set</code>. These additional fields store the current constraint bounds and the bounds originally given, respectively. This distinction is needed to facilitate deletion methods such as deleting a bounded hold variable.</p><p>These constraint objects are what store constraints in <code>InfiniteModel</code>s. And these are referred to by appropriate explicit type of <a href="#InfiniteOpt.GeneralConstraintRef"><code>GeneralConstraintRef</code></a>. These explicit types are <a href="#InfiniteOpt.InfiniteConstraintRef"><code>InfiniteConstraintRef</code></a>, <a href="#InfiniteOpt.FiniteConstraintRef"><code>FiniteConstraintRef</code></a>, and <a href="#InfiniteOpt.MeasureConstraintRef"><code>MeasureConstraintRef</code></a> which correspond to constraints that contain infinite variables, finite variables, and measure variables, respectively.</p><h2 id="Definition-1"><a class="docs-heading-anchor" href="#Definition-1">Definition</a><a class="docs-heading-anchor-permalink" href="#Definition-1" title="Permalink"></a></h2><p>In this section, we describe the ins and outs of defining constraints. Note that this process is analogous to the manner in which variables are defined and added to the model.</p><h3 id="Manual-Definition-1"><a class="docs-heading-anchor" href="#Manual-Definition-1">Manual Definition</a><a class="docs-heading-anchor-permalink" href="#Manual-Definition-1" title="Permalink"></a></h3><p>The <a href="../../JuMP/#JuMP.@constraint"><code>@constraint</code></a> and <a href="#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a> both follow a similar methodology behind the scenes and these commonalities are discussed in this section for conciseness. Defining/initializing a constraint principally involves the following steps:</p><ul><li>Define the constraint information (i.e., function, set, and parameter bounds)</li><li>Construct a concrete subtype of <code>JuMP.AbstractConstraint</code> to store the constraint information</li><li>Add the <code>AbstractConstraint</code> object to an <code>InfiniteModel</code> and assign a name</li><li>Create a concrete subtype of <a href="#InfiniteOpt.GeneralConstraintRef"><code>GeneralConstraintRef</code></a> that points to the constraint object stored in the model.</li></ul><p>The constraint objects are specified via <a href="#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}"><code>build_constraint</code></a>  which requires the user a <code>JuMP.AbstractJuMPScalar</code>, a <code>MOI.AbstractScalarSet</code>, and any keyword arguments such as <code>ParameterBound</code>. For example, let&#39;s build a scalar constraint for <span>$3T(t, x) - g^2(t) \leq 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; constr = build_constraint(error, 3T - g^2, MOI.LessThan(0.0))
ScalarConstraint{GenericQuadExpr{Float64,InfiniteVariableRef},MathOptInterface.LessThan{Float64}}(-g(t)² + 3 T(t, x), MathOptInterface.LessThan{Float64}(0.0))</code></pre><p>Now the built constraint object can be added to the infinite model via <a href="#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint}"><code>add_constraint</code></a>. Let&#39;s do so with our example and assign it the name of <code>c1</code> (note that adding a name is optional):</p><pre><code class="language-julia-repl">julia&gt; cref = add_constraint(model, constr, &quot;c1&quot;)
c1 : -g(t)² + 3 T(t, x) ≤ 0.0</code></pre><p>Thus, we have made our constraint and added it <code>model</code> and now have a constraint reference <code>cref</code> that we can use to access it.</p><p>The <a href="../../JuMP/#JuMP.@constraint"><code>@constraint</code></a> and <a href="#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a> automate the above steps where <code>@BDconstraint</code> is specifically used to implement the <code>parameter_bounds</code> keyword argument in <code>build_constraint</code>.</p><h3 id="Macro-Definition-1"><a class="docs-heading-anchor" href="#Macro-Definition-1">Macro Definition</a><a class="docs-heading-anchor-permalink" href="#Macro-Definition-1" title="Permalink"></a></h3><p>As mentioned above in the Basic Usage section, the <a href="../../JuMP/#JuMP.@constraint"><code>@constraint</code></a> macro should be used for defining all constraints that do not entail specified parameter bounds. In general, the syntax follows the form <code>@constraint([InfiniteModel], [name][indexing expr], [scalar constr expr])</code>. The second argument is optional and is used to assign a name and/or define indexing variables to be used in the constraint expr. When a name is provided it is registered and cannot be used again for another constraint or variable name. The indexing expression can be used to produce an array of constraints as shown below (notice this is equivalent to looping over individual <code>@constraint</code> calls):</p><pre><code class="language-julia-repl">julia&gt; crefs = @constraint(model, [i = 1:2], 2z[i] - g == 0)
2-element Array{InfiniteConstraintRef{ScalarShape},1}:
 2 z[1] - g(t) = 0.0
 2 z[2] - g(t) = 0.0

julia&gt; crefs = Vector{InfiniteConstraintRef{ScalarShape}}(undef, 2);

julia&gt; for i = 1:2
           crefs[i] = @constraint(model, 2z[i] - g == 0)
       end

julia&gt; crefs
2-element Array{InfiniteConstraintRef{ScalarShape},1}:
 2 z[1] - g(t) = 0.0
 2 z[2] - g(t) = 0.0</code></pre><p>Again, please note that only scalar constraints are currently supported and thus the <code>[scalar constr expr]</code> must be scalar.</p><p>An interesting corollary is that <code>@constraint</code> in certain cases will produce bound constraints even if the user doesn&#39;t specify any parameter bounds. This, occurs when a bounded hold variable is included. For example, if we want to make the constraint <span>$g(t) + 2.5w \leg 2$</span> it would only be valid over the sub-domain <span>$t \in [0, 5] \subsetneq [0, 10]$</span> due to the restrictions on <code>w</code>. Thus, <code>@constraint</code> automatically takes this into account and produces a bounded constraint:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, bounded_example, g + 2.5w &lt;= 2)
bounded_example : g(t) + 2.5 w ≤ 2.0, ∀ t ∈ [0, 5]</code></pre><p>If this behavior is not desired, the parameter bounds associated with the variable should be deleted and then should be managed individually for each constraint.</p><p>The <a href="#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a> is very similar except that it adds the capability of symbolically specifying parameter bounds. Thus the syntax is of the form <code>@BDconstraint([InfiniteModel], [name][indexing expr](param bounds), [scalar constr expr])</code>. Note that here the <code>name</code> and <code>[indexing expr]</code> are optional, but the <code>(param bounds)</code> tuple is required. Thus, three arguments must always be given. The <code>(bound expr)</code> can be of the form:</p><ul><li><code>(param in [lb, ub], ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code> (note <code>∈</code> can be used in place of <code>in</code>)</li><li><code>(params in [lb, ub], ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(lb &lt;= param &lt;= ub, ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code></li><li><code>(lb &lt;= params &lt;= ub, ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(param == value, ...)</code> enforcing <code>param</code> to be equal to <code>value</code></li><li><code>(params == value, ...)</code> enforcing that all parameter references in <code>params</code>                           each to be equal to <code>value</code></li><li>Any combination of the above forms. Must be inside parentheses and comma separated.</li></ul><p>Please refer to the Basic Usage section and the manual for examples.</p><p>Finally, the <a href="../../JuMP/#JuMP.@constraint"><code>@constraint</code></a> and <a href="#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a> macros allow the user to specify the <code>container</code> keyword argument when defining an array of constraints. For example, we can force a group of bounded constraint references to be stored in a <code>JuMP.SparseAxisArray</code>:</p><pre><code class="language-julia-repl">julia&gt; @BDconstraint(model, [i = 1:2](x[i] == 0), T^2 + z[i] &lt;= 1,
                     container = SparseAxisArray)
JuMP.Containers.SparseAxisArray{InfiniteConstraintRef{ScalarShape},1,Tuple{Int64}} with 2 entries:
  [2]  =  T(t, x)² + z[2] ≤ 1.0, ∀ x[2] = 0
  [1]  =  T(t, x)² + z[1] ≤ 1.0, ∀ x[1] = 0</code></pre><p>For more information on <code>JuMP</code> containers please visit their page <a href="http://www.juliaopt.org/JuMP.jl/stable/containers/">here</a>.</p><h2 id="Queries-1"><a class="docs-heading-anchor" href="#Queries-1">Queries</a><a class="docs-heading-anchor-permalink" href="#Queries-1" title="Permalink"></a></h2><p>In this section, we describe a variety of methods to extract constraint information.</p><h3 id="Basic-1"><a class="docs-heading-anchor" href="#Basic-1">Basic</a><a class="docs-heading-anchor-permalink" href="#Basic-1" title="Permalink"></a></h3><p>A number of constraint properties can be extracted via constraint references. Principally, the validity, name, model, index, and constraint object can be queried via <a href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>is_valid</code></a>, <a href="#JuMP.name-Tuple{GeneralConstraintRef}"><code>name</code></a>, <a href="#JuMP.owner_model-Tuple{GeneralConstraintRef}"><code>owner_model</code></a>, <a href="#JuMP.index-Tuple{GeneralConstraintRef}"><code>index</code></a>, and <a href="#JuMP.constraint_object-Tuple{GeneralConstraintRef}"><code>constraint_object</code></a>, respectively. These methods all constitute extensions of <code>JuMP</code> methods and follow exactly the same behavior. Let&#39;s try them out with the following example:</p><pre><code class="language-julia-repl">julia&gt; is_valid(model, measure_constr) # check if contained in model
true

julia&gt; name(measure_constr) # get the name
&quot;measure_constr&quot;

julia&gt; m = owner_model(measure_constr); # get the model it is added to

julia&gt; index(measure_constr) # get the constraint&#39;s index
4

julia&gt; constraint_object(measure_constr) # get the raw constraint datatype
ScalarConstraint{GenericAffExpr{Float64,MeasureRef},MathOptInterface.EqualTo{Float64}}(integral(g(t)), MathOptInterface.EqualTo{Float64}(4.0))</code></pre><p>Also, <a href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>constraint_by_name</code></a> can be used to retrieve a constraint reference if only the name is known and its name is unique. For example, let&#39;s extract the reference for <code>&quot;c1&quot;</code>:</p><pre><code class="language-julia-repl">julia&gt; cref = constraint_by_name(model, &quot;c1&quot;)
c1 : -g(t)² + 3 T(t, x) ≤ 0.0</code></pre><h3 id="Parameter-Bounds-1"><a class="docs-heading-anchor" href="#Parameter-Bounds-1">Parameter Bounds</a><a class="docs-heading-anchor-permalink" href="#Parameter-Bounds-1" title="Permalink"></a></h3><p>As explained above, bounded constraints serve as an integral capability of <code>InfiniteOpt</code>. Information about parameter bounds can be obtained via <a href="#InfiniteOpt.has_parameter_bounds-Tuple{GeneralConstraintRef}"><code>has_parameter_bounds</code></a> and <a href="#InfiniteOpt.parameter_bounds-Tuple{GeneralConstraintRef}"><code>parameter_bounds</code></a> which indicate if a constraint is bounded and what its <a href="../variable/#InfiniteOpt.ParameterBounds"><code>ParameterBounds</code></a> are, respectively. These are exemplified below:</p><pre><code class="language-julia-repl">julia&gt; has_parameter_bounds(measure_constr) # check if constraint is bounded
false

julia&gt; has_parameter_bounds(initial)
true

julia&gt; parameter_bounds(initial)
Subdomain bounds (1): t = 0</code></pre><p>Note that <code>parameter_bounds</code> will error if the constraint is not bounded.</p><h3 id="General-1"><a class="docs-heading-anchor" href="#General-1">General</a><a class="docs-heading-anchor-permalink" href="#General-1" title="Permalink"></a></h3><p>Constraints can be defined in a number of ways symbolically that differ from how it is actually stored in the model. This principally occurs since like terms and constants are combined together where possible with the variable terms on the left hand side and the constant on the right hand side. For instance, the constraint <span>$2g(t) + 3g(t) - 2 \leq 1 + z_1$</span> would be normalized <span>$5g(t) - z_1 \leq 3$</span>. In accordance with this behavior <a href="#JuMP.normalized_rhs-Tuple{GeneralConstraintRef}"><code>normalized_rhs</code></a> and <a href="#JuMP.normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef}"><code>normalized_coefficient</code></a> can be used to query the normalized right hand side and the coefficient of a particular variable reference, respectively. Let&#39;s employ the above example to illustrate this:</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, constr, 2g + 3g - 2 &lt;= 1 + z[1])
constr : 5 g(t) - z[1] ≤ 3.0

julia&gt; normalized_rhs(constr)
3.0

julia&gt; normalized_coefficient(constr, g)
5.0</code></pre><p>There also exist a number of methods for querying an infinite model about what constraints it contains. <a href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>list_of_constraint_types</code></a> can be used query what types of constraints have been added to a model. This is provided as a list of tuples where the first element is the expression type and the second element is the set type (recall that constraints are stored in the form <code>func-in-set</code>). Thus, for our current model we obtain:</p><pre><code class="language-julia-repl">julia&gt; list_of_constraint_types(model)
8-element Array{Tuple,1}:
 (GenericQuadExpr{Float64,GeneralVariableRef}, MathOptInterface.LessThan{Float64})
 (GenericAffExpr{Float64,HoldVariableRef}, MathOptInterface.EqualTo{Float64})
 (GenericAffExpr{Float64,MeasureRef}, MathOptInterface.EqualTo{Float64})
 (GenericAffExpr{Float64,InfiniteVariableRef}, MathOptInterface.EqualTo{Float64})
 (GenericQuadExpr{Float64,GeneralVariableRef}, MathOptInterface.GreaterThan{Float64})
 (GenericQuadExpr{Float64,InfiniteVariableRef}, MathOptInterface.LessThan{Float64})
 (GenericAffExpr{Float64,GeneralVariableRef}, MathOptInterface.EqualTo{Float64})
 (GenericAffExpr{Float64,GeneralVariableRef}, MathOptInterface.LessThan{Float64})</code></pre><p>This information is useful when in combination with the <a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar,Type{#s471} where #s471&lt;:MathOptInterface.AbstractSet}"><code>num_constraints</code></a> and <a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar,Type{#s471} where #s471&lt;:MathOptInterface.AbstractSet}"><code>all_constraints</code></a> methods which can take the expression type and/or the set type as inputs. Here <code>num_constraints</code> provides the number of constraints that match a certain type and <code>all_constraints</code> returns a list of constraint references matching the criteria provided. These  have been extended beyond <code>JuMP</code> functionality such additional methods have been provided for the cases in which one wants to query solely off of set or off expression type. Let&#39;s illustrate this with <code>num_constraints</code>:</p><pre><code class="language-julia-repl">julia&gt; num_constraints(model) # total number of constraints
15

julia&gt; num_constraints(model, GenericQuadExpr{Float64,GeneralVariableRef})
4

julia&gt; num_constraints(model, MathOptInterface.LessThan{Float64})
6

julia&gt; num_constraints(model, GenericQuadExpr{Float64,GeneralVariableRef},
                       MathOptInterface.LessThan{Float64})
3                   </code></pre><h2 id="Modification-1"><a class="docs-heading-anchor" href="#Modification-1">Modification</a><a class="docs-heading-anchor-permalink" href="#Modification-1" title="Permalink"></a></h2><p>In this section, we highlight a number of methods that can be used to modify existing constraints.</p><h3 id="Deletion-1"><a class="docs-heading-anchor" href="#Deletion-1">Deletion</a><a class="docs-heading-anchor-permalink" href="#Deletion-1" title="Permalink"></a></h3><p>All constraints in <code>InfiniteOpt</code> can be removed in like manner to typical <code>JuMP</code> constraints with the appropriate extension of <a href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>delete</code></a>. This will remove the corresponding constraint object from the model. However, please note any registered names will remain registered in the infinite model. This means that a constraint with a registered name cannot be repeatedly added and removed using the same name. To exemplify this, let&#39;s delete the constraint <code>c1</code>:</p><pre><code class="language-julia-repl">julia&gt; cref = constraint_by_name(model, &quot;c1&quot;)
c1 : -g(t)² + 3 T(t, x) ≤ 0.0

julia&gt; delete(model, cref)</code></pre><h3 id="General-2"><a class="docs-heading-anchor" href="#General-2">General</a><a class="docs-heading-anchor-permalink" href="#General-2" title="Permalink"></a></h3><p>There also are a number of ways to modify information and characteristics of constraints. First, <a href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>set_name</code></a> can be used to specify a new name for a particular constraint. For instance, let&#39;s update the name of <code>initial</code> to <code>&quot;init_cond&quot;</code>:</p><pre><code class="language-julia-repl">julia&gt; set_name(initial, &quot;init_cond&quot;)

julia&gt; initial
init_cond : g(t) = 0.0, ∀ t = 0</code></pre><p>We can also update the normalized right hand side constant value or normalized left hand side variable coefficient value using <a href="#JuMP.set_normalized_rhs-Tuple{GeneralConstraintRef,Real}"><code>set_normalized_rhs</code></a> and <a href="#JuMP.set_normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef,Real}"><code>set_normalized_coefficient</code></a> , respectively. Let&#39;s again consider the constraint <span>$5g(t) - z_1 \leq 3$</span> as an example. Let&#39;s change the constant term to -1 and the <code>g(t)</code> coefficient to 2.5:</p><pre><code class="language-julia-repl">julia&gt; set_normalized_rhs(constr, -1)

julia&gt; set_normalized_coefficient(constr, g, 2.5)

julia&gt; constr
constr : 2.5 g(t) - z[1] ≤ -1.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In many cases, it may be more convenient to dynamically modify coefficients and other values via the use of finite parameters. This provides an avenue to update parameters without having to be concerned about the normalized form. For more information, see the <a href="../finite_parameter/#finite_param_docs-1">Finite Parameters</a> page.</p></div></div><h3 id="Parameter-Bounds-2"><a class="docs-heading-anchor" href="#Parameter-Bounds-2">Parameter Bounds</a><a class="docs-heading-anchor-permalink" href="#Parameter-Bounds-2" title="Permalink"></a></h3><p>Parameter bounds can be added to, modified, or removed from any constraint in <code>InfiniteOpt</code>. Principally, this is accomplished via <a href="../variable/#InfiniteOpt.@add_parameter_bounds"><code>@add_parameter_bounds</code></a>, <a href="../variable/#InfiniteOpt.@set_parameter_bounds"><code>@set_parameter_bounds</code></a>, <a href="#InfiniteOpt.delete_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef}"><code>delete_parameter_bound</code></a>, and <a href="#InfiniteOpt.delete_parameter_bounds-Tuple{GeneralConstraintRef}"><code>delete_parameter_bounds</code></a> in like manner to hold variables.</p><p>First, parameter bounds can be added to a constraint in an intuitive symbolic syntax via <a href="../variable/#InfiniteOpt.@add_parameter_bounds"><code>@add_parameter_bounds</code></a> which follows form <code>@add_parameter_bounds(ref, bound_expr)</code> where <code>(bound_expr)</code> can be of the form:</p><ul><li><code>(param in [lb, ub], ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code> (note <code>∈</code> can be used in place of <code>in</code>)</li><li><code>(params in [lb, ub], ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(lb &lt;= param &lt;= ub, ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code></li><li><code>(lb &lt;= params &lt;= ub, ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(param == value, ...)</code> enforcing <code>param</code> to be equal to <code>value</code></li><li><code>(params == value, ...)</code> enforcing that all parameter references in <code>params</code>                           each to be equal to <code>value</code></li><li>Any combination of the above forms. Must be inside parentheses and comma separated.</li></ul><p>For example, let&#39;s add the bound <span>$t \in [0, 1]$</span> to <code>constr</code>:</p><pre><code class="language-julia-repl">julia&gt; @add_parameter_bounds(constr, (t in [0, 1]))

julia&gt; constr
constr : 2.5 g(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 1]</code></pre><p>In similar manner, <a href="../variable/#InfiniteOpt.@set_parameter_bounds"><code>@set_parameter_bounds</code></a> can be employed to specify what bounds a constraint has (overwriting any existing ones if forced). It follows the same syntax, so let&#39;s use it to change the bounds on <code>t</code> to <span>$t = 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; @set_parameter_bounds(constr, (t == 0), force = true)

julia&gt; constr
constr : 2.5 g(t) - z[1] ≤ -1.0, ∀ t = 0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Constraint parameters bounds are overlapped with those of any hold variables that are part of the constraint. If no such, overlap exists then an error is thrown.</p></div></div><p>Finally, constraint bounds can be deleted via <a href="#InfiniteOpt.delete_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef}"><code>delete_parameter_bound</code></a> and <a href="#InfiniteOpt.delete_parameter_bounds-Tuple{GeneralConstraintRef}"><code>delete_parameter_bounds</code></a> where the first deletes the bound with associated with a particular parameter and later deletes all parameter bounds. Again, note the parameter bounds associated with hold variables will be unaffected and can only be removed by deleting them from the variables directly. Now let&#39;s delete the parameter bounds associated with our example:</p><pre><code class="language-julia-repl">julia&gt; delete_parameter_bounds(constr)

julia&gt; constr
constr : 2.5 g(t) - z[1] ≤ -1.0</code></pre><p>Note that in this case we could equivalently call</p><pre><code class="language-julia-repl">julia&gt; delete_parameter_bound(constr, t)

julia&gt; constr
constr : 2.5 g(t) - z[1] ≤ -1.0</code></pre><p>since <code>constr</code> only contained 1 parameter bound.</p><h2 id="Datatypes-1"><a class="docs-heading-anchor" href="#Datatypes-1">Datatypes</a><a class="docs-heading-anchor-permalink" href="#Datatypes-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.BoundedScalarConstraint"><code>InfiniteOpt.BoundedScalarConstraint</code></a></li><li><a href="#InfiniteOpt.FiniteConstraintRef"><code>InfiniteOpt.FiniteConstraintRef</code></a></li><li><a href="#InfiniteOpt.GeneralConstraintRef"><code>InfiniteOpt.GeneralConstraintRef</code></a></li><li><a href="#InfiniteOpt.InfiniteConstraintRef"><code>InfiniteOpt.InfiniteConstraintRef</code></a></li><li><a href="#InfiniteOpt.MeasureConstraintRef"><code>InfiniteOpt.MeasureConstraintRef</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.BoundedScalarConstraint" href="#InfiniteOpt.BoundedScalarConstraint"><code>InfiniteOpt.BoundedScalarConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoundedScalarConstraint{F &lt;: JuMP.AbstractJuMPScalar,
                        S &lt;: MOI.AbstractScalarSet} &lt;: JuMP.AbstractConstraint</code></pre><p>A DataType that stores infinite constraints defined on a subset of the infinite parameters on which they depend.</p><p><strong>Fields</strong></p><ul><li><code>func::F</code> The JuMP object.</li><li><code>set::S</code> The MOI set.</li><li><code>bounds::ParameterBounds</code> Set of valid parameter sub-domains that further bound                           constraint.</li><li><code>orig_bounds::ParameterBounds</code> Set of the constraint&#39;s original parameter                                sub-domains (not considering hold variables)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/datatypes.jl#LL701-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.GeneralConstraintRef" href="#InfiniteOpt.GeneralConstraintRef"><code>InfiniteOpt.GeneralConstraintRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeneralConstraintRef</code></pre><p>An abstract type for constraint references unique to InfiniteOpt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/datatypes.jl#LL724-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteConstraintRef" href="#InfiniteOpt.InfiniteConstraintRef"><code>InfiniteOpt.InfiniteConstraintRef</code></a> — <span class="docstring-category">Type</span></header><section><div><p>InfiniteConstraintRef{S &lt;: JuMP.AbstractShape} &lt;: GeneralConstraintRef</p><p>A DataType for constraints that contain infinite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of constraint in model.</li><li><code>shape::JuMP.AbstractShape</code> Shape of constraint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/datatypes.jl#LL731-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FiniteConstraintRef" href="#InfiniteOpt.FiniteConstraintRef"><code>InfiniteOpt.FiniteConstraintRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteConstraintRef{S &lt;: JuMP.AbstractShape} &lt;: GeneralConstraintRef</code></pre><p>A DataType for constraints that contain finite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of constraint in model.</li><li><code>shape::JuMP.AbstractShape</code> Shape of constraint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/datatypes.jl#LL747-L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureConstraintRef" href="#InfiniteOpt.MeasureConstraintRef"><code>InfiniteOpt.MeasureConstraintRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureConstraintRef{S &lt;: JuMP.AbstractShape} &lt;: GeneralConstraintRef</code></pre><p>A DataType for constraints that contain finite variables and measures.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of constraint in model.</li><li><code>shape::JuMP.AbstractShape</code> Shape of constraint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/datatypes.jl#LL763-L772">source</a></section></article><h2 id="Methods/Macros-1"><a class="docs-heading-anchor" href="#Methods/Macros-1">Methods/Macros</a><a class="docs-heading-anchor-permalink" href="#Methods/Macros-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.@BDconstraint"><code>InfiniteOpt.@BDconstraint</code></a></li><li><a href="#InfiniteOpt.add_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef,Number,Number}"><code>InfiniteOpt.add_parameter_bound</code></a></li><li><a href="#InfiniteOpt.delete_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef}"><code>InfiniteOpt.delete_parameter_bound</code></a></li><li><a href="#InfiniteOpt.delete_parameter_bounds-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.delete_parameter_bounds</code></a></li><li><a href="#InfiniteOpt.has_parameter_bounds-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.has_parameter_bounds</code></a></li><li><a href="#InfiniteOpt.parameter_bounds-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.parameter_bounds</code></a></li><li><a href="#InfiniteOpt.set_parameter_bounds-Tuple{GeneralConstraintRef,ParameterBounds}"><code>InfiniteOpt.set_parameter_bounds</code></a></li><li><a href="#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint}"><code>JuMP.add_constraint</code></a></li><li><a href="#JuMP.add_to_function_constant-Tuple{GeneralConstraintRef,Real}"><code>JuMP.add_to_function_constant</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar,Type{#s471} where #s471&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}"><code>JuMP.build_constraint</code></a></li><li><a href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>JuMP.constraint_by_name</code></a></li><li><a href="#JuMP.constraint_object-Tuple{GeneralConstraintRef}"><code>JuMP.constraint_object</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.index-Tuple{GeneralConstraintRef}"><code>JuMP.index</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>JuMP.list_of_constraint_types</code></a></li><li><a href="#JuMP.name-Tuple{GeneralConstraintRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef}"><code>JuMP.normalized_coefficient</code></a></li><li><a href="#JuMP.normalized_rhs-Tuple{GeneralConstraintRef}"><code>JuMP.normalized_rhs</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar,Type{#s471} where #s471&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.owner_model-Tuple{GeneralConstraintRef}"><code>JuMP.owner_model</code></a></li><li><a href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef,Real}"><code>JuMP.set_normalized_coefficient</code></a></li><li><a href="#JuMP.set_normalized_rhs-Tuple{GeneralConstraintRef,Real}"><code>JuMP.set_normalized_rhs</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@BDconstraint" href="#InfiniteOpt.@BDconstraint"><code>InfiniteOpt.@BDconstraint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@BDconstraint(model::InfiniteModel, [i = ..., ...](bound_expr), constr_expr;
              [kw_args...])</code></pre><p>Add an anonymous bounded constraint to <code>model</code> and return an appropriate container of constraint reference(s).</p><pre><code class="language-julia">    @BDconstraint(model::InfiniteModel, name[i = ..., ...](bound_expr),
                  constr_expr; [kw_args...])</code></pre><p>Add a named bounded constraint to <code>model</code> and return an appropriate container of constraint reference(s). This defines the constraint as expressed in <code>constr_expr</code> over some sub-domain of parameters as indicated by <code>bound_expr</code>. The format of <code>constr_expr</code> must follow the same syntax as that specified in <a href="../../JuMP/#JuMP.@constraint"><code>JuMP.@constraint</code></a>. For example, if we want to express the constraint <code>2T(t, x) + 3y = 42</code>, the constraint expression <code>constr_expr</code> would be <code>2 * T + 3 * y == 42</code>.</p><p>By default, <code>JuMP.@constraint</code> would express the above example constraint over the whole domain of <code>t</code> and <code>x</code>. However, we can use <code>@BDconstraint</code> to express this constraint over some sub-domain(s) via <code>bound_expr</code>. Here <code>(bound_expr)</code> can be of the form:</p><ul><li><code>(param in [lb, ub], ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code> (note <code>∈</code> can be used in place of <code>in</code>)</li><li><code>(params in [lb, ub], ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(lb &lt;= param &lt;= ub, ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code></li><li><code>(lb &lt;= params &lt;= ub, ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(param == value, ...)</code> enforcing <code>param</code> to be equal to <code>value</code></li><li><code>(params == value, ...)</code> enforcing that all parameter references in <code>params</code>                           each to be equal to <code>value</code></li><li>Any combination of the above forms. Must be inside parentheses and comma separated.</li></ul><p>Like typical constraints, the <code>container</code> keyword argument can be used to specify the <code>JuMP</code> container type used to store the constraint references. Note this macro errors if <code>bound_expr</code> is ommited or if some unrecognized syntax is used.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @BDconstraint(model, c1(t in [0, 1]), T^2 + z &lt;= 1)
c1 : T(x, t)² + z ≤ 1.0, ∀ t ∈ [0, 1]

julia&gt; @BDconstraint(model, c2[i = 1:3](x[i] in [0, 1]), T^2 + z + x[i] &lt;= 1)
3-element Array{GeneralConstraintRef,1}:
 c2[1] : T(x, t)² + z + x[1] ≤ 1.0, ∀ x[1] ∈ [0, 1]
 c2[2] : T(x, t)² + z + x[2] ≤ 1.0, ∀ x[2] ∈ [0, 1]
 c2[3] : T(x, t)² + z + x[3] ≤ 1.0, ∀ x[3] ∈ [0, 1]

julia&gt; @BDconstraint(model, (x == 0, t == 0), T^2 + z &lt;= 1)
T(x, t)² + z ≤ 1.0, ∀ x[2] = 0, x[3] = 0, t = 0, x[1] = 0

julia&gt; @BDconstraint(model, [i = 1:3](x[i] == 0), T^2 + z &lt;= 1,
                     container = SparseAxisArray)
JuMP.Containers.SparseAxisArray{GeneralConstraintRef,1,Tuple{Any}} with 3 entries:
  [3]  =  T(x, t)² + z ≤ 1.0, ∀ x[3] = 0
  [2]  =  T(x, t)² + z ≤ 1.0, ∀ x[2] = 0
  [1]  =  T(x, t)² + z ≤ 1.0, ∀ x[1] = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/macros.jl#LL1036-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}" href="#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}"><code>JuMP.build_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_constraint(_error::Function, expr::InfiniteExpr,
                      set::MOI.AbstractScalarSet;
                      [parameter_bounds::ParameterBounds = ParameterBounds()])</code></pre><p>Extend <code>JuMP.build_constraint</code> to accept the <code>parameter_bounds</code> argument and return a <a href="#InfiniteOpt.BoundedScalarConstraint"><code>BoundedScalarConstraint</code></a> if the <code>parameter_bounds</code> keyword argument is specifed or return a <a href="../../JuMP/#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a> otherwise. This is primarily intended to work as an internal function for constraint macros.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @infinite_variable(model, g(t));

julia&gt; @hold_variable(model, x);

julia&gt; constr = build_constraint(error, g + x, MOI.EqualTo(42.0),
              parameter_bounds = ParameterBounds(Dict(t =&gt; IntervalSet(0, 1))));

julia&gt; isa(constr, BoundedScalarConstraint)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL61-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint}" href="#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint}"><code>JuMP.add_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_constraint(model::InfiniteModel, c::JuMP.AbstractConstraint,
                    [name::String = &quot;&quot;])</code></pre><p>Extend <a href="../../JuMP/#JuMP.add_constraint-Tuple{Model,AbstractConstraint,String}"><code>JuMP.add_constraint</code></a> to add a constraint <code>c</code> to an infinite model <code>model</code> with name <code>name</code>. Returns an appropriate constraint reference whose type depends on what variables are used to define the constraint. Errors if a vector constraint is used, the constraint only constains parameters, or if any variables do not belong to <code>model</code>. This is primarily used as an internal method for the cosntraint macros.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @infinite_variable(model, g(t));

julia&gt; @hold_variable(model, x);

julia&gt; constr = build_constraint(error, g + x, MOI.EqualTo(42));

julia&gt; cref = add_constraint(model, constr, &quot;name&quot;)
name : g(t) + x = 42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL189-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.owner_model-Tuple{GeneralConstraintRef}" href="#JuMP.owner_model-Tuple{GeneralConstraintRef}"><code>JuMP.owner_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.owner_model(cref::GeneralConstraintRef)::InfiniteModel</code></pre><p>Extend <a href="../../JuMP/#JuMP.owner_model-Tuple{ConstraintRef}"><code>JuMP.owner_model</code></a> to return the infinite model associated with <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; model = owner_model(cref)
An InfiniteOpt Model
Minimization problem with:
Variables: 3
Objective function type: HoldVariableRef
`GenericAffExpr{Float64,FiniteVariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
Names registered in the model: g, t, h, x
Optimizer model backend information:
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.index-Tuple{GeneralConstraintRef}" href="#JuMP.index-Tuple{GeneralConstraintRef}"><code>JuMP.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.index(cref::GeneralConstraintRef)::Int</code></pre><p>Extend <a href="../../JuMP/#JuMP.index-Tuple{ConstraintRef}"><code>JuMP.index</code></a> to return the index of an <code>InfiniteOpt</code> constraint <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; index(cref)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL24-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.constraint_object-Tuple{GeneralConstraintRef}" href="#JuMP.constraint_object-Tuple{GeneralConstraintRef}"><code>JuMP.constraint_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.constraint_object(cref::GeneralConstraintRef)::JuMP.AbstractConstraint</code></pre><p>Extend <a href="../../JuMP/#JuMP.constraint_object"><code>JuMP.constraint_object</code></a> to return the constraint object associated with <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @hold_variable(model, x &lt;= 1);

julia&gt; cref = UpperBoundRef(x);

julia&gt; obj = constraint_object(cref)
ScalarConstraint{HoldVariableRef,MathOptInterface.LessThan{Float64}}(x,
MathOptInterface.LessThan{Float64}(1.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL328-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{GeneralConstraintRef}" href="#JuMP.name-Tuple{GeneralConstraintRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(cref::GeneralConstraintRef)::String</code></pre><p>Extend [<code>JuMP.name</code>](@ref JuMP.name(::JuMP.ConstraintRef{JuMP.Model,&lt;:JuMP._MOICON}) to return the name of an <code>InfiniteOpt</code> constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(cref)
&quot;constr_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL351-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{GeneralConstraintRef,String}" href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(cref::GeneralConstraintRef, name::String)</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_name-Tuple{ConstraintRef{Model,#s472,Shape} where Shape&lt;:AbstractShape where #s472&lt;:MathOptInterface.ConstraintIndex,String}"><code>JuMP.set_name</code></a> to specify the name of a constraint <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(cref, &quot;new_name&quot;)

julia&gt; name(cref)
&quot;new_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL367-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, cref::GeneralConstraintRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}"><code>JuMP.is_valid</code></a> to return <code>Bool</code> whether an <code>InfiniteOpt</code> constraint reference is valid.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_valid(model, cref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL312-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}" href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, cref::GeneralConstraintRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}"><code>JuMP.delete</code></a> to delete an <code>InfiniteOpt</code> constraint and all associated information. Errors if <code>cref</code> is invalid.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z ≥ 0.0
 g(t) + z ≥ 42.0
 t ∈ [0, 6]

julia&gt; delete(model, cref)

julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z ≥ 0.0
 t ∈ [0, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL246-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_parameter_bounds-Tuple{GeneralConstraintRef}" href="#InfiniteOpt.has_parameter_bounds-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.has_parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_parameter_bounds(cref::GeneralConstraintRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>cref</code> is limited to a sub-domain as defined by a <a href="../variable/#InfiniteOpt.ParameterBounds"><code>ParameterBounds</code></a> object.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_parameter_bounds(cref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL387-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_bounds-Tuple{GeneralConstraintRef}" href="#InfiniteOpt.parameter_bounds-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_bounds(cref::GeneralConstraintRef)::ParameterBounds</code></pre><p>Return the <a href="../variable/#InfiniteOpt.ParameterBounds"><code>ParameterBounds</code></a> object associated with the constraint <code>cref</code>. Errors if <code>cref</code> does not have parameter bounds.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_bounds(cref)
Subdomain bounds (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL407-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_parameter_bounds-Tuple{GeneralConstraintRef,ParameterBounds}" href="#InfiniteOpt.set_parameter_bounds-Tuple{GeneralConstraintRef,ParameterBounds}"><code>InfiniteOpt.set_parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_parameter_bounds(cref::GeneralConstraintRef, bounds:ParameterBounds;
                     [force = false])</code></pre><p>Specify a new <a href="../variable/#InfiniteOpt.ParameterBounds"><code>ParameterBounds</code></a> object <code>bounds</code> for the constraint <code>cref</code>. This is meant to be primarily used by <a href="../variable/#InfiniteOpt.@set_parameter_bounds"><code>@set_parameter_bounds</code></a> which provides a more intuitive syntax.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_parameter_bounds(cref, ParameterBounds(Dict(t =&gt; IntervalSet(0, 2))))

julia&gt; parameter_bounds(cref)
Subdomain bounds (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL439-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef,Number,Number}" href="#InfiniteOpt.add_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef,Number,Number}"><code>InfiniteOpt.add_parameter_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_parameter_bound(cref::GeneralConstraintRef, pref::ParameterRef,
                    lower::Number, upper::Number)</code></pre><p>Add an additional parameter bound to <code>cref</code> such that it is defined over the sub-domain based on <code>pref</code> from <code>lower</code> to <code>upper</code>. This is primarily meant to be used by <a href="../variable/#InfiniteOpt.@add_parameter_bounds"><code>@add_parameter_bounds</code></a>.</p><pre><code class="language-julia-repl">julia&gt; add_parameter_bound(cref, t, 0, 2)

julia&gt; parameter_bounds(cref)
Subdomain bounds (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL479-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef}" href="#InfiniteOpt.delete_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef}"><code>InfiniteOpt.delete_parameter_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_parameter_bound(cref::GeneralConstraintRef, pref::ParameterRef)</code></pre><p>Delete the parameter bound of the constraint <code>cref</code> associated with the infinite parameter <code>pref</code> if <code>cref</code> has such a bound. Note that any other parameter bounds will be unaffected. Note any bounds that are needed for hold variables inside in <code>cref</code> will be unaffected.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @BDconstraint(model, c1(x == 0), y &lt;= 42)
c1 : y(x) ≤ 42, ∀ x[1] = 0, x[2] = 0

julia&gt; delete_parameter_bounds(c1, x[2])

julia&gt; c1
c1 : y(x) ≤ 42, ∀ x[1] = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL514-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_parameter_bounds-Tuple{GeneralConstraintRef}" href="#InfiniteOpt.delete_parameter_bounds-Tuple{GeneralConstraintRef}"><code>InfiniteOpt.delete_parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_parameter_bounds(cref::GeneralConstraintRef)</code></pre><p>Delete all the parameter bounds of the constraint <code>cref</code>. Note any bounds that are needed for hold variables inside in <code>cref</code> will be unaffected.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @BDconstraint(model, c1(x == 0), y &lt;= 42)
c1 : y(x) ≤ 42, ∀ x[1] = 0, x[2] = 0

julia&gt; delete_parameter_bounds(c1)

julia&gt; c1
c1 : y(x) ≤ 42</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL550-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_normalized_rhs-Tuple{GeneralConstraintRef,Real}" href="#JuMP.set_normalized_rhs-Tuple{GeneralConstraintRef,Real}"><code>JuMP.set_normalized_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_normalized_rhs(cref::GeneralConstraintRef, value::Real)</code></pre><p>Set the right-hand side term of <code>constraint</code> to <code>value</code>. Note that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint <code>2x + 1 &lt;= 2</code>, <code>set_normalized_rhs(con, 4)</code> will create the constraint <code>2x &lt;= 4</code>, not <code>2x + 1 &lt;= 4</code>.</p><pre><code class="language-julia-repl">julia&gt; @constraint(model, con, 2x + 1 &lt;= 2)
con : 2 x ≤ 1.0

julia&gt; set_normalized_rhs(con, 4)

julia&gt; con
con : 2 x ≤ 4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL589-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.normalized_rhs-Tuple{GeneralConstraintRef}" href="#JuMP.normalized_rhs-Tuple{GeneralConstraintRef}"><code>JuMP.normalized_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.normalized_rhs(cref::GeneralConstraintRef)::Number</code></pre><p>Return the right-hand side term of <code>cref</code> after JuMP has converted the constraint into its normalized form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL622-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_to_function_constant-Tuple{GeneralConstraintRef,Real}" href="#JuMP.add_to_function_constant-Tuple{GeneralConstraintRef,Real}"><code>JuMP.add_to_function_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_to_function_constant(cref::GeneralConstraintRef, value::Real)</code></pre><p>Add <code>value</code> to the function constant term. Note that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by <code>-value</code>. For example, given a constraint <code>2x &lt;= 3</code>, <code>add_to_function_constant(c, 4)</code> will modify it to <code>2x &lt;= -1</code>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL633-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef,Real}" href="#JuMP.set_normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef,Real}"><code>JuMP.set_normalized_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_normalized_coefficient(cref::GeneralConstraintRef,
                                variable::GeneralVariableRef, value::Real)</code></pre><p>Set the coefficient of <code>variable</code> in the constraint <code>constraint</code> to <code>value</code>. Note that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint <code>2x + 3x &lt;= 2</code>, <code>set_normalized_coefficient(con, x, 4)</code> will create the constraint <code>4x &lt;= 2</code>.</p><pre><code class="language-julia-repl">julia&gt; con
con : 5 x ≤ 2.0

julia&gt; set_normalized_coefficient(con, x, 4)

julia&gt; con
con : 4 x ≤ 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL649-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef}" href="#JuMP.normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef}"><code>JuMP.normalized_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.normalized_coefficient(cref::GeneralConstraintRef,
                            variable::GeneralVariableRef)::Number</code></pre><p>Return the coefficient associated with <code>variable</code> in <code>constraint</code> after JuMP has normalized the constraint into its standard form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL685-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.constraint_by_name-Tuple{InfiniteModel,String}" href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>JuMP.constraint_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.constraint_by_name(model::InfiniteModel,
                        name::String)::Union{GeneralConstraintRef, Nothing}</code></pre><p>Extend <a href="../../JuMP/#JuMP.constraint_by_name"><code>JuMP.constraint_by_name</code></a> to return the constraint reference associated with <code>name</code> if one exists or returns nothing. Errors if more than one constraint uses the same name.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; constraint_by_name(model, &quot;constr_name&quot;)
constr_name : x + pt = 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL719-L733">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.list_of_constraint_types-Tuple{InfiniteModel}" href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>JuMP.list_of_constraint_types</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.list_of_constraint_types(model::InfiniteModel)::Vector{Tuple)</code></pre><p>Extend <a href="../../JuMP/#JuMP.list_of_constraint_types-Tuple{Model}"><code>JuMP.list_of_constraint_types</code></a> to return a list of tuples that contain all the used combinations of function types and set types in the model.</p><pre><code class="language-julia-repl">julia&gt; all_constraints(model)
5-element Array{Tuple{DataType,DataType},1}:
 (HoldVariableRef, MathOptInterface.LessThan{Float64})
 (PointVariableRef, MathOptInterface.GreaterThan{Float64})
 (HoldVariableRef, MathOptInterface.GreaterThan{Float64})
 (HoldVariableRef, MathOptInterface.Integer)
 (InfiniteVariableRef, MathOptInterface.GreaterThan{Float64})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL937-L953">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar,Type{#s471} where #s471&lt;:MathOptInterface.AbstractSet}" href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar,Type{#s471} where #s471&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:JuMP.AbstractJuMPScalar},
                     set_type::Type{&lt;:MOI.AbstractSet})::Int</code></pre><p>Extend <a href="../../JuMP/#JuMP.num_constraints-Tuple{Model,Type{#s472} where #s472&lt;:Union{AbstractJuMPScalar, Array{#s471,1} where #s471&lt;:AbstractJuMPScalar},Type{#s470} where #s470&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> to return the number of constraints with a partiuclar function type and set type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_constraints(model, HoldVariableRef, MOI.LessThan)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL758-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar}" href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:JuMP.AbstractJuMPScalar})::Int</code></pre><p>Extend <a href="../../JuMP/#JuMP.num_constraints-Tuple{Model,Type{#s472} where #s472&lt;:Union{AbstractJuMPScalar, Array{#s471,1} where #s471&lt;:AbstractJuMPScalar},Type{#s470} where #s470&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> to search by function types for all MOI sets and return the total number of constraints with a particular function type.</p><pre><code class="language-julia-repl">julia&gt; num_constraints(model, HoldVariableRef)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL785-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:MathOptInterface.AbstractSet}" href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:MOI.AbstractSet})::Int</code></pre><p>Extend <a href="../../JuMP/#JuMP.num_constraints-Tuple{Model,Type{#s472} where #s472&lt;:Union{AbstractJuMPScalar, Array{#s471,1} where #s471&lt;:AbstractJuMPScalar},Type{#s470} where #s470&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> to search by MOI set type for all function types and return the total number of constraints that use a particular MOI set type.</p><pre><code class="language-julia-repl">julia&gt; num_constraints(model, MOI.LessThan)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL803-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel}" href="#JuMP.num_constraints-Tuple{InfiniteModel}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel)::Int</code></pre><p>Extend <a href="../../JuMP/#JuMP.num_constraints-Tuple{Model,Type{#s472} where #s472&lt;:Union{AbstractJuMPScalar, Array{#s471,1} where #s471&lt;:AbstractJuMPScalar},Type{#s470} where #s470&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> to return the total number of constraints in an infinite model <code>model</code>.</p><pre><code class="language-julia-repl">julia&gt; num_constraints(model)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL822-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar,Type{#s471} where #s471&lt;:MathOptInterface.AbstractSet}" href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar,Type{#s471} where #s471&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:JuMP.AbstractJuMPScalar},
                     set_type::Type{&lt;:MOI.AbstractSet}
                     )::Vector{&lt;:GeneralConstraintRef}</code></pre><p>Extend <a href="../../JuMP/#JuMP.all_constraints-Tuple{Model,Type{#s472} where #s472&lt;:Union{AbstractJuMPScalar, Array{#s471,1} where #s471&lt;:AbstractJuMPScalar},Type{#s470} where #s470&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> to return a list of all the constraints with a particular function type and set type.</p><pre><code class="language-julia-repl">julia&gt; all_constraints(model, HoldVariableRef, MOI.LessThan)
1-element Array{GeneralConstraintRef,1}:
 x ≤ 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL838-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar}" href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:AbstractJuMPScalar}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:JuMP.AbstractJuMPScalar}
                     )::Vector{&lt;:GeneralConstraintRef}</code></pre><p>Extend <a href="../../JuMP/#JuMP.all_constraints-Tuple{Model,Type{#s472} where #s472&lt;:Union{AbstractJuMPScalar, Array{#s471,1} where #s471&lt;:AbstractJuMPScalar},Type{#s470} where #s470&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> to search by function types for all MOI sets and return a list of all constraints use a particular function type.</p><pre><code class="language-julia-repl">julia&gt; all_constraints(model, HoldVariableRef)
3-element Array{GeneralConstraintRef,1}:
 x ≥ 0.0
 x ≤ 3.0
 x integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL870-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:MathOptInterface.AbstractSet}" href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s472} where #s472&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel,
                     set_type::Type{&lt;:MOI.AbstractSet}
                     )::Vector{&lt;:GeneralConstraintRef}</code></pre><p>Extend <a href="../../JuMP/#JuMP.all_constraints-Tuple{Model,Type{#s472} where #s472&lt;:Union{AbstractJuMPScalar, Array{#s471,1} where #s471&lt;:AbstractJuMPScalar},Type{#s470} where #s470&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> to search by MOI set type for all function types and return a list of all constraints that use a particular set type.</p><pre><code class="language-julia-repl">julia&gt; all_constraints(model, MOI.GreaterThan)
3-element Array{GeneralConstraintRef,1}:
 x ≥ 0.0
 g(t) ≥ 0.0
 g(0.5) ≥ 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL893-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel}" href="#JuMP.all_constraints-Tuple{InfiniteModel}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel)::Vector{&lt;:GeneralConstraintRef}</code></pre><p>Extend <a href="../../JuMP/#JuMP.all_constraints-Tuple{Model,Type{#s472} where #s472&lt;:Union{AbstractJuMPScalar, Array{#s471,1} where #s471&lt;:AbstractJuMPScalar},Type{#s470} where #s470&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> to return all a list of all the constraints in an infinite model <code>model</code>.</p><pre><code class="language-julia-repl">julia&gt; all_constraints(model)
5-element Array{GeneralConstraintRef,1}:
 x ≥ 0.0
 x ≤ 3.0
 x integer
 g(t) ≥ 0.0
 g(0.5) ≥ 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/constraints.jl#LL916-L932">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../objective/">« Objectives</a><a class="docs-footer-nextpage" href="../transcribe/">Model Transcription »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 March 2020 19:33">Tuesday 24 March 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
