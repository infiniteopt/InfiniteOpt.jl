<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Infinite Parameters · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li class="is-active"><a class="tocitem" href>Infinite Parameters</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage-1"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Parameter-Definition-1"><span>Parameter Definition</span></a></li><li><a class="tocitem" href="#Supports-1"><span>Supports</span></a></li><li><a class="tocitem" href="#Parameter-Queries-1"><span>Parameter Queries</span></a></li><li><a class="tocitem" href="#Parameter-Modification-1"><span>Parameter Modification</span></a></li><li><a class="tocitem" href="#Datatypes-1"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods/Macros-1"><span>Methods/Macros</span></a></li></ul></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Infinite Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Infinite Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/parameter.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="inf_par_page-1"><a class="docs-heading-anchor" href="#inf_par_page-1">Infinite Parameters</a><a class="docs-heading-anchor-permalink" href="#inf_par_page-1" title="Permalink"></a></h1><p>A guide and manual to the definition and use of infinite parameters in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>Infinite parameters are what parameterize the infinite decision spaces for infinite dimensional mathematical programs. In dynamic optimization this corresponds to time and in stochastic optimization this to uncertain parameters that follow a certain underlying statistical distribution. <code>InfiniteOpt</code> considers principally two kinds of infinite parameters, ones defined over continuous intervals and ones characterized by a distribution (others can be added by defining a user-defined type). These can be used to parameterize infinite variables, point variables, measures, and can be used directly inside constraints.</p><h2 id="Basic-Usage-1"><a class="docs-heading-anchor" href="#Basic-Usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-1" title="Permalink"></a></h2><p>First, we need to initialize and add infinite parameters to our <code>InfiniteModel</code>. This can be accomplished using <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. For example, let&#39;s define a parameter for time in a time interval from 0 to 10:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10])
t</code></pre><p>Now <code>t</code> is a Julia variable that stores a <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> which points to where the time parameter is stored in <code>model</code>. It can now be used with infinite variables, measures, and constraints as described in the appropriate sections.</p><p>When the model is optimized, <code>t</code> will be transcribed (discretized) over its domain following its support points. If none are specified by the user than 50 support points are generated that are equidistant over the interval. However, users may wish to employ their own support scheme. This can be done by using the <code>num_supports</code> or <code>supports</code> keyword arguments. For example, if we desire to have only 10 equidistant supports then we could have instead defined <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10)
t</code></pre><p>More complex support schemes can be specified via <code>supports</code> such as:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0; 2; 7; 10])
t</code></pre><p>Where we specified <code>t</code> to use 4 supports: 0, 2, 7, and 10.</p><p>We can also add supports after <code>t</code> has been initialized. This can be accomplished with <a href="#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s472,1} where #s472&lt;:Number}}"><code>add_supports</code></a>. For example, consider the initial case where <code>t</code> has no supports and we now wish to add 4 supports:</p><pre><code class="language-julia-repl">julia&gt; add_supports(t, [0., 2.5, 7.5, 10.])

julia&gt; supports(t)
4-element Array{Number,1}:
  0.0
  2.5
  7.5
 10.0</code></pre><p>Here only 4 supports are specified for the sake of example. Alternatively, we could have initialized the parameter and added supports in just one step using the <code>supports</code> keyword argument:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0., 2.5, 7.5, 10.])
t</code></pre><p>We could also define a random parameter described by a statistical distribution. This can be accomplished using <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> in combination with a distribution from <a href="https://github.com/JuliaStats/Distributions.jl"><code>Distributions.jl</code></a>. For example let&#39;s define a vector of random parameters described by a Normal distribution:</p><pre><code class="language-julia-repl">julia&gt; using Distributions

julia&gt; @infinite_parameter(model, xi[i = 1:3] in Normal())
3-element Array{ParameterRef,1}:
 xi[1]
 xi[2]
 xi[3]</code></pre><p>Note that we could have used <code>i</code> as an index to assign a different distribution to each parameter. Supports can also be specified for each parameter as shown above. The key difference is that by default 50 supports are generated randomly following the distribution. Similarly, the <code>num_supports</code> keyword is used to generate random supports. Now we have infinite parameters <code>t</code> and <code>xi</code> that are ready to be used in defining infinite variables and constraints. We also mention here that the <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> macro is designed to closely emulate <a href="../../JuMP/#JuMP.@variable"><code>JuMP.@variable</code></a> and thus handles arrays and keyword arguments in the same way. This is described in more detail below.</p><h2 id="Parameter-Definition-1"><a class="docs-heading-anchor" href="#Parameter-Definition-1">Parameter Definition</a><a class="docs-heading-anchor-permalink" href="#Parameter-Definition-1" title="Permalink"></a></h2><p>Defining/initializing an infinite parameter principally involves the following steps:</p><ol><li>Define an <a href="../sets/#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a></li><li>Define support points within the set to later discretize the parameter</li><li>Specify if parameter is independent (only for multi-dimensional parameter groups)</li><li>Construct an <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> to store this information</li><li>Add the <code>InfOptParameter</code> object to an <code>InfiniteModel</code> and assign a name</li><li>Create a <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> that points to the parameter object</li></ol><h3 id="Manual-Definition-1"><a class="docs-heading-anchor" href="#Manual-Definition-1">Manual Definition</a><a class="docs-heading-anchor-permalink" href="#Manual-Definition-1" title="Permalink"></a></h3><p>Infinite set definition is described above in the <a href="../sets/#infinite_sets_normal-1">Infinite Sets</a> section. The supports should be a vector of finite numbers that are drawn from the domain of the infinite set. These supports will be used to transcribe the <code>InfiniteModel</code> in preparation for it to be optimized. If desired, the supports can be specified after the parameter is defined and an empty vector will be used to construct the infinite parameter. We&#39;ll discuss independence a little further below. The <a href="#InfiniteOpt.build_parameter-Tuple{Function,AbstractInfiniteSet}"><code>build_parameter</code></a> function is used to construct the <code>InfOptParameter</code>. For example, let&#39;s create a time parameter <span>$t \in [0, 10]$</span> with supports <code>[0, 2, 5, 7, 10]</code>:</p><pre><code class="language-julia-repl">julia&gt; set = IntervalSet(0, 10)
[0, 10]

julia&gt; t_param = build_parameter(error, set, supports = [0, 2, 5, 7, 10])
InfOptParameter{IntervalSet}([0, 10], [0, 2, 5, 7, 10], false)</code></pre><p>Now we have a <code>InfOptParameter</code> that contains an <code>IntervalSet</code> and supports. Note that the <code>num_params</code> and <code>independent</code> arguments are primarily meant to be used by <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> to define array parameters and specify if they are correlated or independent.</p><p>Let&#39;s now add <code>t_param</code> to our <code>InfiniteModel</code> using <a href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,InfOptParameter}"><code>add_parameter</code></a> and assign it the name of <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; t_ref = add_parameter(model, t_param, &quot;t&quot;)
t</code></pre><p>We can also create an anonymous infinite parameter by dropping the name from the <code>add_parameter</code> function call. For example:</p><pre><code class="language-julia-repl">julia&gt; t_ref_noname = add_parameter(model, t_param)
noname</code></pre><p>Now suppose we want to create an infinite parameter that is a random variable with a given distribution. We follow the same procedure as above, except we use distributions from <code>Distributions.jl</code> to define <a href="../sets/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a>. For example, let&#39;s consider a random variable <span>$x \in \mathcal{N}(0,1)$</span> with supports <code>[-0.5, 0.5]</code>:</p><pre><code class="language-julia-repl">julia&gt; dist = Normal(0., 1.)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; set = DistributionSet(dist)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; x_param = build_parameter(error, set, supports = [-0.5, 0.5])
InfOptParameter{DistributionSet{Normal{Float64}}}(Normal{Float64}(μ=0.0, σ=1.0), [-0.5, 0.5], false)</code></pre><p>Again, we use <a href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,InfOptParameter}"><code>add_parameter</code></a> to add <code>x_param</code> to the <code>InfiniteModel</code> and assign it the name <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; x_ref = add_parameter(model, x_param, &quot;x&quot;)
x</code></pre><p>Note that <code>add_parameter</code> does not register the name of the parameters into the model that it adds to. As shown in <a href="#param_macro-1">Macro Definition</a>, the macro definition does not allow for multiple parameters sharing the same name and will throw an error if it happens.</p><h3 id="param_macro-1"><a class="docs-heading-anchor" href="#param_macro-1">Macro Definition</a><a class="docs-heading-anchor-permalink" href="#param_macro-1" title="Permalink"></a></h3><h4 id="One-Dimensional-Parameters-1"><a class="docs-heading-anchor" href="#One-Dimensional-Parameters-1">One-Dimensional Parameters</a><a class="docs-heading-anchor-permalink" href="#One-Dimensional-Parameters-1" title="Permalink"></a></h4><p>One user-friendly way of defining infinite parameters is by macro <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. The macro executes the same process as the manual definition (steps listed in <a href="#Parameter-Definition-1">Parameter Definition</a>), but allows the users to manipulate several features of the defined infinite parameters. Again, let&#39;s consider a time parameter <span>$t \in [0, 10]$</span> with supports <code>[0, 2, 5, 7, 10]</code>. Similar to <a href="../../JuMP/#JuMP.@variable"><code>JuMP.@variable</code></a>, we can use comparison operators to set lower bounds and upper bounds for the infinite parameter:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, 0 &lt;= t &lt;= 10, supports = [0, 2, 5, 7, 10])
t</code></pre><p>More generally, we use <code>in</code> to define the set that an infinite parameter is subject to. The set could be an interval set, or a distribution set. For example, we can define the same parameter <code>t</code> as above in the following way:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10], supports = [0, 2, 5, 7, 10])
t</code></pre><p>In a similar way, we can define a random infinite parameter subject to some distribution. For example, a Gaussian infinite parameter with mean 0 and standard deviation 1 can be defined by</p><pre><code class="language-julia-repl">julia&gt; dist = Normal(0., 1.)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; @infinite_parameter(model, x in dist, supports = [-0.5, 0.5])
x</code></pre><p>Additional ways of defining infinite parameters are provided using keyword arguments. For example, we can use <code>lower_bound</code> and <code>upper_bound</code> to define an infinite parameter in an interval set:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t, lower_bound = 0, upper_bound = 10, supports = [0, 2, 5, 7, 10])
t</code></pre><p>A bit more generally, we can also use <code>set</code> to directly input the <code>AbstractInfiniteSet</code> that the parameter is in. For example:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t, set = IntervalSet(0, 10), supports = [0, 2, 5, 7, 10])
t</code></pre><p>The parameter definition methods using keyword arguments will be useful later when we introduce how to define anonymous parameters. See the part for anonymous parameter definition for more details.</p><p>All the definitions above return a <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> that refer to the defined parameter. Note that we can also ignore the <code>supports</code> keyword argument and the macro will define an empty array of supports for that parameter.</p><h4 id="Multi-Dimensional-Parameter-1"><a class="docs-heading-anchor" href="#Multi-Dimensional-Parameter-1">Multi-Dimensional Parameter</a><a class="docs-heading-anchor-permalink" href="#Multi-Dimensional-Parameter-1" title="Permalink"></a></h4><p>Using macro definition, we can also define multi-dimensional infinite parameters in a concise way. For example, consider a position parameter <code>x</code> in a 3-dimensional space constrained in a unit cube (i.e. in the interval <code>[0, 1]</code>   for all dimensions). This parameter can be defined in one line as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], supports = [0.3, 0.7])
3-element Array{ParameterRef,1}:
 x[1]
 x[2]
 x[3]</code></pre><p>For multi-dimensional parameters, the macro calls for <a href="#InfiniteOpt.build_parameter-Tuple{Function,AbstractInfiniteSet}"><code>build_parameter</code></a> and <a href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,InfOptParameter}"><code>add_parameter</code></a> and creates looped codes that construct separate parameters and references for each dimension. If an array of supports is provided, the macro will assign that array of supports to all dimensions. Otherwise, the indexed syntax can be used to feed in different array of supports to each dimension, similar to <a href="../../JuMP/#JuMP.@variable"><code>JuMP.@variable</code></a>. For example:</p><pre><code class="language-julia-repl">julia&gt; points = [0.2 0.8; 0.3 0.7]
2×2 Array{Float64,2}:
 0.2  0.8
 0.3  0.7

julia&gt; @infinite_parameter(model, a[i = 1:2] in [0, 1], supports = points[i, :])
2-element Array{ParameterRef,1}:
 a[1]
 a[2]

julia&gt; supports(a[1])
2-element Array{Float64,1}:
 0.2
 0.8

julia&gt; supports(a[2])
2-element Array{Float64,1}:
 0.3
 0.7</code></pre><p>In a similar way we can define an infinite parameter subject to a multivariate distribution. For example, a 2-dimensional parameter <code>xi</code> subject to a 2-D normal distribution can be created as follows:</p><pre><code class="language-julia-repl">julia&gt; dist = MvNormal([0., 0.], [1. 0.; 0. 2.])
FullNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 2.0]
)

julia&gt; @infinite_parameter(model, xi[1:2] in dist)
2-element Array{ParameterRef,1}:
 xi[1]
 xi[2]</code></pre><h4 id="Containers-for-Multi-Dimensional-Parameters-1"><a class="docs-heading-anchor" href="#Containers-for-Multi-Dimensional-Parameters-1">Containers for Multi-Dimensional Parameters</a><a class="docs-heading-anchor-permalink" href="#Containers-for-Multi-Dimensional-Parameters-1" title="Permalink"></a></h4><p>Note that for all the cases of multi-dimensional parameter definition above, the macro always returns an <code>Array</code> of <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a>. For most cases this is true. However, we can explicitly dictate the kind of containers we want to hold the defined parameters using the keyword <code>container</code>. For example, we use <code>SparseAxisArray</code> from the <code>JuMP</code> package for the space parameter <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], container = SparseAxisArray)
JuMP.Containers.SparseAxisArray{ParameterRef,1,Tuple{Int64}} with 3 entries:
  [3]  =  x[3]
  [2]  =  x[2]
  [1]  =  x[1]</code></pre><h4 id="independent-for-Multi-Dimensional-Parameters-1"><a class="docs-heading-anchor" href="#independent-for-Multi-Dimensional-Parameters-1"><code>independent</code> for Multi-Dimensional Parameters</a><a class="docs-heading-anchor-permalink" href="#independent-for-Multi-Dimensional-Parameters-1" title="Permalink"></a></h4><p>For examples up to now we did not specify the value for the keyword <code>independent</code>, which is set as <code>false</code> by default. The keyword <code>independent</code> applies to multi-dimensional infinite parameters and dictates whether the supports for different dimensions are independent. Setting <code>independent</code> as <code>true</code> would be useful if the users want to generate a grid of supports for a multi-dimensional parameter. For example, consider the position parameter <code>x</code> in a 3D space. Say <code>x</code> is bounded in <code>[0, 1]</code> in all three dimensions, and the user wants to generate grid points with interval <code>0.5</code> in all three dimensions. In this case, we can define <code>x</code> in the following way:</p><pre><code class="language-julia-repl">julia&gt; pts = collect(range(0, stop = 1, length = 3))
3-element Array{Float64,1}:
 0.0
 0.5
 1.0

julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], supports = pts, independent = true)
3-element Array{ParameterRef,1}:
 x[1]
 x[2]
 x[3]</code></pre><p>If <code>independent</code> is set as <code>false</code>, the transcription step will generate JuMP variables for values of any variable parameterized by <code>x</code> at <code>[0.0, 0.0, 0.0]</code>, <code>[0.5, 0.5, 0.5]</code> and <code>[1.0, 1.0, 1.0]</code>, a total of 3 transcribed variables. Instead, if <code>independent</code> is set as <code>true</code>, the transcription step will obtain a unique permutation of these supports and each transcribe parameterized variable accordingly, leading to a total of 27 transcribed variables in this case.</p><h4 id="Anonymous-Parameter-Definition-and-base_name-1"><a class="docs-heading-anchor" href="#Anonymous-Parameter-Definition-and-base_name-1">Anonymous Parameter Definition and <code>base_name</code></a><a class="docs-heading-anchor-permalink" href="#Anonymous-Parameter-Definition-and-base_name-1" title="Permalink"></a></h4><p>As mentioned above, we can define anonymous parameters using keyword arguments in the macro <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. For instance, we can create an anonymous position parameter in a 3D space, referred to by a list of <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> called <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; x = @infinite_parameter(model, [1:3], lower_bound = 0, upper_bound = 1)
3-element Array{ParameterRef,1}:
 noname
 noname
 noname

julia&gt; typeof(x)
Array{ParameterRef,1}

julia&gt; name(x[1])
&quot;&quot;</code></pre><p>This syntax creates a 1D parameter if the part <code>[1:3]</code> is neglected.</p><p>Note that this macro definition automatically assigns an empty string to the <code>base_name</code>. We can also assign a nontrivial base name to an anonymous parameter using the keyword argument <code>base_name</code>. For example,</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, [1:3], lower_bound = 0, upper_bound = 1, base_name = &quot;x&quot;)
3-element Array{ParameterRef,1}:
 x[1]
 x[2]
 x[3]

julia&gt; @infinite_parameter(model, [1:3], lower_bound = -1, upper_bound = 0, base_name = &quot;x&quot;)
3-element Array{ParameterRef,1}:
 x[1]
 x[2]
 x[3]</code></pre><p>We can see that anonymous parameter definition allows for multiple parameters sharing the same base name. This is not permitted with non-anonymous parameter definition. In fact, in anonymous parameter definition, the macro does not register the name of the parameters in the model, so when the model checks for repeated names it will not detect the <code>x</code>. Refer to <a href="#Detailed-Mechanism-of-Macro-Definition-1">Detailed Mechanism of Macro Definition</a> if more details are desired.</p><h4 id="Detailed-Mechanism-of-Macro-Definition-1"><a class="docs-heading-anchor" href="#Detailed-Mechanism-of-Macro-Definition-1">Detailed Mechanism of Macro Definition</a><a class="docs-heading-anchor-permalink" href="#Detailed-Mechanism-of-Macro-Definition-1" title="Permalink"></a></h4><p>This section is for people who wish to know more about how the macro <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> works in the backend. Users who only want to learn about the setting up the model can skip over this part.</p><p>In general, the macro <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> follows the same steps as the manual definition. First, it parses the arguments and identifies any recognizable keyword arguments. Specifically, the first argument must be the model, and the second argument, if exists, must be an expression that declares the parameter or simply specify the dimension of the parameter if users choose to define it anonymously. If the information in the keyword arguments is not sufficient to define the set the parameter is in, the users also need to specify the sets in the second argument using expressions like <code>a &lt;= x &lt;= b</code> or <code>x in set</code>.</p><p>The keyword arguments give users flexibility in how to define their parameters. As mentioned above, the users can choose to specify the set either in the second argument (nonanonymous parameter definition only), or in the keyword arguments. However, the users cannot do both at the same time. The macro will check this behavior and throw an error if this happens. For example,</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model,  y in [0, 1], lower_bound = 0, upper_bound = 1)
ERROR: LoadError

julia&gt; @infinite_parameter(model,  y in [0, 1], set = IntervalSet(0, 1))
ERROR: LoadError</code></pre><p>Once the check on arguments and keyword arguments is done, the macro will create the <a href="../sets/#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a> based on given information, and create the infinite parameter accordingly. If the users create a multi-dimensional parameter, the macro will create looped code to define individual infinite parameter for each dimension. The looped code will also incorporate different supports for different dimensions.</p><p>In the end, if the created parameter is not anonymous, the macro will register the name to the model. In this way, we prevent parameters created by <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> non-anonymously to share the same name.</p><h2 id="Supports-1"><a class="docs-heading-anchor" href="#Supports-1">Supports</a><a class="docs-heading-anchor-permalink" href="#Supports-1" title="Permalink"></a></h2><p>For an infinite parameter, its supports are a finite set of points that the parameter will take (or possibly take, if the parameter is random). During the transcription stage, the supports specified will become part of the grid points that approximate all functions parameterized by the infinite parameter.</p><p>Once an infinite parameter is defined, users can access the supports using <a href="../measure/#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>supports</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, 0 &lt;= t &lt;= 10, supports = [0, 2, 5, 7, 10])
t

julia&gt; supports(t)
5-element Array{Int64,1}:
  0
  2
  5
  7
 10</code></pre><p>We also provide functions that access other related information about the supports. For example, <a href="#InfiniteOpt.has_supports-Tuple{ParameterRef}"><code>has_supports</code></a> checks whether a parameter has supports, while <a href="#InfiniteOpt.num_supports-Tuple{ParameterRef}"><code>num_supports</code></a> gives the number of supports associated with a parameter:</p><pre><code class="language-julia-repl">julia&gt; has_supports(t)
true

julia&gt; num_supports(t)
5</code></pre><p>Now suppose we want to add more supports to the <code>t</code>, which is already assigned with some supports. We can use <a href="#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s472,1} where #s472&lt;:Number}}"><code>add_supports</code></a> function to achieve this goal:</p><pre><code class="language-julia-repl">julia&gt; add_supports(t, [3, 8])

julia&gt; supports(t)
7-element Array{Int64,1}:
  0
  2
  5
  7
 10
  3
  8</code></pre><p>At times we might want to change the supports completely. In those cases, the function <a href="#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s472,1} where #s472&lt;:Number}"><code>set_supports</code></a> resets the supports for a certain parameter with new supports provided:</p><pre><code class="language-julia-repl">julia&gt; set_supports(t, [0,3,5,8,10], force = true)

julia&gt; supports(t)
5-element Array{Int64,1}:
  0
  3
  5
  8
 10</code></pre><p>Note that the keyword argument [<code>force</code>] must be set as [<code>true</code>] if the parameter has been assigned with supports. Users can also delete all the supports of a parameter with <a href="#InfiniteOpt.delete_supports-Tuple{ParameterRef}"><code>delete_supports</code></a>.</p><h3 id="Automatic-Support-Generation-During-Parameter-Definition-1"><a class="docs-heading-anchor" href="#Automatic-Support-Generation-During-Parameter-Definition-1">Automatic Support Generation During Parameter Definition</a><a class="docs-heading-anchor-permalink" href="#Automatic-Support-Generation-During-Parameter-Definition-1" title="Permalink"></a></h3><p>For the examples in the <a href="#Parameter-Definition-1">Parameter Definition</a>, we have seen how to manually add supports to an infinite parameter. For a quick automatic generation of support points, though, users do not have to input the support points. Instead, the number of support points generated is supplied.</p><p>For an infinite parameter subject to an <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>, uniformly spaced supports including both ends are generated across the interval. For example, defining a time parameter <span>$t \in [0, 10]$</span> with 4 supports using <a href="#InfiniteOpt.build_parameter-Tuple{Function,AbstractInfiniteSet}"><code>build_parameter</code></a> gives</p><pre><code class="language-julia-repl">julia&gt; set = IntervalSet(0, 10)
[0, 10]

julia&gt; t_param = build_parameter(error, set, num_supports = 4, sig_fig = 3)
InfOptParameter{IntervalSet}([0, 10], [0.0, 3.33, 6.67, 10.0], false)</code></pre><p>Using macro definition we have</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, 0 &lt;= t &lt;= 10, num_supports = 4, sig_fig = 3)
t

julia&gt; supports(t)
4-element Array{Float64,1}:
  0.0   
  3.33
  6.67
 10.0   
</code></pre><p>Note that the user can use the keyword argument <code>sig_fig</code> to dictate the significant figures for the supports. The default value of <code>sig_fig</code> is 5.</p><p>For an infinite parameter that follows a univariate distribution, supports are sampled from the underlying distribution. For example, we can define an infinite parameter subject to a normal distribution with mean 0 and variance 1:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in dist, num_supports = 4)
x

julia&gt; supports(x)
4-element Array{Float64,1}:
  0.67911
  0.82841
 -0.35301
 -0.13485
</code></pre><p>For multivariate distributions, though, we require support points are provided in the definition. However, we can use <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> to generate supports for parameters following multivariate distributions. See <a href="#Automatic-Support-Generation-For-Defined-Parameters-1">Automatic Support Generation For Defined Parameters</a> for details.</p><h3 id="Automatic-Support-Generation-For-Defined-Parameters-1"><a class="docs-heading-anchor" href="#Automatic-Support-Generation-For-Defined-Parameters-1">Automatic Support Generation For Defined Parameters</a><a class="docs-heading-anchor-permalink" href="#Automatic-Support-Generation-For-Defined-Parameters-1" title="Permalink"></a></h3><p>So far, we have seen that in both definition methods it is allowed to initialize a parameter with no supports. This is done by not specifying <code>supports</code> and <code>num_supports</code>. However, infinite parameters would not be allowed at the transcription step since it needs information about how to discretize the infinite parameters. In previous examples, we have shown that users can add supports to a defined parameter using methods <a href="#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s472,1} where #s472&lt;:Number}}"><code>add_supports</code></a> and <a href="#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s472,1} where #s472&lt;:Number}"><code>set_supports</code></a>.</p><p>In this section we introduce automatic support generation for defined parameters with no associated supports. This can be done using the <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> functions. <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> can take as argument a <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a>, in which case it will generate supports for the associated infinite parameter. Alternatively, <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> can also take an <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> as an argument, in which case it will generate supports for all infinite parameters of the <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> with no supports.</p><p>The <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> method allows users to specify integer keyword arguments <code>num_supports</code> and <code>sig_fig</code>. <code>num_supports</code> dictates the number of supports to be generated, and <code>sig_fig</code> dictates the significant figures of generated supports desired. The default values are 50 and 5, respectively.</p><p>The ways by which supports are automatically generated are as follows. If the parameter is in an <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>, then we generate an array of supports that are uniformly distributed along the interval, including the two ends. For example, consider a 3D position parameter <code>x</code> distributed in the unit cube <code>[0, 1]</code>. We can generate supports for that point in the following way:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:3] in [0, 1], independent = true);

julia&gt; fill_in_supports!.(x, num_supports = 3);

julia&gt; supports.(x)
3-element Array{Array{Number,1},1}:
 [0.0, 0.5, 1.0]
 [0.0, 0.5, 1.0]
 [0.0, 0.5, 1.0]</code></pre><p>Note that the dot syntax because <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> takes single <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> as argument. In each dimension, three equally spaced supports (<code>[0.0, 0.5, 1.0]</code>) are generated. Since the <code>independent</code> keyword is set as <code>true</code>, the transcription stage will create a three-dimensional grid for all variables parameterized by <code>x</code>, with each point separated by 0.5 units in each dimension.</p><p>If the parameter is in a <a href="../sets/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a>, <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> samples <code>num_supports</code> supports from the distribution. Recall that support generation is not allowed for parameters under multivariate distribution during parameter definition. However, if the parameter is defined first without supports, <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> allows for supports generation. For example, for a 2D random variable <code>xi</code> under a multivariate Gaussian distribution, we can generate supports for it in the following way:</p><pre><code class="language-julia-repl">julia&gt; dist = MvNormal([0., 0.], [1. 0.; 0. 2.])
FullNormal(
dim: 2
μ: [0.0, 0.0]
Σ: [1.0 0.0; 0.0 2.0]
)


julia&gt; @infinite_parameter(model, xi[1:2] in dist);

julia&gt; fill_in_supports!(xi[1], num_supports = 3)

julia&gt; supports.(xi)
2-element Array{Array{Number,1},1}:
 [0.67911, -0.35301, 0.58662]
 [1.1716, -0.19071, 0.4205]</code></pre><p>Note that for parameters under multivariate distribution, the users do not have to call <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> for all <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> associated with that parameter. <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a>, once called upon one <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a>, would search for the other <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> and fill in supports for them if they, together with the original <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a>, make up for the same multi-dimensional parameter under a multivariate distribution.</p><p>Also, <a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a> only fill in supports for parameters with no associated supports. To modify the supports of parameters already associated with some supports, refer to <a href="#Supports-1">Supports</a> for how to do that.</p><h2 id="Parameter-Queries-1"><a class="docs-heading-anchor" href="#Parameter-Queries-1">Parameter Queries</a><a class="docs-heading-anchor-permalink" href="#Parameter-Queries-1" title="Permalink"></a></h2><p>In addition to the modeling framework, this package provides many functions for users to access information about the model. This section will go over basic functions for accessing parameter information.</p><p>Once a (possibly large-scale) <code>InfiniteModel</code> is built, the users might want to check if an infinite parameter is actually used in any way. This could be checked by <a href="../measure/#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>is_used</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1])
x

julia&gt; is_used(x)
false
</code></pre><p>This function checks if the parameter is used by any constraint, measure, or variable. In a similar way, functions <a href="../measure/#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>used_by_constraint</code></a>, <a href="../measure/#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>used_by_measure</code></a> and <a href="#InfiniteOpt.used_by_variable-Tuple{ParameterRef}"><code>used_by_variable</code></a> can be applied to find out any dependency of specific types on the infinite parameter.</p><p>In addition, sometimes we need to check if a certain <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> is valid with an <code>InfiniteModel</code> model, meaning that the parameter reference actually refers to some parameter associated with the model. We extend the <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> function from JuMP for that purpose. To see how to use this, for example,</p><pre><code class="language-julia-repl">julia&gt; pref1 = ParameterRef(model, 1);

julia&gt; pref2 = ParameterRef(model, 2);

julia&gt; is_valid(model, pref1)
true

julia&gt; is_valid(model, pref2)
false</code></pre><p>The second call of <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>is_valid</code></a> returns <code>false</code> because the model does not have parameter with index 2 yet.</p><p>We can also access different information about the set that the infinite parameter is in. This is given by <a href="#InfiniteOpt.infinite_set-Tuple{ParameterRef}"><code>infinite_set</code></a>, which takes a [<code>ParameterRef</code>] as argument. For example, we have</p><pre><code class="language-julia-repl">julia&gt; infinite_set(x)
[0, 1]</code></pre><p><a href="#InfiniteOpt.infinite_set-Tuple{ParameterRef}"><code>infinite_set</code></a> might be more useful if the infinite parameter is in a <a href="../sets/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a>, by which users can access information about the underlying distribution. On the other hand, if we already know that the parameter is in an interval set, we can use <a href="../../JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a>, <a href="../../JuMP/#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a>, <a href="../../JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a>, <a href="../../JuMP/#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> to retrieve information about the interval set in a more specific way:</p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(x)
true

julia&gt; lower_bound(x)
0.0

julia&gt; has_upper_bound(x)
true

julia&gt; upper_bound(x)
1.0</code></pre><p>For multi-dimensional parameters, the definition step would create the parameter for each dimension an add it into the model separately. However, users can find out if different parameters belong to the same group using <a href="#InfiniteOpt.group_id-Tuple{ParameterRef}"><code>group_id</code></a> function. The group ID is simply an index assigned at the parameter definition. See the following example for how to use it:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, y[1:2] in [0, 5])
2-element Array{ParameterRef,1}:
 y[1]
 y[2]

julia&gt; group_id(x)
1

julia&gt; group_id(y)
2

julia&gt; group_id([x, y[1]])
ERROR: Array contains parameters from multiple groups.</code></pre><p>In the example above, the function returns the group ID if it receives one <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a>. If the argument is a vector of <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a>, however, it will throw an error if the parameters do not belong to the same group. Otherwise, it will return the group ID for all parameters in the vector. Again, this function could be helpful if the users want to verify if a set of parameters are correlated.</p><p>Another important piece of information about multi-dimensional parameters is whether different dimensions are independent. This can be checked by <a href="#InfiniteOpt.is_independent-Tuple{ParameterRef}"><code>is_independent</code></a>:</p><pre><code class="language-julia-repl">julia&gt; is_independent(y[1])
false</code></pre><p>A quick way for users to obtain a <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> for a parameter with a known name would be through <a href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>parameter_by_name</code></a> function. This function takes an <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a> and the parameter name in string, and returns a <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> for that parameter. For example,</p><pre><code class="language-julia-repl">julia&gt; pref = parameter_by_name(model, &quot;x&quot;)
x</code></pre><p>If there is no parameter associated with that name, the function would return nothing. Otherwise, if multiple parameters share the same name, the function would throw an error.</p><p>Now we introduce two additional functions that we can use to access parameter information for an  <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteModel</code></a>. The function <a href="#InfiniteOpt.num_parameters-Tuple{InfiniteModel}"><code>num_parameters</code></a> returns the number of infinite parameters associated with a model, while <a href="#InfiniteOpt.all_parameters-Tuple{InfiniteModel}"><code>all_parameters</code></a> returns the list of all infinite parameter references in the model. For a quick example:</p><pre><code class="language-julia-repl">julia&gt; num_parameters(model)
3

julia&gt; all_parameters(model)
3-element Array{ParameterRef,1}:
 x   
 y[1]
 y[2]</code></pre><h2 id="Parameter-Modification-1"><a class="docs-heading-anchor" href="#Parameter-Modification-1">Parameter Modification</a><a class="docs-heading-anchor-permalink" href="#Parameter-Modification-1" title="Permalink"></a></h2><p>In this section we introduce a few shortcuts for users to modify defined infinite parameters.</p><p>First, once an infinite parameter is defined, we can change its name by calling the [<code>JuMP.set_name</code>] function, which takes the [<code>ParameterRef</code>] that needs a name change and the name string as arguments. For example, to change the parameter <code>x</code> to <code>t</code> we can do:</p><pre><code class="language-julia-repl">julia&gt; JuMP.set_name(x, &quot;t&quot;)

julia&gt; all_parameters(model)
3-element Array{ParameterRef,1}:
 t   
 y[1]
 y[2]</code></pre><p>In a similar way, we can also change the infinite set that the parameter is in using the <a href="#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}"><code>set_infinite_set</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; t = parameter_by_name(model, &quot;t&quot;)
t

julia&gt; set_infinite_set(t, IntervalSet(0, 5))

julia&gt; infinite_set(t)
[0, 5]</code></pre><p>For parameters in an <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>, we extend <a href="../../JuMP/#JuMP.set_lower_bound-Tuple{VariableRef,Number}"><code>JuMP.set_lower_bound</code></a> and <a href="../../JuMP/#JuMP.set_upper_bound-Tuple{VariableRef,Number}"><code>JuMP.set_upper_bound</code></a> functions for users to modify the lower bounds and upper bounds. For example,</p><pre><code class="language-julia-repl">julia&gt; JuMP.set_lower_bound(t, 1)

julia&gt; JuMP.set_upper_bound(t, 4)

julia&gt; infinite_set(t)
[1, 4]</code></pre><p>We do not support setting lower bounds and upper bounds for random parameters in a <a href="../sets/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a> and will throw an error if users attempt to do so. If users want to set lower bound and upper bound for a random infinite parameter, consider using <code>Distributions.Truncated</code>, which creates a truncated distribution from a univariate distribution.</p><p>We can also modify the <code>independent</code> status of a parameter using <a href="#InfiniteOpt.set_independent-Tuple{ParameterRef}"><code>set_independent</code></a> and <a href="#InfiniteOpt.unset_independent-Tuple{ParameterRef}"><code>unset_independent</code></a> functions. The <a href="#InfiniteOpt.set_independent-Tuple{ParameterRef}"><code>set_independent</code></a> function sets <code>true</code> for the <code>independent</code> status, while <a href="#InfiniteOpt.unset_independent-Tuple{ParameterRef}"><code>unset_independent</code></a> function sets <code>false</code> for the <code>independent</code> status.</p><pre><code class="language-julia-repl">julia&gt; set_independent(y[1])

julia&gt; is_independent(y[1])
true

julia&gt; is_independent(y[2])
false

julia&gt; unset_independent(y[1])

julia&gt; is_independent(y[1])
false</code></pre><p>Note that these two functions takes one single [<code>ParameterRef</code>] as argument, and it will not automatically find the other associated parameters and reset their status altogether. This gives more flexibility on how we want to discretize certain parameters. For example, if for a 3D position parameter <code>x</code> we want to have uniform discretization along <code>x[1]</code>, but custom supports over the 2D space <code>x[2]</code> and <code>x[3]</code>, we can set <code>x[1]</code> only as independent.</p><h2 id="Datatypes-1"><a class="docs-heading-anchor" href="#Datatypes-1">Datatypes</a><a class="docs-heading-anchor-permalink" href="#Datatypes-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.InfOptParameter"><code>InfiniteOpt.InfOptParameter</code></a></li><li><a href="#InfiniteOpt.ParameterRef"><code>InfiniteOpt.ParameterRef</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptParameter" href="#InfiniteOpt.InfOptParameter"><code>InfiniteOpt.InfOptParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfOptParameter{T &lt;: AbstractInfiniteSet} &lt;: JuMP.AbstractVariable</code></pre><p>A DataType for storing core infinite parameter information.</p><p><strong>Fields</strong></p><ul><li><code>set::T</code> The infinite set that characterizes the parameter.</li><li><code>supports::Vector{&lt;:Number}</code> The support points used to discretize this                              parameter.</li><li><code>independent::Bool</code> Is independent of other parameters that share its group ID                     number.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/datatypes.jl#LL8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ParameterRef" href="#InfiniteOpt.ParameterRef"><code>InfiniteOpt.ParameterRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParameterRef &lt;: GeneralVariableRef</code></pre><p>A DataType for untranscripted infinite parameters references that parameterize the infinite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/datatypes.jl#LL390-L399">source</a></section></article><h2 id="Methods/Macros-1"><a class="docs-heading-anchor" href="#Methods/Macros-1">Methods/Macros</a><a class="docs-heading-anchor-permalink" href="#Methods/Macros-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.@infinite_parameter"><code>InfiniteOpt.@infinite_parameter</code></a></li><li><a href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,InfOptParameter}"><code>InfiniteOpt.add_parameter</code></a></li><li><a href="#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s472,1} where #s472&lt;:Number}}"><code>InfiniteOpt.add_supports</code></a></li><li><a href="#InfiniteOpt.all_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.all_parameters</code></a></li><li><a href="#InfiniteOpt.build_parameter-Tuple{Function,AbstractInfiniteSet}"><code>InfiniteOpt.build_parameter</code></a></li><li><a href="#InfiniteOpt.delete_supports-Tuple{ParameterRef}"><code>InfiniteOpt.delete_supports</code></a></li><li><a href="#InfiniteOpt.fill_in_supports!-Tuple{ParameterRef}"><code>InfiniteOpt.fill_in_supports!</code></a></li><li><a href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>InfiniteOpt.fill_in_supports!</code></a></li><li><a href="#InfiniteOpt.generate_and_add_supports!"><code>InfiniteOpt.generate_and_add_supports!</code></a></li><li><a href="#InfiniteOpt.group_id-Tuple{AbstractArray{#s472,N} where N where #s472&lt;:ParameterRef}"><code>InfiniteOpt.group_id</code></a></li><li><a href="#InfiniteOpt.group_id-Tuple{ParameterRef}"><code>InfiniteOpt.group_id</code></a></li><li><a href="#InfiniteOpt.has_supports-Tuple{ParameterRef}"><code>InfiniteOpt.has_supports</code></a></li><li><a href="#InfiniteOpt.infinite_set-Tuple{ParameterRef}"><code>InfiniteOpt.infinite_set</code></a></li><li><a href="#InfiniteOpt.is_independent-Tuple{ParameterRef}"><code>InfiniteOpt.is_independent</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{ParameterRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.num_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.num_parameters</code></a></li><li><a href="#InfiniteOpt.num_supports-Tuple{ParameterRef}"><code>InfiniteOpt.num_supports</code></a></li><li><a href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>InfiniteOpt.parameter_by_name</code></a></li><li><a href="#InfiniteOpt.set_independent-Tuple{ParameterRef}"><code>InfiniteOpt.set_independent</code></a></li><li><a href="#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}"><code>InfiniteOpt.set_infinite_set</code></a></li><li><a href="#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s472,1} where #s472&lt;:Number}"><code>InfiniteOpt.set_supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{ParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{AbstractArray{#s472,N} where N where #s472&lt;:ParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.unset_independent-Tuple{ParameterRef}"><code>InfiniteOpt.unset_independent</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_variable-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_variable</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{ParameterRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{ParameterRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.lower_bound-Tuple{ParameterRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.name-Tuple{ParameterRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.set_lower_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_lower_bound</code></a></li><li><a href="#JuMP.set_name-Tuple{ParameterRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_upper_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{ParameterRef}"><code>JuMP.upper_bound</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@infinite_parameter" href="#InfiniteOpt.@infinite_parameter"><code>InfiniteOpt.@infinite_parameter</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@infinite_parameter(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> infinite parameter to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the parameter reference.</p><pre><code class="language-julia">@infinite_parameter(model, expr, kw_args...)</code></pre><p>Add a parameter to the model <code>model</code> described by the expression <code>expr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code>, the symbol <code>&gt;=</code>can be used instead of <code>≥</code>, and the symbo <code>in</code> can be used instead of <code>∈</code>) The expression <code>expr</code> can be of the form:</p><ul><li><code>paramexpr</code> creating parameters described by <code>paramexpr</code>.</li><li><code>lb ≤ paramexpr ≤ ub</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ [lb, ub]</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ dist</code> creating parameters described by <code>paramexpr</code> characterized  by the <code>Distributions.jl</code> distribution object <code>dist</code>.</li></ul><p>The expression <code>paramexpr</code> can be of the form:</p><ul><li><code>paramname</code> creating a scalar parameter of name <code>paramname</code></li><li><code>paramname[...]</code> or <code>[...]</code> creating a container of parameters</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the parameter lower bound for an interval set.</li><li><code>upper_bound</code>: Sets the value of the parameter upper bound for an interval set.</li><li><code>set</code>: The <code>InfiniteSet</code> characterizing the parameters see <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>  and <a href="../sets/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a>.</li><li><code>distribution</code>: Sets the <code>Distributions.jl</code> distribution object that characterizes the parameters.</li><li><code>supports</code>: Sets the support points for the parameters.</li><li><code>num_supports</code>: Specifies the number of supports to be automatically generated.                 Note that <code>supports</code> takes precedence. Defaults to 50.</li><li><code>sig_figs</code>: Specifies the number of significant digits that should be used             in automatic support generation. Defaults to 5.</li><li><code>independent</code>: Specifies if the each parameter is independent from each other or not. Defaults to false.</li><li><code>container</code>: Specify the container type. Defaults to automatic</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, 0 &lt;= x &lt;= 1)
x

julia&gt; @infinite_parameter(m, y[i = 1:2] in Normal(), num_supports = 10)
2-element Array{ParameterRef,1}:
 y[1]
 y[2]

julia&gt; z = @infinite_parameter(m, [&quot;a&quot;, &quot;b&quot;], distribution = Uniform(), independent = true)
2-dimensional DenseAxisArray{ParameterRef,2,...} with index sets:
    Dimension 1, &quot;a&quot;
    Dimension 2, &quot;b&quot;
And data, a 1×1 Array{ParameterRef,2}:
 noname</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/macros.jl#LL99-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_parameter-Tuple{Function,AbstractInfiniteSet}" href="#InfiniteOpt.build_parameter-Tuple{Function,AbstractInfiniteSet}"><code>InfiniteOpt.build_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_parameter(_error::Function, set::AbstractInfiniteSet,
                [num_params::Int = 1; num_supports::Int = 0,
                supports::Union{Number, Vector{&lt;:Number}} = Number[],
                independent::Bool = false,
                sig_fig::Int = 5])::InfOptParameter</code></pre><p>Returns a <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> given the appropriate information. This is analagous to <code>JuMP.build_variable</code>. Errors if supports violate the bounds associated <code>set</code>. Also errors if <code>set</code> contains a multivariate distribution with a different dimension than <code>num_params</code>. This is meant to primarily serve as a helper method for <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))
InfOptParameter{IntervalSet}([0, 3], [0, 1, 2, 3], false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL111-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_parameter-Tuple{InfiniteModel,InfOptParameter}" href="#InfiniteOpt.add_parameter-Tuple{InfiniteModel,InfOptParameter}"><code>InfiniteOpt.add_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_parameter(model::InfiniteModel, p::InfOptParameter,
              [name::String = &quot;&quot;])::ParameterRef</code></pre><p>Returns a <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> associated with the parameter <code>p</code> that is added to <code>model</code>. This adds a parameter to the model in a manner similar to <code>JuMP.add_variable</code>. This can be used to add parameters with the use of <a href="#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>. <a href="#InfiniteOpt.build_parameter-Tuple{Function,AbstractInfiniteSet}"><code>build_parameter</code></a> should be used to construct <code>p</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; p = build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))
InfOptParameter{IntervalSet}([0, 3], [0, 1, 2, 3], false)

julia&gt; param_ref = add_parameter(model, p, &quot;name&quot;)
name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL187-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{ParameterRef}" href="#InfiniteOpt.used_by_constraint-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by a constraint or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL223-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{ParameterRef}" href="#InfiniteOpt.used_by_measure-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by a measure or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(t)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL238-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_variable-Tuple{ParameterRef}" href="#InfiniteOpt.used_by_variable-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_variable(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by an infinite variable or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_variable(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL253-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{ParameterRef}" href="#InfiniteOpt.is_used-Tuple{ParameterRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used in the model or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL268-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,ParameterRef}" href="#JuMP.delete-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, pref::ParameterRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on <code>pref</code> are updated to exclude it. Errors if the parameter is contained in an <code>AbstractMeasureData</code> datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that <code>_check_param_in_data(pref, measure_data)</code> needs to be extended to allow deletion of parameters when custom <code>AbstractMeasureData</code> datatypes are used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t, x)*t + x) + z
Subject to
 z &gt;= 0.0
 g(t, x) + z &gt;= 42.0
 g(0.5, x) == 0
 t in [0, 6]
 x in [0, 1]

julia&gt; delete(model, x)

julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 z &gt;= 0.0
 t in [0, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL406-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, pref::ParameterRef)::Bool</code></pre><p>Extend the <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> function to accomodate infinite parameters. Returns true if the <code>InfiniteModel</code> stored in <code>pref</code> matches <code>model</code> and if the parameter index is used by <code>model</code>. It returns false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_valid(model, t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL517-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{ParameterRef}" href="#JuMP.name-Tuple{ParameterRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(pref::ParameterRef)::String</code></pre><p>Extend the <a href="../../JuMP/#JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> function to accomodate infinite parameters. Returns the name string associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(t)
&quot;t&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL537-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{ParameterRef,String}" href="#JuMP.set_name-Tuple{ParameterRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(pref::ParameterRef, name::String)</code></pre><p>Extend the <a href="../../JuMP/#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> function to accomodate infinite parameters. Set a new base name to be associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(t, &quot;time&quot;)

julia&gt; name(t)
&quot;time&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL553-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_parameters-Tuple{InfiniteModel}" href="#InfiniteOpt.num_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.num_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_parameters(model::InfiniteModel)::Int</code></pre><p>Return the number of infinite parameters currently present in <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_parameters(model)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL574-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_set-Tuple{ParameterRef}" href="#InfiniteOpt.infinite_set-Tuple{ParameterRef}"><code>InfiniteOpt.infinite_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_set(pref::ParameterRef)::AbstractInfiniteSet</code></pre><p>Return the infinite set associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_set(t)
[0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL611-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}" href="#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}"><code>InfiniteOpt.set_infinite_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_infinite_set(pref::ParameterRef, set::AbstractInfiniteSet)</code></pre><p>Specify the infinite set of <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_infinite_set(t, IntervalSet(0, 2))

julia&gt; infinite_set(t)
[0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL626-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{ParameterRef}" href="#JuMP.has_lower_bound-Tuple{ParameterRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(pref::ParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_lower_bound</code> function to accomodate infinite parameters. Return true if the set associated with <code>pref</code> has a defined lower bound or if a lower bound can be found. Extensions with user-defined infinite set types should extend <code>JuMP.has_lower_bound(set::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL644-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{ParameterRef}" href="#JuMP.lower_bound-Tuple{ParameterRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(pref::ParameterRef)::Number</code></pre><p>Extend the <code>JuMP.lower_bound</code> function to accomodate infinite parameters. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(t)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL663-L675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{ParameterRef,Number}" href="#JuMP.set_lower_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_lower_bound(pref::ParameterRef, lower::Number)</code></pre><p>Extend the <code>JuMP.set_lower_bound</code> function to accomodate infinite parameters. Updates the infinite set lower bound if such an operation is supported. Set extensions that seek to employ this should extend <code>JuMP.set_lower_bound(set::NewType, lower::Number)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(t, -1)

julia&gt; lower_bound(t)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL684-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{ParameterRef}" href="#JuMP.has_upper_bound-Tuple{ParameterRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(pref::ParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_upper_bound</code> function to accomodate infinite parameters. Return true if the set associated with <code>pref</code> has a defined upper bound or if a upper bound can be found. Extensions with user-defined sets should extend <code>JuMP.has_upper_bound(set::NewType)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL707-L720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{ParameterRef}" href="#JuMP.upper_bound-Tuple{ParameterRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(pref::ParameterRef)::Number</code></pre><p>Extend the <code>JuMP.upper_bound</code> function to accomodate infinite parameters. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined. Extensions with user-defined set types should extend <code>JuMP.has_upper_bound(set::NewType)</code> and <code>JuMP.upper_bound(set::NewType)</code> if appropriate.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(t)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL726-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{ParameterRef,Number}" href="#JuMP.set_upper_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_upper_bound(pref::ParameterRef, lower::Number)</code></pre><p>Extend the <code>JuMP.set_upper_bound</code> function to accomodate infinite parameters. Updates the infinite set upper bound if and only if it is an IntervalSet. Errors otherwise. Extensions with user-defined infinite sets should extend <code>JuMP.set_upper_bound(set::NewType, upper::Number)</code> if appropriate.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_upper_bound(t, 2)

julia&gt; upper_bound(t)
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL749-L764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{ParameterRef}" href="#InfiniteOpt.num_supports-Tuple{ParameterRef}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(pref::ParameterRef)::Int</code></pre><p>Return the number of support points associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_supports(t)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL772-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_supports-Tuple{ParameterRef}" href="#InfiniteOpt.has_supports-Tuple{ParameterRef}"><code>InfiniteOpt.has_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_supports(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> has supports or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_supports(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL787-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{ParameterRef}" href="#InfiniteOpt.supports-Tuple{ParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(pref::ParameterRef)::Vector</code></pre><p>Return the support points associated with <code>pref</code>. Errors if there are no supports.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; supports(t)
2-element Array{Int64,1}:
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL800-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{AbstractArray{#s472,N} where N where #s472&lt;:ParameterRef}" href="#InfiniteOpt.supports-Tuple{AbstractArray{#s472,N} where N where #s472&lt;:ParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(prefs::AbstractArray{&lt;:ParameterRef})::Vector</code></pre><p>Return the support points associated with an array of <code>prefs</code> formatted as a vector of SparseAxisArrays following the format of the input array. If the parameters are not independent then the supports of each parameter are simply spliced together. Alternatively can call <code>supports.</code> to more efficiently obtain an array of the same input format whose parameter references have been replaced with their supports. Errors if all the parameter references do not have the same group ID number (were intialized together as an array) or if the nonindependent parameters have support vectors of different lengths. If the parameters are independent then all the unique combinations are identified and returned as supports. Warning this operation is computationally expensive if there exist a large number of combinations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; x = @infinite_parameter(model, [i = 1:2], set = IntervalSet(-1, 1),
                               base_name = &quot;x&quot;, independent = true)
2-element Array{ParameterRef,1}:
 x[1]
 x[2]

julia&gt; for i = 1:length(x)
           set_supports(x[i], [-1, 1])
       end

julia&gt; supports(x)
4-element Array{JuMP.Containers.SparseAxisArray,1}:
   [2]  =  -1
  [1]  =  -1
   [2]  =  1
  [1]  =  -1
   [2]  =  -1
  [1]  =  1
   [2]  =  1
  [1]  =  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL819-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s472,1} where #s472&lt;:Number}" href="#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s472,1} where #s472&lt;:Number}"><code>InfiniteOpt.set_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_supports(pref::ParameterRef, supports::Vector{&lt;:Number}; [force = false])</code></pre><p>Specify the support points for <code>pref</code>. Errors if the supports violate the bounds associated with the infinite set. Warns if the points are not unique. If <code>force</code> this will overwrite exisiting supports otherwise it will error if there are existing supports.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_supports(t, [0, 1])

julia&gt; supports(t)
2-element Array{Int64,1}:
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL891-L908">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s472,1} where #s472&lt;:Number}}" href="#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s472,1} where #s472&lt;:Number}}"><code>InfiniteOpt.add_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_supports(pref::ParameterRef, supports::Union{Number, Vector{&lt;:Number}})</code></pre><p>Add additional support points for <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; add_supports(t, 0.5)

julia&gt; supports(t)
3-element Array{Float64,1}:
 0.0
 1.0
 0.5

julia&gt; add_supports(t, [0.25, 1])

julia&gt; supports(t)
4-element Array{Float64,1}:
 0.0
 1.0
 0.5
 0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL931-L955">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_supports-Tuple{ParameterRef}" href="#InfiniteOpt.delete_supports-Tuple{ParameterRef}"><code>InfiniteOpt.delete_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_supports(pref::ParameterRef)</code></pre><p>Delete the support points for <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_supports(t)

julia&gt; supports(t)
ERROR: Parameter t does not have supports.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL971-L983">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}" href="#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>InfiniteOpt.fill_in_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_in_supports!(model::InfiniteModel; [num_supports::Int = 10,
                  sig_fig::Int = 5])</code></pre><p>Automatically generate support points for all infinite parameters in model. User can specify the number of significant figures kept after decimal point for the auto-generated supports wtih <code>sig_fig</code>. This calls <a href="#InfiniteOpt.fill_in_supports!-Tuple{ParameterRef}"><code>fill_in_supports!</code></a> for each parameter in the model. See <a href="#InfiniteOpt.fill_in_supports!-Tuple{ParameterRef}"><code>fill_in_supports!</code></a> for more information. Errors if one of the infinite set types is unrecognized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(model, num_supports = 4, sig_fig = 3)

julia&gt; supports(x)
4-element Array{Number,1}:
 0.0
 0.333
 0.667
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1046-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.fill_in_supports!-Tuple{ParameterRef}" href="#InfiniteOpt.fill_in_supports!-Tuple{ParameterRef}"><code>InfiniteOpt.fill_in_supports!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_in_supports!(pref::ParameterRef; [num_supports::Int = 10,
                                       sig_fig::Int = 5])</code></pre><p>Automatically generate support points for a particular infinite parameter <code>pref</code>. Generating <code>num_supports</code> for the parameter. The supports are generated uniformly if the underlying infinite set is an <code>IntervalSet</code> or they are generating randomly accordingly to the distribution if the set is a <code>DistributionSet</code>. User can specify the number of digits kept after decimal point for the auto-generated supports wtih <code>sig_fig</code>. Extensions that use user defined set types should extend <a href="#InfiniteOpt.generate_and_add_supports!"><code>generate_and_add_supports!</code></a> and/or <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> as needed. Errors if the infinite set type is not recognized.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(x, num_supports = 4, sig_fig = 3)

julia&gt; supports(x)
4-element Array{Number,1}:
 0.0
 0.333
 0.667
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1078-L1104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generate_and_add_supports!" href="#InfiniteOpt.generate_and_add_supports!"><code>InfiniteOpt.generate_and_add_supports!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_and_add_supports!(pref::ParameterRef, set::AbstractInfiniteSet;
                           [num_supports::Int = 10, sig_fig::Int = 5])</code></pre><p>Generate supports for <code>pref</code> via <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> and add them to <code>pref</code>. This is intended as an extendable internal method for <a href="#InfiniteOpt.fill_in_supports!-Tuple{ParameterRef}"><code>fill_in_supports!</code></a>. Note that if <code>pref</code> is part of a <code>DistributionSet</code> that features a multivariate distribution, all the associated parameters with <code>pref</code> will also have supports added to them. Most extensions that empoy user-defined infinite sets can typically enable this by extending <a href="../sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a>. However, in some cases it may be necessary to extend this when more complex operations need to take place then just adding supports to a single infinite parameter (e.g., how we enable multivariate distribution sets). Errors if the infinite set type is not recognized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1115-L1129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.group_id-Tuple{ParameterRef}" href="#InfiniteOpt.group_id-Tuple{ParameterRef}"><code>InfiniteOpt.group_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">group_id(pref::ParameterRef)::Int</code></pre><p>Return the group ID number for <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; group_id(t)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1154-L1164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.group_id-Tuple{AbstractArray{#s472,N} where N where #s472&lt;:ParameterRef}" href="#InfiniteOpt.group_id-Tuple{AbstractArray{#s472,N} where N where #s472&lt;:ParameterRef}"><code>InfiniteOpt.group_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">group_id(prefs::AbstractArray{&lt;:ParameterRef})::Int</code></pre><p>Return the group ID number for a group of <code>prefs</code>. Error if contains multiple groups.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; group_id([x[1], x[2]])
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1169-L1180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_independent-Tuple{ParameterRef}" href="#InfiniteOpt.is_independent-Tuple{ParameterRef}"><code>InfiniteOpt.is_independent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_independent(pref::ParameterRef)::Bool</code></pre><p>Returns true for <code>pref</code> if it is independent or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_independent(t)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1188-L1198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_independent-Tuple{ParameterRef}" href="#InfiniteOpt.set_independent-Tuple{ParameterRef}"><code>InfiniteOpt.set_independent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_independent(pref::ParameterRef)</code></pre><p>Specify that <code>pref</code> be independent.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_independent(t)

julia&gt; is_independent(t)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1203-L1215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.unset_independent-Tuple{ParameterRef}" href="#InfiniteOpt.unset_independent-Tuple{ParameterRef}"><code>InfiniteOpt.unset_independent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unset_independent(pref::ParameterRef)</code></pre><p>Specify that <code>pref</code> be not independent.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; unset_independent(t)

julia&gt; is_independent(t)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1223-L1235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}" href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>InfiniteOpt.parameter_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_by_name(model::InfiniteModel, name::String)::Union{ParameterRef,
                                                             Nothing}</code></pre><p>Return the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_by_name(model, &quot;t&quot;)
t</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1243-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_parameters-Tuple{InfiniteModel}" href="#InfiniteOpt.all_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.all_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all_parameters(model::InfiniteModel)::Vector{ParameterRef}</code></pre><p>Return all of the infinite parameter references currently in <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; all_parameters(model)
3-element Array{ParameterRef,1}:
 t
 x[1]
 x[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/8b61c498c0a7a5be203eab8dd22ce909f21c106d/src/parameters.jl#LL1281-L1294">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sets/">« Infinite Sets</a><a class="docs-footer-nextpage" href="../finite_parameter/">Finite Parameters »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 March 2020 19:33">Tuesday 24 March 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
