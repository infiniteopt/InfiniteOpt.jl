<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Derivatives · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start Guide</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li class="is-active"><a class="tocitem" href>Derivatives</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Advanced-Definition"><span>Advanced Definition</span></a></li><li><a class="tocitem" href="#Derivative-Evaluation"><span>Derivative Evaluation</span></a></li><li><a class="tocitem" href="#Query-Methods"><span>Query Methods</span></a></li><li><a class="tocitem" href="#Modification-Methods"><span>Modification Methods</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#deriv_methods"><span>Methods/Macros</span></a></li></ul></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Derivatives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Derivatives</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/derivative.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="deriv_page"><a class="docs-heading-anchor" href="#deriv_page">Derivative Operators</a><a id="deriv_page-1"></a><a class="docs-heading-anchor-permalink" href="#deriv_page" title="Permalink"></a></h1><p>A guide and manual for the definition and use of derivatives in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Derivative operators commonly arise in many infinite-dimensional problems,  particularly in space-time optimization. <code>InfiniteOpt.jl</code> provides a simple yet  powerful interface to model these objects for derivatives of any order, including  partial derivatives. Derivatives can be used in defining measures and constraints. </p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Derivative operators can defined a few different ways in <code>InfiniteOpt</code>. To motivate  these, let&#39;s first define an <code>InfiniteModel</code> along with some parameters and variables:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP, Distributions;

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10], 
                           derivative_method = OrthogonalCollocation(3));

julia&gt; @infinite_parameter(model, ξ in Uniform(-1, 1));

julia&gt; @infinite_variable(model, y(t, ξ));

julia&gt; @infinite_variable(model, q(t));</code></pre><p>Notice that we used the <code>derivative_method</code> keyword argument to specify which  numerical method will be used to evaluate any derivatives that depend on that  infinite parameter <code>t</code>. In this case we, specified to use orthogonal collocation  over finite elements using 3 nodes. We&#39;ll come back to this just a little further  below to more fully describe the various methods we can use. </p><p>First, let&#39;s discuss how to define derivatives in <code>InfiniteOpt.jl</code>. Principally,  this is accomplished via <a href="#InfiniteOpt.@deriv"><code>@deriv</code></a> which will operate on a particular  <code>InfiniteOpt</code> expression (containing parameters, variables, and/or measures) with  respect to infinite parameters specified with their associated orders. Behind the  scenes all the appropriate calculus will be applied, creating derivative variables  as needed. For example, we can define the following:</p><pre><code class="language-julia-repl">julia&gt; d1 = @deriv(y, t)
∂/∂t[y(t, ξ)]

julia&gt; d2 = @deriv(y, t, ξ)
∂/∂ξ[∂/∂t[y(t, ξ)]]

julia&gt; d3 = @∂(q, t^2)
∂/∂t[∂/∂t[q(t)]]

julia&gt; d_expr = @deriv(y * q - 2t, t)
∂/∂t[y(t, ξ)]*q(t) + ∂/∂t[q(t)]*y(t, ξ) - 2</code></pre><p>Thus, we can define derivatives in a variety of forms according to the problem at  hand. The last example even shows how the product rule is correctly applied. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For convenience in making more compact code we provide <a href="#InfiniteOpt.∂"><code>∂</code></a> and  <a href="#InfiniteOpt.@∂"><code>@∂</code></a> as wrappers for <a href="#InfiniteOpt.deriv"><code>deriv</code></a> and <a href="#InfiniteOpt.@deriv"><code>@deriv</code></a>, respectively.</p></div></div><p>Also, notice that the appropriate analytic calculus is applied to infinite  parameters. For example, we could also compute:</p><pre><code class="language-julia-repl">julia&gt; @deriv(3t^2 - 2t, t)
6 t - 2</code></pre><p>Conveniently, <code>@deriv</code> can be called within any measure and constraint. However,  in certain cases we may need to define an initial guess (initial guess trajectory).  This can be accomplished in 2 ways:</p><ul><li>Call <a href="#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef,Union{Function, Real}}"><code>set_start_value_function</code></a>  using the individual derivative (e.g., <code>d1</code> above)</li><li>Define the derivative using <a href="#InfiniteOpt.@derivative_variable"><code>@derivative_variable</code></a> and use the <code>start</code> keyword argument.</li></ul><p>In either case, a single value can be given or a start value function that will generate a value in accordance with the support values (i.e., following the same  syntax as infinite variables). For example, we can specify the starting value of  <code>d1</code> to <code>0</code> via the following:</p><pre><code class="language-julia-repl">julia&gt; set_start_value_function(d1, 0)</code></pre><p>Now let&#39;s return to our discussion on derivative evaluation methods. These are the  methods that can/will be invoked to transcript the derivatives when solving the  model. The methods native to <code>InfiniteOpt</code> are described in the table below:</p><table><tr><th style="text-align: center">Method</th><th style="text-align: center">Type</th><th style="text-align: center">Needed Boundary Conditions</th><th style="text-align: center">Creates Supports</th></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="#InfiniteOpt.Forward"><code>Forward</code></a></td><td style="text-align: center">Final &amp; optional Initial</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="#InfiniteOpt.Central"><code>Central</code></a></td><td style="text-align: center">Initial &amp; Final</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="#InfiniteOpt.Backward"><code>Backward</code></a></td><td style="text-align: center">Initial &amp; optional Final</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.OrthogonalCollocation"><code>OrthogonalCollocation</code></a></td><td style="text-align: center"><a href="#InfiniteOpt.Lobatto"><code>Lobatto</code></a></td><td style="text-align: center">Initial</td><td style="text-align: center">Yes</td></tr></table><p>Here the default method is backward finite difference. These are enforced on an  infinite parameter basis (i.e., the parameter the differential operator is taken  with respect to). Thus, in the above examples any derivatives taken with respect to  <code>t</code> will use orthogonal collocation on finite elements since that is what we  specified as our derivative method. More information is provided in the  <a href="#Derivative-Methods">Derivative Methods</a> Section below. However, we note here that  <a href="#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef,AbstractDerivativeMethod}"><code>set_derivative_method</code></a> can be invoked anytime after parameter definition  to specify/modify the derivative method used. More conveniently, we can call  <a href="#InfiniteOpt.set_all_derivative_methods"><code>set_all_derivative_methods</code></a>:</p><pre><code class="language-julia-repl">julia&gt; set_all_derivative_methods(model, FiniteDifference(Forward))
</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p><code>InfiniteOpt</code> does not ensure proper boundary conditions are provided by the  user. Thus, it is imperative that the user ensure these are provided appropriately  with the derivative evaluation method that is used. We recommend specifying  such conditions via <a href="../constraint/#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a>.</p></div></div><h2 id="Advanced-Definition"><a class="docs-heading-anchor" href="#Advanced-Definition">Advanced Definition</a><a id="Advanced-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Definition" title="Permalink"></a></h2><p>This section will detail the inner-workings and more advanced details behind  defining derivatives in <code>InfiniteOpt</code>.</p><h3 id="Manual-Definition"><a class="docs-heading-anchor" href="#Manual-Definition">Manual Definition</a><a id="Manual-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Definition" title="Permalink"></a></h3><p>The workflow for derivative definition mirrors that of variable definition as  summarized in the following steps:</p><ol><li>Define the variable information via a <code>JuMP.VariableInfo</code>.</li><li>Build the derivative using <a href="#InfiniteOpt.build_derivative"><code>build_derivative</code></a>.</li><li>Add the derivative to the model via <a href="#InfiniteOpt.add_derivative"><code>add_derivative</code></a>.</li></ol><p>To exemplify this process, let&#39;s first define appropriate variable information:</p><pre><code class="language-julia-repl">julia&gt; info = VariableInfo(true, 0., true, 42., false, 0., false, 0., false, false);</code></pre><p>More detailed information on <code>JuMP.VariableInfo</code> is provided in the  <a href="../variable/#Variable-Definition-Methodology">Variable Definition Methodology</a> section. </p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Instances of <code>JuMP.VariableInfo</code> used to define derivatives should have  <code>info.binary = false</code> and <code>info.integer = false</code>, since most derivative  evaluation methods require that derivatives be continuous.</p></div></div><p>Now that we have our variable information we can make a derivative using  <a href="#InfiniteOpt.build_derivative"><code>build_derivative</code></a>:</p><pre><code class="language-julia-repl">julia&gt; d = build_derivative(error, info, y, ξ);

julia&gt; d isa Derivative
true</code></pre><p>Here the argument variable can be an infinite variable, reduced variable,  derivative, or measure that depends on the infinite parameter provided. This will  error to the contrary or if such a derivative has already been to the model  associated with the infinite parameter. </p><p>Now we can add the derivative to the model via <a href="#InfiniteOpt.add_derivative"><code>add_derivative</code></a> which  will add the <a href="#InfiniteOpt.Derivative"><code>Derivative</code></a> object and return <code>GeneralVariableRef</code> pointing  to it that we can use in <code>InfiniteOpt</code> expressions:</p><pre><code class="language-julia-repl">julia&gt; dref = add_derivative(model, d)
∂/∂ξ[y(t, ξ)]</code></pre><p>This will also create any appropriate information based constraints (e.g., lower  bounds).</p><p>Finally, we note that higher order derivatives are made by simply nesting this  process.</p><h3 id="Macro-Definition"><a class="docs-heading-anchor" href="#Macro-Definition">Macro Definition</a><a id="Macro-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-Definition" title="Permalink"></a></h3><p>There are two macros we provide for defining derivatives:  <a href="#InfiniteOpt.@derivative_variable"><code>@derivative_variable</code></a> and <a href="#InfiniteOpt.@deriv"><code>@deriv</code></a>. </p><p>First, <a href="#InfiniteOpt.@derivative_variable"><code>@derivative_variable</code></a> simply automates the process described above in a manner inspired the by the syntax  of the variable macros. As such it will support all the same keywords and  constraint syntax used with the variable macros. For example, we can define the  derivative <span>$\frac{\partial^2 y(t, \xi)}{\partial t^2}$</span> using <code>d1</code> (defined in the  a Basic Usage section) enforcing a lower bound of 1 with an initial guess of 0 and  assign it to an alias <code>GeneralVariableRef</code> called <code>dydt2</code>:</p><pre><code class="language-julia-repl">julia&gt; @derivative_variable(model, d(d1)/d(t), dydt2 &gt;= 1, start = 0)
dydt2(t, ξ)</code></pre><p>This will also support anonymous definition and multi-dimensional definition,   please refer to <a href="#InfiniteOpt.@derivative_variable"><code>@derivative_variable</code></a> in the manual for the full details.</p><p>Second, for more convenient definition we use <a href="#InfiniteOpt.@deriv"><code>@deriv</code></a> (or <a href="#InfiniteOpt.@∂"><code>@∂</code></a>) as shown in the  Basic Usage section above. Unlike <code>@derivative_variable</code> this can handle any  <code>InfiniteOpt</code> expression as the argument input and will automatically take care of  any redundant derivative creation by using the existing derivatives as appropriate.  It also can build derivatives that depend on multiple infinite parameters and/or  are taken to higher orders. This is accomplished via recursive derivative  definition, handling the nesting as appropriate. For example, we can &quot;define&quot;  <span>$\frac{\partial^2 y(t, \xi)}{\partial t^2}$</span> again:</p><pre><code class="language-julia-repl">julia&gt; @deriv(d1, t)
dydt2(t, ξ)

julia&gt; @deriv(y, t^2)
dydt2(t, ξ)</code></pre><p>Notice that no error is thrown (which would have occurred if we called  <code>@derivative_variable</code> again) and that the derivative references all point to the  same derivative object we defined up above with its alias name <code>dydt2</code>. This macro  can also tackle complex expressions using the appropriate calculus such as:</p><pre><code class="language-julia-repl">julia&gt; @deriv(∫(y, ξ) * q, t)
∂/∂t[∫{ξ ∈ [-1, 1]}[y(t, ξ)]]*q(t) + ∂/∂t[q(t)]*∫{ξ ∈ [-1, 1]}[y(t, ξ)]</code></pre><p>Thus, demonstrating the convenience of using <code>@deriv</code>.</p><p>With all this in mind, we recommend using <code>@deriv</code> as the defacto method, but then  using <code>@derivative_variable</code> as a convenient way to specify information constraints  and an initial guess value/trajectory. </p><h2 id="Derivative-Evaluation"><a class="docs-heading-anchor" href="#Derivative-Evaluation">Derivative Evaluation</a><a id="Derivative-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Evaluation" title="Permalink"></a></h2><p>In this section, we detail how derivatives are evaluated in <code>InfiniteOpt</code> to then  be used in reformulating the model for solution. </p><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>To motivate the principles behind numerical derivative evaluation/transcription,  let&#39;s first consider the initial value problem:</p><div>\[\frac{d y(t)}{dt} = f(t, y(t)), \ \ \ y(t_0) = y_0\]</div><p>With a finite support set <span>$\{t_0, t_1, \dots, t_k\}$</span> we can numerically  approximate the value of <span>$\frac{d y(t_n)}{dt}$</span> at each time point <span>$t_n$</span> via  the Euler method (i.e., forward finite difference). We thus obtain a system of  equations:</p><div>\[\begin{aligned}
&amp;&amp;&amp; y(t_{n+1}) = y(t_n) + (t_{n+1} - t_n) \frac{d y(t_n)}{dt}, &amp;&amp; \forall n = 0, \dots, k-1\\
&amp;&amp;&amp; \frac{d y(t_n)}{dt} = f(t_n, y(t_n)), &amp;&amp; \forall n = 0, \dots, k \\ 
&amp;&amp;&amp; y(t_0) = y_0
\end{aligned}\]</div><p>Thus, we obtain 3 sets of equations: </p><ol><li>constraint transcriptions</li><li>auxiliary derivative equations </li><li>boundary conditions. </li></ol><p>In the case above, we could reduce the number of equations by substituting out the  point derivatives in the constraint transcriptions since we have explicit  relationships in the auxiliary equations. However, this is not possible in general,  such as when we encounter more complex partial differential equations. </p><p>Thus, in <code>InfiniteOpt</code> derivatives are treated as variables which can be contained  implicitly in constraints and/or measures. This allows us to support implicit  dependencies and higher order derivatives. This means that when the model is  reformulated, its constraints and measures can be reformulated as normal  (treating any derivative dependencies as variables). We then can apply the  appropriate derivative evaluation technique to derive the necessary set of  auxiliary derivative equations to properly characterize the derivative variables.  This can be formalized as:</p><div>\[\begin{aligned}
&amp;&amp;&amp; f_j(y(\lambda), Dy(\lambda)) \leq 0, &amp;&amp; \forall j \in J, \lambda \in \Lambda \\
&amp;&amp;&amp; h_i(y(\lambda), Dy(\lambda)) == 0, &amp;&amp; \forall i \in I, \lambda \in \Lambda \\
&amp;&amp;&amp; g_k(y(\hat{\lambda}), Dy(\hat{\lambda})) == 0, &amp;&amp; \forall k \in K, \hat{\lambda} \in \hat{\Lambda}
\end{aligned}\]</div><p>where <span>$y(\lambda)$</span> and <span>$Dy(\lambda)$</span> denote all the variables and derivatives  in the problem and <span>$\lambda$</span> the denote all the problem&#39;s infinite parameters.  With this let the constraints <span>$f_j$</span> denote the problem constraints which can  contain any variables, parameters, derivatives, and/or measures associated with  the problem. The constraints <span>$h_i$</span> denote the auxiliary derivative equations  formed by the appropriate numerical method to implicitly define the behavior of  the derivative variables present in <span>$f_j$</span>. Finally, the necessary boundary  conditions are provided in the constraints <span>$g_k$</span>.</p><p>Note that this general paradigm captures a wide breadth of problems and  derivative evaluation techniques. Higher order derivatives are dealt with naturally  since such techniques can be applied to nested derivative operators recursively.  For example, consider the second-order partial derivative:</p><div>\[\frac{\partial^2 y(t, \xi)}{\partial t^2} = \frac{\partial}{\partial t}\left(\frac{\partial y(t, \xi)}{\partial t}\right)\]</div><p>The 2 forms are equivalent thus when we apply the Euler method we obtain the  following auxiliary equations:</p><div>\[\begin{aligned}
&amp;&amp;&amp; y(t_{n+1}, \xi) = y(t_n, \xi) + (t_{n+1} - t_n) \frac{\partial y(t_n, \xi)}{\partial t}, &amp;&amp; \forall \xi \in \mathcal{D}_\xi, n = 0, \dots, k-1\\
&amp;&amp;&amp; \frac{\partial y(t_{n+1}, \xi)}{\partial t} = \frac{\partial y(t_n, \xi)}{\partial t} + (t_{n+1} - t_n) \frac{\partial^2 y(t_n, \xi)}{\partial t^2}, &amp;&amp; \forall \xi \in \mathcal{D}_\xi, n = 0, \dots, k-1\\
\end{aligned}\]</div><p>In the section below we detail the derivative evaluation methods that <code>InfiniteOpt</code>  natively implements.</p><h3 id="Derivative-Methods"><a class="docs-heading-anchor" href="#Derivative-Methods">Derivative Methods</a><a id="Derivative-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Methods" title="Permalink"></a></h3><p>As discussed briefly above in the Basic Usage section, we natively employ 4  derivative methods in <code>InfiniteOpt</code> which are summarized:</p><table><tr><th style="text-align: center">Method</th><th style="text-align: center">Type</th><th style="text-align: center">Needed Boundary Conditions</th><th style="text-align: center">Creates Supports</th></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="#InfiniteOpt.Forward"><code>Forward</code></a></td><td style="text-align: center">Final &amp; optional Initial</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="#InfiniteOpt.Central"><code>Central</code></a></td><td style="text-align: center">Initial &amp; Final</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a></td><td style="text-align: center"><a href="#InfiniteOpt.Backward"><code>Backward</code></a></td><td style="text-align: center">Initial &amp; optional Final</td><td style="text-align: center">No</td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.OrthogonalCollocation"><code>OrthogonalCollocation</code></a></td><td style="text-align: center"><a href="#InfiniteOpt.Lobatto"><code>Lobatto</code></a></td><td style="text-align: center">Initial</td><td style="text-align: center">Yes</td></tr></table><p>These methods are defined in association with individual infinite parameters and  will be applied to any derivatives that are taken with respect to that parameter.  These methods are specified via the <code>derivative_method</code> keyword argument in the  <a href="../parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> macro and can also be defined by invoking  <a href="#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef,AbstractDerivativeMethod}"><code>set_derivative_method</code></a> or <a href="#InfiniteOpt.set_all_derivative_methods"><code>set_all_derivative_methods</code></a>:</p><pre><code class="language-julia-repl">julia&gt; set_derivative_method(t, FiniteDifference(Forward))
</code></pre><p>In this example, we set <code>t</code>&#39;s derivative evaluation method to use forward finite  difference. This will also reset any changes that were made with the old method  (e.g., removing old collocation points). Now let&#39;s describe the ins and outs of  these methods.</p><p>The first class of methods pertain to finite difference techniques. The syntax  for specifying these techniques is described in <a href="#InfiniteOpt.FiniteDifference"><code>FiniteDifference</code></a> and  exemplified here:</p><pre><code class="language-julia-repl">julia&gt; FiniteDifference(Forward, true)
FiniteDifference(Forward, true)</code></pre><p>where the first argument indicates the type of finite difference we wish to employ  and the second argument indicates if this method should be enforced on boundary  points. By default, we have <code>FiniteDifference(Backward, true)</code> which is the default  for all infinite parameters. </p><p>Forward finite difference (i.e., explicit Euler) is exemplified by approximating first  order derivative <span>$\frac{d y(t)}{dt}$</span> via </p><div>\[y(t_{n+1}) = y(t_n) + (t_{n+1} - t_{n})\frac{d y(t_n)}{dt}, \ \forall n = 0, 1, \dots, k-1\]</div><p>Note that in this case, the boundary relation corresponds to <span>$n = 0$</span> and would  be included if we set <code>FiniteDifference(Forward, true)</code> or would excluded if we  let the second argument be <code>false</code>. We recommend, selecting <code>false</code> when an initial  condition is provided. Also, note that a terminal condition should be provided  when using this method since an auxiliary equation for the derivative at the  terminal point cannot be made. Thus, if a terminal condition is not given terminal  point derivative will be a free variable.</p><p>Central finite difference is exemplified by approximating the first order derivative  <span>$\frac{d y(t)}{dt}$</span> via</p><div>\[y(t_{n+1}) = y(t_{n-1}) + (t_{n+1} - t_{n-1})\frac{d y(t_n)}{dt}, \ \forall n = 1, 2, \dots, k-1\]</div><p>Note that this form cannot be invoked at <span>$n = 0$</span> or <span>$n = k$</span> and cannot  an equation at either boundary. With this in mind the syntax is <code>FiniteDifference(Central)</code>  where the second argument is omitted since it doesn&#39;t apply to this scheme. As a  result both initial and terminal conditions should be specified otherwise the  derivatives at those points will be free variables.</p><p>Backward finite difference (i.e., implicit euler) is our last (and default)  finite difference method and is exemplified by approximating the first order  derivative <span>$\frac{d y(t)}{dt}$</span> via</p><div>\[y(t_{n}) = y(t_{n-1}) + (t_{n} - t_{n-1})\frac{d y(t_{n})}{dt}, \ \forall n = 1, 2, \dots, k\]</div><p>Here the boundary case corresponds to <span>$n = k$</span> and would be included if we set  <code>FiniteDifference(Backward, true)</code> (the default) or excluded if we set the second  argument to <code>false</code>. We recommend, selecting <code>false</code> when a terminal condition is  provided. Also, note that an initial condition should always be given otherwise  the derivative at the first point will be free.</p><p>Finally, we employ orthogonal collocation on finite elements via the  <a href="#InfiniteOpt.OrthogonalCollocation"><code>OrthogonalCollocation</code></a> object (please refer to it in the manual for  complete syntax details). In general terms, this technique fits an <span>$m$</span> degree  polynomial to each finite element (i.e., sequential support pair) and this fit is  done via <span>$m+1$</span> collocation nodes (supports) which include the finite element  supports along with <span>$m-1$</span> additional internal collocation nodes chosen at  orthogonal points to the polynomial. The typical syntax for specifying this method  is <code>OrthogonalCollocation(num_nodes)</code> where <code>num_nodes</code> indicates the number  collocation nodes to be used for each finite element. For example, we can specify  to use 3 collocation nodes (i.e., 1 internal node per finite element) corresponding  to a 2nd degree polynomial via</p><pre><code class="language-julia-repl">julia&gt; OrthogonalCollocation(3)
OrthogonalCollocation(1, Lobatto)</code></pre><p>Notice that the 2nd attribute is <code>Lobatto</code> which indicates that we are using  collocation nodes selected via Lobatto quadrature. This is currently the only  supported technique employed by <code>OrthogonalCollocation</code> although more may be added  in future versions. Please note that an initial condition must be provided otherwise  the corresponding derivative will be free variable. For more information on  orthogonal collocation over finite elements, this  <a href="http://apmonitor.com/do/index.php/Main/OrthogonalCollocation">page</a> provides a  good reference.</p><p>Other methods can be employed via user-defined extensions. Please visit our  Extensions page for more information.</p><h3 id="User-Invoked-Evaluation"><a class="docs-heading-anchor" href="#User-Invoked-Evaluation">User-Invoked Evaluation</a><a id="User-Invoked-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#User-Invoked-Evaluation" title="Permalink"></a></h3><p>Typically, derivative evaluation is handled when the model is reformulated in such  a way that the <code>InfiniteModel</code> is unmodified such that modifications and repeated  solutions can be done efficiently and seamlessly. This is also the recommended  workflow. However, we do provide user accessible derivative evaluation methods  that generate the auxiliary derivative equations and add them to the <code>InfiniteModel</code>. This can be useful for visualizing how these techniques work and can be helpful for  user-defined reformulation extensions (i.e., optimizer model extensions).</p><p>We can build these relations for a particular derivative via <a href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>evaluate</code></a>.  For example, let&#39;s build evaluation equations for <code>d1</code>:</p><pre><code class="language-julia-repl">julia&gt; d1 
∂/∂t[y(t, ξ)]

julia&gt; fill_in_supports!(t, num_supports = 3) # add supports first

julia&gt; evaluate(d1)

julia&gt; derivative_constraints(d1)
2-element Array{InfOptConstraintRef,1}:
 5 ∂/∂t[y(t, ξ)](5, ξ) - y(10, ξ) + y(5, ξ) = 0.0, ∀ ξ ~ Uniform
 5 ∂/∂t[y(t, ξ)](0, ξ) - y(5, ξ) + y(0, ξ) = 0.0, ∀ ξ ~ Uniform</code></pre><p>Note that we made sure <code>t</code> had supports first over which we could carry out the  evaluation, otherwise an error would have been thrown. Moreover, once the  evaluation was completed we were able to access the auxiliary equations via  <a href="#InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}"><code>derivative_constraints</code></a>. </p><p>We can also, add the necessary auxiliary equations for all the derivatives in the  model if we call <a href="#InfiniteOpt.evaluate_all_derivatives!"><code>evaluate_all_derivatives!</code></a>:</p><pre><code class="language-julia-repl">julia&gt; fill_in_supports!(ξ, num_supports = 4) # add supports first

julia&gt; evaluate_all_derivatives!(model)

julia&gt; derivative_constraints(dydt2)
2-element Array{InfOptConstraintRef,1}:
 5 dydt2(5, ξ) - ∂/∂t[y(t, ξ)](10, ξ) + ∂/∂t[y(t, ξ)](5, ξ) = 0.0, ∀ ξ ~ Uniform
 5 dydt2(0, ξ) - ∂/∂t[y(t, ξ)](5, ξ) + ∂/∂t[y(t, ξ)](0, ξ) = 0.0, ∀ ξ ~ Uniform</code></pre><p>Finally, we note that once derivative constraints have been added to the  <code>InfiniteModel</code> any changes to the respective infinite parameter sets, supports,  or derivative method will necessitate the deletion of these auxiliary constraints  and a warning will be thrown to indicate such:</p><pre><code class="language-julia-repl">julia&gt; derivative_constraints(d1)
2-element Array{InfOptConstraintRef,1}:
 5 ∂/∂t[y(t, ξ)](5, ξ) - y(10, ξ) + y(5, ξ) = 0.0, ∀ ξ ~ Uniform
 5 ∂/∂t[y(t, ξ)](0, ξ) - y(5, ξ) + y(0, ξ) = 0.0, ∀ ξ ~ Uniform

julia&gt; add_supports(t, 0.2)
┌ Warning: Support/method changes will invalidate existing derivative evaluation constraints that have been added to the InfiniteModel. Thus, these are being deleted.
└ @ InfiniteOpt ~/build/pulsipher/InfiniteOpt.jl/src/scalar_parameters.jl:656

julia&gt; has_derivative_constraints(d1)
false</code></pre><h2 id="Query-Methods"><a class="docs-heading-anchor" href="#Query-Methods">Query Methods</a><a id="Query-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Methods" title="Permalink"></a></h2><p>Here we describe the various query techniques that we can employ on derivatives  in <code>InfiniteOpt</code>.</p><h3 id="Basic-Queries"><a class="docs-heading-anchor" href="#Basic-Queries">Basic Queries</a><a id="Basic-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Queries" title="Permalink"></a></h3><p>First, let&#39;s overview the basic object inquiries: <a href="#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}"><code>derivative_argument</code></a>,  <a href="#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}"><code>operator_parameter</code></a>, <a href="#InfiniteOpt.derivative_method-Tuple{DerivativeRef}"><code>derivative_method</code></a>, and <a href="../variable/#JuMP.name-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>name</code></a>:</p><pre><code class="language-julia-repl">julia&gt; derivative_argument(dydt2) # get the variable the derivative operates on
∂/∂t[y(t, ξ)]

julia&gt; operator_parameter(dydt2) # get the parameter the operator is taken with respect to
t

julia&gt; derivative_method(dydt2) # get the numerical derivative evaluation method
FiniteDifference(Forward, true)

julia&gt; name(dydt2) # get the name if there is one
&quot;dydt2&quot;</code></pre><p>These all work as exemplified above. We note that <code>derivative_method</code> simply  queries the derivative method associated with the operator parameter.</p><p>Derivatives also inherit all the usage methods employed by infinite variables.  For example:</p><pre><code class="language-julia-repl">julia&gt; is_used(d1)
true

julia&gt; used_by_measure(dydt2)
false

julia&gt; used_by_reduced_variable(d2)
true</code></pre><p>Also, since derivatives are analogous to infinite variables, they inherit many  of the same queries including <a href="../constraint/#InfiniteOpt.parameter_refs-Tuple{InfOptConstraintRef}"><code>parameter_refs</code></a>:</p><pre><code class="language-julia-repl">julia&gt; parameter_refs(d1)
(t, ξ)

julia&gt; parameter_refs(derivative_argument(d1))
(t, ξ)</code></pre><p>Since derivatives simply inherit their infinite parameter dependencies from the  argument variable, the above lines are equivalent.</p><h3 id="Variable-Information"><a class="docs-heading-anchor" href="#Variable-Information">Variable Information</a><a id="Variable-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Information" title="Permalink"></a></h3><p>Again, since derivatives are essentially a special case of infinite variables, they  inherit all the same methods for querying variable information. For example,  consider the following queries:</p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(dydt2)
true

julia&gt; lower_bound(dydt2)
1.0

julia&gt; LowerBoundRef(dydt2)
dydt2(t, ξ) ≥ 1.0, ∀ t ∈ [0, 10], ξ ~ Uniform

julia&gt; has_upper_bound(dydt2)
false 

julia&gt; start_value_function(dydt2)
#139 (generic function with 1 method)</code></pre><h3 id="Model-Queries"><a class="docs-heading-anchor" href="#Model-Queries">Model Queries</a><a id="Model-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Queries" title="Permalink"></a></h3><p>We can also determine the number of derivatives a model contains and obtain a list  of them via <a href="#InfiniteOpt.num_derivatives"><code>num_derivatives</code></a> and <a href="#InfiniteOpt.all_derivatives"><code>all_derivatives</code></a>, respectively:</p><pre><code class="language-julia-repl">julia&gt; num_derivatives(model)
7

julia&gt; all_derivatives(model)
7-element Array{GeneralVariableRef,1}:
 ∂/∂t[y(t, ξ)]
 ∂/∂ξ[∂/∂t[y(t, ξ)]]
 ∂/∂t[q(t)]
 ∂/∂t[∂/∂t[q(t)]]
 ∂/∂ξ[y(t, ξ)]
 dydt2(t, ξ)
 ∂/∂t[∫{ξ ∈ [-1, 1]}[y(t, ξ)]]</code></pre><h2 id="Modification-Methods"><a class="docs-heading-anchor" href="#Modification-Methods">Modification Methods</a><a id="Modification-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Modification-Methods" title="Permalink"></a></h2><p>In this section, we&#39;ll highlight some of the modification methods that can be  used on derivatives in <code>InfiniteOpt</code>.</p><h3 id="Variable-Information-2"><a class="docs-heading-anchor" href="#Variable-Information-2">Variable Information</a><a class="docs-heading-anchor-permalink" href="#Variable-Information-2" title="Permalink"></a></h3><p>As discussed above, derivatives inherit the same variable methods as infinite  variables. Thus we can modify/delete bounds and starting values for derivatives  using the same methods. For example:</p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(dydt2, 0)

julia&gt; lower_bound(dydt2)
0.0

julia&gt; set_upper_bound(dydt2, 2)

julia&gt; upper_bound(dydt2)
2.0

julia&gt; fix(dydt2, 42, force = true)

julia&gt; fix_value(dydt2) 
42.0

julia&gt; set_start_value_function(dydt2, (t, xi) -&gt; t + xi)

julia&gt; unfix(dydt2)
</code></pre><h3 id="Deletion"><a class="docs-heading-anchor" href="#Deletion">Deletion</a><a id="Deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Deletion" title="Permalink"></a></h3><p>Finally, the are 2 deletion methods we can employ apart from deleting variable  information. First, we can employ <a href="#InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}"><code>delete_derivative_constraints</code></a> to  delete any derivative evaluation constraints associated with a particular  derivative:</p><pre><code class="language-julia-repl">julia&gt; delete_derivative_constraints(d2)

julia&gt; has_derivative_constraints(d2)
false</code></pre><p>Lastly, we can employ <code>delete</code> to delete a particular derivative and all its  dependencies:</p><pre><code class="language-julia-repl">julia&gt; delete(model, d2)

julia&gt; is_valid(model, d2)
false</code></pre><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.AbstractDerivativeMethod"><code>InfiniteOpt.AbstractDerivativeMethod</code></a></li><li><a href="#InfiniteOpt.Backward"><code>InfiniteOpt.Backward</code></a></li><li><a href="#InfiniteOpt.Central"><code>InfiniteOpt.Central</code></a></li><li><a href="#InfiniteOpt.Derivative"><code>InfiniteOpt.Derivative</code></a></li><li><a href="#InfiniteOpt.DerivativeIndex"><code>InfiniteOpt.DerivativeIndex</code></a></li><li><a href="#InfiniteOpt.DerivativeRef"><code>InfiniteOpt.DerivativeRef</code></a></li><li><a href="#InfiniteOpt.FDTechnique"><code>InfiniteOpt.FDTechnique</code></a></li><li><a href="#InfiniteOpt.FiniteDifference"><code>InfiniteOpt.FiniteDifference</code></a></li><li><a href="#InfiniteOpt.Forward"><code>InfiniteOpt.Forward</code></a></li><li><a href="#InfiniteOpt.GenerativeDerivativeMethod"><code>InfiniteOpt.GenerativeDerivativeMethod</code></a></li><li><a href="#InfiniteOpt.Lobatto"><code>InfiniteOpt.Lobatto</code></a></li><li><a href="#InfiniteOpt.NonGenerativeDerivativeMethod"><code>InfiniteOpt.NonGenerativeDerivativeMethod</code></a></li><li><a href="#InfiniteOpt.OCTechnique"><code>InfiniteOpt.OCTechnique</code></a></li><li><a href="#InfiniteOpt.OrthogonalCollocation"><code>InfiniteOpt.OrthogonalCollocation</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DerivativeIndex" href="#InfiniteOpt.DerivativeIndex"><code>InfiniteOpt.DerivativeIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DerivativeIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.Derivative"><code>Derivative</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DerivativeRef" href="#InfiniteOpt.DerivativeRef"><code>InfiniteOpt.DerivativeRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DerivativeRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for untranscripted derivative references.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::DerivativeIndex</code>: Index of the derivative in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL1380-L1388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Derivative" href="#InfiniteOpt.Derivative"><code>InfiniteOpt.Derivative</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Derivative{V &lt;: GeneralVariableRef} &lt;: InfOptVariable</code></pre><p>A <code>DataType</code> for storing core infinite derivative information. This follows a  derivative of the form: <span>$\frac{\partial x(\alpha, \hdots)}{\partial \alpha}$</span>  where <span>$x(\alpha, \hdots)$</span> is an infinite variable and <span>$\alpha$</span> is an infinite  parameter. Here, both <span>$x$</span> and <span>$\alpha$</span> must be scalars. </p><p>It is important to note that <code>info.start</code> should contain a start value function that generates the start value for a given infinite parameter support. This function should map a support to a start value using user-formatting if <code>is_vector_start = false</code>, otherwise it should do the mapping using a single support vector as input. Also, the variable reference type <code>V</code> must pertain to infinite variables and parameters.</p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{Float64, Float64, Float64, Function}</code>: JuMP variable information.</li><li><code>is_vector_start::Bool</code>: Does the start function take support values formatted as vectors?</li><li><code>variable_ref::V</code>: The variable reference of the infinite variable argument.</li><li><code>parameter_ref::V</code>: The variable reference of the infinite parameter the defines the  differential operator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL776-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractDerivativeMethod" href="#InfiniteOpt.AbstractDerivativeMethod"><code>InfiniteOpt.AbstractDerivativeMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractDerivativeMethod</code></pre><p>An abstract type for storing derivative evaluation data that is pertinent to its  reformation/transcription. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL277-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.GenerativeDerivativeMethod" href="#InfiniteOpt.GenerativeDerivativeMethod"><code>InfiniteOpt.GenerativeDerivativeMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GenerativeDerivativeMethod &lt;: AbstractDerivativeMethod</code></pre><p>An abstract type for derivative evaluation method types that will require support  generation when employed (e.g., internal node points associated with orthogonal  collocation). Such methods can be used with derivatives that on independent  infinite parameters, but cannot be used for ones that depend on dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL285-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.OrthogonalCollocation" href="#InfiniteOpt.OrthogonalCollocation"><code>InfiniteOpt.OrthogonalCollocation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrthogonalCollocation &lt;: GenerativeDerivativeMethod</code></pre><p>A <code>DataType</code> for storing information about orthogonal collocation method for derivative evaluation. Note that the constructor for this method is of the form: </p><pre><code class="language-julia">    OrthogonalCollocation(num_nodes::Int, [technique::Type{&lt;:OCTechnique} = Labatto])</code></pre><p>where <code>num_nodes</code> is total number of nodes for each collocation interval. In  practice, this corresponds to <code>num_nodes = num_internal_nodes + 2</code>. </p><p><strong>Fields</strong></p><ul><li><code>num_internal_nodes::Int</code>: The number of internal collocation points (nodes)  between the each support pair.</li><li><code>technique::Type{&lt;:OCTechnique}</code>: The method used to produce the points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL310-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.OCTechnique" href="#InfiniteOpt.OCTechnique"><code>InfiniteOpt.OCTechnique</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OCTechnique</code></pre><p>An abstract type for the method used to carry out orthogonal collocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL295-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Lobatto" href="#InfiniteOpt.Lobatto"><code>InfiniteOpt.Lobatto</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lobatto &lt;: OCTechnique</code></pre><p>A quadrature method label for orthogonal collocation method that generates internal nodes between public supports using Lobatto quadrature method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL302-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.NonGenerativeDerivativeMethod" href="#InfiniteOpt.NonGenerativeDerivativeMethod"><code>InfiniteOpt.NonGenerativeDerivativeMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonGenerativeDerivativeMethod &lt;: AbstractDerivativeMethod</code></pre><p>An abstract type for derivative evaluation method types that do not require the  definition of additional support points. Such methods are amendable to any  derivative in InfiniteOpt including those with dependent infinite parameter  dependencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL341-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FiniteDifference" href="#InfiniteOpt.FiniteDifference"><code>InfiniteOpt.FiniteDifference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteDifference &lt;: NonGenerativeDerivativeMethod</code></pre><p>A <code>DataType</code> for information about finite difference method applied to  a derivative evaluation. Note that the constructor is of the form:</p><pre><code class="language-julia">    FiniteDifference([technique::Type{&lt;:FDTechnique} = Backward],
                     [add_boundary_constr::Bool = true])</code></pre><p>where <code>technique</code> is the indicated finite difference method to be applied and  <code>add_boundary_constr</code> indicates if the finite difference equation corresponding to  a boundary support should be included. Thus, for backward difference since corresponds to the terminal point and for forward difference this corresponds to  the initial point. We recommend using <code>add_boundary_constr = false</code> when an final  condition is given with a backward method or when an initial condition is given  with a forward method. Note that this argument is ignored for central finite  difference which cannot include any boundary points.</p><p><strong>Fields</strong> </p><ul><li><code>technique::Type{&lt;:FDTechnique}</code>: Mathematical technqiue behind finite difference</li><li><code>add_boundary_constraint::Bool</code>: Indicate if the boundary constraint should be  included in the transcription (e.g., the terminal boundary backward equation for  backward difference)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL383-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FDTechnique" href="#InfiniteOpt.FDTechnique"><code>InfiniteOpt.FDTechnique</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FDTechnique</code></pre><p>An abstract data type for labels of specific techniques applied in the finite  difference method in derivative evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL351-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Forward" href="#InfiniteOpt.Forward"><code>InfiniteOpt.Forward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Forward &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a forward  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL359-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Central" href="#InfiniteOpt.Central"><code>InfiniteOpt.Central</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Central &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a central  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL367-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Backward" href="#InfiniteOpt.Backward"><code>InfiniteOpt.Backward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Backward &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a backward  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL375-L380">source</a></section></article><h2 id="deriv_methods"><a class="docs-heading-anchor" href="#deriv_methods">Methods/Macros</a><a id="deriv_methods-1"></a><a class="docs-heading-anchor-permalink" href="#deriv_methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.@deriv"><code>InfiniteOpt.@deriv</code></a></li><li><a href="#InfiniteOpt.@derivative_variable"><code>InfiniteOpt.@derivative_variable</code></a></li><li><a href="#InfiniteOpt.@∂"><code>InfiniteOpt.@∂</code></a></li><li><a href="#InfiniteOpt.add_derivative"><code>InfiniteOpt.add_derivative</code></a></li><li><a href="#InfiniteOpt.add_derivative_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.add_derivative_supports</code></a></li><li><a href="#InfiniteOpt.all_derivatives"><code>InfiniteOpt.all_derivatives</code></a></li><li><a href="#InfiniteOpt.build_derivative"><code>InfiniteOpt.build_derivative</code></a></li><li><a href="#InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.delete_derivative_constraints</code></a></li><li><a href="#InfiniteOpt.deriv"><code>InfiniteOpt.deriv</code></a></li><li><a href="#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_argument</code></a></li><li><a href="#InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_constraints</code></a></li><li><a href="#InfiniteOpt.derivative_method-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_method</code></a></li><li><a href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>InfiniteOpt.evaluate</code></a></li><li><a href="#InfiniteOpt.evaluate_all_derivatives!"><code>InfiniteOpt.evaluate_all_derivatives!</code></a></li><li><a href="#InfiniteOpt.evaluate_derivative"><code>InfiniteOpt.evaluate_derivative</code></a></li><li><a href="#InfiniteOpt.generate_derivative_supports"><code>InfiniteOpt.generate_derivative_supports</code></a></li><li><a href="#InfiniteOpt.has_derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.has_derivative_constraints</code></a></li><li><a href="#InfiniteOpt.make_reduced_expr"><code>InfiniteOpt.make_reduced_expr</code></a></li><li><a href="#InfiniteOpt.num_derivatives"><code>InfiniteOpt.num_derivatives</code></a></li><li><a href="#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}"><code>InfiniteOpt.operator_parameter</code></a></li><li><a href="#InfiniteOpt.parameter_list-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_list</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.raw_parameter_refs</code></a></li><li><a href="#InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}"><code>InfiniteOpt.reset_start_value_function</code></a></li><li><a href="#InfiniteOpt.set_all_derivative_methods"><code>InfiniteOpt.set_all_derivative_methods</code></a></li><li><a href="#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef,AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a></li><li><a href="#InfiniteOpt.set_derivative_method-Tuple{DependentParameterRef,AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a></li><li><a href="#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef,Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a></li><li><a href="#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.support_label</code></a></li><li><a href="#InfiniteOpt.∂"><code>InfiniteOpt.∂</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@deriv" href="#InfiniteOpt.@deriv"><code>InfiniteOpt.@deriv</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@deriv(expr, pref_expr1[, ...]
       )::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>The macro variant of <a href="#InfiniteOpt.deriv"><code>deriv</code></a> that is more efficient for expression building  and enables symbolic differential operator parameter defintions via <code>pref_expr</code>s.  Like <code>deriv</code> expr can be any InfiniteOpt expression and the appropriate calculus  rules will applied to <code>expr</code> to take its derivative with respect to the indicated  infinite parameters detailed by the <code>pref_expr</code>s. The resulting derivative  expression will contain individual derivatives that were created and added to the  InfiniteModel as needed. Here each <code>pref_expr</code> arugment can be of the form:</p><ul><li><code>pref::GeneralVariableRef</code>: An indiviudal infinite parameter reference</li><li><code>(pref::GeneralVariableRef)^(p::Int)</code>: An infinite parameter applied <code>p</code> times.</li></ul><p>Thus, the syntax <code>@deriv(expr, pref^2)</code> is equivalent to <code>@deriv(expr, pref, pref)</code>. </p><p>This will error if <code>pref_expr</code> is an unrecongnized syntax, no infinite parameter  is given, or if any of the specified parameters are not infinite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1])
t

julia&gt; @infinite_variable(m, x(t))
x(t)

julia&gt; @hold_variable(m, z)
z

julia&gt; deriv_expr = @deriv(x^2 + z, t^2)
2 ∂/∂t[∂/∂t[x(t)]]*x(t) + 2 ∂/∂t[x(t)]²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL362-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@∂" href="#InfiniteOpt.@∂"><code>InfiniteOpt.@∂</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@∂(expr, pref_expr1[, ...])::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>This serves as a convenient unicode wrapper for <a href="#InfiniteOpt.@deriv"><code>@deriv</code></a>. The <code>∂</code> is  produced via <code>\partial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL424-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.deriv" href="#InfiniteOpt.deriv"><code>InfiniteOpt.deriv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deriv(expr::JuMP.AbstractJuMPScalar, pref1::GeneralVariableRef[, ....]
      )::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>Apply appropriate calculus methods to define and return the derivative expression of <code>expr</code>  with respect to the infinite parameter(s) <code>pref1</code>, pref2<code>, etc. in that respective  order. This will implicilty build and add individual [</code>Derivative`](@ref)s as  appropriate. Errors if no infinite parameter is given or if the parameters are  not infinite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1])
t

julia&gt; @infinite_variable(m, x(t))
x(t)

julia&gt; @hold_variable(m, z)
z

julia&gt; deriv_expr = deriv(x^2 + z, t, t)
2 ∂/∂t[∂/∂t[x(t)]]*x(t) + 2 ∂/∂t[x(t)]²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL324-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.∂" href="#InfiniteOpt.∂"><code>InfiniteOpt.∂</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">∂(expr::JuMP.AbstractJuMPScalar, pref1::GeneralVariableRef[, ....]
  )::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>This serves as a convenient unicode wrapper for <a href="#InfiniteOpt.deriv"><code>deriv</code></a>. The <code>∂</code> is  produced via <code>\partial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL413-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@derivative_variable" href="#InfiniteOpt.@derivative_variable"><code>InfiniteOpt.@derivative_variable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@derivative_variable(model::InfiniteModel, kw_args...)::GeneralVariableRef</code></pre><p>Add an <em>anonymous</em> derivative to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable reference. Note that the <code>argument</code> and <code>operator_parameter</code> keywords are required in this case.</p><pre><code class="language-julia">@derivative_variable(model::InfiniteModel, deriv_expr, var_expr,
                     kw_args...)::GeneralVariableRef</code></pre><p>Add a derivative to <code>model</code> described by the expression <code>var_expr</code>, the keyword  arguments <code>kw_args</code>, and the derivative expr <code>deriv_expr</code>. The expression  <code>deriv_expr</code> specifies the derivative argument and operator parameter and must be  of the from: <code>d(arg_vref)/d(pref)</code> where <code>arg_vref</code> is a variable/derivative/measure  with an infinite dependence on the infinite parameter <code>pref</code>. Equivalently, the  derivative can be expressed <code>∂(arg_vref)/∂(pref)</code>. The expression <code>var_expr</code> is  used to define variable specific bounds and whose name is used as an alias for the  derivative reference. The expression <code>var_expr</code> can either be (note that in the  following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be  used instead of <code>≥</code>) of the form:</p><ul><li><code>var_expr</code> creating variables described by <code>varexpr</code></li><li><code>var_expr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>var_expr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>var_expr == value</code> creating variables described by <code>var_expr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ var_expr ≤ ub</code> or <code>ub ≥ var_expr ≥ lb</code> creating variables described by <code>var_expr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>Note that the preferred way to define derivatives is via <a href="#InfiniteOpt.@deriv"><code>@deriv</code></a> which  provides a more succinct way to specify more complex derivatives. However, this  variable based syntax is provided as a convenient way to specify starting  values/functions when needed.</p><p>The expression <code>var_expr</code> can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of alias name <code>varname</code></li><li><code>varname[...]</code> or <code>[...]</code> creating a container of variables.</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>argument</code>: Sets the argument of the differential operator.</li><li><code>operator_parameter</code>: Sets the infinite parameter the derivative is with respect to.</li><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the derivative starting value used as initial guess in optimization.          This can be a single value enforced over the entire infinite          domain or it can be a function that maps a support value to a scalar          guess value. Note that the function arguments must match the format          of <code>parameter_refs(argument)</code>.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_variable(model, x(t) &gt;= 0)
x(t)

julia&gt; @infinite_variable(model, y[1:2](t))
2-element Array{GeneralVariableRef,1}:
 y[1](t)
 y[2](t)

julia&gt; @derivative_variable(model, d(x)/d(t), dx &lt;= 1, start = 0)
dx

julia&gt; dx = @derivative_variable(model, d(x)/d(t), upper_bound = 1, base_name = &quot;dx&quot;)
dx

julia&gt; dx = @derivative_variable(model, upper_bound = 1, base_name = &quot;dx&quot;,
                                  argument = x, operator_parameter = t)
dx

julia&gt; @derivative_variable(model, d(y[i])/d(t), dx2[i = 1:2])
2-element Array{GeneralVariableRef,1}:
 dx2[1]
 dx2[2]

julia&gt; dx = @derivative_variable(model, d(y[i])/d(t), [i = 1:2])
2-element Array{GeneralVariableRef,1}:
 ∂/∂t[y[1](t)]
 ∂/∂t[y[2](t)]
 
julia&gt; dx = @derivative_variable(model, [i = 1:2], argument = y[i], 
                                 operator_parameter = t)
2-element Array{GeneralVariableRef,1}:
 ∂/∂t[y[1](t)]
 ∂/∂t[y[2](t)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/macros.jl#LL1256-L1354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_derivative" href="#InfiniteOpt.build_derivative"><code>InfiniteOpt.build_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_derivative(_error::Function, info::JuMP.VariableInfo, 
                 argument_ref::GeneralVariableRef, 
                 parameter_ref::GeneralVariableRef
                 )::Derivative</code></pre><p>Constructs and returns a <a href="#InfiniteOpt.Derivative"><code>Derivative</code></a> with a differential operator that  depends on <code>parameter_ref</code> and operates on <code>argument_ref</code>. Variable <code>info</code> can also  be provided to associate this derivative with bounds and a starting value function  like that of infinite variables. Errors when <code>argument_ref</code> is not an  infinite/reduced variable or derivative that depends on <code>parameter_ref</code>. Also,  errors if such a derivative was already added to the model.</p><p><strong>Example</strong> ```julia-repl  julia&gt; @infinite<em>parameter(m, t in [0, 1]); @infinite</em>variable(m, x(t));</p><p>julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);</p><p>julia&gt; build<em>derivative(error, info, x, t) Derivative{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Function}(false, 0.0, false, 0.0, false, 0.0, false, start</em>func, false, false), true, x(t), t) ````</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL154-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_derivative" href="#InfiniteOpt.add_derivative"><code>InfiniteOpt.add_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_derivative(model::InfiniteModel, d::Derivative, 
               [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Adds a derivative <code>d</code> to <code>model</code> and returns a <code>GeneralVariableRef</code> that points  to it. Errors if the derivative dependencies do not belong to <code>model</code>. Note that  <code>d</code> should be built using <a href="#InfiniteOpt.build_derivative"><code>build_derivative</code></a> to avoid nuance internal  errors.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1]); @infinite_variable(m, x(t));

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);

julia&gt; d = build_derivative(error, info, x, t);

julia&gt; dref = add_derivative(m, d)
∂/∂t[x(t)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL219-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_argument-Tuple{DerivativeRef}" href="#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_argument</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_argument(dref::DerivativeRef)::GeneralVariableRef</code></pre><p>Returns the infinite variable/derivative reference that is the input the differential operator (i.e., the dependent variable of the derivative).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_argument(dref) 
x(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.operator_parameter-Tuple{DerivativeRef}" href="#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}"><code>InfiniteOpt.operator_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">operator_parameter(dref::DerivativeRef)::GeneralVariableRef</code></pre><p>Returns the infinite parameter reference that is what the differential operator  is operating with respect to (i.e., the independent  variable of the derivative).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; operator_parameter(dref) 
t</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL62-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_method-Tuple{DerivativeRef}" href="#InfiniteOpt.derivative_method-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_method(dref::DerivativeRef)::AbstractDerivativeMethod</code></pre><p>Returns the evaluation method employed by <code>dref</code> that determines the numerical  computation scheme that will be used to evaluate the derivative. Note that this  is set on by the infinite parameter with respect to which the derivative is  defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_method(dref) 
FiniteDifference(Backward, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(dref::DerivativeRef)::VectorTuple{GeneralVariableRef}</code></pre><p>Return the raw <a href="../variable/#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the parameter references that <code>dref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL437-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{DerivativeRef}" href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(dref::DerivativeRef)::Tuple</code></pre><p>Return the parameter references associated with the infinite derivative <code>dref</code>. This is formatted as a Tuple of containing the parameter references as they inputted to define <code>dref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(deriv)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL449-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{DerivativeRef}" href="#InfiniteOpt.parameter_list-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(dref::DerivativeRef)::Vector{GeneralVariableRef}</code></pre><p>Return a vector of the parameter references that <code>dref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL466-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_start_value_function-Tuple{DerivativeRef,Union{Function, Real}}" href="#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef,Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_start_value_function(dref::DerivativeRef,
                         start::Union{Real, Function})::Nothing</code></pre><p>Set the start value function of <code>dref</code>. If <code>start::Real</code> then a function is generated to such that the start value will be <code>start</code> for the entire infinite domain. If <code>start::Function</code> then this function should map to a scalar start value given a support value arguments matching the format of the parameter elements in <code>parameter_refs(dref)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_start_value_function(dref, 1) # all start values will be 1

julia&gt; set_start_value_function(dref, my_func) # each value will be made via my_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL495-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}" href="#InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}"><code>InfiniteOpt.reset_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_start_value_function(dref::DerivativeRef)::Nothing</code></pre><p>Remove the existing start value function and return to the default. Generally, this is triggered by deleting an infinite parameter that <code>dref</code> depends on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; reset_start_value_function(dref)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL528-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_derivatives" href="#InfiniteOpt.num_derivatives"><code>InfiniteOpt.num_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_derivatives(model::InfiniteModel)::Int</code></pre><p>Returns the number of derivatives that have been defined in <code>model</code>. Note that  nested derivatives will be counted in accordance with their components (e.g.,  <span>$\frac{d^2 x(t)}{dt^2} =$</span>\frac{d}{dt}\left(\frac{d x(t)}{dt} \right)``  will count as 2 derivatives.)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_derivatives(model)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL561-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_derivatives" href="#InfiniteOpt.all_derivatives"><code>InfiniteOpt.all_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_derivatives(model::InfiniteModel)::Vector{GeneralVariableRef}</code></pre><p>Returns a list of all the individual derivatives stored in <code>model</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; all_derivatives(model)
3-element Array{GeneralVariableRef,1}:
 ∂/∂t[T(x, t)]
 ∂/∂x[T(x, t)]
 ∂/∂x[∂/∂x[T(x, t)]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL579-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef,AbstractDerivativeMethod}" href="#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef,AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_derivative_method(pref::IndependentParameterRef, 
                      method::AbstractDerivativeMethod)::Nothing</code></pre><p>Specfies the desired derivative evaluation method <code>method</code> for derivatives that are  taken with respect to <code>pref</code>. Any internal supports exclusively associated with  the previous method will be deleted. Also, if any derivatives were evaluated  manually, the associated derivative evaluation constraints will be deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_derivative_method(d, OrthogonalCollocation(2))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/scalar_parameters.jl#LL672-L686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_derivative_method-Tuple{DependentParameterRef,AbstractDerivativeMethod}" href="#InfiniteOpt.set_derivative_method-Tuple{DependentParameterRef,AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_derivative_method(pref::DependentParameterRef, 
                      method::NonGenerativeDerivativeMethod)::Nothing</code></pre><p>Specfies the desired derivative evaluation method <code>method</code> for derivatives that are  taken with respect to <code>pref</code>. Errors if <code>method</code> is generative (i.e., it requires  the definition of additional supports)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_derivative_method(d, FiniteDifference())
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/array_parameters.jl#LL584-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_all_derivative_methods" href="#InfiniteOpt.set_all_derivative_methods"><code>InfiniteOpt.set_all_derivative_methods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_all_derivative_methods(model::InfiniteModel, 
                           method::AbstractDerivativeMethod)::Nothing</code></pre><p>Sets the desired evaluation method <code>method</code> for all the derivatives currently added  to <code>model</code>. Note that this is done with respect to the infinite parameters. Errors  if a generative method is specified and the model contains dependent parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_all_derivative_methods(model, OrthogonalCollocation(2))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/array_parameters.jl#LL613-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate-Tuple{DerivativeRef}" href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>InfiniteOpt.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(dref::DerivativeRef)::Nothing</code></pre><p>Numerically evaluate <code>dref</code> by computing its auxiliary derivative constraints  (e.g., collocation equations) and add them to the model. For normal usage, it is  recommended that this method not be called directly and instead have TranscriptionOpt  handle these equations. Errors if <code>evaluate_derivative</code> is not  defined for the derivative method employed.</p><p>The resulting constraints can be accessed via <code>derivative_constraints</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel(); @infinite_parameter(m, t in [0,2]); @infinite_variable(m, T(t));

julia&gt; dref = @deriv(T,t)
∂/∂t[T(t)]

julia&gt; add_supports(t, [0, 0.5, 1, 1.5, 2])

julia&gt; evaluate(dref)

julia&gt; derivative_constraints(dref)
Feasibility
4-element Array{InfOptConstraintRef,1}:
 0.5 ∂/∂t[T(t)](0.5) - T(0.5) + T(0) = 0.0
 0.5 ∂/∂t[T(t)](1) - T(1) + T(0.5) = 0.0
 0.5 ∂/∂t[T(t)](1.5) - T(1.5) + T(1) = 0.0
 0.5 ∂/∂t[T(t)](2) - T(2) + T(1.5) = 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivative_evaluations.jl#LL327-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate_all_derivatives!" href="#InfiniteOpt.evaluate_all_derivatives!"><code>InfiniteOpt.evaluate_all_derivatives!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate_all_derivatives!(model::InfiniteModel)::Nothing</code></pre><p>Evaluate all the derivatives in <code>model</code> by adding the corresponding auxiliary  equations to <code>model</code>. See <a href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>evaluate</code></a> for more information.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel();

julia&gt; @infinite_parameter(m, t in [0,2], supports = [0, 1, 2]);

julia&gt; @infinite_parameter(m, x in [0,1], supports = [0, 0.5, 1]);

julia&gt; @infinite_variable(m, T(x, t));

julia&gt; dref1 = @deriv(T, t); dref2 = @deriv(T, x^2);

julia&gt; evaluate_all_derivatives!(m)

julia&gt; print(m)
Feasibility
Subject to
 ∂/∂t[T(x, t)](x, 1) - T(x, 1) + T(x, 0) = 0.0, ∀ x ∈ [0, 1]
 ∂/∂t[T(x, t)](x, 2) - T(x, 2) + T(x, 1) = 0.0, ∀ x ∈ [0, 1]
 0.5 ∂/∂x[T(x, t)](0.5, t) - T(0.5, t) + T(0, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[T(x, t)](1, t) - T(1, t) + T(0.5, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[∂/∂x[T(x, t)]](0.5, t) - ∂/∂x[T(x, t)](0.5, t) + ∂/∂x[T(x, t)](0, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[∂/∂x[T(x, t)]](1, t) - ∂/∂x[T(x, t)](1, t) + ∂/∂x[T(x, t)](0.5, t) = 0.0, ∀ t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivative_evaluations.jl#LL379-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_derivative_constraints-Tuple{DerivativeRef}" href="#InfiniteOpt.has_derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.has_derivative_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_derivative_constraints(dref::DerivativeRef)::Bool</code></pre><p>Return a <code>Bool</code> whether <code>dref</code> has been evaluated within the <code>InfiniteModel</code> and  has derivative constraints that have been added to the <code>InfiniteModel</code>. Note this  does not indicate if such constraints have been added to the optimizer model. Thus,  with normal usage (i.e., not using <code>evaluate</code>) this should always return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}" href="#InfiniteOpt.derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_constraints(dref::DerivativeRef)::Vector{InfOptConstraintRef}</code></pre><p>Return a list of the derivative evaluation constraints for <code>dref</code> that have been  added directly to the <code>InfiniteModel</code> associated with <code>dref</code>. An empty vector is  returned is there are no such constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL611-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}" href="#InfiniteOpt.delete_derivative_constraints-Tuple{DerivativeRef}"><code>InfiniteOpt.delete_derivative_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_derivative_constraints(dref::DerivativeRef)::Nothing</code></pre><p>Delete any derivative constraints of <code>dref</code> that have been directly added to the  <code>InfiniteModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivatives.jl#LL624-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate_derivative" href="#InfiniteOpt.evaluate_derivative"><code>InfiniteOpt.evaluate_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate_derivative(dref::GeneralVariableRef, 
                    method::AbstractDerivativeMethod,
                    write_model::JuMP.AbstractModel)::Vector{JuMP.AbstractJuMPScalar}</code></pre><p>Build expressions for derivative <code>dref</code> evaluated in accordance with <code>method</code>.  The expressions are of the form <code>lhs - rhs</code>, where <code>lhs</code> is a function of derivatives evaluated at some supports for certain infinite parameter, and <code>rhs</code> is a function of the derivative arguments evaluated at some supports for certain infinite parameter. For example, for finite difference methods at point <code>t = 1</code>, <code>lhs</code> is <code>Δt * ∂/∂t[T(1)]</code>, and <code>rhs</code> could be <code>T(1+Δt) - T(1)</code> in case of forward difference mode. This is intended as a helper function for <code>evaluate</code>, which  will take the the expressions generated by this method and generate constraints that approximate the derivative values by setting the expressions as 0. However, one can extend this function  to encode custom methods for approximating derivatives. This should invoke  <code>add_derivative_supports</code> if the method is generative and users will likely find  it convenient to use <code>make_reduced_expr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivative_evaluations.jl#LL172-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}" href="#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.support_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">support_label(method::GenerativeDerivativeMethod)</code></pre><p>Return the support label associated with <code>method</code> if there is one, errors otherwise.  This should be extended for any <code>GenerativeDerivativeMethod</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/datatypes.jl#LL417-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.generate_derivative_supports" href="#InfiniteOpt.generate_derivative_supports"><code>InfiniteOpt.generate_derivative_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_derivative_supports(pref::IndependentParameterRef, 
                             method::GenerativeDerivativeMethod)::Vector{Float64}</code></pre><p>Generate and return a vector any additional supports needed by <code>method</code>. This is  intended as an internal method and will need to be extended for user-defined  derivative methods that are generative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivative_evaluations.jl#LL4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_derivative_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.add_derivative_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.add_derivative_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_derivative_supports(pref::Union{IndependentParameterRef, DependentParameterRef})::Nothing</code></pre><p>Add any supports <code>pref</code> that are needed for derivative evaluation. This is intended  as a helper method for derivative evaluation and depends <a href="#InfiniteOpt.generate_derivative_supports"><code>generate_derivative_supports</code></a>  which will need to be extended for user-defined derivative methods that generate supports.  In such cases, it is necessary to also extend  <a href="#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>support_label</code></a> Errors if  such is not defined for the current derivative method associated with <code>pref</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivative_evaluations.jl#LL79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_reduced_expr" href="#InfiniteOpt.make_reduced_expr"><code>InfiniteOpt.make_reduced_expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_reduced_expr(vref::GeneralVariableRef, pref::GeneralVariableRef, 
                  support::Float64, write_model::Union{InfiniteModel, JuMP.Model})</code></pre><p>Given the argument variable <code>vref</code> and the operator parameter <code>pref</code> from a  derivative, build and return the reduced expression in accordance to the support  <code>support</code> with respect to <code>pref</code>. New point/reduced variables will be written to  <code>write_model</code>. This is solely intended as a helper function for derivative  evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e3ea796cd874be29083536e1c20e8bb25b819bf0/src/derivative_evaluations.jl#LL106-L115">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variable/">« Variables</a><a class="docs-footer-nextpage" href="../expression/">Expressions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 24 October 2020 19:41">Saturday 24 October 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
