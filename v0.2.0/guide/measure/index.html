<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measures · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li class="is-active"><a class="tocitem" href>Measures</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#measure_basic_usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Theoretical-Abstraction"><span>Theoretical Abstraction</span></a></li><li><a class="tocitem" href="#Measure-Data-Generation"><span>Measure Data Generation</span></a></li><li><a class="tocitem" href="#Evaluation-Methods"><span>Evaluation Methods</span></a></li><li><a class="tocitem" href="#Expansion"><span>Expansion</span></a></li><li><a class="tocitem" href="#Reduced-Infinite-Variables"><span>Reduced Infinite Variables</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#MeasureToolbox-Datatypes"><span>MeasureToolbox Datatypes</span></a></li><li><a class="tocitem" href="#MeasureToolbox-Methods"><span>MeasureToolbox Methods</span></a></li></ul></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Measures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/measure.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="measure_page"><a class="docs-heading-anchor" href="#measure_page">Measures</a><a id="measure_page-1"></a><a class="docs-heading-anchor-permalink" href="#measure_page" title="Permalink"></a></h1><p>A guide and manual for the definition and use of measures in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Measures are objects that capture the integration of an expression with respect to parameters, which is a distinct feature of optimization problems with infinite decision spaces. In dynamic optimization measures can represent integral terms such as the total cost over time, and in stochastic optimization measures can represent integrals over the uncertain parameters, such as expectations. In <code>InfiniteOpt</code>, measures are evaluated by some discretization scheme, which evaluates the expression at a set of points over the parameter space and approximates the measures based on the expression values at these points.</p><h2 id="measure_basic_usage"><a class="docs-heading-anchor" href="#measure_basic_usage">Basic Usage</a><a id="measure_basic_usage-1"></a><a class="docs-heading-anchor-permalink" href="#measure_basic_usage" title="Permalink"></a></h2><p>First, we consider a dynamic optimization problem with the time parameter <code>t</code> from 0 to 10. We also consider a state variable <code>y(t)</code> and a control variable <code>u(t)</code> that are parameterized by <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_variable(model, y(t))
y(t)

julia&gt; @infinite_variable(model, u(t))
u(t)</code></pre><p>Now suppose we want to evaluate the integral <span>$\int_{2}^{8}y(t)^2 + u(t)^2 dt$</span>. We can construct a measure to represent this integral using the <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> function</p><pre><code class="language-julia-repl">julia&gt; mref1 = integral(y^2 + u^2, t, 2, 8)
integral{t ∈ [2, 8]}[y(t)² + u(t)²]</code></pre><p>The four positional arguments of <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> are the integrand expression,  the parameter of integration, the lower bound, and the upper bound, respectively.  Specifying the integrand expression and the parameter of integration is required. If the lower and upper bounds are not specified, then the integration will be over the entire domain, which is [0, 10] in this case.</p><p>The <code>integral</code> function uses trapezoid rule as the default discretization scheme for univariate parameters in finite <code>IntervalSet</code>s. In addition, the user can also  use quadrature methods for univariate parameters in all <code>IntervalSet</code>s by setting the keyword argument <code>eval_method</code> as <code>Quadrature</code>:</p><pre><code class="language-julia-repl">julia&gt; mref2 = integral(y^2 + u^2, t, eval_method = Quadrature)
integral{t ∈ [0, 10]}[y(t)² + u(t)²]</code></pre><p>The <code>integral</code> function also allows for specifying the number of points for the discretization scheme using the keyword argument <code>num_supports</code>. The default value of <code>num_supports</code> is 10.</p><pre><code class="language-julia-repl">julia&gt; mref3 = integral(y^2 + u^2, t, num_supports = 20)
integral{t ∈ [0, 10]}[y(t)² + u(t)²]</code></pre><p>Two other explicit measure type methods include <a href="#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a> for expectations  and <a href="#InfiniteOpt.MeasureToolbox.support_sum"><code>support_sum</code></a> for summing an expression over the support points of  selected infinite parameters. The syntax for these is analogous to that of <code>integral</code>  except that there are no lower/upper bounds. For example, we can define the following  expectation of a random expression:</p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel();

julia&gt; @infinite_parameter(m, ξ in Normal(), num_supports = 100);

julia&gt; @infinite_variable(m, x(ξ));

julia&gt; expect_x = expect(x^2, ξ)
expect{ξ}[x(ξ)²]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For integrals, expectations, and support sums involving moderate to large  expressions, the macro versions <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a>, <a href="#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a>, and  <a href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>@support_sum</code></a> should be used instead of their functional equivalents  for better performance. </p></div></div><p>Depending on the type of measures created, support points may be generated at the time of creating the measures. In these cases, the new support points will be added to the support list of the integrated parameter.</p><p>Once a measure is created, the evaluation of that measure is stored in a measure data object. Users can query the measure data object using the <a href="#InfiniteOpt.measure_data"><code>measure_data</code></a> function as follows</p><pre><code class="language-julia-repl">julia&gt; measure_data(mref2)
DiscreteMeasureData{GeneralVariableRef,1,Float64}(t, [0.333357, 0.747257, 1.09543, 1.34633, 1.47762, 1.47762, 1.34633, 1.09543, 0.747257, 0.333357], [0.130467, 0.674683, 1.60295, 2.83302, 4.25563, 5.74437, 7.16698, 8.39705, 9.32532, 9.86953], Symbol(&quot;##703&quot;), InfiniteOpt.default_weight, 0.0, 10.0, false)

julia&gt; measure_data(mref3)
FunctionalDiscreteMeasureData{GeneralVariableRef,Float64}(t, InfiniteOpt.MeasureToolbox._trapezoid_coeff, 0, :all, InfiniteOpt.default_weight, 0.0, 10.0, false)</code></pre><p>Note that in <code>InfiniteOpt</code>, two types of measure data objects are used to store the measure data information depending on the nature of the measures created: <code>DiscreteMeasureData</code> and <code>FunctionalDiscreteMeasureData</code>. For more details on the measure data object,  refer to <a href="#Measure-Data-Generation">Measure Data Generation</a>.</p><p>Similarly, one can also query the integrand function using <a href="#InfiniteOpt.measure_function"><code>measure_function</code></a>:</p><pre><code class="language-julia-repl">julia&gt; measure_function(mref3)
y(t)² + u(t)²</code></pre><p>In addition to <code>eval_method</code> and <code>num_supports</code> as shown above, <code>integral</code> function  also accepts <code>weight_func</code> as keyword argument, which dictates the weight function of the measure. The default value of these keyword arguments can be queried using <a href="#InfiniteOpt.MeasureToolbox.uni_integral_defaults"><code>uni_integral_defaults</code></a> and <a href="#InfiniteOpt.MeasureToolbox.multi_integral_defaults"><code>multi_integral_defaults</code></a> as follows:</p><pre><code class="language-julia-repl">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :num_supports =&gt; 10
  :eval_method  =&gt; Automatic
  :weight_func  =&gt; default_weight

julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :num_supports =&gt; 10
  :eval_method  =&gt; Automatic
  :weight_func  =&gt; default_weight</code></pre><p><code>Automatic</code> dictates that the integral is created using the default method depending on the type of integral, and <code>default_weight</code> is assigning weights of 1 for all points.</p><p>Now suppose we want to create multiple measures that share the same keyword argument  values that are different from the defaults. We don&#39;t have to input the keyword argument values every time we construct a new measure. Instead, we can modify the default values of measure keyword arguments, and construct measures using the new  default values. To do that, we use the functions <a href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>set_uni_integral_defaults</code></a> and <a href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>set_multi_integral_defaults</code></a>. Adding new keyword arguments will be useful if users want to extend the measure  functions with their custom discretization/evaluation schemes that need to take  additional arguments somehow. See <a href="../../extensions/#Extensions">Extensions</a> for more details.</p><p>Now we can add integrals to the constraints and objective functions in our model using these measures. For more detailed information, please review the information below.</p><h2 id="Theoretical-Abstraction"><a class="docs-heading-anchor" href="#Theoretical-Abstraction">Theoretical Abstraction</a><a id="Theoretical-Abstraction-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Abstraction" title="Permalink"></a></h2><p>In <code>InfiniteOpt</code>, measures represent integrals of the form</p><div>\[\int_{\tau \in \mathcal{T}} f(\tau)w(\tau) d\tau\]</div><p>where <span>$\tau$</span> is a (possibly multivariate) infinite parameter, <span>$f(\tau)$</span> is an expression parameterized by <span>$\tau$</span>, <span>$w(\tau)$</span> is a weight function, and <span>$\mathcal{T}$</span> is a subset of the domain of <span>$\tau$</span>. The measures approximate the integrals by taking a discretization scheme</p><div>\[\int_{\tau \in \mathcal{T}} f(\tau)w(\tau) d\tau \approx \sum_{i=1}^N \alpha_i f(\tau_i) w(\tau_i)\]</div><p>where <span>$\tau_i$</span> are the grid points where the expression <span>$f(\tau)$</span> is evaluated, and <span>$N$</span> is the total number of points taken.</p><p>This is the abstraction behind both <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> and  <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a> which are the native measure data types  in InfiniteOpt. The <a href="#Measure-Data-Generation">Measure Data Generation</a> section below details how  these can be implemented to enable schemes that fit this mathematical paradigm, but  lie out of the realm of the supported features behind <code>integral</code>, <code>expect</code>, and  <code>support_sum</code>.</p><h2 id="Measure-Data-Generation"><a class="docs-heading-anchor" href="#Measure-Data-Generation">Measure Data Generation</a><a id="Measure-Data-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-Data-Generation" title="Permalink"></a></h2><p>The most general form of <a href="#InfiniteOpt.measure"><code>measure</code></a> function takes two arguments: the integrand expression and a measure data object that contains the details of the discretization scheme. Measure data objects can be constructed using <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, where the parameter of integration, the coefficients <span>$\alpha_i$</span>, and the support points need to be defined explicitly. For example, if we want to evaluate a function at each integer time point between 0 and 10, we can construct the following measure data object to record this discretization scheme:</p><pre><code class="language-julia-repl">julia&gt; md_t = DiscreteMeasureData(t, ones(10), [i for i in 1:10])
DiscreteMeasureData{GeneralVariableRef,1,Float64}(t, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0], Symbol(&quot;##707&quot;), InfiniteOpt.default_weight, NaN, NaN, false)</code></pre><p>The arguments of <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> are parameter, coefficients, and supports. The default weight function is <span>$w(\tau) = 1$</span> for any <span>$\tau$</span>, which can be overwritten by the keyword argument <code>weight_function</code>. The <code>weight_function</code> should take a function that returns a number for any value that is well defined for the integrated infinite parameter. The data type is <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, which is a subtype of the abstract data type <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><p>With <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, a measure can be generated in a custom and quick manner. For example, using the measure data above, we can define a measure for <span>$y^2$</span> as follows:</p><pre><code class="language-julia-repl">julia&gt; mref = measure(y^2, md_t)
measure{t}[y(t)²]</code></pre><p>In the same way, we can define measure data for multivariate infinite parameter. For example, we can define a discretization scheme for a 2D position parameter <span>$x \in [0, 1] \times [0, 1]$</span> as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:2] in [0, 1])
2-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]

julia&gt; md_x = DiscreteMeasureData(x, 0.25 * ones(4), [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]])
DiscreteMeasureData{Array{GeneralVariableRef,1},2,Array{Float64,1}}(GeneralVariableRef[x[1], x[2]], [0.25, 0.25, 0.25, 0.25], [0.25 0.25 0.75 0.75; 0.25 0.75 0.25 0.75], Symbol(&quot;##712&quot;), InfiniteOpt.default_weight, [NaN, NaN], [NaN, NaN], false)</code></pre><p>where <code>md_x</code> cuts the domain into four 0.5-by-0.5 squares, and evaluates the integrand on the center of these squares. Note that for multivariate parameters,  each support point should be an <code>AbstractArray</code> that stores the value at each dimension.</p><p>In addition to the intuitive [<code>DiscreteMeasureData</code>], another type of measure data  object is <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. This type captures measure data where the support points are not known at the time of measure data creation. Instead of  storing the specific support and coefficient values, <code>FunctionalDiscreteMeasureData</code> stores the minimum number of supports required for the measure, and a coefficient function that maps supports to coefficients. When the measure is built on a <code>FunctionalDiscreteMeasureData</code>  is evaluated (expanded), supports will be generated based on the functions stored in  the data object. The method of support generation is recorded as a <code>label</code> in the measure object. </p><p>For example, suppose we want to uniformly generate at least 20 Monte Carlo samples  over the interval that <code>t</code> is in. A build-in label <code>UniformGrid</code> can be used to  signify the use of this method. A <code>FunctionalDiscreteMeasureData</code> can be created as follows:</p><pre><code class="language-julia-repl">julia&gt; coeff_f(supports) = [(10 - 0) / length(supports) for i in supports]
coeff_f (generic function with 1 method)

julia&gt; fmd_t = FunctionalDiscreteMeasureData(t, coeff_f, 20, UniformGrid)
FunctionalDiscreteMeasureData{GeneralVariableRef,Float64}(t, coeff_f, 20, :uniform_grid, InfiniteOpt.default_weight, NaN, NaN, false)</code></pre><p>For more details see <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. </p><p>The <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> function shown in <a href="#measure_basic_usage">Basic Usage</a>,  which does not require explicit construction of the measure data object, calls the <a href="#InfiniteOpt.measure"><code>measure</code></a> function at the lower level. To do that, [<code>integral</code>]  constructs the appropriate measure data object according to the values of the positional and keyword arguments.</p><h2 id="Evaluation-Methods"><a class="docs-heading-anchor" href="#Evaluation-Methods">Evaluation Methods</a><a id="Evaluation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Methods" title="Permalink"></a></h2><p>The <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> function calls <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> under the hood to construct the measure data object. <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> takes as positional arguments the integrated parameter, lower bound, upper bound, and method, and returns a measure data object of type <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>.</p><p><a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> applies multiple dispatch to encode different support generation methods depending on the input <code>eval_method</code>. Each dispatch is distingushed by  the <code>method</code>, which takes a concrete subtype of <code>AbstractIntegralMethod</code>.  Each dispatch of <code>generate_integral_data</code> implements the specified method and returns the resulting measure data, which will be used by [<code>@integral</code>] to create the measure. A table of available <code>method</code> options in our package is listed below. Each method is limited on the dimension of parameter and/or the type of set that it can apply for. For the details of what each method type means, refer to the corresponding docstrings.</p><table><tr><th style="text-align: center">Evaluation Method</th><th style="text-align: center">Uni/Multi-Variate?</th><th style="text-align: center">Set Type</th></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic</code></a></td><td style="text-align: center">Both</td><td style="text-align: center">All</td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>UniTrapezoid</code></a></td><td style="text-align: center">Both</td><td style="text-align: center"><a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>UniIndepMCSampling</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>Quadrature</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center"><a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>GaussLegendre</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>GaussLaguerre</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center">Semi-infinite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>GaussHermite</code></a></td><td style="text-align: center">Univariate</td><td style="text-align: center">Infinite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling</code></a></td><td style="text-align: center">Multivariate</td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr><tr><td style="text-align: center"><a href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>MultiIndepMCSampling</code></a></td><td style="text-align: center">Multivariate</td><td style="text-align: center">Finite <a href="../sets/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a></td></tr></table><p>In summary, the package supports trapezoid rule, Gaussian quadrature methods for univariate parameters, and Monte Carlo sampling for both univariate and multivariate parameters. For extension purposes, users may define their own <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> to encode custom evaluation methods. See <a href="../../extensions/#Extensions">Extensions</a> for more details.</p><h2 id="Expansion"><a class="docs-heading-anchor" href="#Expansion">Expansion</a><a id="Expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Expansion" title="Permalink"></a></h2><p>In a model, each measure records the integrand expression and an evaluation scheme that details the discretization scheme to approximate the integral. The model will not expand the measures until the transcription stage, at which a <code>JuMP.AbstractJuMPScalar</code> is created for each measure to represent how the measure is modeled in a transcription model based on the stored discretization scheme (see <a href="../transcribe/#transcription_docs">Model Transcription</a> for details on transcription). Additional point variables will be created in the expansion process if the measure is evaluated at infinite parameter points that do not have corresponding point variables yet.</p><p>Sometimes for extension purposes, one might want to expand a specific measure before reaching the transcription stage. Alternatively, one might want to use custom reformulation instead of the transcription encoded in this package, in which expanding measures will also be useful. This can be done using the <a href="#InfiniteOpt.expand"><code>expand</code></a> function, which takes a <a href="#InfiniteOpt.MeasureRef"><code>MeasureRef</code></a> object and returns a <code>JuMP.AbstractJuMPScalar</code> based on the <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>. For example, suppose we want to integrate <span>$y^2$</span> in <span>$t$</span>, with two supports <span>$t = 2.5$</span> and <span>$t = 7.5$</span>. We can set up and expand this measure as follows:</p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [5, 5], [2.5, 7.5])
DiscreteMeasureData{GeneralVariableRef,1,Float64}(t, [5.0, 5.0], [2.5, 7.5], Symbol(&quot;##713&quot;), InfiniteOpt.default_weight, NaN, NaN, false)

julia&gt; mref4 = measure(y^2, tdata)
measure{t}[y(t)²]

julia&gt; expanded_measure = expand(mref4)
5 y(2.5)² + 5 y(7.5)²

julia&gt; typeof(expanded_measure)
GenericQuadExpr{Float64,GeneralVariableRef}</code></pre><p>In the expand call, two point variables, <code>y(2.5)</code> and <code>y(7.5)</code>, are created because they are not defined in the model before the expand call. One can use the <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a> function to expand all measures in a model, which simply applies the <a href="#InfiniteOpt.expand"><code>expand</code></a> to all measures stored in the model.</p><h2 id="Reduced-Infinite-Variables"><a class="docs-heading-anchor" href="#Reduced-Infinite-Variables">Reduced Infinite Variables</a><a id="Reduced-Infinite-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Reduced-Infinite-Variables" title="Permalink"></a></h2><p>Expanding measures that cover a subset of infinite parameter dependencies present  in an expression will introduce reduced infinite variables to the model. To see what this means, suppose we have an infinite variable that is parameterized by multiple infinite parameters defined as follows:</p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, T(x, t))
T(x, t)</code></pre><p>Now say we want to integrate <code>T</code> over <code>t</code>. We can define a measure for the integral similar to how we have defined other measures:</p><pre><code class="language-julia-repl">julia&gt; mref5 = measure(T, tdata)
measure{t}[T(x, t)]</code></pre><p>Now if we expand this measure, the measure data object <code>tdata</code> records the supports for <code>t</code>, but no supports for <code>x</code> because <code>T</code> is not evaluated over <code>x</code> in this measure. Therefore, point variables cannot be defined in the measure expansion.</p><p>Instead of point variables, each new variable in the measure expansion will be represented using reduced infinite variables. Reduced infinite variables are &quot;reduced&quot; from their original infinite variables in that they are parameterized by less infinite parameters. In the example above, in the expansion each reduced infinite variable for <code>T</code> should only be parameterized by <code>x</code> since the value of <code>t</code> is fixed. The expanded measure now looks like this:</p><pre><code class="language-julia-repl">julia&gt; expanded_measure = expand(mref5)
5 T([x[1], x[2]], 2.5) + 5 T([x[1], x[2]], 7.5)</code></pre><p>where the expanded measure is a <code>JuMP.GenericAffExpr</code> that takes in its terms <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>s pointing to <a href="#InfiniteOpt.ReducedVariable"><code>ReducedVariable</code></a>s created on the fly. <a href="#InfiniteOpt.ReducedVariable"><code>ReducedVariable</code></a> refers to the information of the reduced infinite variable stored in its model. The reduced variable records a reference for its original infinite variable, and the value of the fixed infinite parameter. One can query this information using <a href="../expression/#InfiniteOpt.infinite_variable_ref-Tuple{GeneralVariableRef}"><code>infinite_variable_ref</code></a> and <a href="../expression/#InfiniteOpt.eval_supports-Tuple{GeneralVariableRef}"><code>eval_supports</code></a> function as follows:</p><pre><code class="language-julia-repl">julia&gt; T1 = first(keys(expanded_measure.terms))
T([x[1], x[2]], 2.5)

julia&gt; infinite_variable_ref(T1)
T(x, t)

julia&gt; eval_supports(T1)
Dict{Int64,Float64} with 1 entry:
  3 =&gt; 2.5</code></pre><p>All the <code>JuMP</code> functions extended for infinite variables are also extended for reduced infinite variables, e.g. <a href="#JuMP.lower_bound-Tuple{ReducedVariableRef}"><code>JuMP.lower_bound</code></a>.</p><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Array{#s38,1} where #s38&lt;:Real,Array{#s9,1} where #s9&lt;:(AbstractArray{#s5,N} where N where #s5&lt;:Real)}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef,Array{#s38,1} where #s38&lt;:Real,Array{#s9,1} where #s9&lt;:Real}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef,Function,Int64,Symbol}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Function,Int64,Symbol}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a></li><li><a href="#InfiniteOpt.MeasureData"><code>InfiniteOpt.MeasureData</code></a></li><li><a href="#InfiniteOpt.MeasureIndex"><code>InfiniteOpt.MeasureIndex</code></a></li><li><a href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a></li><li><a href="#InfiniteOpt.ReducedVariable"><code>InfiniteOpt.ReducedVariable</code></a></li><li><a href="#InfiniteOpt.ReducedVariableIndex"><code>InfiniteOpt.ReducedVariableIndex</code></a></li><li><a href="#InfiniteOpt.ReducedVariableRef"><code>InfiniteOpt.ReducedVariableRef</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractMeasureData" href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractMeasureData</code></pre><p>An abstract type to define data for measures to define the behavior of <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL573-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData" href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData{P &lt;: Union{JuMP.AbstractVariableRef,
                    Vector{&lt;:JuMP.AbstractVariableRef}},
                    N, B &lt;: Union{Float64, Vector{Float64}}
                    } &lt;: AbstractMeasureData</code></pre><p>A DataType for immutable measure abstraction data where the abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>. The supports and coefficients are immutable (i.e., they will not change even if supports are changed for the underlying infinite parameter.) This type can be used for both 1-dimensional and multi-dimensional measures.</p><p><strong>Fields</strong></p><ul><li><code>parameter_refs::P</code>: The infinite parameter(s) over which the integration occurs.                      These can be comprised of multiple independent parameters,                      but dependent parameters cannot be mixed with other types.</li><li><code>coefficients::Vector{Float64}</code>: Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Array{Float64, N}</code>: Supports points <span>$\tau_i$</span>. This is a <code>Vector</code>                                if only one parameter is given, otherwise it is                                a <code>Matrix</code> where the supports are stored column-wise.</li><li><code>label::Symbol</code>: Label for the support points <span>$\tau_i$</span> when stored in the                  infinite parameter(s).</li><li><code>weight_function::Function</code>: Weighting function <span>$w$</span> must map an individual                              support value to a <code>Real</code> scalar value.</li><li><code>lower_bounds::B</code>: Lower bound in accordance with <span>$T$</span>, this denotes the                   intended interval of the measure and should be <code>NaN</code> if ignored</li><li><code>upper_bounds::B</code>: Same as above but the upper bound.</li><li><code>is_expect::Bool</code>: Is this data associated with an expectation call?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL581-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData" href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionalDiscreteMeasureData{P &lt;: Union{JuMP.AbstractVariableRef,
                              Vector{&lt;:JuMP.AbstractVariableRef}},
                              B &lt;: Union{Float64, Vector{Float64}}
                              } &lt;: AbstractMeasureData</code></pre><p>A DataType for mutable measure abstraction data where the abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>. This abstraction is equivalent to that of <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>, but the difference is that the supports are not fully known at the time of measure creation. Thus, functions are stored that will be used to generate the concrete support points <span>$\tau_i$</span> and their coefficients <span>$\alpha_i$</span> when the measure is evaluated (expanded). These supports are identified/generated in accordance with the <code>label</code> with a gaurantee that at least <code>num_supports</code> are generated. For example, if <code>label = MCSample</code> and <code>num_supports = 100</code> then the measure will use all of the supports stored in the <code>parameter_refs</code> with the label <code>MCSample</code> and will ensure there are at least 100 are generated. This type can be used for both 1-dimensional and multi-dimensional measures.</p><p><strong>Fields</strong></p><ul><li><code>parameter_refs::P</code>: The infinite parameter(s) over which the integration occurs.                    These can be comprised of multiple independent parameters,                    but dependent parameters cannot be mixed with other types.</li><li><code>coeff_function::Function</code>: Coefficient generation function making <span>$\alpha_i$</span>                             for the above measure abstraction. It should take                             all the supports as input (formatted as an Array)                             and return the corresponding vector of coefficients.</li><li><code>min_num_supports::Int</code>: Specifies the minimum number of supports <span>$\tau_i$</span>                      desired in association with <code>parameter_refs</code> and <code>label</code>.</li><li><code>label::Symbol</code>: Label for the support points <span>$\tau_i$</span> which are/will be                  stored in the infinite parameter(s).</li><li><code>weight_function::Function</code>: Weighting function <span>$w$</span> must map an individual                             support value to a <code>Real</code> scalar value.</li><li><code>lower_bounds::B</code>: Lower bounds in accordance with <span>$T$</span>, this denotes the                 intended interval of the measure and should be <code>NaN</code> if ignored</li><li><code>upper_bounds::B</code>: Same as above but the upper bounds.</li><li><code>is_expect::Bool</code>: Is this data associated with an expectation call?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL649-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Measure" href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Measure{T &lt;: JuMP.AbstractJuMPScalar, V &lt;: AbstractMeasureData}</code></pre><p>A <code>DataType</code> for measure abstractions. The abstraction is determined by <code>data</code> and is enacted on <code>func</code> when the measure is evaluated (expended).</p><p><strong>Fields</strong></p><ul><li><code>func::T</code> The <code>InfiniteOpt</code> expression to be measured.</li><li><code>data::V</code> Data of the abstraction as described in a <code>AbstractMeasureData</code>           concrete subtype.</li><li><code>object_nums::Vector{Int}</code>: The parameter object numbers of the evaluated                             measure expression (i.e., the object numbers of                             <code>func</code> excluding those that belong to <code>data</code>).</li><li><code>parameter_nums::Vector{Int}</code>: The parameter numbers that parameterize the                                evaluated measure expression. (i.e., the                                parameter numbers of <code>func</code> excluding those                                that belong to <code>data</code>).</li><li><code>constant_func::Bool</code>: Indicates if <code>func</code> is not parameterized by the infinite                        parameters in <code>data</code>. (i.e., do the object numbers of                        <code>func</code> and <code>data</code> have no intersection?) This is useful                        to enable analytic evaluations if possible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL726-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureIndex" href="#InfiniteOpt.MeasureIndex"><code>InfiniteOpt.MeasureIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL124-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureData" href="#InfiniteOpt.MeasureData"><code>InfiniteOpt.MeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureData &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing <a href="#InfiniteOpt.Measure"><code>Measure</code></a>s and their data.</p><p><strong>Fields</strong></p><ul><li><code>measure::Measure</code>: The measure structure.</li><li><code>name::String</code>: The base name used for printing <code>name(meas_expr d(par))</code>.</li><li><code>measure_indices::Vector{MeasureIndex}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{ConstraintIndex}</code>: Indices of dependent constraints.</li><li><code>in_objective::Bool</code>: Is this used in objective?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL756-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureRef" href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureRef &lt;: FiniteVariableRef</code></pre><p>A <code>DataType</code> for referring to measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::MeasureIndex</code>: Index of the measure in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL1136-L1144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ReducedVariable" href="#InfiniteOpt.ReducedVariable"><code>InfiniteOpt.ReducedVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReducedVariable{I &lt;: GeneralVariableRef} &lt;: InfOptVariable</code></pre><p>A <code>DataType</code> for storing reduced infinite variables which partially support an infinite variable.</p><p><strong>Fields</strong></p><ul><li><code>infinite_variable_index::I</code>: The original infinite variable.</li><li><code>eval_supports::Dict{Int, Float64}</code>: The original parameter tuple linear indices                                    to the evaluation supports.</li><li><code>parameter_nums::Vector{Int}</code>: The parameter numbers associated with the reduced                                <code>parameter_refs</code>.</li><li><code>object_nums::Vector{Int}</code>: The parameter object numbers associated with the                             reduced <code>parameter_refs</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL470-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ReducedVariableIndex" href="#InfiniteOpt.ReducedVariableIndex"><code>InfiniteOpt.ReducedVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReducedVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.ReducedVariable"><code>ReducedVariable</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ReducedVariableRef" href="#InfiniteOpt.ReducedVariableRef"><code>InfiniteOpt.ReducedVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReducedVariableRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataTyp</code>e for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::ReducedVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/datatypes.jl#LL1113-L1123">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.@measure"><code>InfiniteOpt.@measure</code></a></li><li><a href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a></li><li><a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.add_measure_variable</code></a></li><li><a href="#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}"><code>InfiniteOpt.add_supports_to_parameters</code></a></li><li><a href="#InfiniteOpt.all_measures"><code>InfiniteOpt.all_measures</code></a></li><li><a href="#InfiniteOpt.analytic_expansion"><code>InfiniteOpt.analytic_expansion</code></a></li><li><a href="#InfiniteOpt.build_measure"><code>InfiniteOpt.build_measure</code></a></li><li><a href="#InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficient_function</code></a></li><li><a href="#InfiniteOpt.coefficients-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficients</code></a></li><li><a href="#InfiniteOpt.default_weight"><code>InfiniteOpt.default_weight</code></a></li><li><a href="#InfiniteOpt.delete_internal_reduced_variable"><code>InfiniteOpt.delete_internal_reduced_variable</code></a></li><li><a href="#InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.delete_reduced_variable</code></a></li><li><a href="#InfiniteOpt.eval_supports-Tuple{ReducedVariableRef}"><code>InfiniteOpt.eval_supports</code></a></li><li><a href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a></li><li><a href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a></li><li><a href="#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a></li><li><a href="#InfiniteOpt.expand_measures"><code>InfiniteOpt.expand_measures</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.internal_reduced_variable"><code>InfiniteOpt.internal_reduced_variable</code></a></li><li><a href="#InfiniteOpt.is_analytic"><code>InfiniteOpt.is_analytic</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.make_point_variable_ref"><code>InfiniteOpt.make_point_variable_ref</code></a></li><li><a href="#InfiniteOpt.make_reduced_variable_ref"><code>InfiniteOpt.make_reduced_variable_ref</code></a></li><li><a href="#InfiniteOpt.measure"><code>InfiniteOpt.measure</code></a></li><li><a href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a></li><li><a href="#InfiniteOpt.measure_data_in_hold_bounds-Tuple{AbstractMeasureData,ParameterBounds}"><code>InfiniteOpt.measure_data_in_hold_bounds</code></a></li><li><a href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a></li><li><a href="#InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.min_num_supports</code></a></li><li><a href="#InfiniteOpt.num_measures"><code>InfiniteOpt.num_measures</code></a></li><li><a href="#InfiniteOpt.num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.num_supports</code></a></li><li><a href="#InfiniteOpt.parameter_list-Tuple{ReducedVariableRef}"><code>InfiniteOpt.parameter_list</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{ReducedVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{MeasureRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.raw_parameter_refs-Tuple{ReducedVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a></li><li><a href="#InfiniteOpt.start_value_function-Tuple{ReducedVariableRef}"><code>InfiniteOpt.start_value_function</code></a></li><li><a href="#InfiniteOpt.support_label-Tuple{AbstractMeasureData}"><code>InfiniteOpt.support_label</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#InfiniteOpt.weight_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.weight_function</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{ReducedVariableRef}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{ReducedVariableRef}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{ReducedVariableRef}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{ReducedVariableRef}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{ReducedVariableRef}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.add_variable-Tuple{InfiniteModel,ReducedVariable,String}"><code>JuMP.add_variable</code></a></li><li><a href="#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.fix_value-Tuple{ReducedVariableRef}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{ReducedVariableRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{ReducedVariableRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.is_binary-Tuple{ReducedVariableRef}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_fixed-Tuple{ReducedVariableRef}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_integer-Tuple{ReducedVariableRef}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.lower_bound-Tuple{ReducedVariableRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.lower_bound-Tuple{AbstractMeasureData}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.set_name-Tuple{ReducedVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.upper_bound-Tuple{ReducedVariableRef}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{AbstractMeasureData}"><code>JuMP.upper_bound</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.default_weight" href="#InfiniteOpt.default_weight"><code>InfiniteOpt.default_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_weight(t) = 1</code></pre><p>Default weight function for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> and <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Returns 1 regardless of the input value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef,Array{#s38,1} where #s38&lt;:Real,Array{#s9,1} where #s9&lt;:Real}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef,Array{#s38,1} where #s38&lt;:Real,Array{#s9,1} where #s9&lt;:Real}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData(pref::GeneralVariableRef,
                    coefficients::Vector{&lt;:Real},
                    supports::Vector{&lt;:Real};
                    [label::Symbol = gensym(),
                    weight_function::Function = [`default_weight`](@ref),
                    lower_bound::Real = NaN,
                    upper_bound::Real = NaN,
                    is_expect::Bool = false]
                    )::DiscreteMeasureData</code></pre><p>Returns a 1-dimensional <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds or an unequal number of supports and coefficients are given. Note that by default a unique <code>label</code> is generated via <code>gensym</code> to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2])
DiscreteMeasureData{GeneralVariableRef,1,Float64}(pref, [0.5, 0.5], [1.0, 2.0], Symbol(&quot;##373&quot;), default_weight, NaN, NaN, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL104-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Array{#s38,1} where #s38&lt;:Real,Array{#s9,1} where #s9&lt;:(AbstractArray{#s5,N} where N where #s5&lt;:Real)}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Array{#s38,1} where #s38&lt;:Real,Array{#s9,1} where #s9&lt;:(AbstractArray{#s5,N} where N where #s5&lt;:Real)}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData(prefs::AbstractArray{GeneralVariableRef},
                    coefficients::Vector{&lt;:Real},
                    supports::Vector{&lt;:AbstractArray{&lt;:Real}};
                    label::Symbol = gensym(),
                    weight_function::Function = [`default_weight`](@ref),
                    lower_bounds::AbstractArray{&lt;:Real} = [NaN...],
                    upper_bounds::AbstractArray{&lt;:Real} = [NaN...],
                    is_expect::Bool = false
                    )::DiscreteMeasureData</code></pre><p>Returns a <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for <code>parameter_refs</code>. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or if mixed infinite parameter types are given. Note that by default a unique <code>label</code> is generated via <code>gensym</code> to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]]);

julia&gt; typeof(data)
DiscreteMeasureData{Array{GeneralVariableRef,1},2,Array{Float64,1}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL222-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef,Function,Int64,Symbol}" href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef,Function,Int64,Symbol}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FunctionalDiscreteMeasureData(pref::GeneralVariableRef,
                              coeff_func::Function,
                              min_num_supports::Int,
                              label::Symbol;
                              [weight_function::Function = [`default_weight`](@ref),
                              lower_bound::Real = NaN,
                              upper_bound::Real = NaN,
                              is_expect::Bool = false]
                              )::FunctionalDiscreteMeasureData</code></pre><p>Returns a 1-dimensional <code>FunctionalDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Errors if <code>pref</code> is not an infinite parameter. Built-in choices for <code>label</code> include:</p><ul><li><code>All</code>: Use all of the supports stored in <code>pref</code></li><li><code>MCSample</code>: Use Monte Carlo samples associated with <code>pref</code></li><li><code>WeightedSample</code>: Use weighted Monte Carlo samples associated with <code>pref</code></li><li><code>UniformGrid</code>: Use uniform grid points associated with <code>pref</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = FunctionalDiscreteMeasureData(pref, my_func, 20, UniformGrid)
FunctionalDiscreteMeasureData{GeneralVariableRef,Float64}(pref, my_func, 20, UniformGrid, default_weight, NaN, NaN, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL280-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Function,Int64,Symbol}" href="#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Function,Int64,Symbol}"><code>InfiniteOpt.FunctionalDiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FunctionalDiscreteMeasureData(prefs::AbstractArray{GeneralVariableRef},
                              coeff_func::Function,
                              min_num_supports::Int,
                              label::Symbol;
                              [weight_function::Function = [`default_weight`](@ref),
                              lower_bounds::AbstractArray{&lt;:Real} = [NaN...],
                              upper_bounds::AbstractArray{&lt;:Real} = [NaN...],
                              is_expect::Bool = false]
                              )::FunctionalDiscreteMeasureData</code></pre><p>Returns a multi-dimensional <code>FunctionalDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure"><code>measure</code></a>. This accepts input for an array of infinite parameters. A description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.FunctionalDiscreteMeasureData"><code>FunctionalDiscreteMeasureData</code></a>. Errors if <code>prefs</code> are not infinite parameters or if the mixed parameter types are provided. Built-in choices for <code>label</code> include:</p><ul><li><code>All</code>: Use all of the supports stored in <code>prefs</code></li><li><code>MCSample</code>: Use Monte Carlo samples associated with <code>prefs</code></li><li><code>WeightedSample</code>: Use weighted Monte Carlo samples associated with <code>prefs</code></li><li><code>UniformGrid</code>: Use uniform grid points associated with <code>prefs</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = FunctionalDiscreteMeasureData(prefs, my_func, 20, MCSample);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL354-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}" href="#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(data::AbstractMeasureData)::Union{GeneralVariableRef,
                                                 AbstractArray{GeneralVariableRef}}</code></pre><p>Return the infinite parameter reference(s) in <code>data</code>. This is intended as an internal function to be used with measure addition. User-defined measure data types will need to extend this function otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL409-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_label-Tuple{AbstractMeasureData}" href="#InfiniteOpt.support_label-Tuple{AbstractMeasureData}"><code>InfiniteOpt.support_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">support_label(data::AbstractMeasureData)::Symbol</code></pre><p>Return the label stored in <code>data</code> associated with its supports. This is intended as en internal method for measure creation and ensures any new supports are added to parameters with such a label. User-defined measure data types should extend this functionif supports are used, otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL431-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{AbstractMeasureData}" href="#JuMP.lower_bound-Tuple{AbstractMeasureData}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}</code></pre><p>Return the lower bound associated with <code>data</code> that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise <code>NaN</code> is returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL451-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{AbstractMeasureData}" href="#JuMP.upper_bound-Tuple{AbstractMeasureData}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}</code></pre><p>Return the lower bound associated with <code>data</code> that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise <code>NaN</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL469-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supports(data::AbstractMeasureData)::Array{Float64}</code></pre><p>Return the supports associated with <code>data</code> and its infinite parameters. This is intended as en internal method for measure creation and ensures any new supports are added to parameters. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL499-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_supports(data::AbstractMeasureData)::Int</code></pre><p>Return the number supports associated with <code>data</code> and its infinite parameters. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise 0 is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL541-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}" href="#InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.min_num_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">min_num_supports(data::AbstractMeasureData)::Int</code></pre><p>Return the minimum number of supports associated with <code>data</code>. By fallback, this will just return <code>num_supports(data)</code>. This is primarily intended for internal queries of <code>FunctionalDiscreteMeasureData</code>, but can be extended for other measure data types if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL559-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}" href="#InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficient_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coefficient_function(data::AbstractMeasureData)::Function</code></pre><p>Return the coefficient function stored in <code>data</code> associated with its expansion abstraction is there is such a function. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown for unsupported types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL576-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.coefficients-Tuple{AbstractMeasureData}" href="#InfiniteOpt.coefficients-Tuple{AbstractMeasureData}"><code>InfiniteOpt.coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coefficients(data::AbstractMeasureData)::Vector{&lt;:Real}</code></pre><p>Return the coefficients associated with <code>data</code> associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL595-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.weight_function-Tuple{AbstractMeasureData}" href="#InfiniteOpt.weight_function-Tuple{AbstractMeasureData}"><code>InfiniteOpt.weight_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">weight_function(data::AbstractMeasureData)::Function</code></pre><p>Return the weight function stored in <code>data</code> associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL617-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_measure" href="#InfiniteOpt.build_measure"><code>InfiniteOpt.build_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_measure(expr::JuMP.AbstractJuMPScalar,
              data::AbstractMeasureData)::Measure</code></pre><p>Build and return a <a href="#InfiniteOpt.Measure"><code>Measure</code></a> given the expression to be measured <code>expr</code> using measure data <code>data</code>. This principally serves as an internal method for measure definition. Errors if the supports associated with <code>data</code> violate an hold variable parameter bounds of hold variables that are included in the measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL704-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_data_in_hold_bounds-Tuple{AbstractMeasureData,ParameterBounds}" href="#InfiniteOpt.measure_data_in_hold_bounds-Tuple{AbstractMeasureData,ParameterBounds}"><code>InfiniteOpt.measure_data_in_hold_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure_data_in_hold_bounds(data::AbstractMeasureData,
                            bounds::ParameterBounds)::Bool</code></pre><p>Return a <code>Bool</code> whether the domain of <code>data</code> is valid in accordance with <code>bounds</code>. This is intended as an internal method and is used to check hold variables used in measures. User-defined measure data types will need to extend this function to enable this error checking, otherwise it is skipped and a warning is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL638-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure" href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_measure(model::InfiniteModel, meas::Measure,
            name::String = &quot;measure&quot;)::GeneralVariableRef</code></pre><p>Add a measure to <code>model</code> and return the corresponding measure reference. This operates in a manner similar to <code>JuMP.add_variable</code>. Note this intended as an internal method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL889-L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}" href="#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}"><code>InfiniteOpt.add_supports_to_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_supports_to_parameters(data::AbstractMeasureData)::Nothing</code></pre><p>Add supports as appropriate with <code>data</code> to the underlying infinite parameters. This is an internal method with by <a href="#InfiniteOpt.add_measure"><code>add_measure</code></a> and should be defined for user-defined measure data types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL763-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_function" href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return the function associated with <code>mref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; measure_function(meas)
y(x, t) + 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL925-L935">source</a></section><section><div><pre><code class="language-julia">InfiniteOpt.measure_function(mref::GeneralVariableRef)</code></pre><p>Define <code>InfiniteOpt.measure_function</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/general_variables.jl#LL744-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_data" href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_data(mref::MeasureRef)::AbstractMeasureData</code></pre><p>Return the measure data associated with <code>mref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; data = measure_data(meas);

julia&gt; typeof(data)
FunctionalDiscreteMeasureData{Vector{GeneralVariableRef},Vector{Float64}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL940-L952">source</a></section><section><div><pre><code class="language-julia">InfiniteOpt.measure_data(mref::GeneralVariableRef)</code></pre><p>Define <code>InfiniteOpt.measure_data</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/general_variables.jl#LL744-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_analytic" href="#InfiniteOpt.is_analytic"><code>InfiniteOpt.is_analytic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_analytic(mref::MeasureRef)::Bool</code></pre><p>Return if <code>mref</code> is evaluated analytically.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_analytic(meas)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL957-L967">source</a></section><section><div><pre><code class="language-julia">InfiniteOpt.is_analytic(mref::GeneralVariableRef)</code></pre><p>Define <code>InfiniteOpt.is_analytic</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/general_variables.jl#LL744-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{MeasureRef}" href="#InfiniteOpt.parameter_refs-Tuple{MeasureRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(mref::MeasureRef)::Tuple</code></pre><p>Return the tuple of infinite parameters that the measured expression associated <code>mref</code> depends on once the measure has been evaluated. Note that this will correspond to the parameter dependencies of the measure function excluding those included in the measure data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(meas)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL993-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure" href="#InfiniteOpt.measure"><code>InfiniteOpt.measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure(expr::JuMP.AbstractJuMPScalar,
        data::AbstractMeasureData;
        [name::String = &quot;measure&quot;])::GeneralVariableRef</code></pre><p>Return a measure reference that evaluates <code>expr</code> using according to <code>data</code>. The measure data <code>data</code> determines how the measure is to be evaluated. Typically, the <code>DiscreteMeasureData</code> and the <code>FunctionalDiscreteMeasureData</code> constructors can be used to for <code>data</code>. The variable expression <code>expr</code> can contain <code>InfiniteOpt</code> variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Typically, this is called inside of <a href="../../JuMP/#JuMP.@expression"><code>JuMP.@expression</code></a>, <a href="../../JuMP/#JuMP.@objective"><code>JuMP.@objective</code></a>, and <a href="../../JuMP/#JuMP.@constraint"><code>JuMP.@constraint</code></a> in a manner similar to <code>sum</code>. Note measures are not explicitly evaluated until <a href="../optimize/#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> is called or unless they are expanded via <a href="#InfiniteOpt.expand"><code>expand</code></a> or <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2]);

julia&gt; xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]]);

julia&gt; constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)
measure{t}[g(t) - s + 2] + s²

julia&gt; @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))
measure{xs}[g(t) - 1 + measure{xs}[T(t, x)]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1015-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@measure" href="#InfiniteOpt.@measure"><code>InfiniteOpt.@measure</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@measure(expr::JuMP.AbstractJuMPScalar,
         data::AbstractMeasureData;
         [name::String = &quot;measure&quot;])::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.measure"><code>measure</code></a>, please see its doc string for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1058-L1065">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(mref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1124-L1134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1109-L1119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_objective(vmref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_objective(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1139-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{MeasureRef}" href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1154-L1164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{MeasureRef}" href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(mref::MeasureRef)::String</code></pre><p>Extend <code>JuMP.name</code> to return the name associated with a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1085-L1090">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{MeasureRef,String}" href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(mref::MeasureRef, name::String)::Nothing</code></pre><p>Extend <code>JuMP.set_name</code> to specify the name of a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1096-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_measures" href="#InfiniteOpt.num_measures"><code>InfiniteOpt.num_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_measures(model::InfiniteModel)::Int</code></pre><p>Return the number of measures defined in <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_measures(model)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1173-L1183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_measures" href="#InfiniteOpt.all_measures"><code>InfiniteOpt.all_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_measures(model::InfiniteModel)::Vector{GeneralVariableRef}</code></pre><p>Return the list of all measures added to <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all_measures(model)
2-element Array{GeneralVariableRef,1}:
 integral{t ∈ [0, 6]}[w(t, x)]
 expect{x}[w(t, x)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1188-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,MeasureRef}" href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, mref::MeasureRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min integral{t ∈ [0, 6]}[g(t)] + z
Subject to
 z ≥ 0.0
 integral{t ∈ [0, 6]}[g(t)] = 0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0

julia&gt; delete(model, meas)

julia&gt; print(model)
Min z
Subject to
 z ≥ 0.0
 0 = 0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measures.jl#LL1214-L1240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand" href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return a JuMP scalar function containing the explicit expansion of the measure <code>mref</code>. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with <a href="#InfiniteOpt.measure"><code>measure</code></a> to expand measures on the fly.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. Optionally, <a href="#InfiniteOpt.analytic_expansion"><code>analytic_expansion</code></a> can also be extended which is triggered by <a href="#InfiniteOpt.is_analytic"><code>is_analytic</code></a> for such types if analytic expansion is possible in certain cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])

julia&gt; expr = expand(measure(g + z + T - h - 2, tdata))
0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL672-L697">source</a></section><section><div><pre><code class="language-none">InfiniteOpt.expand(mref::GeneralVariableRef)</code></pre><p>Define <code>InfiniteOpt.expand</code> for general variable references. Errors if <code>mref</code> does not correspond to a <code>MeasureRef</code>. See the underlying docstrings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/general_variables.jl#LL744-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_all_measures!" href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_all_measures!(model::InfiniteModel)::Nothing</code></pre><p>Expand all of the measures used in the objective and/or constraints of <code>model</code>. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before <code>model</code> is translated into the new model. This method can also be extended to handle custom measure data types by extending <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. Note that this method leverages <code>expand_measure</code> via <a href="#InfiniteOpt.expand_measures"><code>expand_measures</code></a>. Optionally, <a href="#InfiniteOpt.analytic_expansion"><code>analytic_expansion</code></a> can also be extended which is triggered by <a href="#InfiniteOpt.is_analytic"><code>is_analytic</code></a> for such types if analytic expansion is possible in certain cases.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min integral{t ∈ [0, 6]}[g(t)*t] + z
Subject to
 T(t, x) ≥ 0.0, ∀ t ∈ [0, 6], xi ∈ [-1, 1]
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 integral{t ∈ [0, 6]}[T(t, x)] ≥ 0.0, ∀ x ∈ [-1, 1]

julia&gt; expand_all_measures!(model)

julia&gt; print(model)
Min 3 g(6) + z
Subject to
 T(t, x) ≥ 0.0, ∀ t ∈ [0, 6], xi ∈ [-1, 1]
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 0.5 T(0, x) + 0.5 T(6, xi) ≥ 0.0, ∀ x ∈ [-1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL773-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_measure" href="#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_measure(expr, data::AbstractMeasureData,
               write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Return the finite reformulation of a measure containing a variable/parameter expression <code>expr</code> with measure data <code>data</code>. Here <code>write_model</code> is the target model where this expanded expression will be used. Thus, any variables that need to be created will be added to <code>write_model</code>. The methods <a href="#InfiniteOpt.make_point_variable_ref"><code>make_point_variable_ref</code></a> and <a href="#InfiniteOpt.make_reduced_variable_ref"><code>make_reduced_variable_ref</code></a> should be used as appropriate to create these variables. Developers might also choose to use <a href="#InfiniteOpt.delete_internal_reduced_variable"><code>delete_internal_reduced_variable</code></a> in order to remove reduced variables once they are no longer needed. Note this is intended as an internal function, but will need to be extended for unsupported <code>expr</code> types and for user-defined measure data types. Principally, this is leveraged to enable the user methods <a href="#InfiniteOpt.expand"><code>expand</code></a> and <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL158-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.analytic_expansion" href="#InfiniteOpt.analytic_expansion"><code>InfiniteOpt.analytic_expansion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analytic_expansion(expr, data::AbstractMeasureData,
                   write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Analytically, evaluate measure in the simple case where the measure expression <code>expr</code> doesn&#39;t depend on <code>data</code> and thus <code>expr</code> can be treated as a constant in conjunction with an analytic result of the <code>data</code>. This is intended as an internal method that is used by <a href="#InfiniteOpt.expand"><code>expand</code></a> and <a href="#InfiniteOpt.expand_measures"><code>expand_measures</code></a>. For unrecognized <code>data</code> types, <code>expand_measure</code> is called instead. User defined measure data type may choose to extend this method if desired. This is triggered when <code>is_analytic(mref) = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL600-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_measures" href="#InfiniteOpt.expand_measures"><code>InfiniteOpt.expand_measures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_measures(expr, write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar</code></pre><p>Expand all <code>MeasureRef</code>s in <code>expr</code> in-place via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a> and return the expanded expression. This is an internal method used by <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a> and <code>TranscriptionOpt</code> but can be useful for user-defined optimizer model extensions that add implement <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> in combination with <code>expand_measure</code>. <code>write_model</code> is the model that the measure variables are added to as described in <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL709-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_point_variable_ref" href="#InfiniteOpt.make_point_variable_ref"><code>InfiniteOpt.make_point_variable_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_point_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},
                        ivref::GeneralVariableRef,
                        support::Vector{Float64}
                        )::GenealVariableRef</code></pre><p>Make a point variable for infinite variable <code>ivref</code> at <code>support</code>, add it to the <code>write_model</code>, and return the <code>GeneralVariableRef</code>. This is an internal method for point variables produced by expanding measures via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the <code>InfiniteModel</code>. In such cases, <code>write_model</code> should be the optimizer model and <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> should be extended appropriately for point variables. Errors if <code>write_model</code> is an optimizer model and <code>add_measure_variable</code> is not properly extended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_reduced_variable_ref" href="#InfiniteOpt.make_reduced_variable_ref"><code>InfiniteOpt.make_reduced_variable_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_reduced_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},
                          ivref::GeneralVariableRef,
                          indices::Vector{Int},
                          values::Vector{Float64}
                          )::GeneralVariableRef</code></pre><p>Make a reduced variable for infinite variable <code>ivref</code> at <code>support</code>, add it to the <code>write_model</code>, and return the <code>GeneralVariableRef</code>. This is an internal method for reduced variables produced by expanding measures via <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the <code>InfiniteModel</code>. In such cases, <code>write_model</code> should be the optimizer model and <a href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> should be extended appropriately for reduced variables. Errors if <code>write_model</code> is an optimizer model and <code>add_measure_variable</code> is not properly extended. Note this is only intended for optimizer models that are currently stored in <code>InfiniteModel.optimizer_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL71-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}" href="#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.add_measure_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_measure_variable(model::JuMP.Model, var,
                     key::Val{:ext_key_name})::GeneralVariableRef</code></pre><p>Add a measure variable <code>var</code> to the optimizer model <code>model</code> (with <code>key</code>) and return the correct <code>InfiniteOpt</code> variable reference. This is an internal method used by <a href="#InfiniteOpt.make_point_variable_ref"><code>make_point_variable_ref</code></a> and <a href="#InfiniteOpt.make_reduced_variable_ref"><code>make_reduced_variable_ref</code></a> to make point variables and reduced variables when the <code>write_model</code> is an optimizer model. This is useful for extensions that wish to expand measures, but without changing the original <code>InfiniteModel</code>. Thus, this should be extended for adding <code>PointVariable</code>s and <code>ReducedVariable</code>s for such extensions. Otherwise, an error is thrown for unextended variable and/or optimizer model types. Note if this is extended, than <a href="#InfiniteOpt.internal_reduced_variable"><code>internal_reduced_variable</code></a> should also be extended in order to direct reduced variables references to the underlying <a href="#InfiniteOpt.ReducedVariable"><code>ReducedVariable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL33-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_internal_reduced_variable" href="#InfiniteOpt.delete_internal_reduced_variable"><code>InfiniteOpt.delete_internal_reduced_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete_internal_reduced_variable(write_model::Union{InfiniteModel, JuMP.Model},
                                 rvref::ReducedVariableRef)::Nothing</code></pre><p>Delete the variable associated with <code>rvref</code> from <code>write_model</code> if it is purely an internal variable only used for measure expansion and is no longer needed. For <code>write_model</code>s that are an optimizer model, <a href="#InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}"><code>delete_reduced_variable</code></a> will need to be extended for this this to work. Otherwise, a warning will be thrown. Note that this is intended as an internal method to assist with extensions to <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL111-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}" href="#InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}"><code>InfiniteOpt.delete_reduced_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_reduced_variable(model::JuMP.Model, vref, key::Val{:ext_key_name})::Nothing</code></pre><p>Delete the reduced variable associated with <code>vref</code> from the optimizer model <code>model</code> with associated extension key <code>:ext_key_name</code>. A warning is thrown if this is not properly extended. This is intended as a helper function for <a href="#InfiniteOpt.delete_internal_reduced_variable"><code>delete_internal_reduced_variable</code></a> which is used by <a href="#InfiniteOpt.expand_measure"><code>expand_measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/measure_expansions.jl#LL131-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.internal_reduced_variable" href="#InfiniteOpt.internal_reduced_variable"><code>InfiniteOpt.internal_reduced_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">internal_reduced_variable(vref::ReducedVariableRef,
                          key::Val{:my_ext_key})::ReducedVariable</code></pre><p>Return the reduced variable object of <code>vref</code> assuming it is an internal variable made during measure expansion within an optimizer model. This will apply to optimizer model extensions that utilize <code>add_measure_variable</code> in combination with <code>expand_measure</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}" href="#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, ivref::GeneralVariableRef,
                    eval_supports::Dict{Int, Float64}; [check::Bool = true]
                    )::ReducedVariable{GeneralVariableRef}</code></pre><p>Extend the <code>JuMP.build_variable</code> function to build a reduced infinite variable based on the infinite variable <code>ivref</code> with reduction support <code>eval_supports</code>. Will check that input is appropriate if <code>check = true</code>. Errors if <code>ivref</code> is not an infinite variable, <code>eval_supports</code> violate infinite parameter domains, or if the support dimensions don&#39;t match the infinite parameter dimensions of <code>ivref</code>. This is intended an internal method for use in evaluating measures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL75-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_variable-Tuple{InfiniteModel,ReducedVariable,String}" href="#JuMP.add_variable-Tuple{InfiniteModel,ReducedVariable,String}"><code>JuMP.add_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_variable(model::InfiniteModel, var::InfOptVariable,
                  [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Extend the <a href="../JuMP/#JuMP.add_variable"><code>JuMP.add_variable</code></a> function to accomodate <code>InfiniteOpt</code> variable types. Adds a variable to an infinite model <code>model</code> and returns a <a href="expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>. Primarily intended to be an internal function of the constructor macros <a href="#InfiniteOpt.@infinite_variable"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a>. However, it can be used in combination with <a href="measure/#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a> to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in <code>var</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 10]);

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);

julia&gt; inf_var = build_variable(error, info, Infinite, parameter_refs = t);

julia&gt; ivref = add_variable(m, inf_var, &quot;var_name&quot;)
var_name(t)

julia&gt; pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,
                               parameter_values = 0.5);

julia&gt; pvref = add_variable(m, pt_var, &quot;var_alias&quot;)
var_alias

julia&gt; hd_var = build_variable(error, info, Hold);

julia&gt; hvref = add_variable(m, hd_var, &quot;var_name&quot;)
var_name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/variable_basics.jl#LL78-L114">source</a></section><section><div><pre><code class="language-none">JuMP.add_variable(model::InfiniteModel, var::ReducedVariable,
                  [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Extend the <a href="../../JuMP/#JuMP.add_variable"><code>JuMP.add_variable</code></a> function to accomodate <code>InfiniteOpt</code> reduced variable types. Adds <code>var</code> to the infinite model <code>model</code> and returns a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>. Primarily intended to be an internal function used in evaluating measures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL127-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{ReducedVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_variable_ref(vref::ReducedVariableRef)::GeneralVariableRef</code></pre><p>Return the infinite variable reference associated with the reduced infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; infinite_variable_ref(vref)
g(t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL150-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.eval_supports-Tuple{ReducedVariableRef}" href="#InfiniteOpt.eval_supports-Tuple{ReducedVariableRef}"><code>InfiniteOpt.eval_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_supports(vref::ReducedVariableRef)::Dict{Int, Float64}</code></pre><p>Return the evaluation supports associated with the reduced infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; eval_supports(vref)
Dict{Int64,Float64} with 1 entry:
  1 =&gt; 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL166-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{ReducedVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{ReducedVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(vref::ReducedVariableRef)::Tuple</code></pre><p>Return the infinite parameter references associated with the reduced infinite variable <code>vref</code>. This is formatted as a <code>Tuple</code> of containing the parameter references as they were inputted to define the untranscripted infinite variable except, the evaluated parameters are excluded.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(vref)
(t, [x[1], x[2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL199-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{ReducedVariableRef}" href="#InfiniteOpt.parameter_list-Tuple{ReducedVariableRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(vref::ReducedVariableRef)::Vector{GeneralVariableRef}</code></pre><p>Return a vector of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{ReducedVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{ReducedVariableRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{ReducedVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(vref::ReducedVariableRef)::VectorTuple{GeneralVariableRef}</code></pre><p>Return the raw <a href="../variable/#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{ReducedVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{ReducedVariableRef,String}" href="#JuMP.set_name-Tuple{ReducedVariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing</code></pre><p>Extend <a href="../JuMP/#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> to set names of decision variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(vref, &quot;var_name&quot;)

julia&gt; name(vref)
&quot;var_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/variable_basics.jl#LL243-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{ReducedVariableRef}" href="#JuMP.has_lower_bound-Tuple{ReducedVariableRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(vref::ReducedVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL233-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{ReducedVariableRef}" href="#JuMP.lower_bound-Tuple{ReducedVariableRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(vref::ReducedVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a> to return the lower bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL249-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{ReducedVariableRef}" href="#JuMP.LowerBoundRef-Tuple{ReducedVariableRef}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::ReducedVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>JuMP.LowerBoundRef</code></a> to extract a constraint reference for the lower bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = LowerBoundRef(vref)
var &gt;= 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL279-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{ReducedVariableRef}" href="#JuMP.has_upper_bound-Tuple{ReducedVariableRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::ReducedVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL295-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{ReducedVariableRef}" href="#JuMP.upper_bound-Tuple{ReducedVariableRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(vref::ReducedVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> to return the upper bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL311-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{ReducedVariableRef}" href="#JuMP.UpperBoundRef-Tuple{ReducedVariableRef}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::ReducedVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>JuMP.UpperBoundRef</code></a> to extract a constraint reference for the upper bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = UpperBoundRef(vref)
var &lt;= 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL341-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{ReducedVariableRef}" href="#JuMP.is_fixed-Tuple{ReducedVariableRef}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_fixed(vref::ReducedVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_fixed-Tuple{VariableRef}"><code>JuMP.is_fixed</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_fixed(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL357-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{ReducedVariableRef}" href="#JuMP.fix_value-Tuple{ReducedVariableRef}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix_value(vref::ReducedVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.fix_value-Tuple{VariableRef}"><code>JuMP.fix_value</code></a> to return the fix value of the original infinite variable of <code>vref</code>. Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fix_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL373-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{ReducedVariableRef}" href="#JuMP.FixRef-Tuple{ReducedVariableRef}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.FixRef(vref::ReducedVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.FixRef-Tuple{VariableRef}"><code>JuMP.FixRef</code></a> to return the constraint reference of the fix constraint associated with the original infinite variable of <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cref = FixRef(vref)
var == 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL403-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.start_value_function-Tuple{ReducedVariableRef}" href="#InfiniteOpt.start_value_function-Tuple{ReducedVariableRef}"><code>InfiniteOpt.start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_value_function(vref::ReducedVariableRef)::Union{Nothing, Function}</code></pre><p>Return the function that is used to generate the start values of <code>vref</code> for particular support values. Returns <code>nothing</code> if no start behavior has been specified.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; start_value_func(vref)
my_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL425-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{ReducedVariableRef}" href="#JuMP.is_binary-Tuple{ReducedVariableRef}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_binary(vref::ReducedVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_binary-Tuple{VariableRef}"><code>JuMP.is_binary</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is binary.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_binary(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL442-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{ReducedVariableRef}" href="#JuMP.BinaryRef-Tuple{ReducedVariableRef}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.BinaryRef(vref::ReducedVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.BinaryRef-Tuple{VariableRef}"><code>JuMP.BinaryRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL468-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{ReducedVariableRef}" href="#JuMP.is_integer-Tuple{ReducedVariableRef}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_integer(vref::ReducedVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_integer-Tuple{VariableRef}"><code>JuMP.is_integer</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is integer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL485-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{ReducedVariableRef}" href="#JuMP.IntegerRef-Tuple{ReducedVariableRef}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.IntegerRef(vref::ReducedVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.IntegerRef-Tuple{VariableRef}"><code>JuMP.IntegerRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/reduced_variables.jl#LL511-L523">source</a></section></article><h2 id="MeasureToolbox-Datatypes"><a class="docs-heading-anchor" href="#MeasureToolbox-Datatypes">MeasureToolbox Datatypes</a><a id="MeasureToolbox-Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#MeasureToolbox-Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.MeasureToolbox.AbstractIntegralMethod"><code>InfiniteOpt.MeasureToolbox.AbstractIntegralMethod</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>InfiniteOpt.MeasureToolbox.Automatic</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>InfiniteOpt.MeasureToolbox.GaussHermite</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>InfiniteOpt.MeasureToolbox.GaussLaguerre</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>InfiniteOpt.MeasureToolbox.GaussLegendre</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiIndepMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>InfiniteOpt.MeasureToolbox.Quadrature</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.UniIndepMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>InfiniteOpt.MeasureToolbox.UniMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>InfiniteOpt.MeasureToolbox.UniTrapezoid</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractIntegralMethod" href="#InfiniteOpt.MeasureToolbox.AbstractIntegralMethod"><code>InfiniteOpt.MeasureToolbox.AbstractIntegralMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods use in combination with <code>integral</code> and <code>generate_integral_data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.Automatic" href="#InfiniteOpt.MeasureToolbox.Automatic"><code>InfiniteOpt.MeasureToolbox.Automatic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Automatic &lt;: AbstractIntegralMethod</code></pre><p>An integral evaluation type for automically selecting an appropriate integral evaluation method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod" href="#InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractUnivariateMethod &lt;: AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods for 1-dimensional integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniTrapezoid" href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>InfiniteOpt.MeasureToolbox.UniTrapezoid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniTrapezoid &lt;: AbstractUnivariateMethod</code></pre><p>An integral evalution method that uses the trapezoid rule to in combination with all parameter supports available when the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this method will ignore the <code>num_supports</code> keyword argument. Note this is valid only for finite integral domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniMCSampling" href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>InfiniteOpt.MeasureToolbox.UniMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniMCSampling &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy <code>num_supports</code> and it will include all supports with the <code>MCSample</code> label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL38-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.UniIndepMCSampling" href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.UniIndepMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniIndepMCSampling &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to <a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling</code></a>. However, this variant will generate its own set of supports and ignore all other supports with the <code>MCSample</code> label. Note this is valid only for finite integral domains. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL50-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.Quadrature" href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>InfiniteOpt.MeasureToolbox.Quadrature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quadrature &lt;: AbstractUnivariateMethod</code></pre><p>A general integral evaluation method that will automatically select the appropriate quadrature method to approximate the integral. Please note that this will generate a unique set of parameter supports and will ignore existing supports when the integral is evaluated and thus should be used with caution. However, this method is able to handle infinite and semi-infinite integral domains. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussHermite" href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>InfiniteOpt.MeasureToolbox.GaussHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussHermite &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaulation method that uses Gauss-Hermite quadrature to evaluate integrals. This is valid for infinite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL73-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussLegendre" href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>InfiniteOpt.MeasureToolbox.GaussLegendre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussLegendre &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaulation method that uses Gauss-Legendre quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.GaussLaguerre" href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>InfiniteOpt.MeasureToolbox.GaussLaguerre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GaussLaguerre &lt;: AbstractUnivariateMethod</code></pre><p>An integral evaulation method that uses Gauss-Laguerre quadrature to evaluate integrals. This is valid for semi-infinite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod" href="#InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod"><code>InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractMultivariateMethod &lt;: AbstractIntegralMethod</code></pre><p>An abstract type for integral evaluation methods for multi-dimensional integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.MultiMCSampling" href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiMCSampling &lt;: AbstractMultivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy <code>num_supports</code> and it will include all supports with the <code>MCSample</code> label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains. If an array of independent infinite parameters is specified, they must use the same amount of supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL110-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.MultiIndepMCSampling" href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>InfiniteOpt.MeasureToolbox.MultiIndepMCSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiIndepMCSampling &lt;: AbstractMultivariateMethod</code></pre><p>An integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to <a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling</code></a>. However, this variant will generate its own set of supports and ignore all other supports with the <code>MCSample</code> label. Note this is valid only for finite integral domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL123-L131">source</a></section></article><h2 id="MeasureToolbox-Methods"><a class="docs-heading-anchor" href="#MeasureToolbox-Methods">MeasureToolbox Methods</a><a id="MeasureToolbox-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#MeasureToolbox-Methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.MeasureToolbox.@expect"><code>InfiniteOpt.MeasureToolbox.@expect</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.@integral"><code>InfiniteOpt.MeasureToolbox.@integral</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>InfiniteOpt.MeasureToolbox.@support_sum</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.expect"><code>InfiniteOpt.MeasureToolbox.expect</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>InfiniteOpt.MeasureToolbox.generate_integral_data</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>InfiniteOpt.MeasureToolbox.integral</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s38,N} where N where #s38&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>InfiniteOpt.MeasureToolbox.integral</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.multi_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_multi_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_uni_integral_defaults</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.support_sum"><code>InfiniteOpt.MeasureToolbox.support_sum</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.uni_integral_defaults</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@integral" href="#InfiniteOpt.MeasureToolbox.@integral"><code>InfiniteOpt.MeasureToolbox.@integral</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@integral(expr::JuMP.AbstractJuMPScalar,
          prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}},
          [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds,
          upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = default_bounds;
          kwargs...])::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> and <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s38,N} where N where #s38&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>integral</code></a>. Please see the above doc strings for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL740-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}" href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>InfiniteOpt.MeasureToolbox.integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integral(expr::JuMP.AbstractJuMPScalar,
         pref::GeneralVariableRef,
         [lower_bound::Real = lower_bound(pref),
         upper_bound::Real = upper_bound(pref);
         kwargs...])::GeneralVariableRef</code></pre><p>Returns a measure reference that evaluates the integral of <code>expr</code> with respect to infinite parameter <code>pref</code> from <code>lower_bound</code> to <code>upper_bound</code>. This thus considers integrals of the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter and <span>$w$</span> is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> via <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> in accordance with the keyword arugment <code>eval_method</code> that is then used with <a href="#InfiniteOpt.measure"><code>measure</code></a>. Note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a> when <code>expr</code> is not just a single variable reference. Errors for bad bound input.</p><p>The keyword arguments are as follows:</p><ul><li><code>eval_method::Type{&lt;:AbstractUnivariateMethod}</code>: Used to determine the   numerical evaluation scheme<ul><li><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniTrapezoid"><code>UniTrapezoid</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniMCSampling"><code>UniMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.UniIndepMCSampling"><code>UniIndepMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.Quadrature"><code>Quadrature</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussHermite"><code>GaussHermite</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLegendre"><code>GaussLegendre</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.GaussLaguerre"><code>GaussLaguerre</code></a></li></ul></li><li><code>num_supports</code>: The minimum number of supports to be generated (if used by   <code>eval_method</code>)</li><li><code>weight_func</code>: <span>$w(p)$</span> above with parameter value inputs and scalar output</li></ul><p>See <a href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>set_uni_integral_defaults</code></a> to update the default keyword argument values for all one-dimensional integral calls.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1])
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; int = integral(f, x)
integral{x ∈ [0, 1]}[f(x)]

julia&gt; expand(int)
0.2 f(0.8236475079774124) + 0.2 f(0.9103565379264364) + 0.2 f(0.16456579813368521) + 0.2 f(0.17732884646626457) + 0.2 f(0.278880109331201)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL516-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s38,N} where N where #s38&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}" href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s38,N} where N where #s38&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>InfiniteOpt.MeasureToolbox.integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integral(expr::JuMP.AbstractJuMPScalar,
         prefs::AbstractArray{GeneralVariableRef},
         [lower_bounds::Union{Real, AbstractArray{&lt;:Real}} = [lower_bound(pref)...],
         upper_bounds::Union{Real, AbstractArray{&lt;:Real}} = [upper_bound(pref)...];
         kwargs...])::GeneralVariableRef</code></pre><p>Returns a measure reference that evaluates the integral of <code>expr</code> with respect to infinite parameters <code>prefs</code> from <code>lower_bounds</code> to <code>upper_bounds</code>. This thus considers integrals of the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter and <span>$w$</span> is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> via <a href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>generate_integral_data</code></a> in accordance with the keyword arugment <code>eval_method</code> that is then used with <a href="#InfiniteOpt.measure"><code>measure</code></a>. Note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@integral"><code>@integral</code></a> when <code>expr</code> is not just a single variable reference. Errors when the container types and dimensions do not match or the bounds are invalid.</p><p>The keyword arguments are as follows:</p><ul><li><code>eval_method::Type{&lt;:AbstractMultivariateMethod}</code>: Used to determine the   numerical evaluation scheme<ul><li><a href="#InfiniteOpt.MeasureToolbox.Automatic"><code>Automatic</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiMCSampling"><code>MultiMCSampling</code></a></li><li><a href="#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling"><code>MultiIndepMCSampling</code></a></li></ul></li><li><code>num_supports</code>: The minimum number of supports to be generated (if used by   <code>eval_method</code>)</li><li><code>weight_func</code>: <span>$w(p)$</span> above with parameter value inputs and scalar output</li></ul><p>See <a href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>set_multi_integral_defaults</code></a> to update the default keyword argument values for all multi-dimensional integral calls.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:2] in [0, 1], independent = true);

julia&gt; @infinite_variable(model, f(x));

julia&gt; int = integral(f, x)
integral{x ∈ [0, 1]^2}[f(x)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL652-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@expect" href="#InfiniteOpt.MeasureToolbox.@expect"><code>InfiniteOpt.MeasureToolbox.@expect</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@expect(expr::JuMP.AbstractJuMPScalar,
        prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};
        [min_num_supports::Int = DefaultNumSupports])::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.expect"><code>expect</code></a>. Please see its doc string more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/expectations.jl#LL97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.expect" href="#InfiniteOpt.MeasureToolbox.expect"><code>InfiniteOpt.MeasureToolbox.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expect(expr::JuMP.AbstractJuMPScalar,
       prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};
       [min_num_supports::Int = DefaultNumSupports])::GeneralVariableRef</code></pre><p>Creates a measure that represents the expected value of an expression based on <code>prefs</code>. If <code>prefs</code> are not random parameters then this will be equivalent to the following call:</p><pre><code class="language-julia">1/total_num_supports * support_sum(expr, prefs)</code></pre><p>Note that min<em>num</em>supports should be 0 if a single dependent parameter is given. Also, note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@expect"><code>@expect</code></a> when <code>expr</code> is not just a single variable reference.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in Normal())
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = expect(f, min_num_supports = 2)
expect{x}[f(x)]

julia&gt; expand(meas)
0.5 f(0.6791074260357777) + 0.5 f(0.8284134829000359)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/expectations.jl#LL32-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.@support_sum" href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>InfiniteOpt.MeasureToolbox.@support_sum</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@support_sum(expr::JuMP.AbstractJuMPScalar,
             params::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}}
             )::GeneralVariableRef</code></pre><p>An efficient wrapper for <a href="#InfiniteOpt.MeasureToolbox.support_sum"><code>support_sum</code></a> please see its doc string for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/support_sums.jl#LL45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.support_sum" href="#InfiniteOpt.MeasureToolbox.support_sum"><code>InfiniteOpt.MeasureToolbox.support_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support_sum(expr::JuMP.AbstractJuMPScalar,
            params::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}}
            )::GeneralVariableRef</code></pre><p>Creates a measure that represents the sum of the expression over a parameter(s) using all of its supports. Also, note that it is preferred to call <a href="#InfiniteOpt.MeasureToolbox.@support_sum"><code>@support_sum</code></a> when <code>expr</code> is not just a single variable reference.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1], supports = [0.3, 0.7])
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = support_sum(f, x)
support_sum{x}[f(x)]

julia&gt; expand(meas)
f(0.3) + f(0.7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/support_sums.jl#LL7-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.uni_integral_defaults" href="#InfiniteOpt.MeasureToolbox.uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.uni_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uni_integral_defaults()::Dict{Symbol, Any}</code></pre><p>Get the default keyword argument values for defining one-dimensional integrals.</p><pre><code class="language-julia-repl">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :num_supports          =&gt; 10
  :eval_method           =&gt; Automatic
  :weight_func           =&gt; default_weight</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL468-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.set_uni_integral_defaults" href="#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_uni_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_uni_integral_defaults(; kwargs...)::Nothing</code></pre><p>Set the default keyword argument settings for one-dimensional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}"><code>integral</code></a> with a single infinite parameter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :num_supports          =&gt; 10
  :eval_method           =&gt; Automatic
  :weight_func           =&gt; default_weight

julia&gt; set_uni_integral_defaults(num_supports = 5, eval_method = Quadrature,
                                 new_kwarg = true)

julia&gt; uni_integral_defaults()
Dict{Symbol,Any} with 4 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Quadrature
  :weight_func           =&gt; default_weight</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL483-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.multi_integral_defaults" href="#InfiniteOpt.MeasureToolbox.multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.multi_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">multi_integral_defaults()::Dict{Symbol, Any}</code></pre><p>Get the default keyword argument values for defining multi-dimensional integrals.</p><pre><code class="language-julia-repl">julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :num_supports          =&gt; 10
  :eval_method           =&gt; Automatic
  :weight_func           =&gt; default_weight</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL604-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.set_multi_integral_defaults" href="#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults"><code>InfiniteOpt.MeasureToolbox.set_multi_integral_defaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_multi_integral_defaults(; kwargs...)::Nothing</code></pre><p>Set the default keyword argument settings for multi-dimesnional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling <a href="#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s38,N} where N where #s38&lt;:Real},Union{Real, AbstractArray{#s9,N} where N where #s9&lt;:Real}}"><code>integral</code></a> with an array of infinite parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 3 entries:
  :num_supports          =&gt; 10
  :eval_method           =&gt; Automatic
  :weight_func           =&gt; default_weight

julia&gt; set_multi_integral_defaults(num_supports = 5, new_kwarg = true)

julia&gt; multi_integral_defaults()
Dict{Symbol,Any} with 4 entries:
  :new_kwarg             =&gt; true
  :num_supports          =&gt; 5
  :eval_method           =&gt; Automatic
  :weight_func           =&gt; default_weight</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL619-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureToolbox.generate_integral_data" href="#InfiniteOpt.MeasureToolbox.generate_integral_data"><code>InfiniteOpt.MeasureToolbox.generate_integral_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_integral_data(
    prefs::Union{InfiniteOpt.GeneralVariableRef, Vector{InfiniteOpt.GeneralVariableRef}},
    lower_bounds::Union{Real, Vector{&lt;:Real}},
    upper_bounds::Union{Real, Vector{&lt;:Real}},
    method::Type{V}; [num_supports::Int = InfiniteOpt.DefaultNumSupports,
    weight_func::Function = InfiniteOpt.default_weight,
    extra_kwargs...]
    )::InfiniteOpt.AbstractMeasureData where {V &lt;: AbstractIntegralMethod}</code></pre><p>Generate the appropriate concrete realization of <code>AbstractMeasureData</code> using <code>method</code>. Here <code>prefs</code>, <code>lower_bounds</code>, and <code>upper_bounds</code> will always have a 1 to 1 correspondence when this is called from <code>integral</code>. Please refer to the method docstrings for an explanation of each one.</p><p>User-defined method extensions should first define a concrete <code>method</code> type inheriting from <code>AbstractUnivariateMethod</code> or <code>AbstractMultivariateMethod</code> as appropriate and then implement extend this method using that type for <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/MeasureToolbox/integrals.jl#LL137-L156">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../expression/">« Expressions</a><a class="docs-footer-nextpage" href="../objective/">Objectives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 18 September 2020 22:37">Friday 18 September 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
