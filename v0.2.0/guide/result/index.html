<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Results · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li class="is-active"><a class="tocitem" href>Results</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Termination-Queries"><span>Termination Queries</span></a></li><li><a class="tocitem" href="#Variable-Queries"><span>Variable Queries</span></a></li><li><a class="tocitem" href="#Constraint-Queries"><span>Constraint Queries</span></a></li><li><a class="tocitem" href="#LP-Sensitivity"><span>LP Sensitivity</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Results</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Results</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/result.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h1><p>A guide and manual to querying optimized <code>InfiniteOpt</code> models. The Methods section at the bottom comprises the manual and the above sections form the guide.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>So far we have covered defining, transforming, and optimizing <code>InfiniteModel</code>s. Now comes the point to extract information from our optimized model. This is done following extended versions of <code>JuMP</code>s querying functions in combination with the mapping information stored in the optimizer model. Thus, this page will walk through the use of these result query functions.</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Let&#39;s revisit the example from the optimization page to get us started:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP, Ipopt;

julia&gt; model = InfiniteModel(Ipopt.Optimizer);

julia&gt; set_optimizer_attribute(model, &quot;print_level&quot;, 0);

julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10);

julia&gt; @infinite_variable(model, x(t) &gt;= 0);

julia&gt; @hold_variable(model, z &gt;= 0);

julia&gt; @objective(model, Min, 2z);

julia&gt; @constraint(model, c1, z &gt;= x);

julia&gt; @BDconstraint(model, c2(t == 0), x == 42);

julia&gt; print(model)
Min 2 z
Subject to
 x(t) ≥ 0.0, ∀ t ∈ [0, 10]
 z ≥ 0.0
 c1 : z - x(t) ≥ 0.0, ∀ t ∈ [0, 10]
 c2 : x(t) = 42.0, ∀ t = 0

julia&gt; optimize!(model)

******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit http://projects.coin-or.org/Ipopt
******************************************************************************</code></pre><p>Now that the model has been optimized, let&#39;s find out what happened. To determine why the optimizer stopped, we can use <a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a> to report the corresponding <code>MathOptInterface</code> termination code (possible codes are explained <a href="https://jump.dev/JuMP.jl/stable/solutions/#MathOptInterface.TerminationStatusCode">here</a>.</p><pre><code class="language-julia-repl">julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4</code></pre><p>Here we see that our model was locally solved via Ipopt and that is why it stopped. Furthermore, we can query the primal and dual problem optimalities via <a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a> and <a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, respectively.</p><pre><code class="language-julia-repl">julia&gt; primal_status(model)
FEASIBLE_POINT::ResultStatusCode = 1

julia&gt; dual_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre><p>The possible statuses are detailed <a href="https://jump.dev/JuMP.jl/stable/solutions/#MathOptInterface.ResultStatusCode">here</a>. These results are useful in knowing if information can be drawn from the primal and/or dual and what it means. We can also verify that we indeed have answers via <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a> which indicates if our model has optimized variable values.</p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre><p>And indeed we do have values.</p><p>Now we can query the objective value via <a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a> which reports the optimal objective value.</p><pre><code class="language-julia-repl">julia&gt; objective_value(model)
83.99999998250514</code></pre><p>Great now we can inquire about variable values via <a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a>. First, let&#39;s retrieve the value of <code>z</code>:</p><pre><code class="language-julia-repl">julia&gt; value(z)
41.99999999125257</code></pre><p>We get a single value since <code>z</code> is a <code>HoldVariable</code> and therefore finite. Now let&#39;s retrieve the &quot;value&quot; of <code>x(t)</code> which is infinite with respect to <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; value(x)
10-element Array{Float64,1}:
 42.0
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495
 20.999999995620495</code></pre><p>Notice here we obtain an array of values since these correspond to the transcribed finite (discretized) variables used to solve the problem. We obtain the corresponding support (discretized <code>t</code>) values via <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; supports(x)
10-element Array{Tuple,1}:
 (0.0,)
 (1.11111111111,)
 (2.22222222222,)
 (3.33333333333,)
 (4.44444444444,)
 (5.55555555556,)
 (6.66666666667,)
 (7.77777777778,)
 (8.88888888889,)
 (10.0,)</code></pre><p>There is 1-to-1 correspondence between these supports and the values reported above. Note that these are stored in tuples to facilitate multiple infinite parameter dependencies.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The values for an array of variables is obtained via the vectorized call of <code>value</code> following the syntax:</p><pre><code class="language-julia">value.(::AbstractArray{&lt;:GeneralVariableRef})</code></pre><p>This also holds true for many other methods in <code>InfiniteOpt</code>. For example, adding the dot also vectorizes <code>dual</code> and <code>set_binary</code>.</p></div></div><p>We can also query the dual of a constraint via <a href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>dual</code></a> if a model has duals available as indicated by <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true

julia&gt; dual(c1)
10-element Array{Float64,1}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p><code>c1</code> is an infinite constraint and thus we obtain the duals of its transcribed versions. The underlying infinite parameter(s) and support values are queried via <code>parameter_refs</code> and <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; parameter_refs(c1)
(t,)

julia&gt; supports(c1)
10-element Array{Tuple,1}:
 (0.0,)
 (1.11111111111,)
 (2.22222222222,)
 (3.33333333333,)
 (4.44444444444,)
 (5.55555555556,)
 (6.66666666667,)
 (7.77777777778,)
 (8.88888888889,)
 (10.0,)</code></pre><p>These again all have a 1-to-1 correspondence.</p><h2 id="Termination-Queries"><a class="docs-heading-anchor" href="#Termination-Queries">Termination Queries</a><a id="Termination-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-Queries" title="Permalink"></a></h2><p>Termination queries are those that question about how the infinite model was solved and what its optimized state entails. Programmatically, such queries on the <code>InfiniteModel</code> are simply routed to its optimizer model.</p><p>The commonly used queries include <a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a>, <a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a>, <a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, <a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a>, <a href="#JuMP.result_count-Tuple{InfiniteModel}"><code>result_count</code></a> <a href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>solve_time</code></a>. The first four are well exemplified in the Basic Usage section above and are helpful in quickly understanding the optimality status of a given model following the many possible statuses reported by <code>MathOptInterface</code> which are documented <a href="http://www.juliaopt.org/MathOptInterface.jl/stable/apimanual/#Solving-and-retrieving-the-results-1">here</a>. We use <code>result_count</code> to determine how many solutions are recorded in the optimizer.</p><pre><code class="language-julia-repl">julia&gt; result_count(model)
1</code></pre><p>This is useful since it informs what results there are which can be specified via the <code>result</code> keyword argument in many methods such as <code>primal_status</code>, <code>dual_status</code>, <code>objective_value</code>, <code>value</code>, <code>dual</code>, and more.</p><p>We use <code>solve_time</code> to determine the time in seconds used by the optimizer until it terminated its search.</p><pre><code class="language-julia-repl">julia&gt; solve_time(model)
0.004999876022338867</code></pre><p>Note that this query might not be supported with all solvers.</p><p>The above status queries are designed to report information in a consistent format irrespective of the chosen optimizer. However, <a href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>raw_status</code></a> will provide the optimality status verbatim as reported by the optimizer. Thus, following our example with Ipopt we obtain:</p><pre><code class="language-julia-repl">julia&gt; raw_status(model)
&quot;Solve_Succeeded&quot;</code></pre><p>Also, we obtain the best objective bound via <a href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>objective_bound</code></a> which becomes particularly useful solutions that are suboptimal. However, this method is not supported by all optimizers and in this case Ipopt is one such optimizer.</p><p>Finally, we get the best dual objective value via <a href="#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>dual_objective_value</code></a> if the optimizer supplies this information which again Ipopt does not.</p><h2 id="Variable-Queries"><a class="docs-heading-anchor" href="#Variable-Queries">Variable Queries</a><a id="Variable-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Queries" title="Permalink"></a></h2><p>Information about the optimized variables is gathered consistently in comparison to typical <code>JuMP</code> models. With <code>InfiniteModel</code>s this is done by querying the optimizer model and using its stored variable mappings to return the correct information. Thus, here the queries are extended to work with the specifics of the optimizer model to return the appropriate info.</p><p>First, we should verify that the optimized model in fact has variable values via <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a>. In our example, we have:</p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre><p>So we have values readily available to be extracted.</p><p>Now <a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a> can be used to query the values as shown above in the Basic Usage section. This works by calling the appropriate <a href="#InfiniteOpt.map_value"><code>map_value</code></a> defined by the optimizer model. By default this, employs the <code>map_value</code> fallback which uses <code>optimizer_model_variable</code> to do the mapping. Details on how to extend these methods for user-defined optimizer models is explained on the Extensions page.</p><p>Finally, the optimizer index of a variable is queried via <a href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>optimizer_index</code></a> which reports back the index of the variable as used in the <code>MathOptInterface</code> backend:</p><pre><code class="language-julia-repl">julia&gt; optimizer_index(z)
MathOptInterface.VariableIndex(1)

julia&gt; optimizer_index(x)
10-element Array{MathOptInterface.VariableIndex,1}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)
 MathOptInterface.VariableIndex(6)
 MathOptInterface.VariableIndex(7)
 MathOptInterface.VariableIndex(8)
 MathOptInterface.VariableIndex(9)
 MathOptInterface.VariableIndex(10)
 MathOptInterface.VariableIndex(11)</code></pre><p>As noted previously, an array is returned for <code>x(t)</code> in accordance with its transcription variables. In similar manner to <code>value</code>, this is enabled by appropriate versions of <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a>.</p><h2 id="Constraint-Queries"><a class="docs-heading-anchor" href="#Constraint-Queries">Constraint Queries</a><a id="Constraint-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Queries" title="Permalink"></a></h2><p>Like variables, a variety of information can be queried about constraints.</p><p>First, recall that constraints are stored in the form <code>function-in-set</code> where generally <code>function</code> contains the variables and coefficients and the set contains the relational operator and the constant value. With this understanding, we query the value of a constraint&#39;s <code>function</code> via <a href="#JuMP.value-Tuple{InfOptConstraintRef}"><code>value</code></a>:</p><pre><code class="language-julia-repl">julia&gt; constraint_object(c1).func # show the function expression of c1
z - x(t)

julia&gt; value(c1)
10-element Array{Float64,1}:
 -8.747427671096375e-9
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077
 20.999999995632077</code></pre><p>Again, we obtain an array of values since <code>c1</code> is infinite due to its dependence on <code>x(t)</code>. Behind the scenes this is implemented via the appropriate extensions of <a href="#InfiniteOpt.map_value"><code>map_value</code></a>.</p><p>Next the optimizer index(es) of the transcribed constraints in the <code>MathOptInterface</code> backend provided via <a href="#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>optimizer_index</code></a>.</p><pre><code class="language-julia-repl">julia&gt; optimizer_index(c1)
10-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(5)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(6)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(7)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(8)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(9)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(10)</code></pre><p>Here 10 indices are given in accordance with the transcription constraints. The mapping between these and the original infinite constraints is managed via the appropriate extensions of <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a>.</p><p>We can also query dual information from our constraints if it is available. First, we should verify that dual information is available via <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true</code></pre><p>Now we can query the duals via <a href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>dual</code></a>.</p><pre><code class="language-julia-repl">julia&gt; dual(c1)
10-element Array{Float64,1}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p>Here we obtain the optimal dual values for each transcribed version of <code>c1</code>. This is enabled via the proper extensions of <a href="#InfiniteOpt.map_dual"><code>map_dual</code></a>.</p><p>Finally, we query the shadow price of a constraint via <a href="#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>shadow_price</code></a>. This denotes the change in the objective value due to an infinitesimal relaxation of the constraint. For <code>c1</code> we get:</p><pre><code class="language-julia-repl">julia&gt; shadow_price(c1)
10-element Array{Float64,1}:
 -1.9999999988666093
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10</code></pre><p>Similarly, the mapping to the transcription constraints is enabled via the appropriate version of <a href="#InfiniteOpt.map_shadow_price"><code>map_shadow_price</code></a>.</p><h2 id="LP-Sensitivity"><a class="docs-heading-anchor" href="#LP-Sensitivity">LP Sensitivity</a><a id="LP-Sensitivity-1"></a><a class="docs-heading-anchor-permalink" href="#LP-Sensitivity" title="Permalink"></a></h2><p>We also conduct sensitivity analysis for linear problems using <a href="#JuMP.lp_rhs_perturbation_range-Tuple{InfOptConstraintRef}"><code>lp_rhs_perturbation_range</code></a> and <a href="#JuMP.lp_objective_perturbation_range-Tuple{GeneralVariableRef}"><code>lp_objective_perturbation_range</code></a>. These methods will return the ranges indicating how much a constraint RHS constant or a objective coefficient can be changed without violating the feasibility of the solution. This is further explained in the JuMP documentation <a href="https://jump.dev/JuMP.jl/stable/solutions/#Sensitivity-analysis-for-LP-1">here</a>. Furthermore, these methods can only be employed for a solver that implements <code>MOI.ConstraintBasisStatus</code>. In our running example up above, <code>Ipopt.jl</code> does not support this A solver like <code>Gurobi.jl</code> does.</p><pre><code class="language-julia-repl">julia&gt; lp_rhs_perturbation_range(c1)
10-element Array{Tuple{Float64,Float64},1}:
 (-42.0, Inf)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)

julia&gt; lp_objective_perturbation_range(z)
(-2.0, Inf)</code></pre><p>Note that like other query methods, an array of ranges will be provided with testing the sensitivity of an infinite constraint RHS in accordance with the discretization scheme.</p><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><ul><li><a href="#JuMP.barrier_iterations-Tuple{InfiniteModel}"><code>JuMP.barrier_iterations</code></a></li><li><a href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>JuMP.dual</code></a></li><li><a href="#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>JuMP.dual_objective_value</code></a></li><li><a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a></li><li><a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a></li><li><a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a></li><li><a href="#JuMP.lp_objective_perturbation_range-Tuple{GeneralVariableRef}"><code>JuMP.lp_objective_perturbation_range</code></a></li><li><a href="#JuMP.lp_rhs_perturbation_range-Tuple{InfOptConstraintRef}"><code>JuMP.lp_rhs_perturbation_range</code></a></li><li><a href="#JuMP.node_count-Tuple{InfiniteModel}"><code>JuMP.node_count</code></a></li><li><a href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a></li><li><a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a></li><li><a href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>JuMP.optimizer_index</code></a></li><li><a href="#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>JuMP.optimizer_index</code></a></li><li><a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a></li><li><a href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>JuMP.raw_status</code></a></li><li><a href="#JuMP.result_count-Tuple{InfiniteModel}"><code>JuMP.result_count</code></a></li><li><a href="#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>JuMP.shadow_price</code></a></li><li><a href="#JuMP.simplex_iterations-Tuple{InfiniteModel}"><code>JuMP.simplex_iterations</code></a></li><li><a href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>JuMP.solve_time</code></a></li><li><a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a></li><li><a href="#JuMP.value-Tuple{InfOptConstraintRef}"><code>JuMP.value</code></a></li><li><a href="#JuMP.value-Tuple{Union{GenericAffExpr{#s38,#s9} where #s9&lt;:GeneralVariableRef where #s38, GenericQuadExpr{#s5,#s2} where #s2&lt;:GeneralVariableRef where #s5}}"><code>JuMP.value</code></a></li><li><a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a></li><li><a href="#InfiniteOpt.map_dual"><code>InfiniteOpt.map_dual</code></a></li><li><a href="#InfiniteOpt.map_lp_objective_perturbation_range"><code>InfiniteOpt.map_lp_objective_perturbation_range</code></a></li><li><a href="#InfiniteOpt.map_lp_rhs_perturbation_range"><code>InfiniteOpt.map_lp_rhs_perturbation_range</code></a></li><li><a href="#InfiniteOpt.map_optimizer_index"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="#InfiniteOpt.map_shadow_price"><code>InfiniteOpt.map_shadow_price</code></a></li><li><a href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="JuMP.termination_status-Tuple{InfiniteModel}" href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.termination_status(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.termination_status-Tuple{Model}"><code>termination_status</code></a> to return the <code>MOI.TerminationStatus</code> in accordance with the optimizer model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.raw_status-Tuple{InfiniteModel}" href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>JuMP.raw_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.raw_status(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.raw_status-Tuple{Model}"><code>raw_status</code></a> to return the status reported by the solver in accordance with the optimizer model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; raw_status(model) # Ipopt
&quot;Solve_Succeeded&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.primal_status-Tuple{InfiniteModel}" href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> JuMP.primal_status(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="../../JuMP/#JuMP.primal_status-Tuple{Model}"><code>primal_status</code></a> to return the <code>MOI.PrimalStatus</code> reported in accordance with the optimizer model and the result index <code>result</code> of the most recent solution obtained.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; primal_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_status-Tuple{InfiniteModel}" href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual_status(model::InfiniteModel; [result::Int = 1])</code></pre><p>Extend <a href="../../JuMP/#JuMP.dual_status-Tuple{Model}"><code>dual_status</code></a> to return the <code>MOI.DualStatus</code> reported in accordance with the optimizer model and the result index <code>result</code> of the most recent solution obtained.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dual_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solve_time-Tuple{InfiniteModel}" href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>JuMP.solve_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.solve_time(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.solve_time-Tuple{Model}"><code>solve_time</code></a> to return the time used by the solver to terminate reported in accordance with the optimizer model. This will error if not supported by the solver.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; solve_time(model)
0.004999876022338867</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_values-Tuple{InfiniteModel}" href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_values(model::InfiniteModel; [result::Int = 1])::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_values-Tuple{Model}"><code>has_values</code></a> to return a <code>Bool</code> whether variable values are available in accordance with the optimizer model and the result index <code>result</code> of the most recent solution obtained.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL87-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_duals-Tuple{InfiniteModel}" href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_duals(model::InfiniteModel; [result::Int = 1])::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_duals-Tuple{Model}"><code>has_duals</code></a> to return a <code>Bool</code> whether constraint duals are available in accordance with the optimizer model and the result index <code>result</code> of the most recent solution obtained.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL104-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.simplex_iterations-Tuple{InfiniteModel}" href="#JuMP.simplex_iterations-Tuple{InfiniteModel}"><code>JuMP.simplex_iterations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simplex_iterations(model::InfiniteModel)</code></pre><p>Gets the cumulative number of simplex iterations during the most-recent optimization.</p><p>Solvers must implement <code>MOI.SimplexIterations()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.barrier_iterations-Tuple{InfiniteModel}" href="#JuMP.barrier_iterations-Tuple{InfiniteModel}"><code>JuMP.barrier_iterations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barrier_iterations(model::InfiniteModel)</code></pre><p>Gets the cumulative number of barrier iterations during the most-recent optimization.</p><p>Solvers must implement <code>MOI.BarrierIterations()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.node_count-Tuple{InfiniteModel}" href="#JuMP.node_count-Tuple{InfiniteModel}"><code>JuMP.node_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">node_count(model::InfiniteModel)</code></pre><p>Gets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.</p><p>Solvers must implement <code>MOI.NodeCount()</code> to use this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL143-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_bound-Tuple{InfiniteModel}" href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.objective_bound(model::InfiniteModel)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.objective_bound-Tuple{Model}"><code>objective_bound</code></a> to return the objective bound in accordance with the optimizer model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; objective_bound(model)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL158-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_value-Tuple{InfiniteModel}" href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.objective_value(model::InfiniteModel; [result::Int = 1])::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.objective_value-Tuple{Model}"><code>objective_value</code></a> to return the objective value in accordance with the optimizer model and the result index <code>result</code> of the most recent solution obtained.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; objective_value(model)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL174-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_objective_value-Tuple{InfiniteModel}" href="#JuMP.dual_objective_value-Tuple{InfiniteModel}"><code>JuMP.dual_objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual_objective_value(model::InfiniteModel; [result::Int = 1])::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.dual_objective_value-Tuple{Model}"><code>dual_objective_value</code></a> to return the dual objective value in accordance with the optimizer model and the result index <code>result</code> of the most recent solution obtained. Errors if the solver does not support this.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dual_objective_value(model)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL191-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.result_count-Tuple{InfiniteModel}" href="#JuMP.result_count-Tuple{InfiniteModel}"><code>JuMP.result_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.result_count(model::InfiniteModel)</code></pre><p>Extend <a href="../../JuMP/#JuMP.result_count-Tuple{Model}"><code>result_count</code></a> to return the number of results available to query after a call to <code>optimize!</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repla">julia&gt; result_count(model)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/optimize.jl#LL444-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{GeneralVariableRef}" href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(vref::GeneralVariableRef; [result::Int = 1])</code></pre><p>Extend <a href="../../JuMP/#JuMP.value-Tuple{VariableRef}"><code>JuMP.value</code></a> to return the value(s) of <code>vref</code> in accordance with its reformulation variable(s) stored in the optimizer model and the result index <code>result</code> of the most recent solution obtained. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values. For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for variables. To provide context for the results it may be helpful to also query the variable&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> to retrieve the variables(s) that these values are based on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(z)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL258-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{InfOptConstraintRef}" href="#JuMP.value-Tuple{InfOptConstraintRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(cref::InfOptConstraintRef; [result::Int = 1])</code></pre><p>Extend <a href="../../JuMP/#JuMP.value-Tuple{ConstraintRef{Model,#s38,Shape} where Shape&lt;:AbstractShape where #s38&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.value</code></a> to return the value(s) of <code>cref</code> in accordance with its reformulation constraint(s) stored in the optimizer model and the result index <code>result</code> of the most recent solution obtained. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values. For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for constraints. To provide context for the results it may be helpful to also query the constraint&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these values are based on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(c1)
4-element Array{Float64,1}:
 -0.0
 20.9
 20.9
 20.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL283-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{Union{GenericAffExpr{#s38,#s9} where #s9&lt;:GeneralVariableRef where #s38, GenericQuadExpr{#s5,#s2} where #s2&lt;:GeneralVariableRef where #s5}}" href="#JuMP.value-Tuple{Union{GenericAffExpr{#s38,#s9} where #s9&lt;:GeneralVariableRef where #s38, GenericQuadExpr{#s5,#s2} where #s2&lt;:GeneralVariableRef where #s5}}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">value(ex::GenericAffExpr, var_value::Function)</code></pre><p>Evaluate <code>ex</code> using <code>var_value(v)</code> as the value for each variable <code>v</code>.</p></div></section><section><div><pre><code class="language-none">JuMP.value(expr::JuMP.AbstractJuMPScalar; result::Int = 1)</code></pre><p>Return the value(s) of <code>expr</code> in accordance with the optimized variable values the result index <code>result</code> of the most recent solution obtained. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values. To provide context for the results it may be helpful to also query the expression&#39;s <code>parameter_refs</code> and <code>supports</code> which will have a one-to-one correspondence with the value(s). It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_expression"><code>optimizer_model_expression</code></a> to retrieve the expression(s) that these values are based on.</p><p>For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_expression"><code>optimizer_model_expression</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_value"><code>map_value</code></a> has been extended for expressions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(my_finite_expr)
23.34

julia&gt; value(my_infinite_expr)
4-element Array{Float64,1}:
 -0.0
 20.9
 20.9
 20.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL312-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{GeneralVariableRef}" href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimizer_index(vref::GeneralVariableRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.optimizer_index-Tuple{VariableRef}"><code>JuMP.optimizer_index</code></a> to return the <code>MathOptInterface</code> index(es) of <code>vref</code> in accordance with its reformulation variable(s) stored in the optimizer model. For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a> has been extended for variables. It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> to retrieve the variables(s) that these indices are based on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_index(x)
4-element Array{MathOptInterface.VariableIndex,1}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL393-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{InfOptConstraintRef}" href="#JuMP.optimizer_index-Tuple{InfOptConstraintRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimizer_index(cref::InfOptConstraintRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.optimizer_index-Tuple{ConstraintRef{Model,C,Shape} where Shape&lt;:AbstractShape where C}"><code>JuMP.optimizer_index</code></a> to return the <code>MathOptInterface</code> index(es) of <code>cref</code> in accordance with its reformulation constraints(s) stored in the optimizer model. For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a> has been extended for constraints. It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraints(s) that these indices are based on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_index(c1)
4-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL418-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual-Tuple{InfOptConstraintRef}" href="#JuMP.dual-Tuple{InfOptConstraintRef}"><code>JuMP.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual(cref::InfOptConstraintRef; [result::Int = 1])</code></pre><p>Extend <a href="../../JuMP/#JuMP.dual-Tuple{ConstraintRef{Model,#s38,Shape} where Shape&lt;:AbstractShape where #s38&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.dual</code></a> to return the dual(s) of <code>cref</code> in accordance with its reformulation constraint(s) stored in the optimizer model and the result index <code>result</code> of the most recent solution obtained. Use <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> to check if a result exists before asking for duals. For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_dual"><code>map_dual</code></a> has been extended for constraints. It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these duals are based on. Calling <code>parameter_refs</code> and <code>supports</code> may also be insightful.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dual(c1)
4-element Array{Float64,1}:
 -42.0
 -42.0
 32.3
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL471-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.shadow_price-Tuple{InfOptConstraintRef}" href="#JuMP.shadow_price-Tuple{InfOptConstraintRef}"><code>JuMP.shadow_price</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.shadow_price(cref::InfOptConstraintRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.shadow_price-Tuple{ConstraintRef{Model,#s38,Shape} where Shape&lt;:AbstractShape where #s38&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.shadow_price</code></a> to return the shadow price(s) of <code>cref</code> in accordance with its reformulation constraint(s) stored in the optimizer model. Use <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> to check if a result exists before asking for duals. For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_shadow_price"><code>map_shadow_price</code></a> has been extended for constraints. It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these shadow prices are based on. Calling <code>parameter_refs</code> and <code>supports</code> may also be insightful.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; shadow_price(c1)
4-element Array{Float64,1}:
 42.0
 42.0
 -32.3
 -0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL533-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_rhs_perturbation_range-Tuple{InfOptConstraintRef}" href="#JuMP.lp_rhs_perturbation_range-Tuple{InfOptConstraintRef}"><code>JuMP.lp_rhs_perturbation_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lp_rhs_perturbation_range(cref::InfOptConstraintRef;
                               [feasibility_tolerance::Float64 = 1e-8])</code></pre><p>Extend <a href="../../JuMP/#JuMP.lp_rhs_perturbation_range-Tuple{ConstraintRef{Model,#s38,Shape} where Shape&lt;:AbstractShape where #s38&lt;:MathOptInterface.ConstraintIndex}"><code>JuMP.lp_rhs_perturbation_range</code></a> to return the range(s) of the RHS of <code>cref</code> for which the shadow price(s) are valid in accordance with its reformulation constraint(s) stored in the optimizer model. For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> has been extended correctly and/or <a href="#InfiniteOpt.map_lp_rhs_perturbation_range"><code>map_lp_rhs_perturbation_range</code></a> has been implemented. It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>optimizer_model_constraint</code></a> to retrieve the constraint(s) that these ranges are based on. Calling <code>parameter_refs</code> and <code>supports</code> may also be insightful.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lp_rhs_perturbation_range(c1)
4-element Array{Tuple{Float64,Float64},1}:
 (-42.0, Inf)
 (-Inf, 42.0)
 (-Inf, 42.0)
 (-Inf, 42.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL591-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lp_objective_perturbation_range-Tuple{GeneralVariableRef}" href="#JuMP.lp_objective_perturbation_range-Tuple{GeneralVariableRef}"><code>JuMP.lp_objective_perturbation_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lp_objective_perturbation_range(vref::InfOptVariableRef;
                                     [optimality_tolerance::Float64 = 1e-8])</code></pre><p>Extend <a href="../../JuMP/#JuMP.lp_objective_perturbation_range-Tuple{VariableRef}"><code>JuMP.lp_objective_perturbation_range</code></a> to return the range(s) that the reduced cost(s) of <code>vref</code> remain valid in accordance with its reformulation variables(s) stored in the optimizer model. For extensions, this only works if <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> has been extended correctly and/or if <a href="#InfiniteOpt.map_lp_objective_perturbation_range"><code>map_lp_objective_perturbation_range</code></a> has been implemented. It may also be helpful to query via <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>optimizer_model_variable</code></a> to retrieve the variable(s) that these ranges are based on. Calling <code>parameter_refs</code> and <code>supports</code> may also be insightful.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lp_objective_perturbation_range(z)
(-2.0, Inf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL650-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_value" href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_value([ref/expr], key::Val{ext_key_name}, result::Int)</code></pre><p>Map the value(s) of <code>ref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code>, <code>optimizer_model_expression</code>, and/or <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code>, <code>optimizer_model_expression</code>, and <code>optimizer_model_constraint</code> are used to make these mappings by default. Here <code>result</code> is the result index used in <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL212-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_optimizer_index" href="#InfiniteOpt.map_optimizer_index"><code>InfiniteOpt.map_optimizer_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_optimizer_index(ref, key::Val{ext_key_name})</code></pre><p>Map the <code>MathOptInterface</code> index(es) of <code>ref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL358-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_dual" href="#InfiniteOpt.map_dual"><code>InfiniteOpt.map_dual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_dual(cref::InfOptConstraintRef, key::Val{ext_key_name}, result::Int)</code></pre><p>Map the dual(s) of <code>cref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default. Here <code>result</code> is the result index that is used in <code>dual</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL446-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_shadow_price" href="#InfiniteOpt.map_shadow_price"><code>InfiniteOpt.map_shadow_price</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_shadow_price(cref::InfOptConstraintRef, key::Val{ext_key_name})</code></pre><p>Map the shadow price(s) of <code>cref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> and <code>optimizer_model_constraint</code> are used to make these mappings by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL508-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_lp_rhs_perturbation_range" href="#InfiniteOpt.map_lp_rhs_perturbation_range"><code>InfiniteOpt.map_lp_rhs_perturbation_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_lp_rhs_perturbation_range(cref::InfOptConstraintRef,
                              key::Val{ext_key_name}, toler::Float64)</code></pre><p>Map the RHS perturbation range of <code>cref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>cref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_constraint</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_constraint</code> is used to make these mappings by default. Here <code>toler</code> corresponds to the <code>feasibility_tolerance</code> used by <code>lp_rhs_perturbation_range</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL563-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_lp_objective_perturbation_range" href="#InfiniteOpt.map_lp_objective_perturbation_range"><code>InfiniteOpt.map_lp_objective_perturbation_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_lp_objective_perturbation_range(vref::DecisionVariableRef,
                                    key::Val{ext_key_name}, toler::Float64)</code></pre><p>Map the reduced cost range(s) of <code>vref</code> to its counterpart in the optimizer model type that is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>vref</code> need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend <code>optimizer_model_variable</code>. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, <code>optimizer_model_variable</code> is used to make these mappings by default. Here <code>toler</code> corresponds to the <code>optimality_tolerance</code> used by <code>lp_objective_perturbation_range</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/750f4a04e4a6ffd51132613e5a9c3bdc8b86a01e/src/results.jl#LL621-L635">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimize/">« Optimization</a><a class="docs-footer-nextpage" href="../../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 18 September 2020 22:37">Friday 18 September 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
