var documenterSearchIndex = {"docs":
[{"location":"guide/variable/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"A guide and manual for the definition and use of variables in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/variable/#Overview","page":"Variables","title":"Overview","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Decision variables are at the very core of InfiniteOpt as its name alludes to mathematical programs that entail infinite decision spaces (i.e., contain infinite decision variables). Principally, three variable types are employed: infinite, point, and hold. Infinite variables encompass any decision variable that is parameterized by an infinite parameter (e.g., space-time variables and recourse variables). Point variables are infinite variables at a particular infinite parameter value (point). Finally, hold variables are decisions that are made irrespective of the infinite domain (e.g., first stage variables and design variables). Or in other words, they hold a particular value over the infinite domain or some sub-domain of it. We also employ reduced variables which correspond to partially transcribed infinite variables which are artifacts of measure evaluation and thus are discussed on the Measures page.","category":"page"},{"location":"guide/variable/#Basic-Usage","page":"Variables","title":"Basic Usage","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Infinite, point, and hold variables are summarized in the following table:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Variable Type Description Examples\nInfinite Functional variables with infinite co-domain y(t), y(xi), y(t x)\nPoint Infinite variable evaluated at parameter point y(0), y(t_0 x_0)\nHold Held constant over infinite domain z (design and 1st stage variables)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Infinite, point, and hold variables are typically defined via their respective macros: @infinite_variable, @point_variable, and @hold_variable. These macros generally emulate JuMP.@variable except that they each employ additional syntax capabilities to employ their respective variable type.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Let's first setup a simple space-time model with infinite parameters time t and spatial position x:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> using InfiniteOpt, JuMP\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_parameter(model, x[1:2] in [-1, 1], independent = true)\n2-element Array{GeneralVariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"guide/variable/#Infinite-Variables","page":"Variables","title":"Infinite Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now let's define a time dependent infinite variable y(t) with a lower bound of 0:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @infinite_variable(model, y(t) >= 0)\ny(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This creates a Julia variable y that points to the decision variable y(t) that is stored in model which is added to include a lower bound of 0. Another useful case is that of defining an array of variables w that depend on both position and time:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @infinite_variable(model, w[i = 1:3](t, x), start = [0, 2, 1][i])\n3-element Array{GeneralVariableRef,1}:\n w[1](t, x)\n w[2](t, x)\n w[3](t, x)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus we create a Julia array variable w whose elements w[i] point to their respective infinite variables w[i](t, x) stored in model. Note that the i used in the array definition can be used to index attributes assigned to each variable in the array. In this case, we used i to assign different initial guess values for each variable via the start keyword argument.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Moreover, for infinite variables a function can be given to determine the start values over a range of support points (e.g., a guess trajectory). This is discussed further below in the Macro Definition section.","category":"page"},{"location":"guide/variable/#Point-Variables","page":"Variables","title":"Point Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now let's add some point variables. These allow us to consider an infinite variable evaluated at a certain infinite parameter point. For example, let's define a point variable for y(0) with the alias y0 that is fixed at a value of 0:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @point_variable(model, y(0), y0 == 0)\ny0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we create a Julia variable y0 which points to the point variable y(0). Notice that in the second argument we specify the infinite variable indexed at the appropriate parameter value(s). Point variables automatically inherit attributes of the infinite variable (e.g., bounds, start values, etc.), but these are overwritten with properties specified for the point variable. In this case the lower bound inherited from y(t) is overwritten by instead fixing y(0) to a value of 0.  ","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"note: Note\nPoint variables are provided for enhancing the generality of InfiniteOpt, but typically can be avoided by using infinite variables in combination with @BDconstraint to define bounded constraints ( e.g., initial conditions).","category":"page"},{"location":"guide/variable/#Hold-Variables","page":"Variables","title":"Hold Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, we can add hold variables to our model. These denote variables that hold a single value over the infinite domain or some portion of it (e.g., design variables, first stage variables, etc.). Let's add a hold variable 0 leq d leq 42 that is an integer variable and defined over all infinite domains (i.e., time and space):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, 0 <= d <= 42, Int)\nd","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This creates a Julia variable d that points to the hold variable d which has a lower bound of 0, an upper bound of 42, and is an integer variable. Thus, @hold_variable follows the same exact syntax as JuMP.@variable except that it also allows the user to specify a subdomain over which the hold variable is valid. For example, let's add a hold variable z that is only valid over the subdomain t in 0 5 via the parameter_bounds keyword argument:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> anon = @hold_variable(model, parameter_bounds = (t in [0, 5]),\n                             base_name = \"z\")\nz","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we make an anonymous variable for the sake of example whose reference is stored to the Julia variable anon and points to a hold variable z which is only valid for t in 0 5. Thus, this will be enforced in any constraints that involve anon, meaning they will automatically be bounded to such a subdomain. Any number of parameters bounds (bounds on the parameters of the infinite domain) can be added in a tuple like argument as explained in the documentation for @hold_variable.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now we have defined variables that we can use in the objective, measures, and constraints. Please note that the above tutorial only shows a small portion of the capabilities and options available in defining variables. A full description is provided in the documentation below.","category":"page"},{"location":"guide/variable/#Variable-Definition-Methodology","page":"Variables","title":"Variable Definition Methodology","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The @infinite_variable, @point_variable, and @hold_variable macros all follow a similar methodology behind the scenes and these commonalities are discussed in this section for conciseness. Defining/initializing a variable principally involves the following steps:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Define the variable information pertaining to JuMP.VariableInfo (e.g., bounds, indicate if it is integer, etc.)\nConstruct a concrete subtype of InfOptVariable to store the variable information\nAdd the InfOptVariable object to an InfiniteModel and assign a name\nCreate a GeneralVariableRef that points to the variable object stored in the model","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The JuMP.VariableInfo data structure stores the following variable information:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"has_lb::Bool: Specifies a Bool it has a lower bound\nlower_bound::Real: Specifies lower bound value\nhas_ub::Bool: Specifies a Bool it has a upper bound\nupper_bound::Real: Specifies upper bound value\nhas_fix::Bool: Specifies a Bool it is fixed\nfixed_value::Real: Specifies the fixed value\nhas_start::Bool: Specifies a Bool it has a start value\nstart::Union{Real, Function}: Specifies the start guess value, this can be a                                 function for infinite variables that intakes a                                 support and maps it to a guess value (allowing                                 to specify guess trajectories)\nbinary: Specifies Bool if it is binary\ninteger: Specifies Bool if it is integer.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, the user specifies this information to prepare such an object:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> info = VariableInfo(true, 0., true, 42., false, 0., false, 0., false, true)\nVariableInfo{Float64,Float64,Float64,Float64}(true, 0.0, true, 42.0, false, 0.0, false, 0.0, false, true)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we specified a lower bound of 0, an upper bound of 42, and that it is integer.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The variable objects (InfOptVariable subtypes) are defined via build_variable which requires that the user provide a JuMP.VariableInfo object, the variable type to be defined (Infinite, Point, or Hold), and any necessary keyword arguments required for that variable type (i.e., parameter_refs, infinite_variable_ref, and/or parameter_values). For example, let's build an infinite variable y(t) that has an lower bound of 0, an upper bound of 42, and is integer:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> info = VariableInfo(true, 0, true, 42, false, 0, false, 0, false, true);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = (t));","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, we create an InfiniteVariable object with the desired properties. Note that in this case the parameter_refs keyword argument is required to indicate which infinite parameter(s) this infinite variable will depend on.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Once a variable has been built, it needs to be added to our model and a Julia variable should be defined to reference it. Variables are added via add_variable which adds a variable object to the model, assigns a name to the variable, adds any constraints associated with the JuMP.VariableInfo, and returns an appropriate variable reference variable (a GeneralVariableRef). For example, let's add inf_var to model:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> var_ref = add_variable(model, inf_var, \"y\")\ny(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, we have added an infinite variable y that is parameterized by t with the variable information mentioned above and now have a GeneralVariableRef called var_ref that can be used in defining our infinite model.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Note that the use of GeneralVariableRefs and the corresponding concrete subtypes of DispatchVariableRefs is discussed on the Expressions page.","category":"page"},{"location":"guide/variable/#Macro-Variable-Definition","page":"Variables","title":"Macro Variable Definition","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The @infinite_variable, @point_variable, and @hold_variable macros automate the variable definition process discussed above in the Variable Definition Methodology section via a straightforward symbolic syntax. The only key difference is that non-anonymous macro calls will register variable names to ensure they are not repeated. Anonymous macro calls forgo this step and exactly follow the process described above. This section will highlight the details of using these macros.","category":"page"},{"location":"guide/variable/#var_macro_gen_usage","page":"Variables","title":"General Usage","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we discuss the features that the variable macros have in common (generally these pertain to JuMP-like features). To illustrate this via example, let's setup a model with a variety of infinite parameters t in 010, x in -1 1^3, and xi in mathcalN(0 1):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> using InfiniteOpt, JuMP, Distributions\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @infinite_parameter(model, x[1:3] in [-1, 1], independent = true);\n\njulia> @infinite_parameter(model, ξ in Normal());","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We will first consider anonymous variable macro calls which generally are less convenient than non-anonymous macro calls which offer a much more intuitive mathematical syntax. However, anonymous variables can be useful and provide a good foundation to understanding non-anonymous variables. Furthermore, we'll use hold variables as the motivating examples since they best exemplify commonalities between the macros. First, let's consider single anonymous definition a hold variable:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> var_ref = @hold_variable(model)\nnoname","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we just added a nameless hold variable to model and defined var_ref as a GeneralVariableRef that points to it. We can add a name via the base_name keyword argument:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> var_ref1 = @hold_variable(model, base_name = \"d\")\nd\n\njulia> var_ref2 = @hold_variable(model, base_name = \"d\")\nd","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now we've made 2 more hold variables both called d. Thus, the anonymous syntax allows us to define variables with the same name. Moreover, any variable information can be specified via the appropriate keywords which include:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"lower_bound::Real: specifies lower bound\nupper_bound::Real: specifies upper bound\nstart::Union{Real, Function}: specifies the initial guess value the solver will use,                                 for infinite variables this can be a function that                                 takes as input a realization of the infinite parameters                                 (using the same format as parameter_refs) and return the                                 guess value for such as realization (e.g., functionally                                 define a trajectory).\nbinary::Bool: specifies if is binary variable\ninteger::Bool: specifies if is integer variable.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Anonymous variables must use these keyword arguments since symbolic definition is only permitted for non-anonymous macro calls. For example, let's define a hold variable 0 leq d leq 5 that is integer:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> var_ref = @hold_variable(model, base_name = \"d\", lower_bound = 0,\n                                upper_bound = 5, integer = true)\nd","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We can also define arrays of variables using any indices of our choice. For example, let's define a 3-dimensional vector with indices [1, 2, 3]:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> var_refs = @hold_variable(model, [i = 1:3], start = [0, 2, 1][i],\n                                 base_name = \"d\")\n3-element Array{GeneralVariableRef,1}:\n d[1]\n d[2]\n d[3]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, we define 3 variables named d[i] and each with different start values and define var_refs which is a vector of GeneralVariableRefs that uses the indices we specified. Note the syntax i = indices is used to define an iteration variable to use with the keyword arguments to assign different values for each variable being defined. Note the above example is equivalent to:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> starts = [0, 2, 1];\n\njulia> var_refs = Vector{GeneralVariableRef}(undef, 3);\n\njulia> for i = eachindex(var_refs)\n          var_refs[i] = @hold_variable(model, base_name = \"d\", start = starts[i])\n       end","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Other non-standard indices can also be used such as the following examples:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> var_refs2 = @hold_variable(model, [2:4], base_name = \"d\")\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 2:4\nAnd data, a 3-element Array{GeneralVariableRef,1}:\n d[2]\n d[3]\n d[4]\n\njulia> var_refs3 = @hold_variable(model, [[:A, :C, :Z]], base_name = \"d\")\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:A, :C, :Z]\nAnd data, a 3-element Array{GeneralVariableRef,1}:\n d[A]\n d[C]\n d[Z]\n\njulia> var_refs3 = @hold_variable(model, [i=1:2, j=i:2], base_name = \"d\")\nJuMP.Containers.SparseAxisArray{GeneralVariableRef,2,Tuple{Int64,Int64}} with 3 entries:\n  [1, 2]  =  d[1,2]\n  [2, 2]  =  d[2,2]\n  [1, 1]  =  d[1,1]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we see that a variety of indices can be used and this is explained more fully in the documentation of JuMP.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"JuMP employs 2 special array container types: DenseAxisArrays and SparseAxisArrays which help facilitate this special indexing. The variable macros will by default automatically detect which container type should be used. However, the user can specify a particular container type using the container keyword. For example, if we want to use indices a:b where a = 1 and b = 3, a DenseAxisArray will be used by default, but we can force it to be a regular Array:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> a = 1; b = 3;\n\njulia> var_refs1 = @hold_variable(model, [a:b], base_name = \"d\")\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 1:3\nAnd data, a 3-element Array{GeneralVariableRef,1}:\n d[1]\n d[2]\n d[3]\n\njulia> var_refs2 = @hold_variable(model, [a:b], base_name = \"d\", container = Array)\n3-element Array{GeneralVariableRef,1}:\n d[1]\n d[2]\n d[3]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For more information on JuMP containers please visit their page here.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Now that we have a foundation with anonymous variable macro calls, let's focus on non-anonymous calls which offer a much more straightforward syntax. These calls can still implement all of the same keyword arguments. Moreover, they automatically create a Julia variable with the variable name provided and register this name to ensure subsequent automatic Julia variables do not overwrite it.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The supported symbolic syntax principally implements the following keyword arguments:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"base_name\nlower_bound\nupper_bound\ninteger\nbinary\nparameter_refs (for infinite variables)\ninfinite_variable_ref (for point variables)\nparameter_values (for point variables).","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"These are implemented via the syntax @[type]_variable(model, expr, integrality_arg, keyword_args...). Here expr specifies the name, bounds, and/or variable specific keyword arguments. It can use the following forms (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"varexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, providing an intuitive means to specify bounds. The expressions varexpr specifies the name, dimensions, and/or type specific keywords and can be of the form:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"varname creating a scalar real variable of name varname\nvarname[...] creating a container of variables with indices ...\nvarname(params) creating an infinite variable dependent on params\nvarname[...](params) creating infinite variables dependent on params.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The integrality_arg optionally is used to indicate if the variable(s) is/are integer or binary using Int or Bin, respectively.  ","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For example, let's define a hold variable 0 leq d leq 3 that is integer:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, 0 <= d <= 3, Int)\nd","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Note this is equivalent to","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> d = @hold_variable(model, base_name = \"d\", lower_bound = 0, upper_bound = 3,\n                          integer = true)\nd","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"with the exception that the non-anonymous definition registers d as variable name that cannot be duplicated. For one more example let's define a vector of variables a in mathbbR_+^3 with starting values of 0:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, a[1:3] >= 0, start = 0)\n3-element Array{GeneralVariableRef,1}:\n a[1]\n a[2]\n a[3]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, highlighting how keyword arguments can still be used.","category":"page"},{"location":"guide/variable/#Infinite-Variables-2","page":"Variables","title":"Infinite Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Infinite variables entail decision variables that depend on infinite parameter(s). Thus, @infinite_variable follows the general definition methodology with this additional consideration.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Let's first consider a basic anonymous definition of an infinite variable y(t x):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> y = @infinite_variable(model, parameter_refs = (t, x), base_name = \"y\")\ny(t, x)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we created an infinite variable with the base name y that depends on t and x. Notice that each group of parameters are specified in a particular element of the parameter_refs tuple, this is the required format. Moreover, the keyword argument parameter_refs is required to specify what parameterizes the infinite variable. Because we used an anonymous call, we can still make another variable with the same name. For example let's define another infinite variable also called y that only depends on t:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> y2 = @infinite_variable(model, parameter_refs = (t), base_name = \"y\")\ny(t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"More conveniently, we can equivalently define y(t x) symbolically:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @infinite_variable(model, y(t, x))\ny(t, x)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"We can also use this symbolic syntax to add constraint information as described in the previous section. For example, let's define a vector of infinite variables z(t) in 0 1 2^3:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @infinite_variable(model, 0 <= z[1:3](t) <= 2, Int)\n3-element Array{GeneralVariableRef,1}:\n z[1](t)\n z[2](t)\n z[3](t)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"In many cases, it is important to specify a guess trajectory for an infinite variable. Currently, this can be done by defining a start value function and specifying via the start keyword. In particular, the arguments of this function must match the format of the infinite parameters and return a start value for a given realization (point) of the infinite parameters:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> my_traj_func(t_val, x_vals) = t_val + sum(x_vals) # replace with actual functionality\nmy_traj_func (generic function with 1 method)\n\njulia> @infinite_variable(model, y2(t, x), start = (t_val, x_vals) -> my_traj_func(t_val, x_vals))\ny2(t, x)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Notice that above we use an anonymous function in the macro call, this is done to avoid ambiguity in case we have multiple my_traj_func definitions. In general it is recommended that anonymous functions be used.","category":"page"},{"location":"guide/variable/#Point-Variables-2","page":"Variables","title":"Point Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Point variables denote infinite variables evaluated at a particular point in the infinite decision space (i.e., particular infinite parameter values). These are commonly employed when using initial and terminal conditions, and to build discrete characterizations of complex operators such as derivatives. The @point_variable macro is employed to define such variables. Principally, it follows the general variable definition paradigm, but allows us to specify the infinite variable it refers to and the parameter values it is evaluated at. Also, note that by default it inherits the characteristics of the infinite variable (e.g., bounds), but these are overwritten as specified in the point variable macro.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"To begin let's consider defining a boundary point y(0 -1) based on the infinite variable y(t x) and enforce that it be nonnegative. Note that -1 need be a 3 element vector in this case to match the dimensions of x. The anonymous syntax would be:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> y0 = @point_variable(model, infinite_variable_ref = y,\n                            parameter_values = (0, [-1, -1, -1]), lower_bound = 0)\ny(0, [-1, -1, -1])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"This creates a point variable y(0, [-1, -1, -1]) ≥ 0 that is added to model and assigns to the associated GeneralVariableRef to the Julia variable y0. Equivalently, this can accomplished much more conveniently via:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @point_variable(model, y(0, [-1, -1, -1]), y0 >= 0)\ny0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here the 2nd argument specifies the infinite variable and parameter values, and the next argument is used to provide a convenient alias that can be used in combination with the typical symbolic variable syntax described in the previous sections. Let's also demonstrate how this works for multi-dimensional infinite variables. For example consider defining z(0) = 0 for z(t) in 0 1 2^3:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @point_variable(model, z[i](0), z0[i = 1:3] == 0)\n3-element Array{GeneralVariableRef,1}:\n z0[1]\n z0[2]\n z0[3]","category":"page"},{"location":"guide/variable/#Hold-Variables-2","page":"Variables","title":"Hold Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Hold variables denote decision variables that are constant (agnostic) over the infinite domain or some sub-domain of it. This is accomplished via the @hold_variable macro as demonstrated in the General Usage section. By default and as shown in the above examples, hold variables are valid over the entire infinite domain. However, this scope can be limited via the parameter_bounds keyword argument.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For example, let's define a hold variable b in 0 1 that is valid over the entire infinite domain (any infinite parameter value):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, b, Bin)\nb","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Again, this follows the methodology outlined above. Now let's suppose we want to define a hold variable 0 leq c leq 42 that is only valid over the time interval t in 0 5 which is a subset of the entire range being considered. This can be accomplished via parameter_bounds:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, 0 <= c <= 42, parameter_bounds = (t in [0, 5]))\nc","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, we defined c and it can only be used in constraints and measures in accordance with this limited sub-domain. When such a limited hold variable is used in a constraint, the constraint parameter bounds be overlapped with those of c if possible. Otherwise, an error will be thrown. This is further explained on the Constraints page.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Any number of parameters can be specified in a hold variable's sub-domain. For example, let's define e such over the domain t in 0 1, x = -1:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, e, parameter_bounds = (t in [0, 1], x == -1))\ne","category":"page"},{"location":"guide/variable/#Queries","page":"Variables","title":"Queries","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfiniteOpt contains a large suite of methods to query information about variables. This suite is comprised of extensions to all current JuMP query methods and many more that are specific to InfiniteOpt. A number of the more commonly used ones are explained in this section, but all of the available methods are explained in the Methods/Macros section (i.e., the manual) below.","category":"page"},{"location":"guide/variable/#General-Information","page":"Variables","title":"General Information","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Here we describe some methods used to query general variable information such as the name. Variable names can be extracted via name which returns the name of a variable. The index of a variable (where it is stored in the infinite model) is accessed via index and the infinite model it belongs to is given by owner_model. These methods are demonstrated below:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> name(y)\n\"y\"\n\njulia> index(y)\nInfiniteVariableIndex(3)\n\njulia> model_where_stored = owner_model(y);","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Also, num_variables is useful in returning the total number of decision variables currently stored in an infinite model:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> num_variables(model)\n45\n\njulia> num_variables(model, PointVariable)\n5","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Similarly, all_variables returns a list of all the variables currently added to the model.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, variable_by_name can be employed to return the appropriate GeneralVariableRef based off of the variable name if it is unique. Returns nothing if such a name cannot be found and errors if it is not unique. For example, we can request the reference associated with \"c\":","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> variable_by_name(model, \"c\")\nc","category":"page"},{"location":"guide/variable/#Variable-Constraint-Info","page":"Variables","title":"Variable Constraint Info","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"As described above, variables in InfiniteOpt can have constraints associated with them like JuMP variables. These constraints include:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"lower bounds\nupper bounds\nfixed values\nbinary specifications\ninteger specifications.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, a number of methods exist to query information about these constraints.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"First, the [has/is]_[variable constraint type] methods indicate whether or not a variable has that particular constraint type. For example, to query if a variable d has a lower bound we can use has_lower_bound:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> has_lower_bound(d)\ntrue","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, d does have a lower bound. The other methods are has_upper_bound, is_fixed, is_binary, and is_integer.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Next, the [ConstraintType]Ref methods return an appropriate explicit type InfOptConstraintRef that points to the constraint (errors if no such constraint exists). For example, the upper bound constraint of d can be obtained via UpperBoundRef:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> UpperBoundRef(d)\nd ≤ 3.0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"The other methods are LowerBoundRef, FixRef, BinaryRef, and IntegerRef.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, variable constraints that entail values (i.e., lower bounds, upper bounds, and fixed values) have their values queried via the appropriate method. For example, the lower bound value of d is obtained via lower_bound:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> lower_bound(d)\n0.0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Note these methods error when no such constraint is associated with the variable. The other methods are upper_bound and fix_value.","category":"page"},{"location":"guide/variable/#Variable-Use","page":"Variables","title":"Variable Use","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfiniteOpt defines a number of methods to track if and how variables are used in an infinite model. For example, used_by_constraint is used to determine if a variable is used by a constraint. For example, let's see if c is used by a constraint:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> used_by_constraint(c)\ntrue","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Other methods include used_by_measure and used_by_objective. For infinite variables, used_by_point_variable can also be used in a similar manner.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, in general is_used can be used to determine if a variable is used at all in the infinite model or not. For example, if we check e using is_used we find that it isn't:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> is_used(e)\nfalse","category":"page"},{"location":"guide/variable/#Type-Specific","page":"Variables","title":"Type Specific","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfiniteOpt also employs a few methods for specific variable types that return information pertaining to that particular variable type. For infinite variables, parameter_refs returns the tuple of infinite parameters that the variable depends on. For example, consider y(t, x):","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> parameter_refs(y)\n(t, GeneralVariableRef[x[1], x[2], x[3]])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For point variables, infinite_variable_ref and parameter_values return the infinite variable it depends on and the infinite parameter point values, respectively. For example, consider the point variable y0:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> infinite_variable_ref(y0)\ny(t, x)\n\njulia> parameter_values(y0)\n(0.0, [-1.0, -1.0, -1.0])","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For hold variables, has_parameter_bounds returns if a hold variable has parameter bounds (i.e., a specified sub-domain) and parameter_bounds returns those bounds if there are any. For example, consider c:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> has_parameter_bounds(c)\ntrue\n\njulia> parameter_bounds(c)\nSubdomain bounds (1): t ∈ [0, 5]","category":"page"},{"location":"guide/variable/#Modification","page":"Variables","title":"Modification","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfiniteOpt employs a wide variety of methods to modify/delete variables. These are comprised of JuMP extensions and methods native only to InfiniteOpt. This section will highlight some of the more commonly used ones. All of the methods/macros are detailed in the Methods/Macros section (i.e., the manual) below.","category":"page"},{"location":"guide/variable/#Deletion","page":"Variables","title":"Deletion","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Like JuMP v0.19+, InfiniteOpt fully supports deletion throughout its data types. Any variable and its dependencies can be deleted via delete. Thus, when delete is invoked any bound/type constraints associated with the variable will be removed and it will be removed from any other constraints, measures, and/or objectives. For example, if we delete y(t, x) it will be removed along with its bounds and the point variable y0 will also be removed since it is a dependent:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> delete(model, y)","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Another class of deletion methods correspond to variable constraints. For example, delete_lower_bound is used to delete a lower bound associated with a variable if it has one. Let's illustrate this by deleting the lower bound of d:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> delete_lower_bound(d)\n\njulia> has_lower_bound(d)\nfalse","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Other similar methods are delete_upper_bound, unfix, unset_binary, and unset_integer.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, delete_parameter_bounds can be used on hold variables to delete all of their parameter bounds. For example, let's delete all of the parameter bounds associated with c:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> parameter_bounds(c)\nSubdomain bounds (1): t ∈ [0, 5]\n\njulia> delete_parameter_bounds(c)\n\njulia> has_parameter_bounds(c)\nfalse","category":"page"},{"location":"guide/variable/#Variable-Constraints","page":"Variables","title":"Variable Constraints","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Another class of methods seek to add/modify variable constraints such as bounds. For example, set_lower_bound specifies the lower bound of a variable. We can add a lower bound of 0 to c by:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> set_lower_bound(c, 0)\n\njulia> lower_bound(c)\n0.0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Thus, adding a lower bound to c. Furthermore, we can later modify the lower bound using the same method:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> set_lower_bound(c, -2)\n\njulia> lower_bound(c)\n-2.0","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Other similar methods are set_upper_bound, fix, set_binary, and set_integer.","category":"page"},{"location":"guide/variable/#Type-Specific-2","page":"Variables","title":"Type Specific","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Finally, we consider methods unique to InfiniteOpt that exist to modify specific variable types.","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"For hold variables, the parameter bounds can be modified via @add_parameter_bounds and @set_parameter_bounds which facilitate an intuitive symbolic syntax to add and/or overwrite existing parameter bounds for a hold variable. For example, let's add the bounds t in 0 5 and x = 0 to c:","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"julia> @add_parameter_bounds(c, (t in [0, 5], x == 0))","category":"page"},{"location":"guide/variable/#Datatypes","page":"Variables","title":"Datatypes","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Pages   = [\"variable.md\"]\nModules = [InfiniteOpt, InfiniteOpt.Collections]\nOrder   = [:type]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"InfOptVariable\nInfiniteVariable\nPointVariable\nParameterBounds\nHoldVariable\nVariableData\nInfiniteVariableIndex\nPointVariableIndex\nHoldVariableIndex\nInfiniteVariableRef\nPointVariableRef\nHoldVariableRef\nInfiniteOpt.Collections.VectorTuple","category":"page"},{"location":"guide/variable/#InfiniteOpt.InfOptVariable","page":"Variables","title":"InfiniteOpt.InfOptVariable","text":"InfOptVariable <: JuMP.AbstractVariable\n\nAn abstract type for infinite, reduced, point, and hold variables.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.InfiniteVariable","page":"Variables","title":"InfiniteOpt.InfiniteVariable","text":"InfiniteVariable{P <: GeneralVariableRef} <: InfOptVariable\n\nA DataType for storing core infinite variable information. Note that indices that refer to the same dependent parameter group must be in the same tuple element. It is important to note that info.start should contain a start value function that generates the start value for a given infinite parameter support. This function should map a support to a start value using user-formatting if is_vector_start = false, otherwise it should do the mapping using a single support vector as input. Also, the variable reference type P must pertain to infinite parameters.\n\nFields\n\ninfo::JuMP.VariableInfo{Float64, Float64, Float64, Function}: JuMP variable information.\nparameter_refs::VectorTuple{P}: The infinite parameter references that                                   parameterize the variable.\nparameter_nums::Vector{Int}: The parameter numbers of parameter_refs.\nobject_nums::Vector{Int}: The parameter object numbers associated with parameter_refs.\nis_vector_start::Bool: Does the start function take support values formatted as vectors?\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.PointVariable","page":"Variables","title":"InfiniteOpt.PointVariable","text":"PointVariable{I <: GeneralVariableRef} <: InfOptVariable\n\nA DataType for storing point variable information. Note that the elements parameter_values field must match the format of the parameter reference tuple defined in InfiniteVariable\n\nFields\n\ninfo::JuMP.VariableInfo{Float64, Float64, Float64, Float64} JuMP Variable information.\ninfinite_variable_ref::I The infinite variable reference   associated with the point variable.\nparameter_values::Vector{Float64} The infinite parameter values   defining the point.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.ParameterBounds","page":"Variables","title":"InfiniteOpt.ParameterBounds","text":"ParameterBounds{P <: GeneralVariableRef}\n\nA DataType for storing intervaled bounds of parameters. This is used to define subdomains of HoldVariables and BoundedScalarConstraints. Note that the GeneralVariableRef must pertain to infinite parameters.\n\nFields\n\nintervals::Dict{GeneralVariableRef, IntervalSet}: A dictionary of interval bounds on infinite parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.HoldVariable","page":"Variables","title":"InfiniteOpt.HoldVariable","text":"HoldVariable{P <: GeneralVariableRef} <: InfOptVariable\n\nA DataType for storing hold variable information.\n\nFields\n\ninfo::JuMP.VariableInfo{Float64, Float64, Float64, Float64} JuMP variable information.\nparameter_bounds::ParameterBounds{P} Valid parameter sub-domains\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.VariableData","page":"Variables","title":"InfiniteOpt.VariableData","text":"VariableData{V <: InfOptVariable} <: AbstractDataObject\n\nA mutable DataType for storing InfOptVariables and their data.\n\nFields\n\nvariable::V: The scalar variable.\nname::String: The name used for printing.\nlower_bound_index::Union{ConstraintIndex, Nothing}: Index of lower bound constraint.\nupper_bound_index::Union{ConstraintIndex, Nothing}: Index of upper bound constraint.\nfix_index::Union{ConstraintIndex, Nothing}: Index on fixing constraint.\nzero_one_index::Union{ConstraintIndex, Nothing}: Index of binary constraint.\nintegrality_index::Union{ConstraintIndex, Nothing}: Index of integer constraint.\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nconstraint_indices::Vector{ConstraintIndex}: Indices of dependent constraints.\nin_objective::Bool: Is this used in objective?\npoint_var_indices::Vector{PointVariableIndex}: Indices of dependent point variables.\nreduced_var_indices::Vector{ReducedVariableIndex}: Indices of dependent reduced variables.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.InfiniteVariableIndex","page":"Variables","title":"InfiniteOpt.InfiniteVariableIndex","text":"InfiniteVariableIndex <: ObjectIndex\n\nA DataType for storing the index of a InfiniteVariable.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.PointVariableIndex","page":"Variables","title":"InfiniteOpt.PointVariableIndex","text":"PointVariableIndex <: ObjectIndex\n\nA DataType for storing the index of a PointVariable.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.HoldVariableIndex","page":"Variables","title":"InfiniteOpt.HoldVariableIndex","text":"HoldVariableIndex <: ObjectIndex\n\nA DataType for storing the index of a HoldVariable.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.InfiniteVariableRef","page":"Variables","title":"InfiniteOpt.InfiniteVariableRef","text":"InfiniteVariableRef <: DispatchVariableRef\n\nA DataType for untranscripted infinite dimensional variable references (e.g., second stage variables, time dependent variables).\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::InfiniteVariableIndex: Index of the variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.PointVariableRef","page":"Variables","title":"InfiniteOpt.PointVariableRef","text":"PointVariableRef <: FiniteVariableRef\n\nA DataType for variables defined at a transcipted point (e.g., second stage variable at a particular scenario, dynamic variable at a discretized time point).\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::PointVariableIndex: Index of the variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.HoldVariableRef","page":"Variables","title":"InfiniteOpt.HoldVariableRef","text":"HoldVariableRef <: FiniteVariableRef\n\nA DataType for finite fixed variable references (e.g., first stage variables, steady-state variables).\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::HoldVariableIndex: Index of the variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.Collections.VectorTuple","page":"Variables","title":"InfiniteOpt.Collections.VectorTuple","text":"VectorTuple{T}\n\nA collection DataType for storing a Tuple of singular elements of type T and/or AbstractArray{<:T}s in a convenient vector form that utilizes linear indexing. Moreover VectorTuples can be modified using standard vector operations such as empty!, push!, and deleteat!. VectorTuples should be defined from an original tuple via VectorTuple(tuple) or by listing the tuple elements VectorTuple(items...). Note this is still an experimental type and is primarily intended to store infinite parameter reference tuples and point variable support value tuples. Some of the notable capabilities are exemplified below.\n\nExample\n\njulia> tuple = (3, [-2, 4], ones(2, 2))\n(3, [-2, 4], [1.0 1.0; 1.0 1.0])\n\njulia> vt = VectorTuple(tuple) # make by listing items (notice everything is a vector)\n([3.0], [3.0, 4.0], [1.0, 1.0, 1.0, 1.0])\n\njulia> vt[2] # linear indexing\n-2.0\n\njulia> vt[2, 2] # tuple indexing (note the second index is treated linearly)\n4.0\n\njulia> vt[6:end] # linear slicing\n2-element Array{Float64,1}:\n 1.0\n 1.0\n\njulia> vt[2:3, :] # tuple slicing\n2-element Array{Array{Float64,1},1}:\n [-2.0, 4.0]\n [1.0, 1.0, 1.0, 1.0]\n\njulia> tuple2 = Tuple(vt) # rebuild original Tuple with original indices\n([3.0], [-2.0, 4.0], [1.0 1.0; 1.0 1.0])\n\njulia> push!(vt, [42., 42]) # add new tuple element\n([3.0], [-2.0, 4.0], [1.0, 1.0, 1.0, 1.0], [42.0, 42.0])\n\njulia> deleteat!(vt, 4) # delete an element via linear indexing\n([3.0], [-2.0, 4.0], [1.0, 1.0, 1.0])\n\njulia> Tuple(vt) # The 3rd element becomes a SparseAxisArray because of deletion\n([3.0], [-2.0, 4.0],   [1, 2]  =  1.0\n  [2, 2]  =  1.0\n  [2, 1]  =  1.0)\n\njulia> deleteat!(vt, 3, tuple_index = true) # delete a whole tuple element\n([3.0], [-2.0, 4.0])\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#var_methods","page":"Variables","title":"Methods/Macros","text":"","category":"section"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"Pages   = [\"variable.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/variable/","page":"Variables","title":"Variables","text":"@infinite_variable\n@point_variable\n@hold_variable\nJuMP.build_variable(::Function, ::JuMP.VariableInfo, ::Symbol)\nJuMP.add_variable(::InfiniteModel, ::InfOptVariable, ::String)\nused_by_constraint(::DecisionVariableRef)\nused_by_measure(::DecisionVariableRef)\nused_by_objective(::DecisionVariableRef)\nis_used(::DecisionVariableRef)\nused_by_point_variable(::InfiniteVariableRef)\nused_by_reduced_variable(::InfiniteVariableRef)\nis_used(::InfiniteVariableRef)\nJuMP.delete(::InfiniteModel, ::DecisionVariableRef)\nJuMP.num_variables(::InfiniteModel, ::Type{InfOptVariable})\nJuMP.all_variables(::InfiniteModel, ::Type{InfOptVariable})\nJuMP.name(::DecisionVariableRef)\nJuMP.set_name(::DecisionVariableRef, ::String)\nJuMP.variable_by_name(::InfiniteModel, ::String)\nJuMP.has_lower_bound(::UserDecisionVariableRef)\nJuMP.lower_bound(::UserDecisionVariableRef)\nJuMP.set_lower_bound(::UserDecisionVariableRef, ::Real)\nJuMP.LowerBoundRef(::UserDecisionVariableRef)\nJuMP.delete_lower_bound(::UserDecisionVariableRef)\nJuMP.has_upper_bound(::UserDecisionVariableRef)\nJuMP.upper_bound(::UserDecisionVariableRef)\nJuMP.set_upper_bound(::UserDecisionVariableRef, ::Real)\nJuMP.UpperBoundRef(::UserDecisionVariableRef)\nJuMP.delete_upper_bound(::UserDecisionVariableRef)\nJuMP.is_fixed(::UserDecisionVariableRef)\nJuMP.fix_value(::UserDecisionVariableRef)\nJuMP.fix(::UserDecisionVariableRef, ::Real; ::Bool)\nJuMP.FixRef(::UserDecisionVariableRef)\nJuMP.unfix(::UserDecisionVariableRef)\nJuMP.start_value(::UserDecisionVariableRef)\nJuMP.set_start_value(::UserDecisionVariableRef, ::Real)\nstart_value_function(::InfiniteVariableRef)\nset_start_value_function(::InfiniteVariableRef, ::Union{Real, Function})\nreset_start_value_function(::InfiniteVariableRef)\nJuMP.is_binary(::UserDecisionVariableRef)\nJuMP.set_binary(::UserDecisionVariableRef)\nJuMP.BinaryRef(::UserDecisionVariableRef)\nJuMP.unset_binary(::UserDecisionVariableRef)\nJuMP.is_integer(::UserDecisionVariableRef)\nJuMP.set_integer(::UserDecisionVariableRef)\nJuMP.IntegerRef(::UserDecisionVariableRef)\nJuMP.unset_integer(::UserDecisionVariableRef)\nparameter_refs(::InfiniteVariableRef)\nparameter_list(::InfiniteVariableRef)\nraw_parameter_refs(::InfiniteVariableRef)\n@set_parameter_bounds\n@add_parameter_bounds\nhas_parameter_bounds(::HoldVariableRef)\nparameter_bounds(::HoldVariableRef)\nset_parameter_bounds(::HoldVariableRef, ::ParameterBounds{GeneralVariableRef})\nadd_parameter_bounds(::HoldVariableRef, ::ParameterBounds{GeneralVariableRef})\ndelete_parameter_bounds(::HoldVariableRef)\ninfinite_variable_ref(::PointVariableRef)\nparameter_values(::PointVariableRef)\nraw_parameter_values(::PointVariableRef)\nJuMP.relax_integrality(::InfiniteModel)","category":"page"},{"location":"guide/variable/#InfiniteOpt.@infinite_variable","page":"Variables","title":"InfiniteOpt.@infinite_variable","text":"@infinte_variable(model::InfiniteModel, kw_args...)::GeneralVariableRef\n\nAdd an anonymous infinite variable to the model model described by the keyword arguments kw_args and returns the variable reference. Note that the parameter_refs keyword is required in this case.\n\n@infinite_variable(model::InfiniteModel, varexpr, args...,\n                   kw_args...)::GeneralVariableRef\n\nAdd an infinite variable to model described by the expression var_expr, the positional arguments args and the keyword arguments kw_args. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of name varname\nvarname(params...) creating a scalar real variable of name varname with infinite parameters params... see parameter_refs for format.\nvarname[...] or [...] creating a container of variables.\nvarname[...](params...) or [...] creating a container of variables with infinite parameters params... in the first case.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\nparameter_refs: This is mandatory if not specified in varexpr. Can be a single parameter reference, a single parameter array with parameters defined in the same call of @infinite_parameter, or a tuple where each element is either of the first two options listed.\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes. Furthermore, the parameter reference tuple is appended on the end of the name i.e., base_name(params...) or base_name[...](params...).\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.          This can be a single value enforced over the entire infinite variable          domain or it can be a function that maps a support value to a scalar          guess value. Note that the function arguments must match the format          of parameter_refs.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(model, 0 <= t <= 1)\nt\n\njulia> @infinite_parameter(model, w[1:2] in Normal())\n2-element Array{GeneralVariableRef,1}:\n w[1]\n w[2]\n\njulia> @infinite_variable(model, x(t, w) >= 0)\nx(t, w)\n\njulia> x = @infinite_variable(model, parameter_refs = (t, w), base_name = \"x\",\n                              lower_bound = 0)\nx(t, w)\n\njulia> lb = [0, 1]; ub = [10, 12];\n\njulia> @infinite_variable(model, lb[i] <= y[i = 1:2](t) <= ub[i], Int)\n2-element Array{GeneralVariableRef,1}:\n y[1](t)\n y[2](t)\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.@point_variable","page":"Variables","title":"InfiniteOpt.@point_variable","text":"@point_variable(model::InfiniteModel, kw_args...)::GeneralVariableRef\n\nAdd an anonymous point variable to the model model described by the keyword arguments kw_args and returns the variable reference. Note that the infinite_variable_ref and parameter_values keywords are required in this case.\n\n@point_variable(model::InfiniteModel, infvarexpr, varexpr, args...,\n                kw_args...)::GeneralVariableRef\n\nAdd a point variable to model described by the expression varexpr, the positional arguments args, and the keyword arguments kw_args and the infinite variable expr infvarexpr. The expression infvarexpr specifies the infinite variable this point variable corresponds to and the values at which the parameters are evaluated and must be of the form: infvar(param_values...) where the parameter values param_values... are listed in the same format as they are in the definition of infvar. The expression varexpr is used to define variable specific bounds and whose name is used as an alias for the point variable which is simply the infinite variable evaluated at the values indicated. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nNote that by default a point variable inherits all of the same properties as the infinite variable it corresponds to, but that these can be overwritten by specifying properties such as lower bounds, fix values, etc.\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of alias name varname\nvarname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\ninfinite_variable_ref: Sets the infinite variable reference that the point variable is associated with.\nparameter_values: Sets the values of the infinite parameters of the infinite variable at which this poitn variable is evaluated at. MUST be of the SAME FORMAT of that specified for the parameters in the definition of the infinite variable.\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes. This serves as the alias for infvarexpr (the infinite variable evaluated at particular parameter values).\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(model, 0 <= t <= 1)\nt\n\njulia> @infinite_parameter(model, w[1:2] in Normal())\n2-element Array{GeneralVariableRef,1}:\n w[1]\n w[2]\n\njulia> @infinite_variable(model, x(t, w) >= 0)\nx(t, w)\n\njulia> @point_variable(model, x(0, [0, 0]), x0 <= 1)\nx0\n\njulia> x0 = @point_variable(model, x(0, [0, 0]), upper_bound = 1, base_name = \"x0\")\nx0\n\njulia> x0 = @point_variable(model, upper_bound = 1, base_name = \"x0\",\n                            infinite_variable_ref = x, parameter_values = (0, [0, 0]))\nx0\n\njulia> @point_variable(model, x([0, 1][i], [0, 0]), xf[i = 1:2])\n2-element Array{GeneralVariableRef,1}:\n xf[1]\n xf[2]\n\njulia> lb = [0, 1]; ub = [10, 12];\n\njulia> @infinite_variable(model, lb[i] <= y[i = 1:2](t) <= ub[i], Int)\n2-element Array{GeneralVariableRef,1}:\n y[1](t)\n y[2](t)\n\njulia> @point_variable(model, y[i](0), y0[i = 1:2], Bin)\n2-element Array{GeneralVariableRef,1}:\n y0[1]\n y0[2]\n\njulia> y0 = @point_variable(model, [i = 1:2], binary = true, base_name = \"y0\",\n                             infinite_variable_ref = y[i], parameter_values = 0)\n2-element Array{GeneralVariableRef,1}:\n y0[1]\n y0[2]\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.@hold_variable","page":"Variables","title":"InfiniteOpt.@hold_variable","text":"@hold_variable(model::InfiniteModel, kw_args...)::GeneralVariableRef\n\nAdd an anonymous hold variable to the model model described by the keyword arguments kw_args and returns the variable reference.\n\n@hold_variable(model::InfiniteModel, varexpr, args...,\n               kw_args...)::GeneralVariableRef\n\nAdd a hold variable to model described by the expression varexpr, the positional arguments args and the keyword arguments kw_args. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of name varname\nvarname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nSpecifiying a hold variable which applies only to sub-domain of the model's infinite parameter(s) domain can be done via the parameter_bounds keyword argument. It is specified as a tuple of parameter bound expressions which can be of the form:\n\n(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.\n\nPlease note that when specifying value conditions on dependent infinite parameters, a value must be provided for each parameter in the dependent container otherwise an error will be thrown.\n\nThe other recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @hold_variable(model, x)\nx\n\njulia> @hold_variable(model, 0 <= y <= 4, Bin)\ny\n\njulia> y = @hold_variable(model, lower_bound = 0, upper_bound = 4,\n                            binary = true, base_name = \"y\")\ny\n\njulia> @hold_variable(model, z[2:3] == 0)\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, 2:3\nAnd data, a 2-element Array{GeneralVariableRef,1}:\n z[2]\n z[3]\n\njulia> @hold_variable(model, d, parameter_bounds = (t in [0, 5]))\nd\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#JuMP.build_variable-Tuple{Function,VariableInfo,Symbol}","page":"Variables","title":"JuMP.build_variable","text":"JuMP.build_variable(_error::Function, info::JuMP.VariableInfo,\n                    var_type::Symbol;\n                    [parameter_refs::Union{GeneralVariableRef,\n                                          AbstractArray{<:GeneralVariableRef},\n                                          Tuple, Nothing} = nothing,\n                    infinite_variable_ref::Union{GeneralVariableRef,\n                                                 Nothing} = nothing,\n                    parameter_values::Union{Number, AbstractArray{<:Real},\n                                            Tuple, Nothing} = nothing,\n                    parameter_bounds::Union{ParameterBounds{GeneralVariableRef},\n                                            Nothing} = nothing]\n                    )::InfOptVariable\n\nExtend the JuMP.build_variable function to accomodate InfiniteOpt variable types. Returns the appropriate variable Datatype (i.e., InfiniteVariable, PointVariable, and HoldVariable). Primarily, this method is to be used internally by the appropriate constructor macros @infinite_variable, @point_variable, and @hold_variable. However, it can be called manually to build InfiniteOpt variables. Errors if an unneeded keyword argument is given or if the keywoard arguments are formatted incorrectly (e.g., parameter_refs contains repeated parameter references when an infinite variable is defined). Also errors if needed keyword arguments are negated.\n\nExamples\n\njulia> @independent_parameter(m, t in [0, 1])\nt\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t)\nInfiniteVariable{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Function}(false, 0.0, false, 0.0, false, 0.0, false, start_func, false, false), (t,), Int64[], Int64[])\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5)\nPointVariable{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Float64}(false, 0.0, false, 0.0, false, 0.0, true, 0.0, false, false), var_name(t), [0.5])\n\njulia> hd_var = build_variable(error, info, Hold)\nHoldVariable{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Float64}(false, 0.0, false, 0.0, false, 0.0, false, 0.0, false, false), Subdomain bounds (0): )\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.add_variable-Tuple{InfiniteModel,InfOptVariable,String}","page":"Variables","title":"JuMP.add_variable","text":"JuMP.add_variable(model::InfiniteModel, var::InfOptVariable,\n                  [name::String = \"\"])::GeneralVariableRef\n\nExtend the JuMP.add_variable function to accomodate InfiniteOpt variable types. Adds a variable to an infinite model model and returns a GeneralVariableRef. Primarily intended to be an internal function of the constructor macros @infinite_variable, @point_variable, and @hold_variable. However, it can be used in combination with JuMP.build_variable to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in var.\n\nExamples\n\njulia> @infinite_parameter(m, t in [0, 10]);\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t);\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5);\n\njulia> pvref = add_variable(m, pt_var, \"var_alias\")\nvar_alias\n\njulia> hd_var = build_variable(error, info, Hold);\n\njulia> hvref = add_variable(m, hd_var, \"var_name\")\nvar_name\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_constraint-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(vref::DecisionVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_measure-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(vref::DecisionVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a measure.\n\nExample\n\njulia> used_by_measure(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_objective-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vref::DecisionVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by the objective.\n\nExample\n\njulia> used_by_objective(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.is_used-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::DecisionVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_point_variable-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_point_variable","text":"used_by_point_variable(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a point variable.\n\nExample\n\njulia> used_by_point_variable(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_reduced_variable-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_reduced_variable","text":"used_by_reduced_variable(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a reduced infinite variable.\n\nExample\n\njulia> used_by_reduced_variable(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.is_used-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete-Tuple{InfiniteModel,Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}","page":"Variables","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::DecisionVariableRef)::Nothing\n\nExtend JuMP.delete to delete InfiniteOpt variables and their dependencies. Errors if variable is invalid, meaning it has already been deleted or it belongs to another model.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z ≥ 0.0\n g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]\n g(0.5) = 0\n\njulia> delete(model, g)\n\njulia> print(model)\nMin measure(t) + z\nSubject to\n z ≥ 0.0\n z ≥ 42.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.num_variables-Tuple{InfiniteModel,Type{InfOptVariable}}","page":"Variables","title":"JuMP.num_variables","text":"JuMP.num_variables(model::InfiniteModel,\n                   [type::Type{InfOptVariable} = InfOptVariable])::Int\n\nExtend JuMP.num_variables to return the number of InfiniteOpt variables assigned to model. By default, the total number of infinite, reduced, point, and hold variables is returned. The amount of a particular type is obtained by specifying the concrete variable type of InfOptVariable via type. Type options include:\n\nInfOptVariable: all variables\nInfiniteVariable: all infinite variables\nReducedVariable: all reduced variables\nPointVariable: all point variables\nHoldVariable: all hold variables\n\nExample\n\njulia> num_variables(model)\n3\n\njulia> num_variables(model, InfiniteVariable)\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.all_variables-Tuple{InfiniteModel,Type{InfOptVariable}}","page":"Variables","title":"JuMP.all_variables","text":"JuMP.all_variables(model::InfiniteModel,\n                   type::Type{InfOptVariable} = InfOptVariable\n                   )::Vector{GeneralVariableRef}\n\nExtend JuMP.all_variables to return a list of all the variable references associated with model. By default, all of the infinite, reduced, point, and hold variables is returned. Those of a particular type is obtained by specifying the concrete variable type of InfOptVariable via type. Type options include:\n\nInfOptVariable: all variables\nInfiniteVariable: all infinite variables\nReducedVariable: all reduced variables\nPointVariable: all point variables\nHoldVariable: all hold variables\n\nExamples\n\njulia> all_variables(model)\n4-element Array{GeneralVariableRef,1}:\n y(t)\n w(t, x)\n y(0)\n z\n\njulia> all_variables(model, PointVariable)\n1-element Array{GeneralVariableRef,1}:\n y(0)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.name-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}","page":"Variables","title":"JuMP.name","text":"JuMP.name(vref::DecisionVariableRef)::String\n\nExtend JuMP.name to return the names of InfiniteOpt variables.\n\nExample\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_name-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef},String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing\n\nExtend JuMP.set_name to set names of decision variables.\n\nExample\n\njulia> set_name(vref, \"var_name\")\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.variable_by_name-Tuple{InfiniteModel,String}","page":"Variables","title":"JuMP.variable_by_name","text":"JuMP.variable_by_name(model::InfiniteModel,\n                      name::String)::Union{GeneralVariableRef, Nothing}\n\nExtend JuMP.variable_by_name for InfiniteModel objects. Return the variable reference assoociated with a variable name. Errors if multiple variables have the same name. Returns nothing if no such name exists.\n\nExamples\n\njulia> variable_by_name(m, \"var_name\")\nvar_name\n\njulia> variable_by_name(m, \"fake_name\")\n\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.has_lower_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::UserDecisionVariableRef)::Bool\n\nExtend JuMP.has_lower_bound to return a Bool whether an InfiniteOpt variable has a lower bound.\n\nExample\n\njulia> has_lower_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.lower_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::UserDecisionVariableRef)::Float64\n\nExtend JuMP.lower_bound to return the lower bound of an InfiniteOpt variable. Errors if vref doesn't have a lower bound.\n\nExample\n\njulia> lower_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_lower_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}","page":"Variables","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(vref::UserDecisionVariableRef, lower::Real)::Nothing\n\nExtend JuMP.set_lower_bound to specify the lower bound of an InfiniteOpt variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_lower_bound(vref, -1)\n\njulia> lower_bound(vref)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.LowerBoundRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::UserDecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.LowerBoundRef to extract a constraint reference for the lower bound of vref.\n\nExample\n\nvar ≥ 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete_lower_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.delete_lower_bound","text":"JuMP.delete_lower_bound(vref::UserDecisionVariableRef)::Nothing\n\nExtend JuMP.delete_lower_bound to delete lower bound of vref. Errors if it doesn't have a lower bound.\n\nExample\n\njulia> delete_lower_bound(vref)\n\njulia> has_lower_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.has_upper_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::UserDecisionVariableRef)::Bool\n\nExtend JuMP.has_upper_bound to return a Bool whether an InfiniteOpt variable has an upper bound.\n\nExample\n\njulia> has_upper_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.upper_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::UserDecisionVariableRef)::Float64\n\nExtend JuMP.upper_bound to return the upper bound of an InfiniteOpt variable. Errors if vref doesn't have a upper bound.\n\nExample\n\njulia> upper_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_upper_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}","page":"Variables","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(vref::UserDecisionVariableRef, upper::Real)::Nothing\n\nExtend JuMP.set_upper_bound to specify the upper bound of an InfiniteOpt variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_upper_bound(vref, 1)\n\njulia> upper_bound(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.UpperBoundRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::UserDecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.UpperBoundRef to extract a constraint reference for the upper bound of vref.\n\nExample\n\njulia> cref = UpperBoundRef(vref)\nvar ≤ 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete_upper_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.delete_upper_bound","text":"JuMP.delete_upper_bound(vref::UserDecisionVariableRef)::Nothing\n\nExtend JuMP.delete_upper_bound to delete the upper bound of vref. Errors if it doesn't have an upper bound.\n\nExample\n\njulia> delete_upper_bound(vref)\n\njulia> has_upper_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_fixed-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::UserDecisionVariableRef)::Bool\n\nExtend JuMP.is_fixed to return Bool whether an InfiniteOpt variable is fixed.\n\nExample\n\njulia> is_fixed(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.fix_value-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::UserDecisionVariableRef)::Float64\n\nExtend JuMP.fix_value to return the fix value of an InfiniteOpt variable. Errors if variable is not fixed.\n\nExample\n\njulia> fix_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.fix-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}","page":"Variables","title":"JuMP.fix","text":"JuMP.fix(vref::UserDecisionVariableRef, value::Real;\n         force::Bool = false)::Nothing\n\nExtend JuMP.fix to fix the value of an InfiniteOpt variable. Errors if variable has a lower and/or an upper bound(s) unless force = true.\n\nExamples\n\njulia> fix(vref, 3)\n\njulia> fix_value(vref)\n3.0\n\njulia> fix(vref2, 2, force = true)\n\njulia> fix_value(vref2)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.FixRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::UserDecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.FixRef to return the constraint reference of the fix constraint associated with vref. Errors vref is not fixed.\n\nExamples\n\njulia> cref = FixRef(vref)\nvar = 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unfix-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unfix","text":"JuMP.unfix(vref::UserDecisionVariableRef)::Nothing\n\nExtend JuMP.unfix to unfix vref. Errors if it is not fixed.\n\nExample\n\njulia> unfix(vref)\n\njulia> is_fixed(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.start_value-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.start_value","text":"JuMP.start_value(vref::UserDecisionVariableRef)::Union{Nothing, Float64}\n\nExtend JuMP.start_value to return starting value of InfiniteOpt variable if it has one. Returns nothing otherwise.\n\nExample\n\njulia> start_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_start_value-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}","page":"Variables","title":"JuMP.set_start_value","text":"JuMP.set_start_value(vref::UserDecisionVariableRef, value::Real)::Nothing\n\nExtend JuMP.set_start_value to specify the start value of InfiniteOpt variables.\n\nExample\n\njulia> set_start_value(vref, 1)\n\njulia> start_value(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.start_value_function-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.start_value_function","text":"start_value_function(vref::InfiniteVariableRef)::Union{Nothing, Function}\n\nReturn the function that is used to generate the start values of vref for particular support values. Returns nothing if no start behavior has been specified.\n\nExample\n\njulia> start_valuefunction(vref)\nmy_start_func\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.set_start_value_function-Tuple{InfiniteVariableRef,Union{Function, Real}}","page":"Variables","title":"InfiniteOpt.set_start_value_function","text":"set_start_value_function(vref::InfiniteVariableRef,\n                         start::Union{Real, Function})::Nothing\n\nSet the start value function of vref. If start::Real then a function is generated to such that the start value will be start for the entire infinite domain. If start::Function then this function should map to a scalar start value given a support value arguments matching the format of the parameter elements in parameter_refs(vref).\n\nExample\n\njulia> set_start_value_function(vref, 1) # all start values will be 1\n\njulia> set_start_value_function(vref, my_func) # each value will be made via my_func\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.reset_start_value_function-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.reset_start_value_function","text":"reset_start_value_function(vref::InfiniteVariableRef)::Nothing\n\nRemove the existing start value function and return to the default. Generally, this is triggered by deleting an infinite parameter that vref depends on.\n\nExample\n\njulia> reset_start_value_function(vref)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_binary-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::UserDecisionVariableRef)::Bool\n\nExtend JuMP.is_binary to return Bool whether an InfiniteOpt variable is binary.\n\nExample\n\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_binary-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.set_binary","text":"JuMP.set_binary(vref::UserDecisionVariableRef)::Nothing\n\nExtend JuMP.set_binary to specify an InfiniteOpt variable as a binary variable. Errors if vref is an integer variable.\n\nExample\n\njulia> set_binary(vref)\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.BinaryRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::UserDecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.BinaryRef to return a constraint reference to the constraint constrainting vref to be binary. Errors if one does not exist.\n\nExample\n\njulia> cref = BinaryRef(vref)\nvar binary\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unset_binary-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unset_binary","text":"JuMP.unset_binary(vref::UserDecisionVariableRef)::Nothing\n\nExtend JuMP.unset_binary to unset vref as a binary variable. Errors if it is not binary.\n\njulia> unset_binary(vref)\n\njulia> is_binary(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_integer-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::UserDecisionVariableRef)::Bool\n\nExtend JuMP.is_integer to return Bool whether an InfiniteOpt variable is integer.\n\nExample\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_integer-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.set_integer","text":"JuMP.set_integer(vref::UserDecisionVariableRef)::Nothing\n\nExtend JuMP.set_integer to specify an InfiniteOpt variable as a integer variable. Errors if vref is an binary variable.\n\nExample\n\njulia> set_integer(vref)\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.IntegerRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::UserDecisionVariableRef)::InfOptConstraintRef\n\nExtend JuMP.IntegerRef to return a constraint reference to the constraint constrainting vref to be integer. Errors if one does not exist.\n\nExample\n\njulia> cref = IntegerRef(vref)\nvar integer\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unset_integer-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unset_integer","text":"JuMP.unset_integer(vref::UserDecisionVariableRef)::Nothing\n\nExtend JuMP.unset_integer to unset vref as an integer variable. Errors if it is not an integer variable.\n\njulia> unset_integer(vref)\n\njulia> is_integer(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::InfiniteVariableRef)::Tuple\n\nReturn the parameter references associated with the infinite variable vref. This is formatted as a Tuple of containing the parameter references as they inputted to define vref.\n\nExample\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> parameter_refs(T)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_list-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_list","text":"parameter_list(vref::InfiniteVariableRef)::Vector{GeneralVariableRef}\n\nReturn a vector of the parameter references that vref depends on. This is primarily an internal method where parameter_refs is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.raw_parameter_refs-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.raw_parameter_refs","text":"raw_parameter_refs(vref::InfiniteVariableRef)::VectorTuple{GeneralVariableRef}\n\nReturn the raw VectorTuple of the parameter references that vref depends on. This is primarily an internal method where parameter_refs is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.@set_parameter_bounds","page":"Variables","title":"InfiniteOpt.@set_parameter_bounds","text":"@set_parameter_bounds(ref, bound_expr; [force::Bool = false])::Nothing\n\nSpecify new parameter bounds for a constraint reference or hold variable reference ref. These bounds correspond to bounding a constraint in an equivalent way to using @BDconstraint or to limiting the scope of a hold variable in an equivalent way to using the parameter_bounds keyword argument in @hold_variable. Here (bound_expr) can be of the form:\n\n(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.\n\nPlease note that when specifying value conditions on dependent infinite parameters, a value must be provided for each parameter in the dependent container otherwise an error will be thrown.\n\nErrors if the constraint or variable corresponding to ref already has bounds. However, using force = true can be used ignore the current bounds and overwrite them with new ones. Also, note that bounds on dependent constraints of hold variables will be updated to account for changes in hold variable bounds.\n\nExamples\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_variable(model, x(t))\nx(t)\n\njulia> @hold_variable(model, y)\ny\n\njulia> @constraint(model, con, x + y == 0)\ncon : x(t) + y = 0.0, ∀ t ∈ [0, 10]\n\njulia> @set_parameter_bounds(y, t in [0, 5])\n\njulia> con\ncon : x(t) + y = 0.0, ∀ t ∈ [0, 5]\n\njulia> @set_parameter_bounds(con, t == 0, force = true)\n\njulia> con\ncon : x(t) + y = 0.0, ∀ t = 0\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.@add_parameter_bounds","page":"Variables","title":"InfiniteOpt.@add_parameter_bounds","text":"@add_parameter_bounds(ref, bound_expr)::Nothing\n\nAdd new parameter bounds for a constraint reference or hold variable reference ref. These bounds correspond to bounding a constraint in an equivalent way to using @BDconstraint or to limiting the scope of a hold variable in an equivalent way to using the parameter_bounds keyword argument in @hold_variable. Here (bound_expr) can be of the form:\n\n(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.\n\nPlease note that when specifying value conditions on dependent infinite parameters, a value must be provided for each parameter in the dependent container otherwise an error will be thrown.\n\nErrors if the new bounds cause irreconcilable differences with existing measures and constraints. For example, this occurs when adding hold variable bounds that are outside the domain of a bounded constraint that uses that hold variable. Also, note that bounds on dependent constraints of hold variables will be updated to account for changes in hold variable bounds.\n\nExamples\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_parameter(model, q in [-2, 2])\nq\n\njulia> @infinite_variable(model, x(t, q))\nx(t, q)\n\njulia> @hold_variable(model, y)\ny\n\njulia> @constraint(model, con, x + y == 0)\ncon : x(t, q) + y = 0.0, ∀ t ∈ [0, 10], q ∈ [-2, 2]\n\njulia> @add_parameter_bounds(y, t in [0, 5])\n\njulia> con\ncon : x(t, q) + y = 0.0, ∀ t ∈ [0, 5]\n\njulia> @add_parameter_bounds(con, q == 0)\n\njulia> con\ncon : x(t, q) + y = 0.0, ∀ t ∈ [0, 5], q = 0\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.has_parameter_bounds-Tuple{HoldVariableRef}","page":"Variables","title":"InfiniteOpt.has_parameter_bounds","text":"has_parameter_bounds(vref::HoldVariableRef)::Bool\n\nReturn a Bool indicating if vref is limited to a sub-domain as defined by parameter bound.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @hold_variable(model, vref, parameter_bounds = (t in [0, 2]))\nvref\n\njulia> has_parameter_bounds(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_bounds-Tuple{HoldVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_bounds","text":"parameter_bounds(vref::HoldVariableRef)::ParameterBounds\n\nReturn the ParameterBounds object associated with the hold variable vref. It contains a dictionary where each key is a parameter reference which points to an IntervalSet that that defines a sub-domain for vref relative to that parameter reference.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @hold_variable(model, vref, parameter_bounds = (t in [0, 2]))\nvref\n\njulia> parameter_bounds(vref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.set_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds{GeneralVariableRef}}","page":"Variables","title":"InfiniteOpt.set_parameter_bounds","text":"set_parameter_bounds(vref::HoldVariableRef,\n                     bounds::ParameterBounds{GeneralVariableRef};\n                     [force::Bool = false])::Nothing\n\nSpecify a new dictionary of parameter bounds bounds for the hold variable vref. These are stored in a ParameterBounds object which contains a dictionary. Note the dictionary keys must be infinite parameter references and the values must be IntervalSets that indicate a particular sub-domain for which vref is defined. This is meant to be primarily used by @set_parameter_bounds which provides a more intuitive syntax.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @hold_variable(model, vref)\nvref\n\njulia> set_parameter_bounds(vref, ParameterBounds(Dict(t => IntervalSet(0, 2))))\n\njulia> parameter_bounds(vref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.add_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds{GeneralVariableRef}}","page":"Variables","title":"InfiniteOpt.add_parameter_bounds","text":"add_parameter_bounds(vref::HoldVariableRef,\n                     new_bounds::ParameterBounds{GeneralVariableRef}\n                     )::Nothing\n\nAdd additional parameter bounds to vref such that it is defined over the sub-domain based on the intersection of the existing bounds and new_bounds. This is primarily meant to be used by @add_parameter_bounds.\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @hold_variable(model, vref)\nvref\n\njulia> add_parameter_bounds(vref, ParameterBounds(t => IntervalSet(0, 2)))\n\njulia> parameter_bounds(vref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.delete_parameter_bounds-Tuple{HoldVariableRef}","page":"Variables","title":"InfiniteOpt.delete_parameter_bounds","text":"delete_parameter_bounds(vref::HoldVariableRef)::Nothing\n\nDelete all the parameter bounds of the hold variable vref. Any constraints that employ vref will be updated accordingly.\n\nExample\n\njulia> @infinite_parameter(model, x[1:2] in [0, 10])\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]\n\njulia> @hold_variable(model, z, parameter_bounds = (x in [0, 1]))\nz\n\njulia> delete_parameter_bounds(z)\n\njulia> parameter_bounds(z)\nSubdomain bounds (0):\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::PointVariableRef)::GeneralVariableRef\n\nReturn the InfiniteVariableRef associated with the point variable vref.\n\nExample\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> vref = @point_variable(model, T(0))\nT(0)\n\njulia> infinite_variable_ref(vref)\nT(t)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_values-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_values","text":"parameter_values(vref::PointVariableRef)::Tuple\n\nReturn the support point associated with the point variable vref.\n\nExample\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> vref = @point_variable(model, T(0))\nT(0)\n\njulia> parameter_values(vref)\n(0,)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.raw_parameter_values-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.raw_parameter_values","text":"raw_parameter_values(vref::PointVariableRef)::Vector{Float64}\n\nReturn the raw support point values associated with the point variable vref.\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.relax_integrality-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.relax_integrality","text":"JuMP.relax_integrality(model::InfiniteModel)::Function\n\nModifies model to \"relax\" all binary and integrality constraints on variables. Specifically,\n\nBinary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval 0 1.\nIntegrality constraints are deleted without modifying variable bounds.\nAll other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.\n\nReturns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.\n\nExample\n\njulia> undo_relax = relax_integrality(model);\n\njulia> print(model)\nMin x + integral{t ∈ [0, 10]}(y(t))\nSubject to\n x ≥ 0.0\n y(t) ≥ 1.0\n x ≤ 1.0\n y(t) ≤ 10.0\n\njulia> undo_relax()\n\njulia> print(model)\nMin x + integral{t ∈ [0, 10]}(y(t))\nSubject to\n y(t) ≥ 1.0\n y(t) ≤ 10.0\n y(t) integer\n x binary\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#constr_page","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"A guide and manual for defining and manipulating constraints in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.","category":"page"},{"location":"guide/constraint/#Overview","page":"Constraints","title":"Overview","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Constraints are an integral part of infinite dimensional problems and serve as a fundamental utility of InfiniteOpt. In particular, InfiniteOpt supports finite constraints that entail finite variables and/or measures that fully any infinite parameter dependencies (e.g., first stage constraints), infinite constraints that are enforced over the entire domain of its infinite parameter dependencies (e.g., path constraints), and bounded infinite constraints which are enforced over some specified sub-domain of its infinite parameter dependencies (e.g., initial conditions). This page will highlight how to implement these types of constraints in InfiniteOpt.","category":"page"},{"location":"guide/constraint/#Basic-Usage","page":"Constraints","title":"Basic Usage","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Principally, the @constraint and @BDconstraint macros should be employed to specify constraints. Here @constraint is used to specify typical finite and infinite constraints and @BDconstraint is used to specify bounded constraints (i.e., infinite constraints with a constrained sub-domain of its full infinite sub-domain). First, let's setup an infinite model with variables that we can add constraints to:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @infinite_parameter(model, x[1:2] in Normal());\n\njulia> @infinite_variable(model, T(t, x));\n\njulia> @infinite_variable(model, g(t));\n\njulia> @hold_variable(model, z[1:2]);\n\njulia> @hold_variable(model, w, parameter_bounds = (t in [0, 5]));","category":"page"},{"location":"guide/constraint/#Unbounded-Constraints","page":"Constraints","title":"Unbounded Constraints","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Unbounded constraints don't entail user-defined curtailing of dependent infinite parameter domains and are defined using @constraint. This is done following typical JuMP syntax. Anonymous constraints (constraints without associated register names) are defined via 2 arguments where the first is the infinite model and the second is the constraint expression. For example, let's define the constraint 2T(t x) + z^2 leq 0:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> cref = @constraint(model, 2T + sum(z[i]^2 for i = 1:2) <= 0)\nz[1]² + z[2]² + 2 T(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ~ Normal, x[2] ~ Normal","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we added an infinite constraint (which infinite with respect to t and x) to model and stored the corresponding constraint reference to cref. The allowed constraint operators are ==, <=, ≤, >=, and ≥.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nCurrently, InfiniteOpt only supports scalar constraint expressions. Other types such as vector constraints are not currently extended.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Similarly, we can define an array of constraints with varied indexes by including an additional argument before the constraint expression. For example, let's define 3zi - 14 == 0 forall i in 12:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> crefs = @constraint(model, [i = 1:2], 3z[i] - 14 == 0)\n2-element Array{InfOptConstraintRef{ScalarShape},1}:\n 3 z[1] = 14.0\n 3 z[2] = 14.0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we added two constraints to model and stored a vector of the corresponding constraint references to the Julia variable crefs.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Named constraints are defined by including a name as part of the second argument. For example, let's add the constraint int_0^10 g(t) dt == 4:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, measure_constr, integral(g, t) == 4)\nmeasure_constr : integral{t ∈ [0, 10]}[g(t)] = 4.0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we added another constraint named measure_constr and created a Julia variable measure_constr that contains a reference to that constraint.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nLinear algebra constraints can also be used when defining constraints when . is added in front of the constraint operators (e.g., .<=). This behavior is further explained in JuMP's documentation here. However, note that that vector array sets such as MOI.Nonnegatives are not currently supported.","category":"page"},{"location":"guide/constraint/#Bounded-Constraints","page":"Constraints","title":"Bounded Constraints","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Bounded constraints denote constraints with a particular sub-domain of an infinite domain. Such constraints might pertain to point constraints evaluated at a particular infinite parameter values, constraints limited to a certain range of infinite parameter values, and/or entail bounded hold variables whose sub-domains are also taken into consideration. These types of constraints are defined using @BDconstraint. For example, let's add the initial condition g(0) == 0:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @BDconstraint(model, initial(t == 0), g == 0)\ninitial : g(t) = 0.0, ∀ t = 0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we have added a constraint to model defined over the sub-domain t = 0 in accordance with the initial condition. This is referred to as a bounded constraint named initial where a Julia variable initial has been defined to store a reference to that constraint.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"More complex sub-domains can be specified by simply adding more conditions in the second argument. To illustrate this, let's define an anonymous constraint for 2T^2(t x) + w geq 3  forall t = 0  x in -1 1^2:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> cref = @BDconstraint(model, (t == 0, x in [-1, 1]), 2T^2 + w >= 3)\n2 T(t, x)² + w ≥ 3.0, ∀ t = 0, x[1] ~ Normal ∩ [-1, 1], x[2] ~ Normal ∩ [-1, 1]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"where cref contains the corresponding constraint reference.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Now we have added constraints to our model and it is ready to be transcribed!","category":"page"},{"location":"guide/constraint/#Data-Structure","page":"Constraints","title":"Data Structure","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Here we detail the data structures used to store constraints in InfiniteOpt. In general, constraints in JuMP are of the form: [function] in [set] where function corresponds to a JuMP expression and set corresponds to a MOI set. Since InfiniteOpt only supports scalar constraints currently, expressions must be inherited from JuMP.AbstractJuMPScalar and the supported MOI sets are MOI.EqualTo, MOI.LessThan, MOI.GreaterThan, MOI.Integer, and MOI.ZeroOne. Where the last 2 are intended for single variable constraints.  ","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Furthermore, constraints in the form mentioned above are stored in appropriate constraint object inherited from JuMP.AbstractConstraint. Typical scalar constraints use JuMP.ScalarConstraint which has the fields:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"func::JuMP.AbstractJuMPScalar The constraint expression\nset::MOI.AbstractScalarSet The MOI set.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Similarly, bounded constraints are stored in BoundedScalarConstraint which has bounds and orig_bounds fields in addition to func and set. These additional fields store the current constraint bounds and the bounds originally given, respectively. This distinction is needed to facilitate deletion methods such as deleting a bounded hold variable.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"These constraint objects are what store constraints in InfiniteModels. And these are referred to by an InfOptConstraintRef.","category":"page"},{"location":"guide/constraint/#Definition","page":"Constraints","title":"Definition","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"In this section, we describe the ins and outs of defining constraints. Note that this process is analogous to the manner in which variables are defined and added to the model.","category":"page"},{"location":"guide/constraint/#Manual-Definition","page":"Constraints","title":"Manual Definition","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"The @constraint and @BDconstraint both follow a similar methodology behind the scenes and these commonalities are discussed in this section for conciseness. Defining/initializing a constraint principally involves the following steps:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Define the constraint information (i.e., function, set, and parameter bounds)\nConstruct a concrete subtype of JuMP.AbstractConstraint to store the constraint information\nAdd the AbstractConstraint object to an InfiniteModel and assign a name\nCreate an InfOptConstraintRef that points to the constraint object stored in the model.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"The constraint objects are specified via JuMP.build_constraint which requires that the user provides a JuMP.AbstractJuMPScalar, a MOI.AbstractScalarSet, and any keyword arguments such as ParameterBound. For example, let's build a scalar constraint for 3T(t x) - g^2(t) leq 0:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> constr = build_constraint(error, 3T - g^2, MOI.LessThan(0.0))\nScalarConstraint{GenericQuadExpr{Float64,GeneralVariableRef},MathOptInterface.LessThan{Float64}}(-g(t)² + 3 T(t, x), MathOptInterface.LessThan{Float64}(0.0))","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Now the built constraint object can be added to the infinite model via add_constraint. Let's do so with our example and assign it the name of c1 (note that adding a name is optional):","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> cref = add_constraint(model, constr, \"c1\")\nc1 : -g(t)² + 3 T(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ~ Normal, x[2] ~ Normal","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Thus, we have made our constraint and added it model and now have a constraint reference cref that we can use to access it.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"The @constraint and @BDconstraint automate the above steps where @BDconstraint is specifically used to implement the parameter_bounds keyword argument in build_constraint.","category":"page"},{"location":"guide/constraint/#Macro-Definition","page":"Constraints","title":"Macro Definition","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"As mentioned above in the Basic Usage section, the @constraint macro should be used for defining all constraints that do not entail specified parameter bounds. In general, the syntax follows the form @constraint([InfiniteModel], [name][indexing expr], [scalar constr expr]). The second argument is optional and is used to assign a name and/or define indexing variables to be used in the constraint expr. When a name is provided it is registered and cannot be used again for another constraint or variable name. The indexing expression can be used to produce an array of constraints as shown below (notice this is equivalent to looping over individual @constraint calls):","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> crefs = @constraint(model, [i = 1:2], 2z[i] - g == 0)\n2-element Array{InfOptConstraintRef{ScalarShape},1}:\n 2 z[1] - g(t) = 0.0, ∀ t ∈ [0, 10]\n 2 z[2] - g(t) = 0.0, ∀ t ∈ [0, 10]\n\njulia> crefs = Vector{InfOptConstraintRef{ScalarShape}}(undef, 2);\n\njulia> for i = 1:2\n           crefs[i] = @constraint(model, 2z[i] - g == 0)\n       end\n\njulia> crefs\n2-element Array{InfOptConstraintRef{ScalarShape},1}:\n 2 z[1] - g(t) = 0.0, ∀ t ∈ [0, 10]\n 2 z[2] - g(t) = 0.0, ∀ t ∈ [0, 10]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Again, please note that only scalar constraints are currently supported and thus the [scalar constr expr] must be scalar.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"An interesting corollary is that @constraint in certain cases will produce bound constraints even if the user doesn't specify any parameter bounds. This, occurs when a bounded hold variable is included. For example, if we want to make the constraint g(t) + 25w leg 2 it would only be valid over the sub-domain t in 0 5 subsetneq 0 10 due to the restrictions on w. Thus, @constraint automatically takes this into account and produces a bounded constraint:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, bounded_example, g + 2.5w <= 2)\nbounded_example : g(t) + 2.5 w ≤ 2.0, ∀ t ∈ [0, 5]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"If this behavior is not desired, the parameter bounds associated with the variable should be deleted and then should be managed individually for each constraint.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"The @BDconstraint is very similar except that it adds the capability of symbolically specifying parameter bounds. Thus the syntax is of the form @BDconstraint([InfiniteModel], [name][indexing expr](bound expr), [scalar constr expr]). Note that here the name and [indexing expr] are optional, but the (param bounds) tuple is required. Thus, three arguments must always be given. The (bound expr) can be of the form:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Please refer to the Basic Usage section and the manual for examples.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Finally, the @constraint and @BDconstraint macros allow the user to specify the container keyword argument when defining an array of constraints. For example, we can force a group of bounded constraint references to be stored in a JuMP.SparseAxisArray:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @BDconstraint(model, [i = 1:2](x[i] in [0, 1]), T^2 + z[i] <= 1,\n                     container = SparseAxisArray)\nJuMP.Containers.SparseAxisArray{InfOptConstraintRef{ScalarShape},1,Tuple{Int64}} with 2 entries:\n  [2]  =  T(t, x)² + z[2] ≤ 1.0, ∀ t ∈ [0, 10], x[1] ~ Normal, x[2] ~ Normal ∩ [0, 1] \n  [1]  =  T(t, x)² + z[1] ≤ 1.0, ∀ t ∈ [0, 10], x[1] ~ Normal ∩ [0, 1], x[2] ~ Normal","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"For more information on JuMP containers please visit their page here.","category":"page"},{"location":"guide/constraint/#Queries","page":"Constraints","title":"Queries","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"In this section, we describe a variety of methods to extract constraint information.","category":"page"},{"location":"guide/constraint/#Basic","page":"Constraints","title":"Basic","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"A number of constraint properties can be extracted via constraint references. Principally, the validity, name, model, index, and constraint object can be queried via is_valid, name, owner_model, index, and constraint_object, respectively. These methods all constitute extensions of JuMP methods and follow exactly the same behavior. Let's try them out with the following example:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> is_valid(model, measure_constr) # check if contained in model\ntrue\n\njulia> name(measure_constr) # get the name\n\"measure_constr\"\n\njulia> m = owner_model(measure_constr); # get the model it is added to\n\njulia> index(measure_constr) # get the constraint's index\nConstraintIndex(4)\n\njulia> constraint_object(measure_constr) # get the raw constraint datatype\nScalarConstraint{GenericAffExpr{Float64,GeneralVariableRef},MathOptInterface.EqualTo{Float64}}(integral{t ∈ [0, 10]}[g(t)], MathOptInterface.EqualTo{Float64}(4.0))","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Also, constraint_by_name can be used to retrieve a constraint reference if only the name is known and its name is unique. For example, let's extract the reference for \"c1\":","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> cref = constraint_by_name(model, \"c1\")\nc1 : -g(t)² + 3 T(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ~ Normal, x[2] ~ Normal","category":"page"},{"location":"guide/constraint/#Parameter-Bounds","page":"Constraints","title":"Parameter Bounds","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"As explained above, bounded constraints serve as an integral capability of InfiniteOpt. Information about parameter bounds can be obtained via has_parameter_bounds and parameter_bounds which indicate if a constraint is bounded and what its ParameterBounds are, respectively. These are exemplified below:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> has_parameter_bounds(measure_constr) # check if constraint is bounded\nfalse\n\njulia> has_parameter_bounds(initial)\ntrue\n\njulia> parameter_bounds(initial)\nSubdomain bounds (1): t = 0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Note that parameter_bounds will error if the constraint is not bounded.","category":"page"},{"location":"guide/constraint/#General","page":"Constraints","title":"General","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Constraints can be defined in a number of ways symbolically that differ from how it is actually stored in the model. This principally occurs since like terms and constants are combined together where possible with the variable terms on the left hand side and the constant on the right hand side. For instance, the constraint 2g(t) + 3g(t) - 2 leq 1 + z_1 would be normalized 5g(t) - z_1 leq 3. In accordance with this behavior normalized_rhs and normalized_coefficient can be used to query the normalized right hand side and the coefficient of a particular variable reference, respectively. Let's employ the above example to illustrate this:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, constr, 2g + 3g - 2 <= 1 + z[1])\nconstr : 5 g(t) - z[1] ≤ 3.0, ∀ t ∈ [0, 10]\n\njulia> normalized_rhs(constr)\n3.0\n\njulia> normalized_coefficient(constr, g)\n5.0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"There also exist a number of methods for querying an infinite model about what constraints it contains. list_of_constraint_types can be used query what types of constraints have been added to a model. This is provided as a list of tuples where the first element is the expression type and the second element is the set type (recall that constraints are stored in the form func-in-set). Thus, for our current model we obtain:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> list_of_constraint_types(model)\n4-element Array{Tuple{DataType,DataType},1}:\n (GenericQuadExpr{Float64,GeneralVariableRef}, MathOptInterface.LessThan{Float64})\n (GenericQuadExpr{Float64,GeneralVariableRef}, MathOptInterface.GreaterThan{Float64})\n (GenericAffExpr{Float64,GeneralVariableRef}, MathOptInterface.LessThan{Float64})\n (GenericAffExpr{Float64,GeneralVariableRef}, MathOptInterface.EqualTo{Float64})","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"This information is useful when in combination with the num_constraints and all_constraints methods which can take the expression type and/or the set type as inputs. Here num_constraints provides the number of constraints that match a certain type  and all_constraints returns a list of constraint references matching the criteria provided. These  have been extended beyond JuMP functionality such additional methods have been provided for the cases in which one wants to query solely off of set or off expression type. Let's illustrate this with num_constraints:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> num_constraints(model) # total number of constraints\n15\n\njulia> num_constraints(model, GenericQuadExpr{Float64,GeneralVariableRef})\n5\n\njulia> num_constraints(model, MathOptInterface.LessThan{Float64})\n6\n\njulia> num_constraints(model, GenericQuadExpr{Float64,GeneralVariableRef},\n                       MathOptInterface.LessThan{Float64})\n4                   ","category":"page"},{"location":"guide/constraint/#Modification","page":"Constraints","title":"Modification","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"In this section, we highlight a number of methods that can be used to modify existing constraints.","category":"page"},{"location":"guide/constraint/#Deletion","page":"Constraints","title":"Deletion","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"All constraints in InfiniteOpt can be removed in like manner to typical JuMP constraints with the appropriate extension of delete. This will remove the corresponding constraint object from the model. However, please note any registered names will remain registered in the infinite model. This means that a constraint with a registered name cannot be repeatedly added and removed using the same name. To exemplify this, let's delete the constraint c1:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> cref = constraint_by_name(model, \"c1\")\nc1 : -g(t)² + 3 T(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ~ Normal, x[2] ~ Normal\n\njulia> delete(model, cref)","category":"page"},{"location":"guide/constraint/#General-2","page":"Constraints","title":"General","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"There also are a number of ways to modify information and characteristics of constraints. First, set_name can be used to specify a new name for a particular constraint. For instance, let's update the name of initial to \"init_cond\":","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> set_name(initial, \"init_cond\")\n\njulia> initial\ninit_cond : g(t) = 0.0, ∀ t = 0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"We can also update the normalized right hand side constant value or normalized left hand side variable coefficient value using set_normalized_rhs and set_normalized_coefficient , respectively. Let's again consider the constraint 5g(t) - z_1 leq 3 as an example. Let's change the constant term to -1 and the g(t) coefficient to 2.5:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> set_normalized_rhs(constr, -1)\n\njulia> set_normalized_coefficient(constr, g, 2.5)\n\njulia> constr\nconstr : 2.5 g(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 10]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nIn some cases, it may be more convenient to dynamically modify coefficients and other values via the use of finite parameters. This provides an avenue to update parameters without having to be concerned about the normalized form. For more information, see the Finite Parameters page.","category":"page"},{"location":"guide/constraint/#Parameter-Bounds-2","page":"Constraints","title":"Parameter Bounds","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Parameter bounds can be added to, modified, or removed from any constraint in InfiniteOpt. Principally, this is accomplished via @add_parameter_bounds, @set_parameter_bounds, and delete_parameter_bounds in like manner to hold variables.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"First, parameter bounds can be added to a constraint in an intuitive symbolic syntax via @add_parameter_bounds which follows form @add_parameter_bounds(ref, bound_expr) where (bound_expr) can be of the form:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"For example, let's add the bound t in 0 1 to constr:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @add_parameter_bounds(constr, (t in [0, 1]))\n\njulia> constr\nconstr : 2.5 g(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 1]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"In similar manner, @set_parameter_bounds can be employed to specify what bounds a constraint has (overwriting any existing ones if forced). It follows the same syntax, so let's use it to change the bounds on t to t = 0:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> @set_parameter_bounds(constr, (t == 0), force = true)\n\njulia> constr\nconstr : 2.5 g(t) - z[1] ≤ -1.0, ∀ t = 0","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"note: Note\nConstraint parameters bounds are intersected with those of any hold variables that are part of the constraint. If no such intersection exists then an error is thrown.","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Finally, constraint bounds can be deleted via delete_parameter_bounds which deletes all parameter bounds. Again, note the parameter bounds associated with hold variables will be unaffected and can only be removed by deleting them from the variables directly. Now let's delete the parameter bounds associated with our example:","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"julia> delete_parameter_bounds(constr)\n\njulia> constr\nconstr : 2.5 g(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 10]","category":"page"},{"location":"guide/constraint/#Datatypes","page":"Constraints","title":"Datatypes","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Pages   = [\"constraint.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"BoundedScalarConstraint\nConstraintData\nConstraintIndex\nInfOptConstraintRef","category":"page"},{"location":"guide/constraint/#InfiniteOpt.BoundedScalarConstraint","page":"Constraints","title":"InfiniteOpt.BoundedScalarConstraint","text":"BoundedScalarConstraint{F <: JuMP.AbstractJuMPScalar,\n                        S <: MOI.AbstractScalarSet,\n                        P <: GeneralVariableRef\n                        } <: JuMP.AbstractConstraint\n\nA DataType that stores scalar constraints that are defined over a sub-domain of infinite parameters.\n\nFields\n\nfunc::F The JuMP object.\nset::S The MOI set.\nbounds::ParameterBounds{P} Set of valid parameter   sub-domains that further boundconstraint.\norig_bounds::ParameterBounds{P} Set of the constraint's   original parameter sub-domains (not considering hold variables)\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#InfiniteOpt.ConstraintData","page":"Constraints","title":"InfiniteOpt.ConstraintData","text":"ConstraintData <: AbstractDataObject\n\nA mutable DataType for storing constraints and their data.\n\nFields\n\nconstraint::JuMP.AbstractConstraint: The scalar constraint.\nobject_nums::Vector{Int}: The object numbers of the parameter objects that the                             constraint depends on.\nname::String: The name used for printing.\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nis_info_constraint::Bool: Is this is constraint based on variable info (e.g., lower bound)\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#InfiniteOpt.ConstraintIndex","page":"Constraints","title":"InfiniteOpt.ConstraintIndex","text":"ConstraintIndex <: ObjectIndex\n\nA DataType for storing the index of constraint objects.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#InfiniteOpt.InfOptConstraintRef","page":"Constraints","title":"InfiniteOpt.InfOptConstraintRef","text":"InfOptConstraintRef{S <: JuMP.AbstractShape}\n\nA DataType for constraints that are in InfiniteModels\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::ConstraintIndex: Index of the constraint in model.\nshape::JuMP.AbstractShape: Shape of the constraint\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#Methods/Macros","page":"Constraints","title":"Methods/Macros","text":"","category":"section"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"Pages   = [\"constraint.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/constraint/","page":"Constraints","title":"Constraints","text":"@BDconstraint\nJuMP.build_constraint(::Function, ::Union{JuMP.GenericAffExpr{Any, <:GeneralVariableRef}, JuMP.GenericQuadExpr{Any, <:GeneralVariableRef}}, ::MOI.AbstractScalarSet)\nJuMP.add_constraint(::InfiniteModel, ::JuMP.AbstractConstraint, ::String)\nJuMP.owner_model(::InfOptConstraintRef)\nJuMP.index(::InfOptConstraintRef)\nJuMP.constraint_object(::InfOptConstraintRef)\nJuMP.name(::InfOptConstraintRef)\nJuMP.set_name(::InfOptConstraintRef, ::String)\nJuMP.is_valid(::InfiniteModel, ::InfOptConstraintRef)\nJuMP.delete(::InfiniteModel, ::InfOptConstraintRef)\nparameter_refs(::InfOptConstraintRef)\nhas_parameter_bounds(::InfOptConstraintRef)\nparameter_bounds(::InfOptConstraintRef)\nset_parameter_bounds(::InfOptConstraintRef, ::ParameterBounds{GeneralVariableRef})\nadd_parameter_bounds(::InfOptConstraintRef, ::ParameterBounds{GeneralVariableRef})\ndelete_parameter_bounds(::InfOptConstraintRef)\nJuMP.set_normalized_rhs(::InfOptConstraintRef, ::Real)\nJuMP.normalized_rhs(::InfOptConstraintRef)\nJuMP.add_to_function_constant(::InfOptConstraintRef, ::Real)\nJuMP.set_normalized_coefficient(::InfOptConstraintRef, ::GeneralVariableRef, ::Real)\nJuMP.normalized_coefficient(::InfOptConstraintRef, ::GeneralVariableRef)\nJuMP.constraint_by_name(::InfiniteModel, ::String)\nJuMP.list_of_constraint_types(::InfiniteModel)\nJuMP.num_constraints(::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar}, ::Type{<:MOI.AbstractSet})\nJuMP.num_constraints(::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar})\nJuMP.num_constraints(::InfiniteModel, ::Type{<:MOI.AbstractSet})\nJuMP.num_constraints(::InfiniteModel)\nJuMP.all_constraints(::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar}, ::Type{<:MOI.AbstractSet})\nJuMP.all_constraints(::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar})\nJuMP.all_constraints(::InfiniteModel, ::Type{<:MOI.AbstractSet})\nJuMP.all_constraints(::InfiniteModel)","category":"page"},{"location":"guide/constraint/#InfiniteOpt.@BDconstraint","page":"Constraints","title":"InfiniteOpt.@BDconstraint","text":"@BDconstraint(model::InfiniteModel, [i = ..., ...](bound_expr), constr_expr;\n              [kw_args...])::InfOptConstraintRef\n\nAdd an anonymous bounded constraint to model and return an appropriate container of constraint reference(s).\n\n    @BDconstraint(model::InfiniteModel, name[i = ..., ...](bound_expr),\n                  constr_expr; [kw_args...])::InfOptConstraintRef\n\nAdd a named bounded constraint to model and return an appropriate container of constraint reference(s). This defines the constraint as expressed in constr_expr over some sub-domain of parameters as indicated by bound_expr. The format of constr_expr must follow the same syntax as that specified in JuMP.@constraint. For example, if we want to express the constraint 2T(t, x) + 3y = 42, the constraint expression constr_expr would be 2 * T + 3 * y == 42.\n\nBy default, JuMP.@constraint would express the above example constraint over the whole domain of t and x. However, we can use @BDconstraint to express this constraint over some sub-domain(s) via bound_expr. Here (bound_expr) can be of the form:\n\n(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.\n\nPlease note that when specifying value conditions on dependent infinite parameters, a value must be provided for each parameter in the dependent container otherwise an error will be thrown.\n\nLike typical constraints, the container keyword argument can be used to specify the JuMP container type used to store the constraint references. Note this macro errors if bound_expr is ommited or if some unrecognized syntax is used.\n\nExamples\n\njulia> @BDconstraint(model, c1(t in [0, 1]), T^2 + z <= 1)\nc1 : T(x, t)² + z ≤ 1.0, ∀ t ∈ [0, 1], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1], x[3] ∈ [-1, 1],\n\njulia> @BDconstraint(model, c2[i = 1:3](x[i] in [0, 1]), T^2 + z + x[i] <= 1)\n3-element Array{InfiniteConstraintRef,1}:\n c2[1] : T(x, t)² + z + x[1] ≤ 1.0, ∀ t ∈ [0, 1], x[1] ∈ [0, 1], x[2] ∈ [-1, 1], x[3] ∈ [-1, 1]\n c2[2] : T(x, t)² + z + x[2] ≤ 1.0, ∀ t ∈ [0, 1], x[1] ∈ [-1, 1], x[2] ∈ [0, 1], x[3] ∈ [-1, 1]\n c2[3] : T(x, t)² + z + x[3] ≤ 1.0, ∀ t ∈ [0, 1], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1], x[3] ∈ [0, 1]\n\njulia> @BDconstraint(model, (x == 0, t == 0), T^2 + z <= 1)\nT(x, t)² + z ≤ 1.0, ∀ t = 0, x[1] = 0, x[2] = 0, x[3] = 0\n\njulia> @BDconstraint(model, [i = 1:3](x[i] == 0), T^2 + z <= 1,\n                     container = SparseAxisArray)\nJuMP.Containers.SparseAxisArray{InfiniteConstraintRef,1,Tuple{Any}} with 3 entries:\n  [3]  =  T(x, t)² + z ≤ 1.0, ∀ t ∈ [0, 1], x[1] = 0, x[2] ∈ [-1, 1], x[3] ∈ [-1, 1]\n  [2]  =  T(x, t)² + z ≤ 1.0, ∀ t ∈ [0, 1], x[1] ∈ [-1, 1], x[2] = 0, x[3] ∈ [-1, 1]\n  [1]  =  T(x, t)² + z ≤ 1.0, ∀ t ∈ [0, 1], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1], x[3] = 0\n\n\n\n\n\n","category":"macro"},{"location":"guide/constraint/#JuMP.build_constraint-Tuple{Function,Union{GenericAffExpr{Any,#s38} where #s38<:GeneralVariableRef, GenericQuadExpr{Any,#s9} where #s9<:GeneralVariableRef},MathOptInterface.AbstractScalarSet}","page":"Constraints","title":"JuMP.build_constraint","text":"JuMP.build_constraint(_error::Function, expr::JuMP.AbstractJuMPScalar,\n                      set::MOI.AbstractScalarSet;\n                      [parameter_bounds::ParameterBounds = ParameterBounds()]\n                      )::JuMP.AbstractConstraint\n\nExtend JuMP.build_constraint to accept the parameter_bounds argument and return a BoundedScalarConstraint if the parameter_bounds keyword argument is specifed or return a JuMP.ScalarConstraint otherwise. This is primarily intended to work as an internal function for constraint macros.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @infinite_variable(model, g(t));\n\njulia> @hold_variable(model, x);\n\njulia> constr = build_constraint(error, g + x, MOI.EqualTo(42.0),\n              parameter_bounds = ParameterBounds((t => IntervalSet(0, 1),)));\n\njulia> isa(constr, BoundedScalarConstraint)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint,String}","page":"Constraints","title":"JuMP.add_constraint","text":"JuMP.add_constraint(model::InfiniteModel, c::JuMP.AbstractConstraint,\n                    [name::String = \"\"])::InfOptConstraintRef\n\nExtend JuMP.add_constraint to add a constraint c to an infinite model model with name name. Returns an appropriate constraint reference whose type depends on what variables are used to define the constraint. Errors if a vector constraint is used, the constraint only constains parameters, or if any variables do not belong to model. This is primarily used as an internal method for the cosntraint macros.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @infinite_variable(model, g(t));\n\njulia> @hold_variable(model, x);\n\njulia> constr = build_constraint(error, g + x, MOI.EqualTo(42));\n\njulia> cref = add_constraint(model, constr, \"name\")\nname : g(t) + x = 42.0, ∀ t ∈ [0, 10]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.owner_model-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::InfOptConstraintRef)::InfiniteModel\n\nExtend JuMP.owner_model to return the infinite model associated with cref.\n\nExample\n\njulia> model = owner_model(cref)\nAn InfiniteOpt Model\nMinimization problem with:\nFinite Parameters: 0\nInfinite Parameters: 3\nVariables: 3\nMeasures: 0\nObjective function type: GeneralVariableRef\n`GenericAffExpr{Float64,GeneralVariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\nNames registered in the model: g, t, h, x\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.index-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.index","text":"JuMP.index(cref::InfOptConstraintRef)::ConstraintIndex\n\nExtend JuMP.index to return the index of an InfiniteOpt constraint cref.\n\nExample\n\njulia> index(cref)\nConstrainIndex(2)\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.constraint_object-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::InfOptConstraintRef)::JuMP.AbstractConstraint\n\nExtend JuMP.constraint_object to return the constraint object associated with cref.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @hold_variable(model, x <= 1);\n\njulia> cref = UpperBoundRef(x);\n\njulia> obj = constraint_object(cref)\nScalarConstraint{GeneralVariableRef,MathOptInterface.LessThan{Float64}}(x,\nMathOptInterface.LessThan{Float64}(1.0))\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.name-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.name","text":"JuMP.name(cref::InfOptConstraintRef)::String\n\nExtend [JuMP.name](@ref JuMP.name(::JuMP.ConstraintRef{JuMP.Model,<:JuMP._MOICON}) to return the name of an InfiniteOpt constraint.\n\nExample\n\njulia> name(cref)\n\"constr_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.set_name-Tuple{InfOptConstraintRef,String}","page":"Constraints","title":"JuMP.set_name","text":"JuMP.set_name(cref::InfOptConstraintRef, name::String)::Nothing\n\nExtend JuMP.set_name to specify the name of a constraint cref.\n\nExample\n\njulia> set_name(cref, \"new_name\")\n\njulia> name(cref)\n\"new_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.is_valid-Tuple{InfiniteModel,InfOptConstraintRef}","page":"Constraints","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, cref::InfOptConstraintRef)::Bool\n\nExtend JuMP.is_valid to return Bool whether an InfiniteOpt constraint reference is valid.\n\nExample\n\njulia> is_valid(model, cref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.delete-Tuple{InfiniteModel,InfOptConstraintRef}","page":"Constraints","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, cref::InfOptConstraintRef)::Nothing\n\nExtend JuMP.delete to delete an InfiniteOpt constraint and all associated information. Errors if cref is invalid.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z ≥ 0.0\n g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]\n\njulia> delete(model, cref)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z ≥ 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.parameter_refs-Tuple{InfOptConstraintRef}","page":"Constraints","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(cref::InfOptConstraintRef)::Tuple\n\nReturn the tuple of infinite parameter references that determine the infinite dependencies of cref.\n\nExample\n\njulia> parameter_refs(cref)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.has_parameter_bounds-Tuple{InfOptConstraintRef}","page":"Constraints","title":"InfiniteOpt.has_parameter_bounds","text":"has_parameter_bounds(cref::InfOptConstraintRef)::Bool\n\nReturn a Bool indicating if cref is limited to a sub-domain as defined by a ParameterBounds object.\n\nExample\n\njulia> has_parameter_bounds(cref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.parameter_bounds-Tuple{InfOptConstraintRef}","page":"Constraints","title":"InfiniteOpt.parameter_bounds","text":"parameter_bounds(cref::InfOptConstraintRef)::ParameterBounds{GeneralVariableRef}\n\nReturn the ParameterBounds object associated with the constraint cref. Errors if cref does not have parameter bounds.\n\nExample\n\njulia> parameter_bounds(cref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.set_parameter_bounds-Tuple{InfOptConstraintRef,ParameterBounds{GeneralVariableRef}}","page":"Constraints","title":"InfiniteOpt.set_parameter_bounds","text":"set_parameter_bounds(cref::InfOptConstraintRef,\n                     bounds:ParameterBounds{GeneralVariableRef};\n                     [force::Bool = false])::Nothing\n\nSpecify a new ParameterBounds object bounds for the constraint cref. This is meant to be primarily used by @set_parameter_bounds which provides a more intuitive syntax.\n\nExample\n\njulia> set_parameter_bounds(cref, ParameterBounds((t => IntervalSet(0, 2),)))\n\njulia> parameter_bounds(cref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.add_parameter_bounds-Tuple{InfOptConstraintRef,ParameterBounds{GeneralVariableRef}}","page":"Constraints","title":"InfiniteOpt.add_parameter_bounds","text":"add_parameter_bounds(cref::InfOptConstraintRef,\n                     new_bounds::ParameterBounds{GeneralVariableRef}\n                     )::Nothing\n\nAdd an additional parameter bound to cref such that it is defined over the sub-domain based on pref from lower to upper. This is primarily meant to be used by @add_parameter_bounds.\n\njulia> add_parameter_bounds(cref, ParameterBounds((t => IntervalSet(0, 2),))\n\njulia> parameter_bounds(cref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.delete_parameter_bounds-Tuple{InfOptConstraintRef}","page":"Constraints","title":"InfiniteOpt.delete_parameter_bounds","text":"delete_parameter_bounds(cref::InfOptConstraintRef)::Nothing\n\nDelete all the parameter bounds of the constraint cref. Note any bounds that are needed for hold variables inside in cref will be unaffected.\n\nExample\n\njulia> @BDconstraint(model, c1(x == 0), y <= 42)\nc1 : y(x) ≤ 42, ∀ x[1] = 0, x[2] = 0\n\njulia> delete_parameter_bounds(c1)\n\njulia> c1\nc1 : y(x) ≤ 42, ∀ x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.set_normalized_rhs-Tuple{InfOptConstraintRef,Real}","page":"Constraints","title":"JuMP.set_normalized_rhs","text":"JuMP.set_normalized_rhs(cref::InfOptConstraintRef, value::Real)::Nothing\n\nSet the right-hand side term of constraint to value. Note that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x ≤ 1.0\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x ≤ 4.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.normalized_rhs-Tuple{InfOptConstraintRef}","page":"Constraints","title":"JuMP.normalized_rhs","text":"JuMP.normalized_rhs(cref::InfOptConstraintRef)::Float64\n\nReturn the right-hand side term of cref after JuMP has converted the constraint into its normalized form.\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.add_to_function_constant-Tuple{InfOptConstraintRef,Real}","page":"Constraints","title":"JuMP.add_to_function_constant","text":"JuMP.add_to_function_constant(cref::InfOptConstraintRef, value::Real)::Nothing\n\nAdd value to the function constant term. Note that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1. ```\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.set_normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef,Real}","page":"Constraints","title":"JuMP.set_normalized_coefficient","text":"JuMP.set_normalized_coefficient(cref::InfOptConstraintRef,\n                                variable::GeneralVariableRef,\n                                value::Real)::Nothing\n\nSet the coefficient of variable in the constraint constraint to value. Note that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\njulia> con\ncon : 5 x ≤ 2.0\n\njulia> set_normalized_coefficient(con, x, 4)\n\njulia> con\ncon : 4 x ≤ 2.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.normalized_coefficient-Tuple{InfOptConstraintRef,GeneralVariableRef}","page":"Constraints","title":"JuMP.normalized_coefficient","text":"JuMP.normalized_coefficient(cref::InfOptConstraintRef,\n                            variable::GeneralVariableRef)::Float64\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form.\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.constraint_by_name-Tuple{InfiniteModel,String}","page":"Constraints","title":"JuMP.constraint_by_name","text":"JuMP.constraint_by_name(model::InfiniteModel,\n                        name::String)::Union{InfOptConstraintRef, Nothing}\n\nExtend JuMP.constraint_by_name to return the constraint reference associated with name if one exists or returns nothing. Errors if more than one constraint uses the same name.\n\nExample\n\njulia> constraint_by_name(model, \"constr_name\")\nconstr_name : x + pt = 3.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.list_of_constraint_types-Tuple{InfiniteModel}","page":"Constraints","title":"JuMP.list_of_constraint_types","text":"JuMP.list_of_constraint_types(model::InfiniteModel)::Vector{Tuple{DataType, DataType}}\n\nExtend JuMP.list_of_constraint_types to return a list of tuples that contain all the used combinations of function types and set types in the model.\n\njulia> all_constraints(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GeneralVariableRef, MathOptInterface.LessThan{Float64})\n (GeneralVariableRef, MathOptInterface.GreaterThan{Float64})\n (GeneralVariableRef, MathOptInterface.Integer)\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s38} where #s38<:AbstractJuMPScalar,Type{#s9} where #s9<:MathOptInterface.AbstractSet}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar},\n                     set_type::Type{<:MOI.AbstractSet})::Int\n\nExtend JuMP.num_constraints to return the number of constraints with a partiuclar function type and set type.\n\nExample\n\njulia> num_constraints(model, HoldVariableRef, MOI.LessThan)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s38} where #s38<:AbstractJuMPScalar}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar})::Int\n\nExtend JuMP.num_constraints to search by function types for all MOI sets and return the total number of constraints with a particular function type.\n\njulia> num_constraints(model, HoldVariableRef)\n3\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s38} where #s38<:MathOptInterface.AbstractSet}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:MOI.AbstractSet})::Int\n\nExtend JuMP.num_constraints to search by MOI set type for all function types and return the total number of constraints that use a particular MOI set type.\n\njulia> num_constraints(model, MOI.LessThan)\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel)::Int\n\nExtend JuMP.num_constraints to return the total number of constraints in an infinite model model.\n\njulia> num_constraints(model)\n4\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s38} where #s38<:AbstractJuMPScalar,Type{#s9} where #s9<:MathOptInterface.AbstractSet}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar},\n                     set_type::Type{<:MOI.AbstractSet}\n                     )::Vector{InfOptConstraintRef}\n\nExtend JuMP.all_constraints to return a list of all the constraints with a particular function type and set type.\n\njulia> all_constraints(model, GeneralVariableRef, MOI.LessThan)\n1-element Array{InfOptConstraintRef,1}:\n x ≤ 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s38} where #s38<:AbstractJuMPScalar}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar}\n                     )::Vector{InfOptConstraintRef}\n\nExtend JuMP.all_constraints to search by function types for all MOI sets and return a list of all constraints use a particular function type.\n\njulia> all_constraints(model, GeneralVariableRef)\n3-element Array{InfOptConstraintRef,1}:\n x ≥ 0.0\n x ≤ 3.0\n x integer\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s38} where #s38<:MathOptInterface.AbstractSet}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     set_type::Type{<:MOI.AbstractSet}\n                     )::Vector{InfOptConstraintRef}\n\nExtend JuMP.all_constraints to search by MOI set type for all function types and return a list of all constraints that use a particular set type.\n\njulia> all_constraints(model, MOI.GreaterThan)\n3-element Array{InfOptConstraintRef,1}:\n x ≥ 0.0\n g(t) ≥ 0.0, ∀ t ∈ [0, 6]\n g(0.5) ≥ 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel)::Vector{InfOptConstraintRef}\n\nExtend JuMP.all_constraints to return all a list of all the constraints in an infinite model model.\n\njulia> all_constraints(model)\n5-element Array{InfOptConstraintRef,1}:\n x ≥ 0.0\n x ≤ 3.0\n x integer\n g(t) ≥ 0.0, ∀ t ∈ [0, 6]\n g(0.5) ≥ 0.0\n\n\n\n\n\n","category":"method"},{"location":"develop/#Developers-Guide","page":"Development","title":"Developers Guide","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"InfiniteOpt is large project with a lot of opportunity for development. As such we warmly welcome and encourage contributions. This page serves as the guide of how contributions can be made and how we prefer that they be carried out.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Before starting please review our Code of Conduct.","category":"page"},{"location":"develop/#Contribution-Roadmap","page":"Development","title":"Contribution Roadmap","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"This section will provide a birds-eye view on how to make a contribution to this project. More precise details such as the preferred style are detailed in the sections further below.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"So you want to help improve InfiniteOpt, awesome and thank you! Let's walk through step by step how this should be done.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Setup a GitHub account if you do not already have one. Here is the link to do so.\nSelect a specific task to develop that is well-defined. This can as simple as correcting/clarifying a documentation page or as involved as implementing a more efficient data management paradigm. With a task in mind, please start a new issue here in the InfiniteOpt repository. Also, this a good place find tasks to contribute to by browsing what open issues are (especially ones with the tag good first issue). Note that if your proposed contribution corresponds to an existing issue please do not make a new issue. A guide to using issues in GitHub is located here.\nFork the InfiniteOpt repository to your GitHuB account. Only core developers have permissions to modify InfiniteOpt directly, thus other need to fork it which essentially amounts to creating their own linked copy. This is done by clicking the Fork button at the top left corner on the main repository page here.\nInstall Git on your computer. Git is an open source version control program for repositories (it is why GitHub uses the word Git). This needed to manipulate the repository (all the package files) locally on your computer. A simple google search should indicate how his should be done for your computer. I personally prefer Git for Windows as a Windows user.\nNow you need to install your forked version of InfiniteOpt in Julia on your computer. This needs to be done via the dev command in the package manager so you can edit it. The syntax is as follows:\n(v1.5) pkg> dev https://github.com/username-here/InfiniteOpt.jl\nWe also recommend you install Revise.jl which is very useful when developing packages in Julia.\nDevelop your contribution. Please follow the style guides featured in the sections below. A programmatic contribution will involve the following parts:\nediting/adding code to the .jl files in the src (source) directory\nadding a docstring for each public function/datatype\nincluding comments that describe each internal function/datatype\nadding a unit-testing for each function in the appropriate test files in the test directory\nadding documentation of the new functionality in the appropriate place in the documentation by adding the files in the docs/src directory.\nThese aspects are detailed further in the sections below.\nCommit and push your changes to your forked repository. This is done via Git using your preferred interface and one should pull, add, commit, and then push the changes. Using a bash terminal it would look like this:\nusername@ubuntu:~$ cd repo_directory\nusername@ubuntu:~/repo_directory$ git pull origin master\nusername@ubuntu:~/repo_directory$ git add *\nusername@ubuntu:~/repo_directory$ git commit -m \"insert commit message here\"\nusername@ubuntu:~/repo_directory$ git push origin master\nCreate a pull request. Go here to InfiniteOpt's main page and create a pull request drawing from your forked repository. A step by step explanation is provided here.\nMake necessary changes if the tests fail and/or we ask you to make specific changes. The Codecov tests will ensure every new line of code is tested at least once with the new test functions and Travis CI will ensure that the tests pass on a range of operating systems and Julia versions.\nThat's it. Once the new additions are ready, we will merge them into the  main repository.\nContribute more by repeating steps 2 and 6-10. Just make sure to update your forked repository before getting started which can be done as explained here. Also, be sure to pull the updated repository unto your computer before getting started.","category":"page"},{"location":"develop/#Style-Guide","page":"Development","title":"Style Guide","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Below we detail the formatting, naming, and organizational styles used in InfiniteOpt. We kindly ask developers to adhere to these practices in efforts to foster consistency.","category":"page"},{"location":"develop/#File-Organization","page":"Development","title":"File Organization","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Files for InfiniteOpt are principally stored in 5 locations:","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"the base directory ./,\nthe source file directory ./src/,\nthe source code testing directory ./test/,\nthe documentation source file directory ./docs/,\nand the example scripts directory ./examples/.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"The base directory is for certain critical package files such as the README.md file and the CI (virtual testing service) configuration files. Files should NOT be added or removed from this directory, but may be modified as needed.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Naturally, the source directory is where all the source code files are located. The principal file InfiniteOpt.jl is where the main module is defined, all source code files are included, and all methods/datatypes/macros are exported. This file shouldn't contain any function or datatype definitions directly, but rather should include source files containing such via include(\"file_name.jl\"). Where possible new datatypes should be defined in datatypes.jl and new methods should be defined in the appropriate file (e.g., a new parameter method should be defined in parameters.jl). New files can be added as necessary to help with organization and to prevent a particular file from becoming too long. Also, note that any submodule (e.g., TranscriptionOpt) should be defined within its own sub-directory named after itself.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"The test directory contains all the files in appropriate organization to test all of the methods, datatypes, and macros defined in the source files. The file structure here should emulate that of the ./src/ directory since each file should by systematically tested as described be below in the Unit Tests section. Here the principle file is runtests.jl which serves as the backbone for all the unit testing. Again, no explicit tests should be contain in it, but rather inclusions of test files via include(\"file_name\").","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"The documentation directory follows a particular structure as explained in the documentation for Documenter.jl. Here the root directory ./docs/ contains make.jl which is the script that generates the documentation via Documenter.jl. The Project.toml includes the packages necessary to do this. The ./docs/src/ sub-directory is where source code is stored to build the documentation pages. When building the documentation locally, a ./docs/build directory will also appear that stores the built HTML files. However, this directory is not tracked by Git and any changes here will be ignored.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"The example directory contains scripted use examples of InfiniteOpt. Each example should be stored in single .jl file where possible. However, other more complex examples that use multiple files should be stored in an appropriately named folder.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Please note that all file/folder names should use complete names and avoid abbreviations where possible unless the abbreviations are unambiguous and common knowledge. Moreover, names should be lowercase and use underscores between words: example_file_name.jl.  ","category":"page"},{"location":"develop/#Julia-Code","page":"Development","title":"Julia Code","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Here we detail the programmatic style used with InfiniteOpt. This is done in an effort to make this package intuitive for new-comers and to ease development. This style closely follows that of JuMP.jl with similar deviations from typical Julia styles. Please refer to the JuMP style guide here as this is the style used by InfiniteOpt.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"In addition, we adopt the following practices:","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"All names should be meaningful and readily identifiable. This is bad:\nx = y2 - cp\nThis is good:\nnew_pizza_cost = old_pizza_cost - discount\nThis will make lines longer, but much more understandable.\nAvoid the use explicit numeric values (i.e., magic numbers): This is bad:\ntax = 0.07 * total_price\nTypically, this will employ the use of constants via const This is good:\nconst TAX_RATE = 0.07\ntax = TAX_RATE * total_price\nExceptions to this rule include the use of 1, 1.0, 0, 0.0, -1, -1.0, Inf, and -Inf.\nWhere possible use eachindex to iterate over an datatype: This is bad:\nfor i in 1:length(A)\n    A[i] = i\nend\nThis is good:\nfor i in eachindex(A)\n    A[i] = i\nend\nAll function arguments and struct elements should be typed. Also, function outputs should be typed where possible.    This is bad:\nfunction my_new_function(arg1, arg2)\n    return arg1 + arg2\nend\nstruct MyNewStruct\n    thing1\n    thing2\nend\nThis is good:\nfunction my_new_function(arg1::Int, arg2::Int)::Int\n    return arg1 + arg2\nend\nstruct MyNewStruct\n    thing1::Int\n    thing2::String\nend\nType dispatch should be used instead of conditional statements based on type: This is bad:\nfunction my_new_function(arg::AbstractType)::ReturnType\n  if arg isa Type1\n      temp = arg + 1\n  elseif arg isa Type2\n      temp = 0\n  end\n  # do more stuff with temp\n  return temp\nend\nThis is good:\n## Internal dispatch for my_new_function\n# Type1\nfunction _my_internal_function(arg::Type1)::Int\n    return arg + 1\nend\n# Type2\nfunction _my_internal_function(arg::Type1)::Int\n    return 0\nend\n# Fallback\nfunction _my_internal_function(arg::AbstractType)\n    error(\"Unrecognized type...\")\nend\n# Main method\nfunction my_new_function(arg::AbstractType)::ReturnType\n  temp = _my_internal_function(arg)\n  # do more stuff with temp\n  return temp\nend\nFunctions should be built in a modular manner to avoid code repetition and excessively long function definitions.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"In addition to the above guidelines, contributions should be structured such that extensions are readily possible without having to rewrite all of the associated functions. The ability to easily facilitate extensions is a core goal of InfiniteOpt and this should be kept in mind when developing contributions.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"TODO add example.","category":"page"},{"location":"develop/#Docstrings-and-Comments","page":"Development","title":"Docstrings and Comments","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Here we discuss the use of Docstrings and comments in InfiniteOpt. All public functions, macros, and datatypes should have a Docstring. This is enables the help query tool in Julia and is needed for inclusion in the documentation pages. For functions and macros the format should follow the form:","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"\"\"\"\n    my_new_function(arg1::Type, [arg2::Type = 0; karg1::Type = 42])::Type\n\nPrecise and concise description of what `my_new_function` does and what it\nreturns (also what will cause it will trigger errors). This is in markdown\nformat.\n\n**Example**\n```jldoctest; setup = :(using JuMP, InfiniteOpt; [other commands])\njulia> my_new_function(input...)\nexpected_output\n```\n\"\"\"\nfunction my_new_function(arg1::Type, arg2::Type = 0; karg1::Type = 42)::Type\n    return arg1 + arg2 + karg1\nend","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Notice that the function is declared at the top with an ident and the optional arguments are enclosed within square brackets. This can be spaced over several lines if there are too many arguments to fit on one line. Also, the jldoctest should be used where possible (this actually runs and tests that the example works), but when this is not possible it can be replaced with julia which will provide syntax highlighting without running the code.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"For datatypes Docstrings should follow the form:","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"\"\"\"\n    MyNewStruct\n\nPrecise and concise description of what this is.\n\n**Fields**\n- `element1::Type` Description of what this is.\n- `element2::Type` Description of what this is.\n\"\"\"\nstruct MyNewStruct\n    element1::Type\n    element2::Type\nend","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Note that if the struct is parametric and/or has inheritance, this information should also be shown in the header. For example, we have that InfOptParameter{T <: AbstractInfiniteSet} <: JuMP.AbstractVariable.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"For more docstring information please visit the Julia documentation here.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Furthermore, all internal functions and datatypes should have an appropriate commented description of what they do above them. This should follow the form:","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"# Description of what _my_internal_function does. Bla Bla Bla Bla Bla Bla Bla\n# Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla Bla.\nfunction _my_internal_function(arg1::Type, arg2::Type)::Type\n    return arg1 + arg2\nend","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Finally, we encourage a healthy usage of comments throughout source code to enhance its readability. A simple comment before a complex block of code can make all the difference.","category":"page"},{"location":"develop/#Unit-Tests","page":"Development","title":"Unit Tests","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"A nice attribute of InfiniteOpt is that it is near perfect code testing coverage. This success is due to strictly testing every method and macro rigorously such that every line is called. This has been very advantageous in detecting many bugs which can be difficult to anticipate given the quantity of source code. Thus, tests must be created/updated to cover any new additions/changes in the ./src/ directory.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"The runtests.jl file serves as the principal backbone for doing this. We use a nested @testset structure using Test.jl. Please refer to the documentation here to learn about the relevant testing macros. The structure typically groups related functions together where each function/macro/datatype is tested via a @testset that employs a number of tests via @test that thoroughly test it. This is typically of the form:","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"@testset \"my_new_function\" begin\n    @test my_new_function(input1) == expected_output1\n    @test my_new_function(input2) == expected_output2\n    @test my_new_function(input3) == expected_output3\n    .\n    .\n    .\nend","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Thus, a function's @testset should be updated when the respective function has been modified. Moreover, a new @testset should be added for each new function/macro. New function tests should be implemented in an order such that any other functions/macros they depend on are tested first.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Also, where possible please include comments to explain what is going on.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Please refer to InfiniteOpt/test/ for examples.","category":"page"},{"location":"develop/#Documentation-Pages","page":"Development","title":"Documentation Pages","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Documentation in InfiniteOpt is generated via Documenter.jl. Please refer to its documentation to learn about how to use it.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"The source markdown files stored in ./docs/src/ are what comprise the source code for the documentation pages and are principally what should be updated. A guide for markdown syntax is provided here. Also, note that Documenter enables unique functionality in addition to this general guide.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"When a new Docstring is created as described above, it should be included on the appropriate guide page in the @docs block at the bottom. Moreover, content should be added in an appropriate section above (or perhaps in a new section) that overviews how to implement the new capabilities in an example driven fashion. These examples should use jldoctests where possible as well to assess whether the example code is functional.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Documentation content should be concise and use examples and lists where possible to provide a more visual guide. Also, we ask that passive voice be avoided.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Be sure to test the documentation first locally by running make.jl to check for problems which may include:","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"unrecognized docstrings\nfailed doctests\nfaulty links\nunrecognized formats\nmissing package dependencies\netc.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"note: Note\nDoctests should be setup to pass on Linux and not other operating systems since Linux is used to build the website. For example, in the symbol ∀ is used in Linux while in Windows the phrase for all is used. Thus, a number of doctests will fail when run on Windows which is fine. However, users should choose the expected output to be what Linux will return.","category":"page"},{"location":"guide/install/#Installation-Guide","page":"Installation","title":"Installation Guide","text":"","category":"section"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"A complete guide to installing all that is necessary to use InfiniteOpt.jl.","category":"page"},{"location":"guide/install/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"InfiniteOpt is a Julia package. Thus, we first need have an installation of Julia to get started. An appropriate download can be found here. Alternatively, users with a limited programming background might find it easier to install and use JuliaPro.","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"note: Note\nThis version of InfiniteOpt requires that Julia 1.0 or newer be used.","category":"page"},{"location":"guide/install/#Install-Packages","page":"Installation","title":"Install Packages","text":"","category":"section"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"Now that Julia has been installed we can add the needed packages. Open up a Julia terminal and enter the package manager:","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"julia> ]\n\n(v1.5) pkg>","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"Use the add command in the package to manager to add the following packages:","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"JuMP\nDistributions (required for stochastic programming)","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"For example, to install JuMP we would enter:","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"(v1.5) pkg> add JuMP","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"Now let's install InfiniteOpt:","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"(v1.5) pkg> add InfiniteOpt","category":"page"},{"location":"guide/install/#Install-Optimization-Solvers","page":"Installation","title":"Install Optimization Solvers","text":"","category":"section"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"InfiniteOpt relies on solvers to solve optimization problems. Many solvers are not native to Julia and might require commercial licenses. A list of currently supported solvers and their corresponding Julia packages is provided in Supported Optimizers.","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"For example, we can install Ipopt which is an open-source nonlinear solver:","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"(v1.5) pkg> add Ipopt","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"Now Ipopt can be used as the optimizer (solver) for an infinite model by running:","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"julia> using InfiniteOpt, JuMP, Ipopt\n\njulia> model = InfiniteModel(Ipopt.Optimizer)","category":"page"},{"location":"guide/install/","page":"Installation","title":"Installation","text":"Most solver packages follow the ModuleName.Optimizer naming convention, but this may not always be the case. See Infinite Models for more information on defining infinite models and specifying solvers.","category":"page"},{"location":"guide/model/#infinite_model_docs","page":"Infinite Models","title":"Infinite Models","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"A guide and manual for initializing infinite models and understanding how they work. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/model/#Overview","page":"Infinite Models","title":"Overview","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Infinite models are expressed via the InfiniteModel datatype which is at the core of InfiniteOpt. These model objects are designed to emulate the behavior of Model objects in JuMP. These data objects store the parameters, variables, measures, objective, constraints, and all other data used in InfiniteOpt. This differs from JuMP models which store such information in a MathOptInterface model backend.","category":"page"},{"location":"guide/model/#Basic-Usage","page":"Infinite Models","title":"Basic Usage","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Infinite models can be initialized with no arguments by default:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariables: 0\nMeasures: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"The optimizer that will be used to solve the model can also be specified at model definition:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP, Ipopt\n\njulia> model = InfiniteModel(Ipopt.Optimizer)\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariables: 0\nMeasures: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Ipopt","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Note that any optimizer currently supported by JuMP v0.19.0 or newer is supported for use in InfiniteOpt. For completeness, the table of currently supported optimizers is provided below in Supported Optimizers.","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"We can also specify optimizer attributes via optimizer_with_attributes which allows us to append as many attributes as we like, for example:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP, Ipopt\n\njulia> model = InfiniteModel(optimizer_with_attributes(Ipopt.Optimizer,\n                                                       \"output_level\" => 0))\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariables: 0\nMeasures: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Ipopt","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Now you have an initialized InfiniteModel that is ready for your mathematical model to be defined and optimized!","category":"page"},{"location":"guide/model/#Advanced-Definition-Information","page":"Infinite Models","title":"Advanced Definition Information","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"As you may have noticed in the above examples, InfiniteModels contain an optimizer model backend which simply corresponds to a JuMP Model that will be used to store and optimize the reformulation of the infinite mathematical model stored in InfiniteModel. It also will contain a mapping between its optimization model and that of the InfiniteModel (e.g., a mapping between the variables and constraints). By default, InfiniteModels use a TranscriptionModel optimizer model backend which will store a transcribed (discretized) version of the infinite model. More information on the internal use of TranscriptionModels is provided in Model Transcription.","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"All the arguments used with the InfiniteModel constructor (e.g., the optimizer) are simply passed on and stored in the optimizer model backend. Thus, any argument supported by JuMP.Model can be passed on to the optimizer model by including it in the InfiniteModel constructor. For example, we can specify the caching_mode keyword argument in the InfiniteModel call to use in the definition of the optimizer model:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP, Ipopt, MathOptInterface\n\njulia> const MOIU = MathOptInterface.Utilities;\n\njulia> model = InfiniteModel(Ipopt.Optimizer,\n                             caching_mode = MOIU.MANUAL)\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariables: 0\nMeasures: 0\nOptimizer model backend information:\nModel mode: MANUAL\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Ipopt","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Notice that the model mode of the optimizer model is now MANUAL.","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Moreover, alternative optimizer model types (i.e., not a TranscriptionModel) can be  specified via the OptimizerModel keyword argument when initializing the  InfiniteModel. Thus, to redundantly specify a TranscriptionModel we would call:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt\n\njulia> model = InfiniteModel(OptimizerModel = TranscriptionModel)\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariables: 0\nMeasures: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"More information on implementing custom optimizer models is located on the  Extensions page.","category":"page"},{"location":"guide/model/#Supported-Optimizers","page":"Infinite Models","title":"Supported Optimizers","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"InfiniteOpt can use any optimizer that is supported by JuMP v0.19.0 or newer. In spirit of providing complete documentation, the table of optimizers currently supported by JuMP.jl is provided below. This information comes directly from their documentation pages. Please refer to JuMP documentation for additional optimizer information on installation and use.","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Solver Julia Package License Supports\nArtelys Knitro KNITRO.jl Comm. LP, MILP, SOCP, MISOCP, NLP, MINLP\nCbc Cbc.jl EPL MILP\nCDCS CDCS.jl GPL LP, SOCP, SDP\nCDD CDDLib.jl GPL LP\nClp Clp.jl EPL LP\nCOSMO COSMO.jl Apache LP, QP, SOCP, SDP\nCPLEX CPLEX.jl Comm. LP, MILP, SOCP, MISOCP\nCSDP CSDP.jl EPL LP, SDP\nECOS ECOS.jl GPL LP, SOCP\nFICO Xpress Xpress.jl Comm. LP, MILP, SOCP, MISOCP\nGLPK GLPK.jl GPL LP, MILP\nGurobi Gurobi.jl Comm. LP, MILP, SOCP, MISOCP\nIpopt Ipopt.jl EPL LP, QP, NLP\nJuniper Juniper.jl MIT MISOCP, MINLP\nMOSEK MosekTools.jl Comm. LP, MILP, SOCP, MISOCP, SDP\nOSQP OSQP.jl Apache LP, QP\nProxSDP ProxSDP.jl MIT LP, SOCP, SDP\nSCIP SCIP.jl ZIB MILP, MINLP\nSCS SCS.jl MIT LP, SOCP, SDP\nSDPA SDPA.jl, SDPAFamily.jl GPL LP, SDP\nSDPNAL SDPNAL.jl CC BY-SA LP, SDP\nSDPT3 SDPT3.jl GPL LP, SOCP, SDP\nSeDuMi SeDuMi.jl GPL LP, SOCP, SDP\nTulip Tulip.jl MPL-2 LP","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"Where:","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex   quadratic constraints and/or objective)\nMILP = Mixed-integer linear programming\nNLP = Nonlinear programming\nMINLP = Mixed-integer nonlinear programming\nSDP = Semidefinite programming\nMISDP = Mixed-integer semidefinite programming","category":"page"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"You may also use AmplNLWriter to access solvers that support the nl format. Such solvers include Bonmin and Couenne. See a more complete list here.","category":"page"},{"location":"guide/model/#Datatypes","page":"Infinite Models","title":"Datatypes","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"InfiniteModel\nAbstractDataObject\nAbstractInfOptIndex\nObjectIndex","category":"page"},{"location":"guide/model/#InfiniteOpt.InfiniteModel","page":"Infinite Models","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel <: JuMP.AbstractModel\n\nA DataType for storing all of the mathematical modeling information needed to model an optmization problem with an infinite-dimensional decision space.\n\nFields\n\nindependent_params::MOIUC.CleverDict{IndependentParameterIndex, ScalarParameterData{IndependentParameter}}:  The independent parameters and their mapping information.\ndependent_params::MOIUC.CleverDict{DependentParametersIndex, MultiParameterData}:  The dependent parameters and their mapping information.\nfinite_params::MOIUC.CleverDict{FiniteParameterIndex, ScalarParameterData{FiniteParameter}}:  The finite parameters and their mapping information.\nname_to_param::Union{Dict{String, AbstractInfOptIndex}, Nothing}:  Field to help find a parameter given the name.\nlast_param_num::Int: The last parameter number to be used.\nparam_object_indices::Vector{Union{IndependentParameterIndex, DependentParametersIndex}}: The collection of parameter object indices in creation order.\ninfinite_vars::MOIUC.CleverDict{InfiniteVariableIndex, <:VariableData{<:InfiniteVariable}}:  The infinite variables and their mapping information.\nreduced_vars::MOIUC.CleverDict{ReducedVariableIndex, <:VariableData{<:ReducedVariable}}:  The reduced infinite variables and their mapping information.\npoint_vars::MOIUC.CleverDict{PointVariableIndex, <:VariableData{<:PointVariable}}:  The point variables and their mapping information.\nhold_vars::MOIUC.CleverDict{HoldVariableIndex, <:VariableData{<:HoldVariable}}:  The hold variables and their mapping information.\nname_to_var::Union{Dict{String, AbstractInfOptIndex}, Nothing}:  Field to help find a variable given the name.\nhas_hold_bounds::Bool:  Does any variable have parameter bounds?\nmeasures::MOIUC.CleverDict{MeasureIndex, MeasureData}:  The measures and their mapping information.\nintegral_defaults::Dict{Symbol}:  The default keyword arguments for integral.\nconstraints::MOIUC.CleverDict{ConstraintIndex, ConstraintData}:  The constraints and their mapping information.\nname_to_constr::Union{Dict{String, ConstraintIndex}, Nothing}:  Field to help find a constraint given the name.\nobjective_sense::MOI.OptimizationSense: Objective sense.\nobjective_function::JuMP.AbstractJuMPScalar: Finite scalar function.\nobjective_has_measures::Bool: Does the objective contain measures?\nobj_dict::Dict{Symbol, Any}: Store Julia symbols used with InfiniteModel\noptimizer_constructor: MOI optimizer constructor (e.g., Gurobi.Optimizer).\noptimizer_model::JuMP.Model: Model used to solve InfiniteModel\nready_to_optimize::Bool: Is the optimizer_model up to date.\next::Dict{Symbol, Any}: Store arbitrary extension information.\n\n\n\n\n\n","category":"type"},{"location":"guide/model/#InfiniteOpt.AbstractDataObject","page":"Infinite Models","title":"InfiniteOpt.AbstractDataObject","text":"AbstractDataObject\n\nAn abstract type for DataTypes that store core variable DataTypes and their model specific information (e.g., dependency mappings). These are what are stored in the InfiniteModel CleverDicts.\n\n\n\n\n\n","category":"type"},{"location":"guide/model/#InfiniteOpt.AbstractInfOptIndex","page":"Infinite Models","title":"InfiniteOpt.AbstractInfOptIndex","text":"AbstractInfOptIndex\n\nAn abstract type for all index objects used in InfiniteOpt.\n\n\n\n\n\n","category":"type"},{"location":"guide/model/#InfiniteOpt.ObjectIndex","page":"Infinite Models","title":"InfiniteOpt.ObjectIndex","text":"ObjectIndex <: AbstractInfOptIndex\n\nAn abstract type for indices of objects stored in MOI.Utilities.CleverDicts.\n\n\n\n\n\n","category":"type"},{"location":"guide/model/#Methods","page":"Infinite Models","title":"Methods","text":"","category":"section"},{"location":"guide/model/","page":"Infinite Models","title":"Infinite Models","text":"InfiniteModel()","category":"page"},{"location":"guide/model/#InfiniteOpt.InfiniteModel-Tuple{}","page":"Infinite Models","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel([optimizer_constructor];\n              [OptimizerModel::Function = TranscriptionModel,\n              caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,\n              bridge_constraints::Bool = true, optimizer_model_kwargs...])\n\nReturn a new infinite model where an optimizer is specified if an optimizer_constructor is given. The optimizer can also later be set with the JuMP.set_optimizer call. By default the optimizer_model data field is initialized with a TranscriptionModel, but a different type of model can be assigned via set_optimizer_model as can be required by extensions.\n\nExample\n\njulia> using InfiniteOpt, JuMP, Ipopt;\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariables: 0\nMeasures: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> model = InfiniteModel(Ipopt.Optimizer)\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariables: 0\nMeasures: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Ipopt\n\n\n\n\n\n","category":"method"},{"location":"guide/sets/#infinite_sets_normal","page":"Infinite Sets","title":"Infinite Sets","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"A guide and manual to the definition and use of infinite sets in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/sets/#Basic-Usage","page":"Infinite Sets","title":"Basic Usage","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Interval sets are what characterize the behavior of infinite parameters in InfiniteOpt, since they comprise the domains of infinite parameters. However, most users will not need to work directly with infinite sets and can instead focus on the use of infinite parameters as defined via @infinite_parameter and as discussed on the Infinite Parameters page.","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"However, for convenience below we summary the infinite sets associated with InfiniteOpt:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Set Type Domain Type\nIntervalSet lb ub InfiniteScalarSet\nUniDistributionSet sim mathcalD subseteq mathbbR InfiniteScalarSet\nMultiDistributionSet sim mathcalD subseteq mathbbR^n InfiniteArraySet\nCollectionSet Combination of Univariate Domains InfiniteArraySet","category":"page"},{"location":"guide/sets/#Infinite-Set-Classes","page":"Infinite Sets","title":"Infinite Set Classes","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"The domain of a given infinite parameter(s) is described by an infinite set inherited from AbstractInfiniteSet. InfiniteOpt natively supports two set sub-groups, namely InfiniteScalarSets and InfiniteArraySets.  These correspond to a single independent infinite parameter and a dependent multi-dimensional  group of infinite parameters, respectively. We describe each group's natively  supported sets below.","category":"page"},{"location":"guide/sets/#Univariate-Sets","page":"Infinite Sets","title":"Univariate Sets","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Univariate infinite sets (i.e., InfiniteScalarSets) are one-dimensional  domains (subseteq mathbbR) that describe the behavior of one single independent  infinite parameter (i.e., infinite parameters made using independent = true). The  two natively supported concrete types are IntervalSets and UniDistributionSets.","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"IntervalSets describe a continuous interval from some lower bound up to  some upper bound. Where the range is inclusive of the bounds. Such sets often  arise for parameters that pertain to time and/or spatial position. For example,  to define a position interval -2 2 we would use:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> set = IntervalSet(-2, 2)\n[-2, 2]","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Note that (semi-)infinite bounds are acceptable, as shown in the following example:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> infinite_set = IntervalSet(-Inf, Inf)\n[-Inf, Inf]","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"UniDistributionSets pertain to the co-domain of a univariate distribution.  In other words, these correspond to the underlying distributions that characterize  uncertain scalar parameters. These sets are compatible with any univariate  distribution native to Distributions.jl. For example, let's make a UniDistributionSet that depends on a Beta distribution:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> using Distributions;\n\njulia> set = UniDistributionSet(Beta(2,2))\nBeta{Float64}(α=2.0, β=2.0)","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"User-defined distributions are also permissible so long as they are created in accordance with Distributions.jl.","category":"page"},{"location":"guide/sets/#Multivariate-Sets","page":"Infinite Sets","title":"Multivariate Sets","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Multivariate infinite sets (i.e., [InfiniteArraySet])(@ref)s are multi-dimensional  domains that define the behavior of a group of dependent infinite parameters  (i.e., an array of infinite parameters where independent = false). This is a  unique feature to InfiniteOpt that enables a much richer set of possibilities  for modeling infinite domain. Natively two set types are supported:  MultiDistributionSets and CollectionSets. ","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"MultiDistributionSets correspond to the co-domain of a multi-variate  (or matrix-variate) distribution which characterizes the behavior of multi-dimensional  uncertain parameters. Again, these correspond to any appropriate distribution  defined in Distributions.jl. For example, we can make a MultiDistributionSet  that depends on a 2-D normal distribution as follows:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> using Distributions;\n\njulia> dist = MvNormal([0., 0.], [1. 0.; 0. 2.]);\n\njulia> set = MultiDistributionSet(dist)\nFullNormal(\ndim: 2\nμ: [0.0, 0.0]\nΣ: [1.0 0.0; 0.0 2.0]\n)","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"note: Note\nThe dimensions (shape) of a chosen distribution used in an MultiDistriubtionSet  must match those of the corresponding infinite parameter array.","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Finally, CollectionSets are a dependent collection of InfiniteScalarSets that correspond to a group of infinite parameters that are treated dependently.  This can be useful when the user wishes to have complete control over how the  supports are generated for a group independent parameters where the default  combinatorial approach in not wanted. For example, let's make a set of IntervalSets:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> set = CollectionSet([IntervalSet(-2, 2), IntervalSet(-1, 4)])\nCollectionSet with 2 sets:\n [-2, 2]\n [-1, 4]","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Now we could use this set in define a two-dimensional infinite parameter of which  we can have the freedom to define a non-combinatorial support grid.","category":"page"},{"location":"guide/sets/#Bound-Query/Modification-Methods-for-Infinite-Sets","page":"Infinite Sets","title":"Bound Query/Modification Methods for Infinite Sets","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Once an infinite set is created, one can query the lower bound and upper bound of the set  similar to how one queries the bounds of a JuMP variable. Thus, the functions  JuMP.has_lower_bound, JuMP.has_upper_bound, JuMP.lower_bound, JuMP.upper_bound  are all applicable to infinite sets mentioned above. For example, for an IntervalSet [-2, 2] we can query the bound information as follows:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> set = IntervalSet(-2, 2);\n\njulia> has_lower_bound(set)\ntrue\n\njulia> has_upper_bound(set)\ntrue\n\njulia> lower_bound(set)\n-2.0\n\njulia> upper_bound(set)\n2.0","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"In addition, we can also apply JuMP.set_lower_bound and JuMP.set_upper_bound  to IntervalSets to generate a new set with updated bounds. Note that this will not modify the original set. For example, we can change the bounds of the set [-2, 2] as follows:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> set_lower_bound(set, -1)\n[-1, 2]\n\njulia> set_upper_bound(set, 1)\n[-2, 1]","category":"page"},{"location":"guide/sets/#Support-Generation-for-Infinite-Sets","page":"Infinite Sets","title":"Support Generation for Infinite Sets","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"InfiniteOpt provides a systematic interface to generate support points for infinite sets. This is crucial as support generation decides how each infinite-dimensional parameter, which is subject to certain infinite set, is discretized later in the transcription stage. The interface will allow users to automatically generate support points using our default methods. Later we will also show that users can  also input support points manually for an infinite parameter. Please note that these  methods are called by the @infinite_parameter macro when the num_supports  keyword is used. Thus, users typically will not need to use this interface directly.","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"In InfiniteOpt supports can be generated via generate_supports function. For example, let's  generate 5 equidistant support points for the IntervalSet [-2, 2]:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> supps, label = generate_supports(set, num_supports = 5)\n([-2.0, -1.0, 0.0, 1.0, 2.0], :uniform_grid)\n\njulia> supps\n5-element Array{Float64,1}:\n -2.0\n -1.0\n  0.0\n  1.0\n  2.0\n\njulia> label\n:uniform_grid","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Note that the number of supports generated is specified via num_supports keyword argument, which will take a default value of 10 if not specified.  The function generate_supports returns a vector of the supports generated, and a label that symbolizes the underlying method. In this case the label returned is UniformGrid, which is the default  support generation method for IntervalSets. Another support generation method implemented for IntervalSets is MCSample, which is to sample from a uniform distribution over the interval. To use this mehtod, users need to specify a second positional argument, as shown in the following example:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> generate_supports(set, MCSample, num_supports = 5)\n([1.29459, 1.64143, -1.34174, -1.29068, -0.88448], :mc_sample)","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"In this case, the returned label is MCSample, instead of UniformGrid.","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"generate_supports can also be applied to DistributionSets. The default (and currently only) method implemented for DistributionSets is WeightedSample, which generates Monte Carlo samples that are  weighted based on the underlying probability density function of the distribution.  For example, a set of support points for a 2-D normal distribution can be generated as follows:","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"julia> dist = MvNormal([0., 0.], [1. 0.;0. 2.]);\n\njulia> set = MultiDistributionSet(dist);\n\njulia> supps, label = generate_supports(set, num_supports = 3)\n([0.679107426036 -0.353007400301 0.586617074633; 1.17155358277 -0.190712174623 0.420496392851], :weighted_sample)\n\njulia> supps\n2×3 Array{Float64,2}:\n 0.679107  -0.353007  0.586617\n 1.17155   -0.190712  0.420496","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"For those who are interested in coding up their own support generation functions, generate_supports is an inteface that calls the proper generate_support_values function based on the type of set and value of method. Therefore, to use custom support generation methods, users can implement extensions for generate_support_values  with a different method label from the existing methods. See Extensions for full details.","category":"page"},{"location":"guide/sets/#User-Defined-Sets","page":"Infinite Sets","title":"User Defined Sets","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Furthermore, custom infinite sets that inherit AbstractInfiniteSet can also be defined. See Extensions for more information.","category":"page"},{"location":"guide/sets/#Datatypes","page":"Infinite Sets","title":"Datatypes","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Pages   = [\"sets.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"AbstractInfiniteSet\nInfiniteScalarSet\nIntervalSet\nUniDistributionSet\nInfiniteArraySet\nMultiDistributionSet\nCollectionSet","category":"page"},{"location":"guide/sets/#InfiniteOpt.AbstractInfiniteSet","page":"Infinite Sets","title":"InfiniteOpt.AbstractInfiniteSet","text":"AbstractInfiniteSet\n\nAn abstract type for sets that characterize infinite parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/sets/#InfiniteOpt.InfiniteScalarSet","page":"Infinite Sets","title":"InfiniteOpt.InfiniteScalarSet","text":"InfiniteScalarSet <: AbstractInfiniteSet\n\nAn abstract type for infinite sets that are one-dimensional.\n\n\n\n\n\n","category":"type"},{"location":"guide/sets/#InfiniteOpt.IntervalSet","page":"Infinite Sets","title":"InfiniteOpt.IntervalSet","text":"IntervalSet <: InfiniteScalarSet\n\nA DataType that stores the lower and upper interval bounds for infinite parameters that are continuous over a certain that interval. This is for use with a IndependentParameter.\n\nFields\n\nlower_bound::Float64 Lower bound of the infinite parameter.\nupper_bound::Float64 Upper bound of the infinite parameter.\n\n\n\n\n\n","category":"type"},{"location":"guide/sets/#InfiniteOpt.UniDistributionSet","page":"Infinite Sets","title":"InfiniteOpt.UniDistributionSet","text":"UniDistributionSet{T <: Distributions.UnivariateDistribution} <: InfiniteScalarSet\n\nA DataType that stores the distribution characterizing an infinite parameter that is random. This is for use with a IndependentParameter.\n\nFields\n\ndistribution::T Distribution of the random parameter.\n\n\n\n\n\n","category":"type"},{"location":"guide/sets/#InfiniteOpt.InfiniteArraySet","page":"Infinite Sets","title":"InfiniteOpt.InfiniteArraySet","text":"InfiniteArraySet <: AbstractInfiniteSet\n\nAn abstract type for multi-dimensional infinite sets.\n\n\n\n\n\n","category":"type"},{"location":"guide/sets/#InfiniteOpt.MultiDistributionSet","page":"Infinite Sets","title":"InfiniteOpt.MultiDistributionSet","text":"MultiDistributionSet{T <: NonUnivariateDistribution} <: InfiniteArraySet\n\nA DataType that stores the distribution characterizing a collection of infinite parameters that follows its form. This is for use with DependentParameters.\n\nFields\n\ndistribution::T Distribution of the random parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/sets/#InfiniteOpt.CollectionSet","page":"Infinite Sets","title":"InfiniteOpt.CollectionSet","text":"CollectionSet{T <: InfiniteScalarSet} <: InfiniteArraySet\n\nA DataType that stores a collection of InfiniteScalarSets characterizing a collection of infinite parameters that follows its form. This is for use with DependentParameters.\n\nFields\n\nsets::Array{T} The collection of scalar sets.\n\n\n\n\n\n","category":"type"},{"location":"guide/sets/#Methods","page":"Infinite Sets","title":"Methods","text":"","category":"section"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"Pages   = [\"sets.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/sets/","page":"Infinite Sets","title":"Infinite Sets","text":"collection_sets\nJuMP.has_lower_bound(::AbstractInfiniteSet)\nJuMP.lower_bound(::AbstractInfiniteSet)\nJuMP.set_lower_bound(::AbstractInfiniteSet, ::Real)\nJuMP.has_upper_bound(::AbstractInfiniteSet)\nJuMP.upper_bound(::AbstractInfiniteSet)\nJuMP.set_upper_bound(::AbstractInfiniteSet, ::Real)\nsupports_in_set\ngenerate_supports\nInfiniteOpt.generate_support_values","category":"page"},{"location":"guide/sets/#InfiniteOpt.collection_sets","page":"Infinite Sets","title":"InfiniteOpt.collection_sets","text":"collection_sets(set::AbstractInfiniteSet)\n\nReturn the array of sets associated with a CollectionSet. Error if the input set is not a CollectionSet.\n\n\n\n\n\n","category":"function"},{"location":"guide/sets/#JuMP.has_lower_bound-Tuple{AbstractInfiniteSet}","page":"Infinite Sets","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(set::AbstractInfiniteSet)::Bool\n\nReturn Bool indicating if set has a lower bound that can be determined. This should be extended for user-defined infinite sets. It defaults to false for unrecognized set types.\n\nExample\n\njulia> set = InfiniteSet(0, 1);\n\njulia> has_lower_bound(set)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/sets/#JuMP.lower_bound-Tuple{AbstractInfiniteSet}","page":"Infinite Sets","title":"JuMP.lower_bound","text":"JuMP.lower_bound(set::AbstractInfiniteSet)::Union{Real, Vector{<:Real}}\n\nReturn the lower bound of set if one exists. This should be extended for user-defined infinite sets if appropriate. Errors if JuMP.has_lower_bound returns false. Extensions are enabled by JuMP.has_lower_bound(set) and JuMP.lower_bound(set).\n\nExample\n\njulia> set = InfiniteSet(0, 1);\n\njulia> lower_bound(set)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/sets/#JuMP.set_lower_bound-Tuple{AbstractInfiniteSet,Real}","page":"Infinite Sets","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(set::AbstractInfiniteSet,\n                     lower::Union{Real, Vector{<:Real}})::AbstractInfiniteSet\n\nSet and return the lower bound of set if such an operation makes sense. Errors if the type of set does not support this operation or has not been extended. User-defined set types should extend this if appropriate.\n\nExample\n\njulia> set = InfiniteSet(0, 1);\n\njulia> set_lower_bound(set, 0.5)\n[0.5, 1]\n\n\n\n\n\n","category":"method"},{"location":"guide/sets/#JuMP.has_upper_bound-Tuple{AbstractInfiniteSet}","page":"Infinite Sets","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(set::AbstractInfiniteSet)::Bool\n\nReturn Bool indicating if set has a upper bound that can be determined. This should be extended for user-defined infinite sets. It defaults to false for unrecognized set types.\n\nExample\n\njulia> set = InfiniteSet(0, 1);\n\njulia> has_upper_bound(set)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/sets/#JuMP.upper_bound-Tuple{AbstractInfiniteSet}","page":"Infinite Sets","title":"JuMP.upper_bound","text":"JuMP.upper_bound(set::AbstractInfiniteSet)::Union{Real, Vector{<:Real}}\n\nReturn the upper bound of set if one exists. This should be extended for user-defined infinite sets if appropriate. Errors if JuMP.has_upper_bound returns false. Extensions are enabled by JuMP.has_upper_bound(set) and JuMP.upper_bound(set).\n\nExample\n\njulia> set = InfiniteSet(0, 1);\n\njulia> upper_bound(set)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/sets/#JuMP.set_upper_bound-Tuple{AbstractInfiniteSet,Real}","page":"Infinite Sets","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(set::AbstractInfiniteSet,\n                     upper::Real)::AbstractInfiniteSet\n\nSet and return the upper bound of set if such an aoperation makes sense. Errors if the type of set does not support this operation or has not been extended. User-defined set types should extend this if appropriate.\n\nExample\n\njulia> set = InfiniteSet(0, 1);\n\njulia> set_upper_bound(set, 0.5)\n[0, 0.5]\n\n\n\n\n\n","category":"method"},{"location":"guide/sets/#InfiniteOpt.supports_in_set","page":"Infinite Sets","title":"InfiniteOpt.supports_in_set","text":"supports_in_set(supports::Union{Real, Vector{<:Real}, Array{<:Real, 2}},\n                set::AbstractInfiniteSet)::Bool\n\nUsed to check if supports are in the domain of set. Returns true if supports are in domain of set and returns false otherwise. This is primarily an internal method for performing checks but can be extended for user-defined set types. Extending this is optional, but recommended where possible. Note by fallback, this returns true for unrecognized set types such that an error won't be thrown.\n\n\n\n\n\n","category":"function"},{"location":"guide/sets/#InfiniteOpt.generate_supports","page":"Infinite Sets","title":"InfiniteOpt.generate_supports","text":"generate_supports(set::AbstractInfiniteSet\n                  method::Union{Symbol, Nothing} = Nothing;\n                  [num_supports::Int = DefaultNumSupports,\n                  sig_digits::Int = DefaultSigDigits]\n                  )::Tuple{Array{<:Real}, Symbol}\n\nGenerate num_supports support values with sig_digits significant digits in accordance with set and return them along with the correct generation label(s). IntervalSets generate supports uniformly with label UniformGrid and distribution sets generate them randomly accordingly to the underlying distribution. Moreover, method indicates the generation method that should be used. These methods correspond to parameter support labels. Current labels that can be used as generation methods include (but may not be defined for certain set types):\n\nMCSample: Uniformly distributed Monte Carlo samples.\nWeightedSample: Monte Carlo samples that are weighted by an underlying PDF.\nUniformGrid: Samples that are generated uniformly over the set domain.\n\nExtensions that employ user-defined infinite set types and/or methods should extend generate_support_values to enable this. Errors if the set type and /or methods are unrecognized. This is intended as an internal method to be used by methods such as generate_and_add_supports!.\n\n\n\n\n\n","category":"function"},{"location":"guide/sets/#InfiniteOpt.generate_support_values","page":"Infinite Sets","title":"InfiniteOpt.generate_support_values","text":"generate_support_values(set::AbstractInfiniteSet,\n                        [method::Val{:MyMethod} = Val(:MyMethod)];\n                        num_supports::Int = DefaultNumSupports,\n                        sig_digits::Int = DefaultSigDigits,\n                        )::Tuple{Array{<:Real}, Symbol}\n\nA multiple dispatch method for generate_supports. This will return a tuple where the first element are the supports and the second is their label. This can be extended for user-defined infinite sets and/or generation methods. When defining a new set type the default method dispatch should make method an optional argument (making it the default). Otherwise, other method dispatches for a given set must ensure that method is positional argument without a default value (contrary to the definition above).\n\n\n\n\n\n","category":"function"},{"location":"guide/finite_parameter/#finite_param_docs","page":"Finite Parameters","title":"Finite Parameters","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"A guide and manual to the definition and use of finite parameters in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/finite_parameter/#Overview","page":"Finite Parameters","title":"Overview","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Often a mathematical model needs to be optimized several times in accordance with a set of fixed parameter values. In such cases, it is typically preferable to modify these values in place without having to redefine the entire model. This ability is provided in InfiniteOpt via @finite_parameter which permits users to define finite parameters whose values can later be modified as needed. Furthermore, at the optimization step these parameters are replaced with their numeric values. Thus, not adding unnecessary decision variables as is typically done in JuMP models using JuMP.fix on placeholder variables.  ","category":"page"},{"location":"guide/finite_parameter/#Basic-Usage","page":"Finite Parameters","title":"Basic Usage","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Once an InfiniteModel model has been defined we can add a finite parameter via @finite_parameter. For example, let's define a maximum cost parameter called max_cost with an initial value of 42:","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"julia> @finite_parameter(model, max_cost, 42)\nmax_cost","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Notice that a Julia variable called max_cost is returned that contains a GeneralVariableRef that points to the finite parameter we have just created. An array of parameters can also be defined following standard JuMP macro syntax:","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"julia> values = [2, 3.2, 1];\n\njulia> @finite_parameter(model, params[i = 1:3], values[i])\n3-element Array{GeneralVariableRef,1}:\n params[1]\n params[2]\n params[3]","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"The @finite_parameter macro emulates all typical JuMP functionality and can define anonymous parameters, use JuMP containers and more. We refer to its documentation below to learn more. Once a finite parameter is defined the corresponding GeneralVariableRef can be used in expressions, objectives, measures, and constraints just like infinite parameters.","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"The value of a finite parameter can be checked using parameter_value and can modified using JuMP.set_value. For example, let's update the value of max_cost to be now be 10.2:","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"julia> parameter_value(max_cost)\n42.0\n\njulia> set_value(max_cost, 10.2)\n\njulia> parameter_value(max_cost)\n10.2","category":"page"},{"location":"guide/finite_parameter/#Advanced-Details","page":"Finite Parameters","title":"Advanced Details","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"The ability to implement finite parameters stems from its ability to support  mixed variable types using by using the GeneralVariableRef buffer. As such,  finite parameters will be treated as variables until the model is transcribed.  For example, this means that the expression max_cost * x will be treated as a  quadratic expression when it is expressed in its InfiniteOpt form, however it is  converted into the appropriate affine expression when transcripted. ","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"note: Note\nIn previous versions finite parameters were just special cases of infinite  parameters. However, they now have their own distinct underlying data structure. ","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"warning: Warning\nInfiniteOpt's implementation of finite parameters should not be a reason to  use InfiniteOpt to model non-infinite-dimensional problems, since the added  overhead will make it slower than just iteratively building JuMP models.","category":"page"},{"location":"guide/finite_parameter/#Datatypes","page":"Finite Parameters","title":"Datatypes","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Pages   = [\"finite_parameter.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"FiniteParameter\nFiniteParameterIndex\nFiniteParameterRef","category":"page"},{"location":"guide/finite_parameter/#InfiniteOpt.FiniteParameter","page":"Finite Parameters","title":"InfiniteOpt.FiniteParameter","text":"FiniteParameter <: ScalarParameter\n\nA DataType for storing finite parameters meant to be nested in expressions and replaced with their values at runtime.\n\nFields\n\nvalue::Float64: The parameter value.\n\n\n\n\n\n","category":"type"},{"location":"guide/finite_parameter/#InfiniteOpt.FiniteParameterIndex","page":"Finite Parameters","title":"InfiniteOpt.FiniteParameterIndex","text":"FiniteParameterIndex <: ObjectIndex\n\nA DataType for storing the index of a FiniteParameter.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/finite_parameter/#InfiniteOpt.FiniteParameterRef","page":"Finite Parameters","title":"InfiniteOpt.FiniteParameterRef","text":"FiniteParameterRef <: FiniteVariableRef\n\nA DataType for finite parameters references who are replaced with their values at the transcription step.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::FiniteParameterIndex: Index of the parameter in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/finite_parameter/#Methods/Macros","page":"Finite Parameters","title":"Methods/Macros","text":"","category":"section"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"Pages   = [\"finite_parameter.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/finite_parameter/","page":"Finite Parameters","title":"Finite Parameters","text":"@finite_parameter\nparameter_value(::FiniteParameterRef)\nJuMP.set_value(::FiniteParameterRef, ::Real)","category":"page"},{"location":"guide/finite_parameter/#InfiniteOpt.@finite_parameter","page":"Finite Parameters","title":"InfiniteOpt.@finite_parameter","text":"@finite_parameter(model::InfiniteModel, value)::GeneralVariableRef\n\nDefine and add an anonymous finite parameter to model and return its parameter reference. Its value is equal to value.\n\n    @finite_parameter(model::InfiniteModel, param_expr,\n                      value_expr)::GeneralVariableRef\n\nDefine and add a finite parameter(s) to model and return appropriate parameter reference(s). The parameter(s) has/have value(s) indicated by the value_expr. The expression param_expr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe expression value_expr simply expresses the value of the parameter(s). This is typically a number but could be an array indexed using an index defined in param_expr.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\ncontainer: Specify the container type.\n\nExamples\n\njulia> par = @finite_parameter(model, 2)\nnoname\n\njulia> vals = [3, 2];\n\njulia> pars = @finite_parameter(model, [i = 1:2], vals[i], base_name = \"par\")\n2-element Array{ParameterRef,1}:\n par[1]\n par[2]\n\njulia> @finite_parameter(model, par2, 42)\npar2\n\n\n\n\n\n","category":"macro"},{"location":"guide/finite_parameter/#InfiniteOpt.parameter_value-Tuple{FiniteParameterRef}","page":"Finite Parameters","title":"InfiniteOpt.parameter_value","text":"parameter_value(pref::FiniteParameterRef)::Float64\n\nReturn the value of a finite parameter reference pref. Errors if it is an infinite parameter.\n\nExample\n\njulia> value(cost)\n42.0\n\n\n\n\n\n","category":"method"},{"location":"guide/finite_parameter/#JuMP.set_value-Tuple{FiniteParameterRef,Real}","page":"Finite Parameters","title":"JuMP.set_value","text":"JuMP.set_value(pref::FiniteParameterRef, value::Real)::Nothing\n\nSet the value of pref so long as it is a finite parameter. Errors if it is an infinite parameter.\n\nExample\n\njulia> set_value(cost, 27)\n\njulia> value(cost)\n27.0\n\n\n\n\n\n","category":"method"},{"location":"library/#Source-Code-Library","page":"Library","title":"Source Code Library","text":"","category":"section"},{"location":"library/#Infinite-Models","page":"Library","title":"Infinite Models","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/model.md\"]\nModules = [InfiniteOpt]","category":"page"},{"location":"library/#Infinite-Sets","page":"Library","title":"Infinite Sets","text":"","category":"section"},{"location":"library/#Datatypes","page":"Library","title":"Datatypes","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/sets.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"library/#Methods","page":"Library","title":"Methods","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/sets.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"library/#Infinite-Parameters","page":"Library","title":"Infinite Parameters","text":"","category":"section"},{"location":"library/#Datatypes-2","page":"Library","title":"Datatypes","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/parameter.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"library/#Methods/Macros","page":"Library","title":"Methods/Macros","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/parameter.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"library/#Finite-Parameters","page":"Library","title":"Finite Parameters","text":"","category":"section"},{"location":"library/#Methods/Macros-2","page":"Library","title":"Methods/Macros","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/finite_parameter.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"library/#Variables","page":"Library","title":"Variables","text":"","category":"section"},{"location":"library/#Datatypes-3","page":"Library","title":"Datatypes","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/variable.md\"]\nModules = [InfiniteOpt, InfiniteOpt.Collections]\nOrder   = [:type]","category":"page"},{"location":"library/#Methods/Macros-3","page":"Library","title":"Methods/Macros","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/variable.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"library/#Measures","page":"Library","title":"Measures","text":"","category":"section"},{"location":"library/#Datatypes-4","page":"Library","title":"Datatypes","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/measure.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"library/#Methods-2","page":"Library","title":"Methods","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/measure.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:function]","category":"page"},{"location":"library/#Constraints","page":"Library","title":"Constraints","text":"","category":"section"},{"location":"library/#Datatypes-5","page":"Library","title":"Datatypes","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/constraint.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"library/#Methods/Macros-4","page":"Library","title":"Methods/Macros","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/constraint.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"library/#TranscriptionOpt","page":"Library","title":"TranscriptionOpt","text":"","category":"section"},{"location":"library/#Datatypes-6","page":"Library","title":"Datatypes","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/transcribe.md\"]\nModules = [InfiniteOpt, InfiniteOpt.TranscriptionOpt]\nOrder   = [:type]","category":"page"},{"location":"library/#Methods-3","page":"Library","title":"Methods","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/transcribe.md\"]\nModules = [InfiniteOpt, InfiniteOpt.TranscriptionOpt]\nOrder   = [:function]","category":"page"},{"location":"library/#Optimization","page":"Library","title":"Optimization","text":"","category":"section"},{"location":"library/#Methods-4","page":"Library","title":"Methods","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/optimize.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:function]","category":"page"},{"location":"library/#Result-Queries","page":"Library","title":"Result Queries","text":"","category":"section"},{"location":"library/#Methods-5","page":"Library","title":"Methods","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages   = [\"guide/result.md\"]\nModules = [JuMP, InfiniteOpt, InfiniteOpt.TranscriptionOpt]\nOrder   = [:function]","category":"page"},{"location":"guide/objective/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"A guide and manual for specifying and modifying objective functions in InfiniteOpt. The Methods section at the end comprises the manual, and the above sections comprise the guide.","category":"page"},{"location":"guide/objective/#Overview","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Naturally, objective functions serve as a key aspect of optimization problems in general and this is certainly the case with infinite dimensional ones. In InfiniteOpt objectives are defined in much the same way they are in JuMP. One key idea to keep in mind is that the objective must evaluate to a finite expression. Note this means that objectives can only explicitly contain hold variables and point variables. Infinite expressions must be evaluated in a measure to be included (e.g., evaluate the expectation of a random variable).","category":"page"},{"location":"guide/objective/#obj_basic","page":"Objectives","title":"Basic Usage","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Principally, the objective function is specified via @objective as is done in JuMP. For example, let's define the stochastic objective to minimize 05 x_1 + 05 x_2 + mathbbE_xi y^2 - y:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> @infinite_parameter(model, ξ in Normal())\nξ\n\njulia> @infinite_variable(model, y(ξ))\ny(ξ)\n\njulia> @hold_variable(model, x[1:2])\n2-element Array{GeneralVariableRef,1}:\n x[1]\n x[2]\n\njulia> @objective(model, Min, 0.5x[1] + 0.5x[2] + expect(y^2 - y, ξ))\n0.5 x[1] + 0.5 x[2] + expect{ξ}[y(ξ)² - y(ξ)]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Thus, we have defined an objective using InfiniteOpt's straightforward syntax. Note that the second argument indicates the objective sense which can be expressed Min for minimization problems and Max for maximization problems. The objective function (expression) must be finite containing only hold variables, point variables, and/or measures. Also, any included measures must fully integrate over all the infinite parameters contained in its input function. For example, if we define had an infinite variable z(ξ, t) then the measure expect(z, ξ) could not be included since the resulting expression would still be infinite with respect to t. However, adding a measure for t would result in a valid object to add to an objective: integral(expect(z, ξ), t).","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Now we can add objectives to our infinite models. For more detailed information, please review the information below.  ","category":"page"},{"location":"guide/objective/#Queries","page":"Objectives","title":"Queries","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"This section will highlight the available methods for extracting objective information. These are all derived from extensions to JuMP functions and thus follow syntax.","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Principally, these methods correspond to objective_sense, objective_funcion, and objective_function_type which return the objective sense (a subtype of MOI.OptimizationSense), the objective function (expression), and the objective function type, respectively. These methods are demonstrated in accordance with the example presented above in the Basic Usage section:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\njulia> objective_function(model)\n0.5 x[1] + 0.5 x[2] + expect{ξ}[y(ξ)² - y(ξ)]\n\njulia> objective_function_type(model)\nGenericAffExpr{Float64,GeneralVariableRef}","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"The objective sense can be one of three possibilities: MIN_SENSE, MAX_SENSE, or FEASIBILITY_SENSE. The later sense applies to models that contain no objective function.","category":"page"},{"location":"guide/objective/#Modification","page":"Objectives","title":"Modification","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"This section will review the methods that can be used to modify the objective. First, we'll consider the useful set_objective_coefficient method and then we'll explain the methods that enable @objective.","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"The coefficient of a particular variable in an objective can be readily updated via set_objective_coefficient. This is useful repeatedly optimizing an infinite model with varied objective coefficients (e.g., varied tradeoff parameters). For example, let's consider updating the coefficient of x[1] in the previous example from 0.5 to 0.25:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> set_objective_coefficient(model, x[1], 0.25)\n\njulia> objective_function(model)\n0.25 x[1] + 0.5 x[2] + expect{ξ}[y(ξ)² - y(ξ)]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Now let's consider the modification methods that enable the @objective macro. The objective function is specified via set_objective_function which simply updates the expression stored in the objective. For example, let's update out objective to simply be 05x_1 + 05x_2:","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> set_objective_function(model, 0.5x[1] + 0.5x[2])\n\njulia> objective_function(model)\n0.5 x[1] + 0.5 x[2]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"The objective sense is updated via set_objective_sense which can specify the sense as one of the MOI.OptimizationSense subtypes. For example, let's change the current objective to be maximization problem: ``jldoctest obj julia> setobjectivesense(model, MOI.MAX_SENSE)","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"julia> objectivesense(model) MAXSENSE::OptimizationSense = 1","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"\nThe above 2 methods are both called via [`set_objective`](@ref JuMP.set_objective(::InfiniteModel, ::MOI.OptimizationSense, ::Union{JuMP.AbstractJuMPScalar, Real})). This is the\nfunction that enables [`@objective`](@ref) behind the scenes. Thus, the previous\n2 examples could have been implemented equivalently in the following ways:\n``jldoctest obj\njulia> set_objective(model, MOI.MAX_SENSE, 0.5x[1] + 0.5x[2])\n\njulia> @objective(model, Max, 0.5x[1] + 0.5x[2])\n0.5 x[1] + 0.5 x[2]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Notice that @objective offers a more intuitive syntax and is also more efficient at parsing expressions.","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"note: Note\nWhen possible, the @objective since it is more stable and efficient than the set_objective_[aspect] methods due to its enhanced methodology for parsing expressions.","category":"page"},{"location":"guide/objective/#Methods","page":"Objectives","title":"Methods","text":"","category":"section"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"Pages   = [\"objective.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/objective/","page":"Objectives","title":"Objectives","text":"JuMP.objective_sense(::InfiniteModel)\nJuMP.objective_function_type(::InfiniteModel)\nJuMP.objective_function(::InfiniteModel)\nJuMP.set_objective_function(::InfiniteModel, ::JuMP.AbstractJuMPScalar)\nJuMP.set_objective_function(::InfiniteModel, ::Real)\nJuMP.set_objective_sense(::InfiniteModel, ::MOI.OptimizationSense)\nJuMP.set_objective(::InfiniteModel, ::MOI.OptimizationSense, ::Union{JuMP.AbstractJuMPScalar, Real})\nJuMP.set_objective_coefficient(::InfiniteModel, ::GeneralVariableRef, ::Real)\nobjective_has_measures","category":"page"},{"location":"guide/objective/#JuMP.objective_sense-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_sense","text":"JuMP.objective_sense(model::InfiniteModel)::MOI.OptimizationSense\n\nExtend JuMP.objective_sense to return the objective sense of the infinite model model.\n\nExample\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.objective_function_type-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_function_type","text":"JuMP.objective_function_type(model::InfiniteModel)::Type{<:JuMP.AbstractJuMPScalar}\n\nExtend JuMP.objective_function_type to return the objective function type of infinite model model.\n\nExample\n\njulia> objective_function_type(model)\nGenericAffExpr{Float64,GeneralVariableRef}\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.objective_function-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_function","text":"JuMP.objective_function(model::InfiniteModel)::JuMP.AbstractJuMPScalar\n\nExtend JuMP.objective_function to return the objective of infinite model model.\n\nExample\n\njulia> objective_function(model)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective_function-Tuple{InfiniteModel,AbstractJuMPScalar}","page":"Objectives","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(model::InfiniteModel,\n                            func::JuMP.AbstractJuMPScalar)::Nothing\n\nExtend JuMP.set_objective_function to set the objective expression of infinite model model. Errors if func contains infinite variables and/or parameters. Also errors if func contains invalid variables.\n\nExample\n\njulia> set_objective_function(model, 2x + 1)\n\njulia> objective_function(model)\n2 x + 1\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective_function-Tuple{InfiniteModel,Real}","page":"Objectives","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(model::InfiniteModel, func::Real)::Nothing\n\nExtend JuMP.set_objective_function to set the objective expression of model with a number.\n\nExample\n\njulia> set_objective_function(model, 3)\n\njulia> objective_function(model)\n3\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective_sense-Tuple{InfiniteModel,MathOptInterface.OptimizationSense}","page":"Objectives","title":"JuMP.set_objective_sense","text":"JuMP.set_objective_sense(model::InfiniteModel,\n                         sense::MOI.OptimizationSense)::Nothing\n\nExtend JuMP.set_objective_sense to set the objective sense of infinite model model.\n\nExample\n\njulia> set_objective_sense(model, MOI.MIN_SENSE)\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective-Tuple{InfiniteModel,MathOptInterface.OptimizationSense,Union{Real, AbstractJuMPScalar}}","page":"Objectives","title":"JuMP.set_objective","text":"JuMP.set_objective(model::InfiniteModel, sense::MOI.OptimizationSense,\n                   func::Union{JuMP.AbstractJuMPScalar, Real})::Nothing\n\nExtend JuMP.set_objective to set the objective of infinite model model. Errors if func contains infinite variables and/or parameters, or if it does not belong to the model.\n\nExample\n\njulia> set_objective(model, MOI.MIN_SENSE, 2x + 1)\n\njulia> objective_function(model)\n2 x + 1\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective_coefficient-Tuple{InfiniteModel,GeneralVariableRef,Real}","page":"Objectives","title":"JuMP.set_objective_coefficient","text":"JuMP.set_objective_coefficient(model::InfiniteModel,\n                               variable::GeneralVariableRef,\n                               coefficient::Real)::Nothing\n\nExtend JuMP.set_objective_coefficient Set the linear objective coefficient associated with variable to coefficient. Errors if the function type is unsupported.\n\nExample\n\njulia> @hold_variable(model, x)\nx\n\njulia> @hold_variable(model, y)\ny\n\njulia> @objective(model, x + y)\nx + y\n\njulia> set_objective_coefficient(model, y, 2)\n\njulia> objective_function(model)\nx + 2 y\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#InfiniteOpt.objective_has_measures","page":"Objectives","title":"InfiniteOpt.objective_has_measures","text":"objective_has_measures(model::InfiniteModel)::Bool\n\nReturn Bool whether the objective function contains any measures.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#Results","page":"Results","title":"Results","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"A guide and manual to querying optimized InfiniteOpt models. The Methods section at the bottom comprises the manual and the above sections form the guide.","category":"page"},{"location":"guide/result/#Overview","page":"Results","title":"Overview","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"So far we have covered defining, transforming, and optimizing InfiniteModels. Now comes the point to extract information from our optimized model. This is done following extended versions of JuMPs querying functions in combination with the mapping information stored in the optimizer model. Thus, this page will walk through the use of these result query functions.","category":"page"},{"location":"guide/result/#Basic-Usage","page":"Results","title":"Basic Usage","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Let's revisit the example from the optimization page to get us started:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> using InfiniteOpt, JuMP, Ipopt;\n\njulia> model = InfiniteModel(Ipopt.Optimizer);\n\njulia> set_optimizer_attribute(model, \"print_level\", 0);\n\njulia> @infinite_parameter(model, t in [0, 10], num_supports = 10);\n\njulia> @infinite_variable(model, x(t) >= 0);\n\njulia> @hold_variable(model, z >= 0);\n\njulia> @objective(model, Min, 2z);\n\njulia> @constraint(model, c1, z >= x);\n\njulia> @BDconstraint(model, c2(t == 0), x == 42);\n\njulia> print(model)\nMin 2 z\nSubject to\n x(t) ≥ 0.0, ∀ t ∈ [0, 10]\n z ≥ 0.0\n c1 : z - x(t) ≥ 0.0, ∀ t ∈ [0, 10]\n c2 : x(t) = 42.0, ∀ t = 0\n\njulia> optimize!(model)\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit http://projects.coin-or.org/Ipopt\n******************************************************************************","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Now that the model has been optimized, let's find out what happened. To determine why the optimizer stopped, we can use termination_status to report the corresponding MathOptInterface termination code (possible codes are explained here.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Here we see that our model was locally solved via Ipopt and that is why it stopped. Furthermore, we can query the primal and dual problem optimalities via primal_status and dual_status, respectively.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1\n\njulia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"The possible statuses are detailed here. These results are useful in knowing if information can be drawn from the primal and/or dual and what it means. We can also verify that we indeed have answers via has_values which indicates if our model has optimized variable values.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> has_values(model)\ntrue","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"And indeed we do have values.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Now we can query the objective value via objective_value which reports the optimal objective value.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> objective_value(model)\n83.99999998250514","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Great now we can inquire about variable values via value. First, let's retrieve the value of z:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> value(z)\n41.99999999125257","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We get a single value since z is a HoldVariable and therefore finite. Now let's retrieve the \"value\" of x(t) which is infinite with respect to t:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> value(x)\n10-element Array{Float64,1}:\n 42.0\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495\n 20.999999995620495","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Notice here we obtain an array of values since these correspond to the transcribed finite (discretized) variables used to solve the problem. We obtain the corresponding support (discretized t) values via supports:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> supports(x)\n10-element Array{Tuple,1}:\n (0.0,)\n (1.11111111111,)\n (2.22222222222,)\n (3.33333333333,)\n (4.44444444444,)\n (5.55555555556,)\n (6.66666666667,)\n (7.77777777778,)\n (8.88888888889,)\n (10.0,)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"There is 1-to-1 correspondence between these supports and the values reported above. Note that these are stored in tuples to facilitate multiple infinite parameter dependencies.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"note: Note\nThe values for an array of variables is obtained via the vectorized call of value following the syntax:value.(::AbstractArray{<:GeneralVariableRef})This also holds true for many other methods in InfiniteOpt. For example, adding the dot also vectorizes dual and set_binary.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We can also query the dual of a constraint via dual if a model has duals available as indicated by has_duals:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> has_duals(model)\ntrue\n\njulia> dual(c1)\n10-element Array{Float64,1}:\n 1.9999999988666093\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"c1 is an infinite constraint and thus we obtain the duals of its transcribed versions. The underlying infinite parameter(s) and support values are queried via parameter_refs and supports:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> parameter_refs(c1)\n(t,)\n\njulia> supports(c1)\n10-element Array{Tuple,1}:\n (0.0,)\n (1.11111111111,)\n (2.22222222222,)\n (3.33333333333,)\n (4.44444444444,)\n (5.55555555556,)\n (6.66666666667,)\n (7.77777777778,)\n (8.88888888889,)\n (10.0,)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"These again all have a 1-to-1 correspondence.","category":"page"},{"location":"guide/result/#Termination-Queries","page":"Results","title":"Termination Queries","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Termination queries are those that question about how the infinite model was solved and what its optimized state entails. Programmatically, such queries on the InfiniteModel are simply routed to its optimizer model.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"The commonly used queries include termination_status, primal_status, dual_status, objective_value, result_count solve_time. The first four are well exemplified in the Basic Usage section above and are helpful in quickly understanding the optimality status of a given model following the many possible statuses reported by MathOptInterface which are documented here. We use result_count to determine how many solutions are recorded in the optimizer.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> result_count(model)\n1","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"This is useful since it informs what results there are which can be specified via the result keyword argument in many methods such as primal_status, dual_status, objective_value, value, dual, and more.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We use solve_time to determine the time in seconds used by the optimizer until it terminated its search.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> solve_time(model)\n0.004999876022338867","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Note that this query might not be supported with all solvers.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"The above status queries are designed to report information in a consistent format irrespective of the chosen optimizer. However, raw_status will provide the optimality status verbatim as reported by the optimizer. Thus, following our example with Ipopt we obtain:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> raw_status(model)\n\"Solve_Succeeded\"","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Also, we obtain the best objective bound via objective_bound which becomes particularly useful solutions that are suboptimal. However, this method is not supported by all optimizers and in this case Ipopt is one such optimizer.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Finally, we get the best dual objective value via dual_objective_value if the optimizer supplies this information which again Ipopt does not.","category":"page"},{"location":"guide/result/#Variable-Queries","page":"Results","title":"Variable Queries","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Information about the optimized variables is gathered consistently in comparison to typical JuMP models. With InfiniteModels this is done by querying the optimizer model and using its stored variable mappings to return the correct information. Thus, here the queries are extended to work with the specifics of the optimizer model to return the appropriate info.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"First, we should verify that the optimized model in fact has variable values via has_values. In our example, we have:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> has_values(model)\ntrue","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"So we have values readily available to be extracted.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Now value can be used to query the values as shown above in the Basic Usage section. This works by calling the appropriate map_value defined by the optimizer model. By default this, employs the map_value fallback which uses optimizer_model_variable to do the mapping. Details on how to extend these methods for user-defined optimizer models is explained on the Extensions page.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Finally, the optimizer index of a variable is queried via optimizer_index which reports back the index of the variable as used in the MathOptInterface backend:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> optimizer_index(z)\nMathOptInterface.VariableIndex(1)\n\njulia> optimizer_index(x)\n10-element Array{MathOptInterface.VariableIndex,1}:\n MathOptInterface.VariableIndex(2)\n MathOptInterface.VariableIndex(3)\n MathOptInterface.VariableIndex(4)\n MathOptInterface.VariableIndex(5)\n MathOptInterface.VariableIndex(6)\n MathOptInterface.VariableIndex(7)\n MathOptInterface.VariableIndex(8)\n MathOptInterface.VariableIndex(9)\n MathOptInterface.VariableIndex(10)\n MathOptInterface.VariableIndex(11)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"As noted previously, an array is returned for x(t) in accordance with its transcription variables. In similar manner to value, this is enabled by appropriate versions of map_optimizer_index.","category":"page"},{"location":"guide/result/#Constraint-Queries","page":"Results","title":"Constraint Queries","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Like variables, a variety of information can be queried about constraints.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"First, recall that constraints are stored in the form function-in-set where generally function contains the variables and coefficients and the set contains the relational operator and the constant value. With this understanding, we query the value of a constraint's function via value:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> constraint_object(c1).func # show the function expression of c1\nz - x(t)\n\njulia> value(c1)\n10-element Array{Float64,1}:\n -8.747427671096375e-9\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077\n 20.999999995632077","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Again, we obtain an array of values since c1 is infinite due to its dependence on x(t). Behind the scenes this is implemented via the appropriate extensions of map_value.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Next the optimizer index(es) of the transcribed constraints in the MathOptInterface backend provided via optimizer_index.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> optimizer_index(c1)\n10-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(5)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(6)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(7)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(8)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(9)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(10)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Here 10 indices are given in accordance with the transcription constraints. The mapping between these and the original infinite constraints is managed via the appropriate extensions of map_optimizer_index.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"We can also query dual information from our constraints if it is available. First, we should verify that dual information is available via has_duals:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> has_duals(model)\ntrue","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Now we can query the duals via dual.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> dual(c1)\n10-element Array{Float64,1}:\n 1.9999999988666093\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10\n 1.1930560126841273e-10","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Here we obtain the optimal dual values for each transcribed version of c1. This is enabled via the proper extensions of map_dual.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Finally, we query the shadow price of a constraint via shadow_price. This denotes the change in the objective value due to an infinitesimal relaxation of the constraint. For c1 we get:","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> shadow_price(c1)\n10-element Array{Float64,1}:\n -1.9999999988666093\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10\n -1.1930560126841273e-10","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Similarly, the mapping to the transcription constraints is enabled via the appropriate version of map_shadow_price.","category":"page"},{"location":"guide/result/#LP-Sensitivity","page":"Results","title":"LP Sensitivity","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"We also conduct sensitivity analysis for linear problems using lp_rhs_perturbation_range and lp_objective_perturbation_range. These methods will return the ranges indicating how much a constraint RHS constant or a objective coefficient can be changed without violating the feasibility of the solution. This is further explained in the JuMP documentation here. Furthermore, these methods can only be employed for a solver that implements MOI.ConstraintBasisStatus. In our running example up above, Ipopt.jl does not support this A solver like Gurobi.jl does.","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"julia> lp_rhs_perturbation_range(c1)\n10-element Array{Tuple{Float64,Float64},1}:\n (-42.0, Inf)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n\njulia> lp_objective_perturbation_range(z)\n(-2.0, Inf)","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"Note that like other query methods, an array of ranges will be provided with testing the sensitivity of an infinite constraint RHS in accordance with the discretization scheme.","category":"page"},{"location":"guide/result/#Methods","page":"Results","title":"Methods","text":"","category":"section"},{"location":"guide/result/","page":"Results","title":"Results","text":"Pages   = [\"result.md\"]\nModules = [JuMP, InfiniteOpt, InfiniteOpt.TranscriptionOpt]\nOrder   = [:function]","category":"page"},{"location":"guide/result/","page":"Results","title":"Results","text":"JuMP.termination_status(::InfiniteModel)\nJuMP.raw_status(::InfiniteModel)\nJuMP.primal_status(::InfiniteModel)\nJuMP.dual_status(::InfiniteModel)\nJuMP.solve_time(::InfiniteModel)\nJuMP.has_values(::InfiniteModel)\nJuMP.has_duals(::InfiniteModel)\nJuMP.simplex_iterations(::InfiniteModel)\nJuMP.barrier_iterations(::InfiniteModel)\nJuMP.node_count(::InfiniteModel)\nJuMP.objective_bound(::InfiniteModel)\nJuMP.objective_value(::InfiniteModel)\nJuMP.dual_objective_value(::InfiniteModel)\nJuMP.result_count(::InfiniteModel)\nJuMP.value(::GeneralVariableRef)\nJuMP.value(::InfOptConstraintRef)\nJuMP.value(::Union{JuMP.GenericAffExpr{<:Any, <:GeneralVariableRef}, JuMP.GenericQuadExpr{<:Any, <:GeneralVariableRef}})\nJuMP.optimizer_index(::GeneralVariableRef)\nJuMP.optimizer_index(::InfOptConstraintRef)\nJuMP.dual(::InfOptConstraintRef)\nJuMP.shadow_price(::InfOptConstraintRef)\nJuMP.lp_rhs_perturbation_range(::InfOptConstraintRef)\nJuMP.lp_objective_perturbation_range(::GeneralVariableRef)\nInfiniteOpt.map_value\nInfiniteOpt.map_optimizer_index\nInfiniteOpt.map_dual\nInfiniteOpt.map_shadow_price\nInfiniteOpt.map_lp_rhs_perturbation_range\nInfiniteOpt.map_lp_objective_perturbation_range","category":"page"},{"location":"guide/result/#JuMP.termination_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.termination_status","text":"JuMP.termination_status(model::InfiniteModel)\n\nExtend termination_status to return the MOI.TerminationStatus in accordance with the optimizer model.\n\nExample\n\njulia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.raw_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.raw_status","text":"JuMP.raw_status(model::InfiniteModel)\n\nExtend raw_status to return the status reported by the solver in accordance with the optimizer model.\n\nExample\n\njulia> raw_status(model) # Ipopt\n\"Solve_Succeeded\"\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.primal_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.primal_status","text":" JuMP.primal_status(model::InfiniteModel; [result::Int = 1])\n\nExtend primal_status to return the MOI.PrimalStatus reported in accordance with the optimizer model and the result index result of the most recent solution obtained.\n\nExample\n\njulia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.dual_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.dual_status","text":"JuMP.dual_status(model::InfiniteModel; [result::Int = 1])\n\nExtend dual_status to return the MOI.DualStatus reported in accordance with the optimizer model and the result index result of the most recent solution obtained.\n\nExample\n\njulia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.solve_time-Tuple{InfiniteModel}","page":"Results","title":"JuMP.solve_time","text":"JuMP.solve_time(model::InfiniteModel)\n\nExtend solve_time to return the time used by the solver to terminate reported in accordance with the optimizer model. This will error if not supported by the solver.\n\nExample\n\njulia> solve_time(model)\n0.004999876022338867\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.has_values-Tuple{InfiniteModel}","page":"Results","title":"JuMP.has_values","text":"JuMP.has_values(model::InfiniteModel; [result::Int = 1])::Bool\n\nExtend has_values to return a Bool whether variable values are available in accordance with the optimizer model and the result index result of the most recent solution obtained.\n\nExample\n\njulia> has_values(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.has_duals-Tuple{InfiniteModel}","page":"Results","title":"JuMP.has_duals","text":"JuMP.has_duals(model::InfiniteModel; [result::Int = 1])::Bool\n\nExtend has_duals to return a Bool whether constraint duals are available in accordance with the optimizer model and the result index result of the most recent solution obtained.\n\nExample\n\njulia> has_duals(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.simplex_iterations-Tuple{InfiniteModel}","page":"Results","title":"JuMP.simplex_iterations","text":"simplex_iterations(model::InfiniteModel)\n\nGets the cumulative number of simplex iterations during the most-recent optimization.\n\nSolvers must implement MOI.SimplexIterations() to use this function.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.barrier_iterations-Tuple{InfiniteModel}","page":"Results","title":"JuMP.barrier_iterations","text":"barrier_iterations(model::InfiniteModel)\n\nGets the cumulative number of barrier iterations during the most-recent optimization.\n\nSolvers must implement MOI.BarrierIterations() to use this function.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.node_count-Tuple{InfiniteModel}","page":"Results","title":"JuMP.node_count","text":"node_count(model::InfiniteModel)\n\nGets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.\n\nSolvers must implement MOI.NodeCount() to use this function.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.objective_bound-Tuple{InfiniteModel}","page":"Results","title":"JuMP.objective_bound","text":"JuMP.objective_bound(model::InfiniteModel)::Float64\n\nExtend objective_bound to return the objective bound in accordance with the optimizer model.\n\nExample\n\njulia> objective_bound(model)\n42.0\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.objective_value-Tuple{InfiniteModel}","page":"Results","title":"JuMP.objective_value","text":"JuMP.objective_value(model::InfiniteModel; [result::Int = 1])::Float64\n\nExtend objective_value to return the objective value in accordance with the optimizer model and the result index result of the most recent solution obtained.\n\nExample\n\njulia> objective_value(model)\n42.0\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.dual_objective_value-Tuple{InfiniteModel}","page":"Results","title":"JuMP.dual_objective_value","text":"JuMP.dual_objective_value(model::InfiniteModel; [result::Int = 1])::Float64\n\nExtend dual_objective_value to return the dual objective value in accordance with the optimizer model and the result index result of the most recent solution obtained. Errors if the solver does not support this.\n\nExample\n\njulia> dual_objective_value(model)\n42.0\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.result_count-Tuple{InfiniteModel}","page":"Results","title":"JuMP.result_count","text":"JuMP.result_count(model::InfiniteModel)\n\nExtend result_count to return the number of results available to query after a call to optimize!.\n\nExample\n\njulia> result_count(model)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.value-Tuple{GeneralVariableRef}","page":"Results","title":"JuMP.value","text":"JuMP.value(vref::GeneralVariableRef; [result::Int = 1])\n\nExtend JuMP.value to return the value(s) of vref in accordance with its reformulation variable(s) stored in the optimizer model and the result index result of the most recent solution obtained. Use JuMP.has_values to check if a result exists before asking for values. For extensions, this only works if optimizer_model_variable has been extended correctly and/or map_value has been extended for variables. To provide context for the results it may be helpful to also query the variable's parameter_refs and supports which will have a one-to-one correspondence with the value(s). It may also be helpful to query via optimizer_model_variable to retrieve the variables(s) that these values are based on.\n\nExample\n\njulia> value(z)\n42.0\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.value-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.value","text":"JuMP.value(cref::InfOptConstraintRef; [result::Int = 1])\n\nExtend JuMP.value to return the value(s) of cref in accordance with its reformulation constraint(s) stored in the optimizer model and the result index result of the most recent solution obtained. Use JuMP.has_values to check if a result exists before asking for values. For extensions, this only works if optimizer_model_constraint has been extended correctly and/or map_value has been extended for constraints. To provide context for the results it may be helpful to also query the constraint's parameter_refs and supports which will have a one-to-one correspondence with the value(s). It may also be helpful to query via optimizer_model_constraint to retrieve the constraint(s) that these values are based on.\n\nExample\n\njulia> value(c1)\n4-element Array{Float64,1}:\n -0.0\n 20.9\n 20.9\n 20.9\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.value-Tuple{Union{GenericAffExpr{#s38,#s9} where #s9<:GeneralVariableRef where #s38, GenericQuadExpr{#s5,#s2} where #s2<:GeneralVariableRef where #s5}}","page":"Results","title":"JuMP.value","text":"value(ex::GenericAffExpr, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nJuMP.value(expr::JuMP.AbstractJuMPScalar; result::Int = 1)\n\nReturn the value(s) of expr in accordance with the optimized variable values the result index result of the most recent solution obtained. Use JuMP.has_values to check if a result exists before asking for values. To provide context for the results it may be helpful to also query the expression's parameter_refs and supports which will have a one-to-one correspondence with the value(s). It may also be helpful to query via optimizer_model_expression to retrieve the expression(s) that these values are based on.\n\nFor extensions, this only works if optimizer_model_expression has been extended correctly and/or map_value has been extended for expressions.\n\nExample\n\njulia> value(my_finite_expr)\n23.34\n\njulia> value(my_infinite_expr)\n4-element Array{Float64,1}:\n -0.0\n 20.9\n 20.9\n 20.9\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.optimizer_index-Tuple{GeneralVariableRef}","page":"Results","title":"JuMP.optimizer_index","text":"JuMP.optimizer_index(vref::GeneralVariableRef)\n\nExtend JuMP.optimizer_index to return the MathOptInterface index(es) of vref in accordance with its reformulation variable(s) stored in the optimizer model. For extensions, this only works if optimizer_model_variable has been extended correctly and/or map_optimizer_index has been extended for variables. It may also be helpful to query via optimizer_model_variable to retrieve the variables(s) that these indices are based on.\n\nExample\n\njulia> optimizer_index(x)\n4-element Array{MathOptInterface.VariableIndex,1}:\n MathOptInterface.VariableIndex(2)\n MathOptInterface.VariableIndex(3)\n MathOptInterface.VariableIndex(4)\n MathOptInterface.VariableIndex(5)\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.optimizer_index-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.optimizer_index","text":"JuMP.optimizer_index(cref::InfOptConstraintRef)\n\nExtend JuMP.optimizer_index to return the MathOptInterface index(es) of cref in accordance with its reformulation constraints(s) stored in the optimizer model. For extensions, this only works if optimizer_model_constraint has been extended correctly and/or map_optimizer_index has been extended for constraints. It may also be helpful to query via optimizer_model_constraint to retrieve the constraints(s) that these indices are based on.\n\nExample\n\njulia> optimizer_index(c1)\n4-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)\n MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.dual-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.dual","text":"JuMP.dual(cref::InfOptConstraintRef; [result::Int = 1])\n\nExtend JuMP.dual to return the dual(s) of cref in accordance with its reformulation constraint(s) stored in the optimizer model and the result index result of the most recent solution obtained. Use JuMP.has_duals to check if a result exists before asking for duals. For extensions, this only works if optimizer_model_constraint has been extended correctly and/or map_dual has been extended for constraints. It may also be helpful to query via optimizer_model_constraint to retrieve the constraint(s) that these duals are based on. Calling parameter_refs and supports may also be insightful.\n\nExample\n\njulia> dual(c1)\n4-element Array{Float64,1}:\n -42.0\n -42.0\n 32.3\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.shadow_price-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.shadow_price","text":"JuMP.shadow_price(cref::InfOptConstraintRef)\n\nExtend JuMP.shadow_price to return the shadow price(s) of cref in accordance with its reformulation constraint(s) stored in the optimizer model. Use JuMP.has_duals to check if a result exists before asking for duals. For extensions, this only works if optimizer_model_constraint has been extended correctly and/or map_shadow_price has been extended for constraints. It may also be helpful to query via optimizer_model_constraint to retrieve the constraint(s) that these shadow prices are based on. Calling parameter_refs and supports may also be insightful.\n\nExample\n\njulia> shadow_price(c1)\n4-element Array{Float64,1}:\n 42.0\n 42.0\n -32.3\n -0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.lp_rhs_perturbation_range-Tuple{InfOptConstraintRef}","page":"Results","title":"JuMP.lp_rhs_perturbation_range","text":"JuMP.lp_rhs_perturbation_range(cref::InfOptConstraintRef;\n                               [feasibility_tolerance::Float64 = 1e-8])\n\nExtend JuMP.lp_rhs_perturbation_range to return the range(s) of the RHS of cref for which the shadow price(s) are valid in accordance with its reformulation constraint(s) stored in the optimizer model. For extensions, this only works if optimizer_model_constraint has been extended correctly and/or map_lp_rhs_perturbation_range has been implemented. It may also be helpful to query via optimizer_model_constraint to retrieve the constraint(s) that these ranges are based on. Calling parameter_refs and supports may also be insightful.\n\nExample\n\njulia> lp_rhs_perturbation_range(c1)\n4-element Array{Tuple{Float64,Float64},1}:\n (-42.0, Inf)\n (-Inf, 42.0)\n (-Inf, 42.0)\n (-Inf, 42.0)\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.lp_objective_perturbation_range-Tuple{GeneralVariableRef}","page":"Results","title":"JuMP.lp_objective_perturbation_range","text":"JuMP.lp_objective_perturbation_range(vref::InfOptVariableRef;\n                                     [optimality_tolerance::Float64 = 1e-8])\n\nExtend JuMP.lp_objective_perturbation_range to return the range(s) that the reduced cost(s) of vref remain valid in accordance with its reformulation variables(s) stored in the optimizer model. For extensions, this only works if optimizer_model_variable has been extended correctly and/or if map_lp_objective_perturbation_range has been implemented. It may also be helpful to query via optimizer_model_variable to retrieve the variable(s) that these ranges are based on. Calling parameter_refs and supports may also be insightful.\n\nExample\n\njulia> lp_objective_perturbation_range(z)\n(-2.0, Inf)\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_value","page":"Results","title":"InfiniteOpt.map_value","text":"map_value([ref/expr], key::Val{ext_key_name}, result::Int)\n\nMap the value(s) of ref to its counterpart in the optimizer model type that is distininguished by its extension key key as type Val{ext_key_name}. Here ref need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend optimizer_model_variable, optimizer_model_expression, and/or optimizer_model_constraint. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, optimizer_model_variable, optimizer_model_expression, and optimizer_model_constraint are used to make these mappings by default. Here result is the result index used in value.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_optimizer_index","page":"Results","title":"InfiniteOpt.map_optimizer_index","text":"map_optimizer_index(ref, key::Val{ext_key_name})\n\nMap the MathOptInterface index(es) of ref to its counterpart in the optimizer model type that is distininguished by its extension key key as type Val{ext_key_name}. Here ref need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend optimizer_model_variable and optimizer_model_constraint. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, optimizer_model_variable and optimizer_model_constraint are used to make these mappings by default.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_dual","page":"Results","title":"InfiniteOpt.map_dual","text":"map_dual(cref::InfOptConstraintRef, key::Val{ext_key_name}, result::Int)\n\nMap the dual(s) of cref to its counterpart in the optimizer model type that is distininguished by its extension key key as type Val{ext_key_name}. Here ref need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend optimizer_model_variable and optimizer_model_constraint. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, optimizer_model_variable and optimizer_model_constraint are used to make these mappings by default. Here result is the result index that is used in dual.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_shadow_price","page":"Results","title":"InfiniteOpt.map_shadow_price","text":"map_shadow_price(cref::InfOptConstraintRef, key::Val{ext_key_name})\n\nMap the shadow price(s) of cref to its counterpart in the optimizer model type that is distininguished by its extension key key as type Val{ext_key_name}. Here ref need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend optimizer_model_variable and optimizer_model_constraint. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, optimizer_model_variable and optimizer_model_constraint are used to make these mappings by default.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_lp_rhs_perturbation_range","page":"Results","title":"InfiniteOpt.map_lp_rhs_perturbation_range","text":"map_lp_rhs_perturbation_range(cref::InfOptConstraintRef,\n                              key::Val{ext_key_name}, toler::Float64)\n\nMap the RHS perturbation range of cref to its counterpart in the optimizer model type that is distininguished by its extension key key as type Val{ext_key_name}. Here cref need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend optimizer_model_constraint. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, optimizer_model_constraint is used to make these mappings by default. Here toler corresponds to the feasibility_tolerance used by lp_rhs_perturbation_range.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_lp_objective_perturbation_range","page":"Results","title":"InfiniteOpt.map_lp_objective_perturbation_range","text":"map_lp_objective_perturbation_range(vref::DecisionVariableRef,\n                                    key::Val{ext_key_name}, toler::Float64)\n\nMap the reduced cost range(s) of vref to its counterpart in the optimizer model type that is distininguished by its extension key key as type Val{ext_key_name}. Here vref need refer to methods for both variable references and constraint references. This only needs to be defined for reformulation extensions that cannot readily extend optimizer_model_variable. Such as is the case with reformuations that do not have a direct mapping between variables and/or constraints in the original infinite form. Otherwise, optimizer_model_variable is used to make these mappings by default. Here toler corresponds to the optimality_tolerance used by lp_objective_perturbation_range.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#expr_page","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"A guide for the defining and understanding the variable expressions used in InfiniteOpt.","category":"page"},{"location":"guide/expression/#Overview","page":"Expressions","title":"Overview","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Expressions in InfiniteOpt (also called functions) refer to mathematical statements involving variables and numbers. Thus, these comprise the mathematical expressions used that are used in measures, objectives, and constraints. Programmatically, InfiniteOpt simply extends JuMP expression types and methods principally pertaining to affine and quadratic mathematical expressions. A natively supported abstraction for general nonlinear expressions is planned for development since that of JuMP is not readily extendable.","category":"page"},{"location":"guide/expression/#Variable-Hierarchy","page":"Expressions","title":"Variable Hierarchy","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Expressions employ variable reference types inherited from JuMP.AbstractVariableRef to form expression objects. InfiniteOpt uses a hierarchy of such types to organize the complexities associated with modeling infinite dimensional programs. The figure below summarizes this hierarchy of variable reference types where the abstract types are depicted in green and the concrete types are shown blue.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"(Image: tree)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"In consistently with JuMP expression support, GeneralVariableRef exists as a variable reference type that is able to represent any of the above conrete subtypes of DispatchVariableRef. This allows the expression containers to be homogeneous in variable type. This is a paradigm shift from previous versions of InfiniteOpt that used the hierarchy of types directly to construct expressions. This behavior led to stability and performance limitations and thus a has been discontinued.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"However, the variable hierarchy is still used to create for variable methods. To accomplish this appropriate GeneralVariableRef dispatch methods are implemented (which are detailed in User Methods section at the bottom of this page) that utilize dispatch_variable_ref to create the appropriate concrete subtype of DispatchVariableRef and call the appropriate underlying method. These dispatch methods have been implemented for all public methods and the underlying methods are what are documented in the method manuals throughout the User Guide pages.","category":"page"},{"location":"guide/expression/#Affine-Expressions","page":"Expressions","title":"Affine Expressions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"An affine expression pertains to a mathematical function of the form:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"f_a(x) = a_1x_1 +  + a_nx_n + b","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"where x in mathbbR^n denote variables, a in mathbbR^n denote coefficients, and b in mathbbR denotes a constant value. Such expressions, are prevalent in any problem than involves linear constraints and/or objectives.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"In InfiniteOpt, affine expressions can be defined directly using Julia's arithmetic operators (i.e., +, -, *, etc.) or using @expression.  For example, let's define the expression 2y(t) + z - 3t noting that the following methods are equivalent:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_variable(model, y(t))\ny(t)\n\njulia> @hold_variable(model, z)\nz\n\njulia> expr = 2y + z - 3t\n2 y(t) + z - 3 t\n\njulia> expr = 2 * y + z - 3 * t\n2 y(t) + z - 3 t\n\njulia> expr = @expression(model, 2y + z - 3t)\n2 y(t) + z - 3 t\n\njulia> typeof(expr)\nGenericAffExpr{Float64,GeneralVariableRef}","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Notice that coefficients to variables can simply be put alongside variables without having to use the * operator. Also, note that all of these expressions are stored in a container referred to as a GenericAffExpr which is a JuMP object for storing affine expressions.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"note: Note\nWhere possible, it is preferable to use @expression for defining expressions as it is much more efficient than explicitly using the standard operators.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"GenericAffExpr objects contain 2 fields which are:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"constant::CoefType The constant value of the affine expression.\nterms::OrderDict{VarType, CoefType} A dictionary mapping variables to coefficients.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"For example, let's see what these fields look like in the above example:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> expr.terms\nOrderedCollections.OrderedDict{GeneralVariableRef,Float64} with 3 entries:\n  y(t) => 2.0\n  z    => 1.0\n  t    => -3.0\n\njulia> expr.constant\n0.0","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Notice that the ordered dictionary preserves the order in which the variables appear in the expression.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"More information can be found in the documentation for affine expressions in JuMP.","category":"page"},{"location":"guide/expression/#Quadratic-Expressions","page":"Expressions","title":"Quadratic Expressions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"A quadratic function pertains to a mathematical function of the form:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"f_q(x) = a_1x_1^2 + a_2 x_1 x_2 +  + a_m x_n^2 + f_a(x)","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"where x in mathbbR^n are the variables, f_a(x) mathbbR^n mapsto mathbbR is an affine function, and m = n(n+1)2 is the number of unique combinations of variables x. Like affine expressions, quadratic expressions can be defined via Julia's arithmetic operators or via @expression. For example, let's define 2y^2(t) - zy(t) + 42t - 3 using the following equivalent methods:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> expr = 2y^2 - z * y + 42t - 3\n2 y(t)² - z*y(t) + 42 t - 3\n\njulia> expr = @expression(model, 2y^2 - z * y + 42t - 3)\n2 y(t)² - y(t)*z + 42 t - 3\n\njulia> typeof(expr)\nGenericQuadExpr{Float64,GeneralVariableRef}","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Again, notice that coefficients need not employ *. Also, the object used to store the expression is a GenericQuadExpr which is a JuMP object used for storing quadratic expressions.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"GenericQuadExpr object contains 2 data fields which are:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"aff::GenericAffExpr{CoefType,VarType} An affine expression\nterms::OrderedDict{UnorderedPair{VarType}, CoefType} A dictionary mapping quadratic variable pairs to coefficients.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Here the UnorderedPair type is unique to JuMP and contains the fields:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"a::AbstractVariableRef One variable in a quadratic pair\nb::AbstractVariableRef The other variable in a quadratic pair.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Thus, this form can be used to store arbitrary quadratic expressions. For example, let's look at what these fields look like in the above example:","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"julia> expr.aff\n42 t - 3\n\njulia> typeof(expr.aff)\nGenericAffExpr{Float64,GeneralVariableRef}\n\njulia> expr.terms\nOrderedCollections.OrderedDict{UnorderedPair{GeneralVariableRef},Float64} with 2 entries:\n  UnorderedPair{GeneralVariableRef}(y(t), y(t)) => 2.0\n  UnorderedPair{GeneralVariableRef}(y(t), z)    => -1.0","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Notice again that the ordered dictionary preserves the order.","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"tip: Tip\nPolynomial expressions can be represented by introducing dumby variables and nested quadratic/affine expressions. For instance, z^3 + 2 can be expressed by introducing a dumby variable x = z^2:julia> @hold_variable(model, x)\nx\n\njulia> @constraint(model, x == z^2)\n-z² + x = 0.0\n\njulia> expr = @expression(model, z * x + 2)\nz*x + 2","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"More information can be found in the documentation for quadratic expressions in JuMP.","category":"page"},{"location":"guide/expression/#Nonlinear-Expressions","page":"Expressions","title":"Nonlinear Expressions","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"General nonlinear expressions as generated via @NLexpression and similar methods in JuMP are not yet extended for InfiniteOpt. This is because JuMP does not readily support nonlinear extensions, but a native nonlinear implementation is planned for development and should be released in the relatively near future.","category":"page"},{"location":"guide/expression/#DataTypes","page":"Expressions","title":"DataTypes","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Pages   = [\"expression.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"GeneralVariableRef\nDispatchVariableRef\nMeasureFiniteVariableRef\nFiniteVariableRef","category":"page"},{"location":"guide/expression/#InfiniteOpt.GeneralVariableRef","page":"Expressions","title":"InfiniteOpt.GeneralVariableRef","text":"GeneralVariableRef <: JuMP.AbstractVariableRef\n\nA DataType that serves as the principal variable reference in InfiniteOpt for building variable expressions. It contains the needed information to create a variable type specifc reference (e.g., InfiniteVariableRef) via dispatch_variable_ref to obtain the correct subtype of DispatchVariableRef based off of index_type. This allows us to construct expressions using concrete containers unlike previous versions of InfiniteOpt which provides us a significant performance boost.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nraw_index::Int: The raw index to be used in the index_type constructor.\nindex_type::DataType: The concrete AbstractInfOptIndex type/constructor.\nparam_index::Int: The index of a parameter in DependentParameters. This is ignored for other variable types.\n\n\n\n\n\n","category":"type"},{"location":"guide/expression/#InfiniteOpt.DispatchVariableRef","page":"Expressions","title":"InfiniteOpt.DispatchVariableRef","text":"DispatchVariableRef <: JuMP.AbstractVariableRef\n\nAn abstract type for variable references that are created from GeneralVariableRefs and are used to dispatch to the appropriate methods for that particular variable/parameter/measure type.\n\n\n\n\n\n","category":"type"},{"location":"guide/expression/#InfiniteOpt.MeasureFiniteVariableRef","page":"Expressions","title":"InfiniteOpt.MeasureFiniteVariableRef","text":"MeasureFiniteVariableRef <: DispatchVariableRef\n\nAn abstract type to define finite variable and measure references.\n\n\n\n\n\n","category":"type"},{"location":"guide/expression/#InfiniteOpt.FiniteVariableRef","page":"Expressions","title":"InfiniteOpt.FiniteVariableRef","text":"FiniteVariableRef <: MeasureFiniteVariableRef\n\nAn abstract type to define new finite variable references.\n\n\n\n\n\n","category":"type"},{"location":"guide/expression/#Expression-Methods","page":"Expressions","title":"Expression Methods","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"parameter_refs(::Union{JuMP.GenericAffExpr, JuMP.GenericQuadExpr})","category":"page"},{"location":"guide/expression/#InfiniteOpt.parameter_refs-Tuple{Union{GenericAffExpr, GenericQuadExpr}}","page":"Expressions","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(expr)::Tuple\n\nReturn the tuple of infinite parameter references that determine the infinite dependencies of expr.\n\nExample\n\njulia> parameter_refs(my_expr)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#GeneralVariableRef-User-Methods","page":"Expressions","title":"GeneralVariableRef User Methods","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"Pages   = [\"expression.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"JuMP.owner_model(::GeneralVariableRef)\nJuMP.owner_model(::DispatchVariableRef)\nJuMP.index(::GeneralVariableRef)\nJuMP.index(::DispatchVariableRef)\ndispatch_variable_ref(::GeneralVariableRef)\ndispatch_variable_ref\nJuMP.name(::GeneralVariableRef)\nJuMP.set_name(::GeneralVariableRef, ::String)\nJuMP.is_valid(::InfiniteModel,::GeneralVariableRef)\nJuMP.is_valid(::InfiniteModel, ::DispatchVariableRef)\nused_by_infinite_variable(::GeneralVariableRef)\nused_by_point_variable(::GeneralVariableRef)\nused_by_measure(::GeneralVariableRef)\nused_by_objective(::GeneralVariableRef)\nused_by_constraint(::GeneralVariableRef)\nis_used(::GeneralVariableRef)\nparameter_value(::GeneralVariableRef)\nJuMP.set_value(::GeneralVariableRef, ::Real)\ninfinite_set(::GeneralVariableRef)\ninfinite_set(::AbstractArray{<:GeneralVariableRef})\nset_infinite_set(::GeneralVariableRef, ::InfiniteScalarSet)\nset_infinite_set(::AbstractArray{<:GeneralVariableRef}, ::InfiniteArraySet)\nnum_supports(::GeneralVariableRef)\nnum_supports(::AbstractArray{<:GeneralVariableRef})\nhas_supports(::GeneralVariableRef)\nhas_supports(::AbstractArray{<:GeneralVariableRef})\nsupports(::GeneralVariableRef)\nsupports(::AbstractArray{<:GeneralVariableRef})\nset_supports(::GeneralVariableRef,::Union{Real, Vector{<:Real}})\nset_supports(::AbstractArray{<:GeneralVariableRef},::Union{Array{<:Real, 2}, AbstractArray{<:Vector{<:Real}}})\nadd_supports(::GeneralVariableRef,::Union{Real, Vector{<:Real}})\nadd_supports(::AbstractArray{<:GeneralVariableRef},::Union{Array{<:Real, 2}, AbstractArray{<:Vector{<:Real}}})\ndelete_supports(::GeneralVariableRef)\ndelete_supports(::AbstractArray{<:GeneralVariableRef})\nfill_in_supports!(::GeneralVariableRef)\nfill_in_supports!(::AbstractArray{<:GeneralVariableRef})\nraw_parameter_refs(::GeneralVariableRef)\nparameter_refs(::GeneralVariableRef)\nparameter_list(::GeneralVariableRef)\ninfinite_variable_ref(::GeneralVariableRef)\neval_supports(::GeneralVariableRef)\nraw_parameter_values(::GeneralVariableRef)\nparameter_values(::GeneralVariableRef)\nparameter_bounds(::GeneralVariableRef)\nhas_parameter_bounds(::GeneralVariableRef)\nset_parameter_bounds(::GeneralVariableRef,::ParameterBounds{GeneralVariableRef})\nadd_parameter_bounds(::GeneralVariableRef,::ParameterBounds{GeneralVariableRef})\ndelete_parameter_bounds(::GeneralVariableRef)\nsignificant_digits(::GeneralVariableRef)\nmeasure_function(::GeneralVariableRef)\nmeasure_data(::GeneralVariableRef)\nis_analytic(::GeneralVariableRef)\nJuMP.delete(::InfiniteModel, ::GeneralVariableRef)\nJuMP.delete(::InfiniteModel,::AbstractArray{<:GeneralVariableRef})\nJuMP.has_lower_bound(::GeneralVariableRef)\nJuMP.lower_bound(::GeneralVariableRef)\nJuMP.set_lower_bound(::GeneralVariableRef,::Real)\nJuMP.LowerBoundRef(::GeneralVariableRef)\nJuMP.delete_lower_bound(::GeneralVariableRef)\nJuMP.has_upper_bound(::GeneralVariableRef)\nJuMP.upper_bound(::GeneralVariableRef)\nJuMP.set_upper_bound(::GeneralVariableRef,::Real)\nJuMP.UpperBoundRef(::GeneralVariableRef)\nJuMP.delete_upper_bound(::GeneralVariableRef)\nJuMP.is_fixed(::GeneralVariableRef)\nJuMP.fix_value(::GeneralVariableRef)\nJuMP.fix(::GeneralVariableRef, ::Real)\nJuMP.FixRef(::GeneralVariableRef)\nJuMP.unfix(::GeneralVariableRef)\nJuMP.start_value(::GeneralVariableRef)\nJuMP.set_start_value(::GeneralVariableRef, ::Real)\nstart_value_function(::GeneralVariableRef)\nset_start_value_function(::GeneralVariableRef, ::Any)\nreset_start_value_function(::GeneralVariableRef)\nJuMP.is_binary(::GeneralVariableRef)\nJuMP.set_binary(::GeneralVariableRef)\nJuMP.BinaryRef(::GeneralVariableRef)\nJuMP.unset_binary(::GeneralVariableRef)\nJuMP.is_integer(::GeneralVariableRef)\nJuMP.set_integer(::GeneralVariableRef)\nJuMP.IntegerRef(::GeneralVariableRef)\nJuMP.unset_integer(::GeneralVariableRef)","category":"page"},{"location":"guide/expression/#JuMP.owner_model-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::GeneralVariableRef)::InfiniteModel\n\nExtend JuMP.owner_model to return the model where vref is stored.\n\nExample\n\njulia> owner_model(vref)\nAn InfiniteOpt Model\nFeasibility problem with:\nFinite Parameters: 0\nInfinite Parameters: 0\nVariable: 1\nMeasures: 0\n`HoldVariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\n`HoldVariableRef`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\nNames registered in the model: vref\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.owner_model-Tuple{DispatchVariableRef}","page":"Expressions","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::DispatchVariableRef)::InfiniteModel\n\nExtend JuMP.owner_model to return the model where vref is stored.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.index-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.index","text":"JuMP.index(vref::GeneralVariableRef)::AbstractInfOptIndex\n\nExtend JuMP.index to return the appropriate index of vref.\n\nExample\n\njulia> index(vref)\nHoldVariableIndex(1)\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.index-Tuple{DispatchVariableRef}","page":"Expressions","title":"JuMP.index","text":"JuMP.index(vref::DispatchVariableRef)::AbstractInfOptIndex\n\nExtend JuMP.index to return the appropriate index of vref.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.dispatch_variable_ref-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.dispatch_variable_ref","text":"dispatch_variable_ref(vef::GeneralVariableRef)::DispatchVariableRef\n\nReturn the concrete DispatchVariableRef this associated with vref. This relies on dispatch_variable_ref being extended for the index type, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.dispatch_variable_ref","page":"Expressions","title":"InfiniteOpt.dispatch_variable_ref","text":"dispatch_variable_ref(model::InfiniteModel, index::AbstractInfOptIndex)\n\nReturn the variable reference associated the type of index. This needs to be defined for each variable reference type.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#JuMP.name-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.name","text":"JuMP.name(vref::GeneralVariableRef)::String\n\nExtend JuMP.name to return the name of vref. It relies on JuMP.name being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.set_name-Tuple{GeneralVariableRef,String}","page":"Expressions","title":"JuMP.set_name","text":"JuMP.set_name(vref::GeneralVariableRef, name::String)::Nothing\n\nExtend JuMP.set_name to set the name of vref. It relies on JuMP.set_name being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.is_valid-Tuple{InfiniteModel,GeneralVariableRef}","page":"Expressions","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::GeneralVariableRef)::Bool\n\nExtend JuMP.is_valid to return Bool if vref is a valid reference.\n\nExample\n\njulia> is_valid(model, vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.is_valid-Tuple{InfiniteModel,DispatchVariableRef}","page":"Expressions","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::DispatchVariableRef)::Bool\n\nExtend JuMP.is_valid to return Bool if vref is a valid reference.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.used_by_infinite_variable-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_infinite_variable","text":"InfiniteOpt.used_by_infinite_variable(vref::GeneralVariableRef)::Bool\n\nDefine InfiniteOpt.used_by_infinite_variable for general variable references. It relies on InfiniteOpt.used_by_infinite_variable being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.used_by_point_variable-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_point_variable","text":"InfiniteOpt.used_by_point_variable(vref::GeneralVariableRef)::Bool\n\nDefine InfiniteOpt.used_by_point_variable for general variable references. It relies on InfiniteOpt.used_by_point_variable being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.used_by_measure-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_measure","text":"InfiniteOpt.used_by_measure(vref::GeneralVariableRef)::Bool\n\nDefine InfiniteOpt.used_by_measure for general variable references. It relies on InfiniteOpt.used_by_measure being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.used_by_objective-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_objective","text":"InfiniteOpt.used_by_objective(vref::GeneralVariableRef)::Bool\n\nDefine InfiniteOpt.used_by_objective for general variable references. It relies on InfiniteOpt.used_by_objective being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.used_by_constraint-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.used_by_constraint","text":"InfiniteOpt.used_by_constraint(vref::GeneralVariableRef)::Bool\n\nDefine InfiniteOpt.used_by_constraint for general variable references. It relies on InfiniteOpt.used_by_constraint being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.is_used-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.is_used","text":"InfiniteOpt.is_used(vref::GeneralVariableRef)::Bool\n\nDefine InfiniteOpt.is_used for general variable references. It relies on InfiniteOpt.is_used being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.parameter_value-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_value","text":"InfiniteOpt.parameter_value(prefs; [kwargs...])\n\nDefine InfiniteOpt.parameter_value for general variable references. It relies on InfiniteOpt.parameter_value being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.set_value-Tuple{GeneralVariableRef,Real}","page":"Expressions","title":"JuMP.set_value","text":"JuMP.set_value(vref::DispatchVariableRef, value::Real)::Nothing\n\nExtend JuMP.set_value to set the value of vref. It relies on JuMP.set_value being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.infinite_set-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.infinite_set","text":"InfiniteOpt.infinite_set(prefs; [kwargs...])\n\nDefine InfiniteOpt.infinite_set for general variable references. It relies on InfiniteOpt.infinite_set being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.infinite_set-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.infinite_set","text":"InfiniteOpt.infinite_set(prefs; [kwargs...])\n\nDefine InfiniteOpt.infinite_set for general variable references. It relies on InfiniteOpt.infinite_set being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.set_infinite_set-Tuple{GeneralVariableRef,InfiniteScalarSet}","page":"Expressions","title":"InfiniteOpt.set_infinite_set","text":"set_infinite_set(pref::GeneralVariableRef, set::InfiniteScalarSet)::Nothing\n\nSpecify the scalar infinite set of the infinite parameter pref to set. Note this will reset/delete all the supports contained in the underlying parameter object. Also, errors if pref is used by a measure. An ArgumentError is thrown if pref is not an infinite parameter.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.set_infinite_set-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef,InfiniteArraySet}","page":"Expressions","title":"InfiniteOpt.set_infinite_set","text":"set_infinite_set(prefs::AbstractArray{<:GeneralVariableRef},\n                 set::InfiniteArraySet)::Nothing\n\nSpecify the multi-dimensional infinite set of the dependent infinite parameters prefs to set. Note this will reset/delete all the supports contained in the underlying DependentParameters object. This will error if the not all of the dependent infinite parameters are included or if any of them are used by measures. An ArgumentError is thrown if prefs are not dependent infinite parameters.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.num_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.num_supports","text":"InfiniteOpt.num_supports(prefs; [kwargs...])\n\nDefine InfiniteOpt.num_supports for general variable references. It relies on InfiniteOpt.num_supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.num_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.num_supports","text":"InfiniteOpt.num_supports(prefs; [kwargs...])\n\nDefine InfiniteOpt.num_supports for general variable references. It relies on InfiniteOpt.num_supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.has_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.has_supports","text":"InfiniteOpt.has_supports(prefs; [kwargs...])\n\nDefine InfiniteOpt.has_supports for general variable references. It relies on InfiniteOpt.has_supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.has_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.has_supports","text":"InfiniteOpt.has_supports(prefs; [kwargs...])\n\nDefine InfiniteOpt.has_supports for general variable references. It relies on InfiniteOpt.has_supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.supports","text":"supports(expr::JuMP.AbstractJuMPScalar; [kwargs...])\n\nReturn the support associated with expr. Errors if expr is not associated with the constraint mappings stored in optimizer_model or if InfiniteOpt.expression_supports has not been extended. By default, no keyword arguments are accepted, but extensions may employ some.\n\nExample\n\njulia> supports(cref)\n2-element Array{Tuple{Float64},1}:\n (0.0,)\n (1.0,)\n\n\n\n\n\nInfiniteOpt.supports(prefs; [kwargs...])\n\nDefine InfiniteOpt.supports for general variable references. It relies on InfiniteOpt.supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.supports-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.supports","text":"InfiniteOpt.supports(prefs; [kwargs...])\n\nDefine InfiniteOpt.supports for general variable references. It relies on InfiniteOpt.supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.set_supports-Tuple{GeneralVariableRef,Union{Real, Array{#s38,1} where #s38<:Real}}","page":"Expressions","title":"InfiniteOpt.set_supports","text":"set_supports(pref::GeneralVariableRef, supports::Union{Real, Vector{<:Real}};\n             [force::Bool = false])::Nothing\n\nSet the support points associated with a single infinite parameter pref. An ArgumentError is thrown if pref is not an independent infinite parameter.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.set_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef,Union{AbstractArray{#s5,N} where N where #s5<:(Array{#s2,1} where #s2<:Real), Array{#s9,2} where #s9<:Real}}","page":"Expressions","title":"InfiniteOpt.set_supports","text":"set_supports(\n    prefs::Union{Vector{GeneralVariableRef}, AbstractArray{<:GeneralVariableRef}},\n    supports::Union{Array{<:Real, 2}, AbstractArray{<:Vector{<:Real}}};\n    [force::Bool = false]\n    )::Nothing\n\nSet the support points associated with dependent infinite parameters prefs. An ArgumentError is thrown if prefs is are not dependent infinite parameters.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.add_supports-Tuple{GeneralVariableRef,Union{Real, Array{#s38,1} where #s38<:Real}}","page":"Expressions","title":"InfiniteOpt.add_supports","text":"add_supports(pref::GeneralVariableRef,\n             supports::Union{Real, Vector{<:Real}})::Nothing\n\nAdd the support points supports to a single infinite parameter pref. An ArgumentError is thrown if pref is not an independent infinite parameter.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.add_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef,Union{AbstractArray{#s5,N} where N where #s5<:(Array{#s2,1} where #s2<:Real), Array{#s9,2} where #s9<:Real}}","page":"Expressions","title":"InfiniteOpt.add_supports","text":"add_supports(\n    prefs::Union{Vector{GeneralVariableRef}, AbstractArray{<:GeneralVariableRef}},\n    supports::Union{Array{<:Real, 2}, AbstractArray{<:Vector{<:Real}}}\n    )::Nothing\n\nAdd the support points supports to the dependent infinite parameters prefs. An ArgumentError is thrown if prefs is are not dependent infinite parameters.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.delete_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.delete_supports","text":"InfiniteOpt.delete_supports(prefs; [kwargs...])\n\nDefine InfiniteOpt.delete_supports for general variable references. It relies on InfiniteOpt.delete_supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.delete_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.delete_supports","text":"InfiniteOpt.delete_supports(prefs; [kwargs...])\n\nDefine InfiniteOpt.delete_supports for general variable references. It relies on InfiniteOpt.delete_supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.fill_in_supports!","text":"InfiniteOpt.fill_in_supports!(prefs; [kwargs...])\n\nDefine InfiniteOpt.fill_in_supports! for general variable references. It relies on InfiniteOpt.fill_in_supports! being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.fill_in_supports!","text":"InfiniteOpt.fill_in_supports!(prefs; [kwargs...])\n\nDefine InfiniteOpt.fill_in_supports! for general variable references. It relies on InfiniteOpt.fill_in_supports! being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.raw_parameter_refs-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.raw_parameter_refs","text":"InfiniteOpt.raw_parameter_refs(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.raw_parameter_refs for general variable references. It relies on InfiniteOpt.raw_parameter_refs being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.parameter_refs-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_refs","text":"InfiniteOpt.parameter_refs(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.parameter_refs for general variable references. It relies on InfiniteOpt.parameter_refs being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.parameter_list-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_list","text":"InfiniteOpt.parameter_list(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.parameter_list for general variable references. It relies on InfiniteOpt.parameter_list being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.infinite_variable_ref-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.infinite_variable_ref","text":"InfiniteOpt.infinite_variable_ref(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.infinite_variable_ref for general variable references. It relies on InfiniteOpt.infinite_variable_ref being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.eval_supports-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.eval_supports","text":"InfiniteOpt.eval_supports(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.eval_supports for general variable references. It relies on InfiniteOpt.eval_supports being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.raw_parameter_values-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.raw_parameter_values","text":"InfiniteOpt.raw_parameter_values(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.raw_parameter_values for general variable references. It relies on InfiniteOpt.raw_parameter_values being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.parameter_values-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_values","text":"InfiniteOpt.parameter_values(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.parameter_values for general variable references. It relies on InfiniteOpt.parameter_values being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.parameter_bounds-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.parameter_bounds","text":"InfiniteOpt.parameter_bounds(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.parameter_bounds for general variable references. It relies on InfiniteOpt.parameter_bounds being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.has_parameter_bounds-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.has_parameter_bounds","text":"has_parameter_bounds(vref::GeneralVariableRef)::Bool\n\nReturn a Bool indicating if vref is limited to a sub-domain as defined by parameter bound.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.set_parameter_bounds-Tuple{GeneralVariableRef,ParameterBounds{GeneralVariableRef}}","page":"Expressions","title":"InfiniteOpt.set_parameter_bounds","text":"set_parameter_bounds(vref::GeneralVariableRef,\n                     bounds::ParameterBounds{GeneralVariableRef};\n                     [force::Bool = false])::Nothing\n\nSpecify a new set of parameter bounds for a hold variable vref. An ArgumentError is thrown if vref is not a hold variable.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.add_parameter_bounds-Tuple{GeneralVariableRef,ParameterBounds{GeneralVariableRef}}","page":"Expressions","title":"InfiniteOpt.add_parameter_bounds","text":"add_parameter_bounds(vref::GeneralVariableRef,\n                     bounds::ParameterBounds{GeneralVariableRef}\n                     )::Nothing\n\nSpecify more parameter bounds for a hold variable vref. An ArgumentError is thrown if vref is not a hold variable.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.delete_parameter_bounds-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.delete_parameter_bounds","text":"InfiniteOpt.delete_parameter_bounds(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.delete_parameter_bounds for general variable references. It relies on InfiniteOpt.delete_parameter_bounds being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.significant_digits-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.significant_digits","text":"InfiniteOpt.significant_digits(prefs; [kwargs...])\n\nDefine InfiniteOpt.significant_digits for general variable references. It relies on InfiniteOpt.significant_digits being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information. Note that this is a auto generated wrapper and the underlying method may or may not use kwargs.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.measure_function-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.measure_function","text":"InfiniteOpt.measure_function(mref::GeneralVariableRef)\n\nDefine InfiniteOpt.measure_function for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.measure_data-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.measure_data","text":"InfiniteOpt.measure_data(mref::GeneralVariableRef)\n\nDefine InfiniteOpt.measure_data for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.is_analytic-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.is_analytic","text":"InfiniteOpt.is_analytic(mref::GeneralVariableRef)\n\nDefine InfiniteOpt.is_analytic for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.delete-Tuple{InfiniteModel,GeneralVariableRef}","page":"Expressions","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::GeneralVariableRef)::Nothing\n\nExtend JuMP.delete to delete vref and its dependencies. It relies on JuMP.delete being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.delete-Tuple{InfiniteModel,AbstractArray{#s38,N} where N where #s38<:GeneralVariableRef}","page":"Expressions","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel,\n            prefs::AbstractArray{<:GeneralVariableRef})::Nothing\n\nExtend JuMP.delete to delete a group of dependent infinite parameters and their dependencies. An ArugmentError is thrown if prefs are not dependent infinite parameters.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.has_lower_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.has_lower_bound","text":"JuMP.JuMP.has_lower_bound(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.has_lower_bound for general variable references. It relies on JuMP.JuMP.has_lower_bound being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.lower_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.lower_bound","text":"JuMP.JuMP.lower_bound(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.lower_bound for general variable references. It relies on JuMP.JuMP.lower_bound being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.set_lower_bound-Tuple{GeneralVariableRef,Real}","page":"Expressions","title":"JuMP.set_lower_bound","text":"JuMP.JuMP.set_lower_bound(vref::GeneralVariableRef, value::Real)::Nothing\n\nDefine JuMP.JuMP.set_lower_bound for general variable references. It relies on JuMP.JuMP.set_lower_bound being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.LowerBoundRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.LowerBoundRef","text":"JuMP.JuMP.LowerBoundRef(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.LowerBoundRef for general variable references. It relies on JuMP.JuMP.LowerBoundRef being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.delete_lower_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.delete_lower_bound","text":"JuMP.JuMP.delete_lower_bound(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.delete_lower_bound for general variable references. It relies on JuMP.JuMP.delete_lower_bound being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.has_upper_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.has_upper_bound","text":"JuMP.JuMP.has_upper_bound(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.has_upper_bound for general variable references. It relies on JuMP.JuMP.has_upper_bound being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.upper_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.upper_bound","text":"JuMP.JuMP.upper_bound(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.upper_bound for general variable references. It relies on JuMP.JuMP.upper_bound being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.set_upper_bound-Tuple{GeneralVariableRef,Real}","page":"Expressions","title":"JuMP.set_upper_bound","text":"JuMP.JuMP.set_upper_bound(vref::GeneralVariableRef, value::Real)::Nothing\n\nDefine JuMP.JuMP.set_upper_bound for general variable references. It relies on JuMP.JuMP.set_upper_bound being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.UpperBoundRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.UpperBoundRef","text":"JuMP.JuMP.UpperBoundRef(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.UpperBoundRef for general variable references. It relies on JuMP.JuMP.UpperBoundRef being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.delete_upper_bound-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.delete_upper_bound","text":"JuMP.JuMP.delete_upper_bound(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.delete_upper_bound for general variable references. It relies on JuMP.JuMP.delete_upper_bound being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.is_fixed-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.is_fixed","text":"JuMP.JuMP.is_fixed(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.is_fixed for general variable references. It relies on JuMP.JuMP.is_fixed being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.fix_value-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.fix_value","text":"JuMP.JuMP.fix_value(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.fix_value for general variable references. It relies on JuMP.JuMP.fix_value being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.fix-Tuple{GeneralVariableRef,Real}","page":"Expressions","title":"JuMP.fix","text":"JuMP.fix(vref::GeneralVariableRef, value::Real; force::Bool = false)::Nothing\n\nDefine JuMP.fix for general variable references. It relies on JuMP.fix being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.FixRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.FixRef","text":"JuMP.JuMP.FixRef(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.FixRef for general variable references. It relies on JuMP.JuMP.FixRef being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.unfix-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.unfix","text":"JuMP.JuMP.unfix(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.unfix for general variable references. It relies on JuMP.JuMP.unfix being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.start_value-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.start_value","text":"JuMP.JuMP.start_value(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.start_value for general variable references. It relies on JuMP.JuMP.start_value being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.set_start_value-Tuple{GeneralVariableRef,Real}","page":"Expressions","title":"JuMP.set_start_value","text":"JuMP.JuMP.set_start_value(vref::GeneralVariableRef, value::Real)::Nothing\n\nDefine JuMP.JuMP.set_start_value for general variable references. It relies on JuMP.JuMP.set_start_value being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.start_value_function-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.start_value_function","text":"InfiniteOpt.start_value_function(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.start_value_function for general variable references. It relies on InfiniteOpt.start_value_function being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.set_start_value_function-Tuple{GeneralVariableRef,Any}","page":"Expressions","title":"InfiniteOpt.set_start_value_function","text":"set_start_value_function(vref::GeneralVariableRef, start::Union{Real, Function})::Nothing\n\nSet the start value function of vref. It relies on set_start_value_function being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt.reset_start_value_function-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt.reset_start_value_function","text":"InfiniteOpt.reset_start_value_function(vref::GeneralVariableRef)\n\nDefine InfiniteOpt.reset_start_value_function for general variable references. It relies on InfiniteOpt.reset_start_value_function being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.is_binary-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.is_binary","text":"JuMP.JuMP.is_binary(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.is_binary for general variable references. It relies on JuMP.JuMP.is_binary being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.set_binary-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.set_binary","text":"JuMP.JuMP.set_binary(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.set_binary for general variable references. It relies on JuMP.JuMP.set_binary being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.BinaryRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.BinaryRef","text":"JuMP.JuMP.BinaryRef(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.BinaryRef for general variable references. It relies on JuMP.JuMP.BinaryRef being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.unset_binary-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.unset_binary","text":"JuMP.JuMP.unset_binary(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.unset_binary for general variable references. It relies on JuMP.JuMP.unset_binary being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.is_integer-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.is_integer","text":"JuMP.JuMP.is_integer(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.is_integer for general variable references. It relies on JuMP.JuMP.is_integer being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.set_integer-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.set_integer","text":"JuMP.JuMP.set_integer(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.set_integer for general variable references. It relies on JuMP.JuMP.set_integer being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.IntegerRef-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.IntegerRef","text":"JuMP.JuMP.IntegerRef(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.IntegerRef for general variable references. It relies on JuMP.JuMP.IntegerRef being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#JuMP.unset_integer-Tuple{GeneralVariableRef}","page":"Expressions","title":"JuMP.unset_integer","text":"JuMP.JuMP.unset_integer(vref::GeneralVariableRef)\n\nDefine JuMP.JuMP.unset_integer for general variable references. It relies on JuMP.JuMP.unset_integer being defined for the underlying DispatchVariableRef, otherwise an ArugmentError is thrown. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#Developer-Internal-Methods","page":"Expressions","title":"Developer Internal Methods","text":"","category":"section"},{"location":"guide/expression/","page":"Expressions","title":"Expressions","text":"InfiniteOpt._add_data_object\nInfiniteOpt._data_dictionary\nInfiniteOpt._data_object\nInfiniteOpt._delete_data_object\nInfiniteOpt._core_variable_object\nInfiniteOpt._core_variable_object(::GeneralVariableRef)\nInfiniteOpt._set_core_variable_object\nInfiniteOpt._infinite_variable_dependencies\nInfiniteOpt._infinite_variable_dependencies(::GeneralVariableRef)\nInfiniteOpt._reduced_variable_dependencies\nInfiniteOpt._reduced_variable_dependencies(::GeneralVariableRef)\nInfiniteOpt._point_variable_dependencies\nInfiniteOpt._point_variable_dependencies(::GeneralVariableRef)\nInfiniteOpt._measure_dependencies\nInfiniteOpt._measure_dependencies(::GeneralVariableRef)\nInfiniteOpt._constraint_dependencies\nInfiniteOpt._constraint_dependencies(::GeneralVariableRef)\nInfiniteOpt._parameter_number\nInfiniteOpt._parameter_number(::GeneralVariableRef)\nInfiniteOpt._object_number\nInfiniteOpt._object_number(::GeneralVariableRef)","category":"page"},{"location":"guide/expression/#InfiniteOpt._add_data_object","page":"Expressions","title":"InfiniteOpt._add_data_object","text":"_add_data_object(model::InfiniteModel, object::AbstractDataObject)::ObjectIndex\n\nAdd object to the appropriate CleverDict in model and return the its index. This needs to be defined for the type of object. These definitions need to use MOIUC.add_item to add the object to the CleverDict.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._data_dictionary","page":"Expressions","title":"InfiniteOpt._data_dictionary","text":"_data_dictionary(vref::DispatchVariableRef)::MOIUC.CleverDict\n\nReturn the CleverDict that stores data objects for the type of vref. This needs to be defined for the type of vref.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._data_object","page":"Expressions","title":"InfiniteOpt._data_object","text":"_data_object(vref::DispatchVariableRef)::AbstractDataObject\n\nReturn the data object associated with vref, in other words the object its index points to in the InfiniteModel. This needs to be defined for the type of vref. This should use _data_dictionary to access the CleverDict that the object is stored in.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._delete_data_object","page":"Expressions","title":"InfiniteOpt._delete_data_object","text":"_delete_data_object(vref::DispatchVariableRef)::Nothing\n\nDelete the concrete AbstractDataObject associated with vref.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._core_variable_object","page":"Expressions","title":"InfiniteOpt._core_variable_object","text":"_core_variable_object(vref::DispatchVariableRef)::Union{InfOptParameter, InfOptVariable, Measure}\n\nReturn the core object that vref points to. This needs to be extended for type of vref. This should use _data_object to access the data object where the variable object is stored.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._core_variable_object-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._core_variable_object","text":"_core_variable_object(vref::GeneralVariableRef)::Union{InfOptParameter, InfOptVariable, Measure}\n\nReturn the core object that vref points to. This is enabled with appropriate definitions of _core_variable_object for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt._set_core_variable_object","page":"Expressions","title":"InfiniteOpt._set_core_variable_object","text":"_set_core_variable_object(vref::DispatchVariableRef, object)::Nothing\n\nSets the core object that vref points to object. This needs to be extended for types of vref and object. This should use _data_object to access the data object where the variable object is stored.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._infinite_variable_dependencies","page":"Expressions","title":"InfiniteOpt._infinite_variable_dependencies","text":"InfiniteOpt._infinite_variable_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._infinite_variable_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._infinite_variable_dependencies","text":"InfiniteOpt._infinite_variable_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of InfiniteOpt._infinite_variable_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt._reduced_variable_dependencies","page":"Expressions","title":"InfiniteOpt._reduced_variable_dependencies","text":"InfiniteOpt._reduced_variable_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._reduced_variable_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._reduced_variable_dependencies","text":"InfiniteOpt._reduced_variable_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of InfiniteOpt._reduced_variable_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt._point_variable_dependencies","page":"Expressions","title":"InfiniteOpt._point_variable_dependencies","text":"InfiniteOpt._point_variable_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._point_variable_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._point_variable_dependencies","text":"InfiniteOpt._point_variable_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of InfiniteOpt._point_variable_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt._measure_dependencies","page":"Expressions","title":"InfiniteOpt._measure_dependencies","text":"InfiniteOpt._measure_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._measure_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._measure_dependencies","text":"InfiniteOpt._measure_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of InfiniteOpt._measure_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt._constraint_dependencies","page":"Expressions","title":"InfiniteOpt._constraint_dependencies","text":"InfiniteOpt._constraint_dependencies(vref::DispatchVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This needs to be extended for type of vref. This should use _data_object to access the data object where the name is stored if appropriate.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._constraint_dependencies-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._constraint_dependencies","text":"InfiniteOpt._constraint_dependencies(vref::GeneralVariableRef)::Vector{AbstractInfOptIndex}\n\nReturn the indices of these entities that depend on vref. This is enabled with appropriate definitions of InfiniteOpt._constraint_dependencies for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt._parameter_number","page":"Expressions","title":"InfiniteOpt._parameter_number","text":"_parameter_number(pref::DispatchVariableRef)::Int\n\nReturn the parameter creation number for pref assuming it is an infinite parameter. This needs to be defined for the type of pref. This should use the _data_object to get the number.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._parameter_number-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._parameter_number","text":"_parameter_number(pref::GeneralVariableRef)::Int\n\nReturn the parameter creation number for pref assuming it is an infinite parameter. It relies on _parameter_number being properly defined for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#InfiniteOpt._object_number","page":"Expressions","title":"InfiniteOpt._object_number","text":"_object_number(pref::DispatchVariableRef)::Int\n\nReturn the object number for pref assuming it is an infinite parameter. This needs to be defined for the type of pref. This should use the _data_object to get the number.\n\n\n\n\n\n","category":"function"},{"location":"guide/expression/#InfiniteOpt._object_number-Tuple{GeneralVariableRef}","page":"Expressions","title":"InfiniteOpt._object_number","text":"_object_number(pref::GeneralVariableRef)::Int\n\nReturn the object number for pref assuming it is an infinite parameter. It relies on _object_number being properly defined for the underlying DispatchVariableRef, otherwise an MethodError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#inf_par_page","page":"Infinite Parameters","title":"Infinite Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"A guide and manual to the definition and use of infinite parameters in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/parameter/#Overview","page":"Infinite Parameters","title":"Overview","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Infinite parameters are what parameterize the infinite decision spaces for infinite dimensional mathematical programs. In dynamic optimization this corresponds to time and in stochastic optimization this to uncertain parameters that follow a certain underlying statistical distribution. InfiniteOpt considers principally two kinds of infinite parameters, ones defined over continuous intervals and ones characterized by a distribution (others can be added by defining a user-defined type). These can be used to parameterize infinite variables, point variables, measures, and can be used directly inside constraints.","category":"page"},{"location":"guide/parameter/#Basic-Usage","page":"Infinite Parameters","title":"Basic Usage","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"First, we need to initialize and add infinite parameters to our InfiniteModel. This can be accomplished using @infinite_parameter. For example, let's define a parameter for time in a time interval from 0 to 10:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> using InfiniteOpt, JuMP\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now t is a Julia variable that stores a GeneralVariableRef which points to where the time parameter is stored in model. It can now be used with infinite variables, measures, and constraints as described in the appropriate sections.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"When the model is optimized, t will be transcribed (discretized) over its domain following its support points. If none are specified by the user than 50 support points are generated that are equidistant over the interval. However, users may wish to employ their own support scheme. This can be done by using the num_supports or supports keyword arguments. For example, if we desire to have only 10 equi-distant supports then we could have instead defined t:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], num_supports = 10)\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"More complex support schemes can be specified via supports such as:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0; 2; 7; 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Where we specified t to use 4 supports: 0, 2, 7, and 10.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also add supports after t has been initialized. This can be accomplished with add_supports. For example, consider the initial case where t has no supports and we now wish to add 4 supports:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> add_supports(t, [0., 2.5, 7.5, 10.])\n\njulia> supports(t)\n4-element Array{Float64,1}:\n  0.0\n  2.5\n  7.5\n 10.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Here only 4 supports are specified for the sake of example. Alternatively, we could have initialized the parameter and added supports in just one step using the supports keyword argument:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0., 2.5, 7.5, 10.])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We could also define a random parameter described by a statistical distribution. This can be accomplished using @infinite_parameter in combination with a distribution from Distributions.jl. For example let's define a vector of independent random parameters described by a Normal distribution:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> using Distributions\n\njulia> @infinite_parameter(model, xi[i = 1:3] in Normal(), independent = true)\n3-element Array{GeneralVariableRef,1}:\n xi[1]\n xi[2]\n xi[3]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that we could have used i as an index to assign a different distribution to each parameter. Supports can also be specified for each parameter as shown above. Similarly, the num_supports keyword is used to generate random supports. Now we have infinite parameters t and xi that are ready to be used in defining infinite variables and constraints. We also mention here that the @infinite_parameter macro is designed to closely emulate JuMP.@variable and thus handles arrays and keyword arguments in the same way. This is described in more detail below.","category":"page"},{"location":"guide/parameter/#Parameter-Definition","page":"Infinite Parameters","title":"Parameter Definition","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Defining/initializing an infinite parameter principally involves the following steps:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Define an AbstractInfiniteSet\nDefine support points within the set to later discretize the parameter\nConstruct an InfOptParameter to store this information\nAdd the InfOptParameter object to an InfiniteModel and assign a name\nCreate a GeneralVariableRef that points to the parameter object","category":"page"},{"location":"guide/parameter/#Manual-Definition","page":"Infinite Parameters","title":"Manual Definition","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Infinite set definition is described above in the Infinite Sets section. The supports should be a vector of finite numbers that are drawn from the domain of the infinite set. These supports will be used to transcribe the InfiniteModel in preparation for it to be optimized. If desired, the supports can be specified after the parameter is defined and the support container of the defined parameter will be temporarily empty.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"InfOptParameter is an abstract data type that encompasses all concrete infinite parameter types. The concrete type for individual infinite parameters is IndependentParameter, since these parameters are independent from other parameters. On the other hand, DependentParameters handle multivariate infinite parameters, within which each individual parameter is not independent. These are useful for characterizing, for example, parameters subject to multivariate distribution.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Regardless of the specific concrete type, the build_parameter function is used to construct an InfOptParameter. For example, let's create a time parameter t in 0 10 with supports [0, 2, 5, 7, 10]:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set = IntervalSet(0, 10)\n[0, 10]\n\njulia> t_param = build_parameter(error, set, supports = [0, 2, 5, 7, 10])\nIndependentParameter{IntervalSet}([0, 10], DataStructures.SortedDict(0.0=>Set([:user_defined]),2.0=>Set([:user_defined]),5.0=>Set([:user_defined]),7.0=>Set([:user_defined]),10.0=>Set([:user_defined])), 12)","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now that we have a InfOptParameter that contains an IntervalSet and supports, let's now add t_param to our InfiniteModel using add_parameter and assign it the name of t:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t_ref = add_parameter(model, t_param, \"t\")\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also create an anonymous infinite parameter by dropping the name from the add_parameter function call. For example:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t_ref_noname = add_parameter(model, t_param)\nnoname","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now suppose we want to create an infinite parameter that is a random variable with a given distribution. We follow the same procedure as above, except we use distributions from Distributions.jl to define a UniDistributionSet. For example, let's consider a random variable x in mathcalN(01) with supports [-0.5, 0.5]:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = Normal(0., 1.)\nNormal{Float64}(μ=0.0, σ=1.0)\n\njulia> set = UniDistributionSet(dist)\nNormal{Float64}(μ=0.0, σ=1.0)\n\njulia> x_param = build_parameter(error, set, supports = [-0.5, 0.5])\nIndependentParameter{UniDistributionSet{Normal{Float64}}}(Normal{Float64}(μ=0.0, σ=1.0), DataStructures.SortedDict(-0.5=>Set([:user_defined]),0.5=>Set([:user_defined])), 12)","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Again, we use add_parameter to add x_param to the InfiniteModel and assign it the name x:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> x_ref = add_parameter(model, x_param, \"x\")\nx","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that add_parameter does not register the name of the parameters into the model that it adds to. As shown in Macro Definition, the macro definition does not allow for multiple parameters sharing the same name and will throw an error if it happens.","category":"page"},{"location":"guide/parameter/#param_macro","page":"Infinite Parameters","title":"Macro Definition","text":"","category":"section"},{"location":"guide/parameter/#One-Dimensional-Parameters","page":"Infinite Parameters","title":"One-Dimensional Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"One user-friendly way of defining infinite parameters is by macro @infinite_parameter. The macro executes the same process as the manual definition (steps listed in Parameter Definition), but allows the users to manipulate several features of the defined infinite parameters. Again, let's consider a time parameter t in 0 10 with supports [0, 2, 5, 7, 10]. Similar to JuMP.@variable, we can use comparison operators to set lower bounds and upper bounds for the infinite parameter:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, 0 <= t <= 10, supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"More generally, we use in to define the set that an infinite parameter is subject to. The set could be an interval set, or a distribution set. For example, we can define the same parameter t as above in the following way:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In a similar way, we can define a random infinite parameter subject to some distribution. For example, a Gaussian infinite parameter with mean 0 and standard deviation 1 can be defined by","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = Normal(0., 1.)\nNormal{Float64}(μ=0.0, σ=1.0)\n\njulia> @infinite_parameter(model, x in dist, supports = [-0.5, 0.5])\nx","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Additional ways of defining infinite parameters are provided using keyword arguments. For example, we can use lower_bound and upper_bound to define an infinite parameter in an interval set:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t, lower_bound = 0, upper_bound = 10, supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"A bit more generally, we can also use set to directly input the AbstractInfiniteSet that the parameter is in. For example:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t, set = IntervalSet(0, 10), supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The parameter definition methods using keyword arguments will be useful later when we introduce how to define anonymous parameters. See the part for anonymous parameter definition for more details.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"All the definitions above return a GeneralVariableRef that refer to the defined parameter. Note that we can also ignore the supports keyword argument and the macro will define an empty array of supports for that parameter.","category":"page"},{"location":"guide/parameter/#Multi-Dimensional-Parameter","page":"Infinite Parameters","title":"Multi-Dimensional Parameter","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Using macro definition, we can also define multi-dimensional infinite parameters in a concise way. For example, consider a position parameter x in a 3-dimensional space constrained in a unit cube (i.e. in the interval [0, 1]   for all dimensions). This parameter can be defined in one line as follows:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x[1:3] in [0, 1], supports = [0.3, 0.7])\n3-element Array{GeneralVariableRef,1}:\n x[1]\n x[2]\n x[3]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For multi-dimensional parameters, the macro calls for an internal function that works similar to build_parameter for univariate infinite parameter and then add_parameter to add the multi-dimensional parameters. If an array of supports is provided, the macro will assign that array of supports to all dimensions. Otherwise, the indexed syntax can be used to feed in different array of supports to each dimension, similar to JuMP.@variable. For example:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> points = [0.2 0.8; 0.3 0.7]\n2×2 Array{Float64,2}:\n 0.2  0.8\n 0.3  0.7\n\njulia> @infinite_parameter(model, a[i = 1:2] in [0, 1], supports = points[i, :])\n2-element Array{GeneralVariableRef,1}:\n a[1]\n a[2]\n\njulia> supports(a[1])\n2-element Array{Float64,1}:\n 0.2\n 0.8\n\njulia> supports(a[2])\n2-element Array{Float64,1}:\n 0.3\n 0.7","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In a similar way we can define an infinite parameter subject to a multivariate distribution. For example, a 2-dimensional parameter xi subject to a 2-D normal distribution can be created as follows:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = MvNormal([0., 0.], [1. 0.; 0. 2.])\nFullNormal(\ndim: 2\nμ: [0.0, 0.0]\nΣ: [1.0 0.0; 0.0 2.0]\n)\n\njulia> @infinite_parameter(model, xi[1:2] in dist)\n2-element Array{GeneralVariableRef,1}:\n xi[1]\n xi[2]","category":"page"},{"location":"guide/parameter/#Containers-for-Multi-Dimensional-Parameters","page":"Infinite Parameters","title":"Containers for Multi-Dimensional Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that for all the cases of multi-dimensional parameter definition above, the macro always returns an Array of GeneralVariableRef. For most cases this is true. However, we can explicitly dictate the kind of containers we want to hold the defined parameters using the keyword container. For example, we use SparseAxisArray from the JuMP package for the space parameter x:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x[1:3] in [0, 1], container = SparseAxisArray)\nJuMP.Containers.SparseAxisArray{GeneralVariableRef,1,Tuple{Int64}} with 3 entries:\n  [3]  =  x[3]\n  [2]  =  x[2]\n  [1]  =  x[1]","category":"page"},{"location":"guide/parameter/#Specifying-independence-of-infinite-parameters","page":"Infinite Parameters","title":"Specifying independence of infinite parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The concrete data object that stores information of infinite parameters are IndependentParameter and DependentParameters, both under the abstract data type InfOptParameter. IndependentParameter stores scalar infinite parameters that are independent from other infinite parameters. DependentParameters stores multiple infinite parameters that are dependent on each other, e.g. multi-dimensional random parameters. Each IndependentParameter or DependentParameters stores the AbstractInfiniteSet that the parameters are in and supports that discretize the parameters.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For examples up to now we did not specify the value for the keyword independent, which is set as false by default. In the case of scalar infinite parameter, independent is ignored and an IndependentParameter is always created. The keyword independent applies to multi-dimensional infinite parameters and dictates whether the supports for different dimensions are independent. Setting independent as true would be useful if the users want to generate a grid of supports for a multi-dimensional parameter. In this case the macro call creates an array of IndependentParameter. Otherwise, the macro call creates DependentParameters. For example, consider the position parameter x in a 3D space. Say x is bounded in [0, 1] in all three dimensions, and the user wants to generate grid points with interval 0.5 in all three dimensions. In this case, we can define x in the following way:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> pts = collect(range(0, stop = 1, length = 3))\n3-element Array{Float64,1}:\n 0.0\n 0.5\n 1.0\n\njulia> @infinite_parameter(model, x[1:3] in [0, 1], supports = pts, independent = true)\n3-element Array{GeneralVariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> typeof(dispatch_variable_ref(x[1]))\nIndependentParameterRef","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"If independent is set as false, the transcription step will generate JuMP variables for values of any variable parameterized by x at [0.0, 0.0, 0.0], [0.5, 0.5, 0.5] and [1.0, 1.0, 1.0], a total of 3 transcribed variables. Instead, if independent is set as true, the transcription step will obtain a unique permutation of these supports and each transcribe parameterized variable accordingly, leading to a total of 27 transcribed variables in this case.","category":"page"},{"location":"guide/parameter/#Anonymous-Parameter-Definition-and-base_name","page":"Infinite Parameters","title":"Anonymous Parameter Definition and base_name","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"As mentioned above, we can define anonymous parameters using keyword arguments in the macro @infinite_parameter. For instance, we can create an anonymous position parameter in a 3D space, referred to by a list of GeneralVariableRef called x:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> x = @infinite_parameter(model, [1:3], lower_bound = 0, upper_bound = 1)\n3-element Array{GeneralVariableRef,1}:\n noname\n noname\n noname\n\njulia> typeof(x)\nArray{GeneralVariableRef,1}\n\njulia> name(x[1])\n\"\"","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"This syntax creates a 1D parameter if the part [1:3] is neglected.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that this macro definition automatically assigns an empty string to the base_name. We can also assign a nontrivial base name to an anonymous parameter using the keyword argument base_name. For example,","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, [1:3], lower_bound = 0, upper_bound = 1, base_name = \"x\")\n3-element Array{GeneralVariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @infinite_parameter(model, [1:3], lower_bound = -1, upper_bound = 0, base_name = \"x\")\n3-element Array{GeneralVariableRef,1}:\n x[1]\n x[2]\n x[3]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can see that anonymous parameter definition allows for multiple parameters sharing the same base name. This is not permitted with non-anonymous parameter definition. In fact, in anonymous parameter definition, the macro does not register the name of the parameters in the model, so when the model checks for repeated names it will not detect the x. Refer to Detailed Mechanism of Macro Definition if more details are desired.","category":"page"},{"location":"guide/parameter/#Detailed-Mechanism-of-Macro-Definition","page":"Infinite Parameters","title":"Detailed Mechanism of Macro Definition","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"This section is for people who wish to know more about how the macro @infinite_parameter works in the backend. Users who only want to learn about the setting up the model can skip over this part.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In general, the macro @infinite_parameter follows the same steps as the manual definition. First, it parses the arguments and identifies any recognizable keyword arguments. Specifically, the first argument must be the model, and the second argument, if exists, must be an expression that declares the parameter or simply specify the dimension of the parameter if users choose to define it anonymously. If the information in the keyword arguments is not sufficient to define the set the parameter is in, the users also need to specify the sets in the second argument using expressions like a <= x <= b or x in set.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The keyword arguments give users flexibility in how to define their parameters. As mentioned above, the users can choose to specify the set either in the second argument (nonanonymous parameter definition only), or in the keyword arguments. However, the users cannot do both at the same time. The macro will check this behavior and throw an error if this happens. For example,","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model,  y in [0, 1], lower_bound = 0, upper_bound = 1)\nERROR: LoadError\n\njulia> @infinite_parameter(model,  y in [0, 1], set = IntervalSet(0, 1))\nERROR: LoadError","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Once the check on arguments and keyword arguments is done, the macro will create the AbstractInfiniteSet based on given information, and create the infinite parameter accordingly. If the users create a multi-dimensional parameter, the macro will create looped code to define individual infinite parameter for each dimension. The looped code will also incorporate different supports for different dimensions.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In the end, if the created parameter is not anonymous, the macro will register the name to the model. In this way, we prevent parameters created by @infinite_parameter non-anonymously to share the same name.","category":"page"},{"location":"guide/parameter/#Supports","page":"Infinite Parameters","title":"Supports","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter, its supports are a finite set of points that the parameter will take (or possibly take, if the parameter is random). During the transcription stage, the supports specified will become part of the grid points that approximate all functions parameterized by the infinite parameter.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Once an infinite parameter is defined, users can access the supports using supports function:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, 0 <= t <= 10, supports = [0, 2, 5, 7, 10])\nt\n\njulia> supports(t)\n5-element Array{Float64,1}:\n  0.0\n  2.0\n  5.0\n  7.0\n 10.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We also provide functions that access other related information about the supports. For example, has_supports checks whether a parameter has supports, while num_supports gives the number of supports associated with a parameter:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> has_supports(t)\ntrue\n\njulia> num_supports(t)\n5","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now suppose we want to add more supports to the t, which is already assigned with some supports. We can use add_supports function to achieve this goal:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> add_supports(t, [3, 8])\n\njulia> supports(t)\n7-element Array{Float64,1}:\n  0.0\n  2.0\n  3.0\n  5.0\n  7.0\n  8.0\n 10.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"At times we might want to change the supports completely. In those cases, the function set_supports resets the supports for a certain parameter with new supports provided:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set_supports(t, [0,3,5,8,10], force = true)\n\njulia> supports(t)\n5-element Array{Float64,1}:\n  0.0\n  3.0\n  5.0\n  8.0\n 10.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the keyword argument [force] must be set as [true] if the parameter has been assigned with supports. Users can also delete all the supports of a parameter with delete_supports.","category":"page"},{"location":"guide/parameter/#Automatic-Support-Generation-During-Parameter-Definition","page":"Infinite Parameters","title":"Automatic Support Generation During Parameter Definition","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For the examples in the Parameter Definition, we have seen how to manually add supports to an infinite parameter. For a quick automatic generation of support points, though, users do not have to input the support points. Instead, the number of support points generated is supplied.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter subject to an IntervalSet, uniformly spaced supports including both ends are generated across the interval. For example, defining a time parameter t in 0 10 with 4 supports using build_parameter gives","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set = IntervalSet(0, 10)\n[0, 10]\n\njulia> t_param = build_parameter(error, set, num_supports = 4, sig_digits = 3)\nIndependentParameter{IntervalSet}([0, 10], DataStructures.SortedDict(0.0=>Set([:uniform_grid]),3.33=>Set([:uniform_grid]),6.67=>Set([:uniform_grid]),10.0=>Set([:uniform_grid])), 3)","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Using macro definition we have","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, 0 <= t <= 10, num_supports = 4, sig_digits = 3)\nt\n\njulia> supports(t)\n4-element Array{Float64,1}:\n  0.0   \n  3.33\n  6.67\n 10.0   \n","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the user can use the keyword argument sig_digits to dictate the significant figures for the supports. The default value of sig_digits is 12.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter that follows a univariate distribution, supports are sampled from the underlying distribution. For example, we can define an infinite parameter subject to a normal distribution with mean 0 and variance 1:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x in dist, num_supports = 4)\nx\n\njulia> supports(x)\n4-element Array{Float64,1}:\n -0.353007400301\n -0.134853871931\n  0.679107426036\n  0.8284134829  ","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For multivariate distributions, though, we require support points are provided in the definition. However, we can use fill_in_supports! to generate supports for parameters following multivariate distributions. See Automatic Support Generation For Defined Parameters for details.","category":"page"},{"location":"guide/parameter/#Automatic-Support-Generation-For-Defined-Parameters","page":"Infinite Parameters","title":"Automatic Support Generation For Defined Parameters","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"So far, we have seen that in both definition methods it is allowed to initialize a parameter with no supports. This is done by not specifying supports and num_supports. However, infinite parameters would not be allowed at the transcription step since it needs information about how to discretize the infinite parameters. In previous examples, we have shown that users can add supports to a defined parameter using methods add_supports and set_supports.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In this section we introduce automatic support generation for defined parameters with no associated supports. This can be done using the fill_in_supports! functions. fill_in_supports! can take as argument a GeneralVariableRef or an AbstractArray{<:GeneralVariableRef}, in which case it will generate supports for the associated infinite parameter. Alternatively, fill_in_supports! can also take an InfiniteModel as an argument, in which case it will generate supports for all infinite parameters of the InfiniteModel with no supports.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The fill_in_supports! method allows users to specify integer keyword arguments num_supports and sig_digits. num_supports dictates the number of supports to be generated, and sig_digits dictates the significant figures of generated supports desired. The default values are 10 and 12, respectively.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The ways by which supports are automatically generated are as follows. If the parameter is in an IntervalSet, then we generate an array of supports that are uniformly distributed along the interval, including the two ends. For example, consider a 3D position parameter x distributed in the unit cube [0, 1]. We can generate supports for that point in the following way:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x[1:3] in [0, 1], independent = true);\n\njulia> fill_in_supports!.(x, num_supports = 3);\n\njulia> supports.(x)\n3-element Array{Array{Float64,1},1}:\n [0.0, 0.5, 1.0]\n [0.0, 0.5, 1.0]\n [0.0, 0.5, 1.0]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the dot syntax because fill_in_supports! takes single GeneralVariableRef as argument. In each dimension, three equally spaced supports ([0.0, 0.5, 1.0]) are generated. Since the independent keyword is set as true, the transcription stage will create a three-dimensional grid for all variables parameterized by x, with each point separated by 0.5 units in each dimension.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"If the parameter is in a UniDistributionSet or MultiDistributionSet, fill_in_supports! samples num_supports supports from the distribution. Recall that support generation is not allowed for parameters under multivariate distribution during parameter definition. However, if the parameter is defined first without supports, fill_in_supports! allows for supports generation. For example, for a 2D random variable xi under a multivariate Gaussian distribution, we can generate supports for it in the following way:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = MvNormal([0., 0.], [1. 0.; 0. 2.])\nFullNormal(\ndim: 2\nμ: [0.0, 0.0]\nΣ: [1.0 0.0; 0.0 2.0]\n)\n\n\njulia> @infinite_parameter(model, xi[1:2] in dist);\n\njulia> fill_in_supports!(xi, num_supports = 3)\n\njulia> supports(xi)\n2×3 Array{Float64,2}:\n -0.353007  0.679107  0.586617\n -0.190712  1.17155   0.420496","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that fill_in_supports! only fill in supports for parameters with no associated supports. To modify the supports of parameters already associated with some supports, refer to Supports for how to do that.","category":"page"},{"location":"guide/parameter/#Parameter-Queries","page":"Infinite Parameters","title":"Parameter Queries","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In addition to the modeling framework, this package provides many functions for users to access information about the model. This section will go over basic functions for accessing parameter information.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Once a (possibly large-scale) InfiniteModel is built, the users might want to check if an infinite parameter is actually used in any way. This could be checked by is_used function as follows:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x in [0, 1])\nx\n\njulia> is_used(x)\nfalse\n","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"This function checks if the parameter is used by any constraint, measure, or variable. In a similar way, functions used_by_constraint, used_by_measure and used_by_infinite_variable can be applied to find out any dependency of specific types on the infinite parameter.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In addition, sometimes we need to check if a certain GeneralVariableRef for an infinite parameter is valid with an InfiniteModel model, meaning that the parameter reference actually refers to some parameter associated with the model. We extend the JuMP.is_valid function from JuMP for that purpose. To see how to use this, for example,","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> pref1 = GeneralVariableRef(model, 1, IndependentParameterIndex);\n\njulia> pref2 = GeneralVariableRef(model, 2, IndependentParameterIndex);\n\njulia> is_valid(model, pref1)\ntrue\n\njulia> is_valid(model, pref2)\nfalse","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"The second call of is_valid returns false because the model does not have parameter with index 2 yet.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also access different information about the set that the infinite parameter is in. This is given by infinite_set, which takes a [GeneralVariableRef] as argument. For example, we have","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> infinite_set(x)\n[0, 1]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"infinite_set might be more useful if the infinite parameter is in a UniDistributionSet or MultiDistributionSet, by which users can access information about the underlying distribution. On the other hand, if we already know that the parameter is in an interval set, we can use JuMP.has_lower_bound, JuMP.lower_bound, JuMP.has_upper_bound, JuMP.upper_bound to retrieve information about the interval set in a more specific way:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> has_lower_bound(x)\ntrue\n\njulia> lower_bound(x)\n0.0\n\njulia> has_upper_bound(x)\ntrue\n\njulia> upper_bound(x)\n1.0","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"A quick way for users to obtain a GeneralVariableRef for a parameter with a known name would be through parameter_by_name function. This function takes an InfiniteModel and the parameter name in string, and returns a GeneralVariableRef for that parameter. For example,","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> pref = parameter_by_name(model, \"x\")\nx","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"If there is no parameter associated with that name, the function would return nothing. Otherwise, if multiple parameters share the same name, the function would throw an error.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now we introduce two additional functions that we can use to access parameter information for an  InfiniteModel. The function num_parameters returns the number of infinite parameters associated with a model, while all_parameters returns the list of all infinite parameter references in the model. For a quick example:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, y[1:2] in [0, 5])\n2-element Array{GeneralVariableRef,1}:\n y[1]\n y[2]\n\njulia> num_parameters(model)\n3\n\njulia> all_parameters(model)\n3-element Array{GeneralVariableRef,1}:\n x   \n y[1]\n y[2]","category":"page"},{"location":"guide/parameter/#Parameter-Modification","page":"Infinite Parameters","title":"Parameter Modification","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In this section we introduce a few shortcuts for users to modify defined infinite parameters.","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"First, once an infinite parameter is defined, we can change its name by calling the [JuMP.set_name] function, which takes the [GeneralVariableRef] of the parameter that needs a name change and the name string as arguments. For example, to change the parameter x to t we can do:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> JuMP.set_name(x, \"t\")\n\njulia> all_parameters(model)\n3-element Array{GeneralVariableRef,1}:\n t   \n y[1]\n y[2]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"In a similar way, we can also change the infinite set that the parameter is in using the set_infinite_set function as follows:","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t = parameter_by_name(model, \"t\")\nt\n\njulia> set_infinite_set(t, IntervalSet(0, 5))\n\njulia> infinite_set(t)\n[0, 5]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"For parameters in an IntervalSet, we extend JuMP.set_lower_bound and JuMP.set_upper_bound functions for users to modify the lower bounds and upper bounds. For example,","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> JuMP.set_lower_bound(t, 1)\n\njulia> JuMP.set_upper_bound(t, 4)\n\njulia> infinite_set(t)\n[1, 4]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"We do not support setting lower bounds and upper bounds for random parameters in a UniDistributionSet and will throw an error if users attempt to do so. If users want to set lower bound and upper bound for a random infinite parameter, consider using Distributions.Truncated, which creates a truncated distribution from a univariate distribution.","category":"page"},{"location":"guide/parameter/#Datatypes","page":"Infinite Parameters","title":"Datatypes","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Pages   = [\"parameter.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"InfOptParameter\nScalarParameter\nIndependentParameter\nDependentParameters\nScalarParameterData\nMultiParameterData\nIndependentParameterIndex\nDependentParametersIndex\nDependentParameterIndex\nIndependentParameterRef\nDependentParameterRef","category":"page"},{"location":"guide/parameter/#InfiniteOpt.InfOptParameter","page":"Infinite Parameters","title":"InfiniteOpt.InfOptParameter","text":"InfOptParameter <: JuMP.AbstractVariable\n\nAn abstract type for all parameters used in InfiniteOpt.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.ScalarParameter","page":"Infinite Parameters","title":"InfiniteOpt.ScalarParameter","text":"ScalarParameter <: InfOptParameter\n\nAn abstract type for scalar parameters used in InfiniteOpt.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.IndependentParameter","page":"Infinite Parameters","title":"InfiniteOpt.IndependentParameter","text":"IndependentParameter{T <: InfiniteScalarSet} <: ScalarParameter\n\nA DataType for storing independent scalar infinite parameters.\n\nFields\n\nset::T: The infinite set that characterizes the parameter.\nsupports::DataStructures.SortedDict{Float64, Set{Symbol}}: The support points  used to discretize the parameter and their associated type labels stored as  Symbols.\nsig_digits::Int: The number of significant digits used to round the support values.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.DependentParameters","page":"Infinite Parameters","title":"InfiniteOpt.DependentParameters","text":"DependentParameters{T <: InfiniteArraySet} <: InfOptParameter\n\nA DataType for storing a collection of dependent infinite parameters.\n\nFields\n\nset::T: The infinite set that characterizes the parameters.\nsupports::Dict{Vector{Float64}, Set{Symbol}}: Support dictionary where keys             are supports and the values are the set of labels for each support\nsig_digits::Int: The number of significant digits used to round the support values.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.ScalarParameterData","page":"Infinite Parameters","title":"InfiniteOpt.ScalarParameterData","text":"ScalarParameterData{P <: ScalarParameter} <: AbstractDataObject\n\nA mutable DataType for storing ScalarParameters and their data.\n\nFields\n\nparameter::P: The scalar parameter.\nobject_num::Int: The location of the corresponding ObjectIndex in   InfiniteModel.param_object_indices (given by InfiniteModel.last_object_num).\nparameter_num::Int: Given by InfiniteModel.last_param_num (updated when                       prior parameters are deleted)\nname::String: The name used for printing.\ninfinite_var_indices::Vector{InfiniteVariableIndex}: Indices of dependent  infinite variables.\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nconstraint_indices::Vector{ConstraintIndex}: Indices of dependent constraints.\nin_objective::Bool: Is this used in objective? This should be true only for finite parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.MultiParameterData","page":"Infinite Parameters","title":"InfiniteOpt.MultiParameterData","text":"MultiParameterData{T <: InfiniteArraySet} <: AbstractDataObject\n\nA mutable DataType for storing DependentParameters and their data.\n\nFields\n\nparameters::DependentParametersP: The parameter collection.\nobject_num::Int: The location of the corresponding ObjectIndex in  InfiniteModel.param_object_indices (given by InfiniteModel.last_object_num).\nparameter_nums::UnitRange{Int}: Given by InfiniteModel.last_param_num                                   (updated when prior parameters are deleted)\nnames::Vector{String}: The names used for printing each parameter.\ninfinite_var_indices::Vector{InfiniteVariableIndex}: Indices of  dependent infinite variables.\nmeasure_indices::Vector{Vector{MeasureIndex}}: Indices of dependent measures.\nconstraint_indices::Vector{Vector{ConstraintIndex}}: Indices of dependent constraints.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.IndependentParameterIndex","page":"Infinite Parameters","title":"InfiniteOpt.IndependentParameterIndex","text":"IndependentParameterIndex <: ObjectIndex\n\nA DataType for storing the index of a IndependentParameter.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.DependentParametersIndex","page":"Infinite Parameters","title":"InfiniteOpt.DependentParametersIndex","text":"DependentParametersIndex <: ObjectIndex\n\nA DataType for storing the index of a DependentParameters object.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.DependentParameterIndex","page":"Infinite Parameters","title":"InfiniteOpt.DependentParameterIndex","text":"DependentParameterIndex <: AbstractInfOptIndex\n\nA DataType for storing the index of an indiviudal parameter in a DependentParameters object.\n\nFields\n\nobject_index::DependentParametersIndex: The index of the parameter collection.\nparam_index::Int: The index of the individual parameter in the above object.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.IndependentParameterRef","page":"Infinite Parameters","title":"InfiniteOpt.IndependentParameterRef","text":"IndependentParameterRef <: DispatchVariableRef\n\nA DataType for independent infinite parameters references that parameterize infinite variables.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::IndependentParameterIndex: Index of the parameter in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.DependentParameterRef","page":"Infinite Parameters","title":"InfiniteOpt.DependentParameterRef","text":"DependentParameterRef <: DispatchVariableRef\n\nA DataType for dependent infinite parameter references that parameterize infinite variables.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::DependentParameterIndex: Index of the dependent parameter.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#Methods/Macros","page":"Infinite Parameters","title":"Methods/Macros","text":"","category":"section"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"Pages   = [\"parameter.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/parameter/","page":"Infinite Parameters","title":"Infinite Parameters","text":"@infinite_parameter\n@independent_parameter\n@dependent_parameters\nbuild_parameter(::Function, ::InfiniteScalarSet)\nbuild_parameter(::Function, ::Real)\nadd_parameter(::InfiniteModel, ::IndependentParameter,::String)\nadd_parameters\nJuMP.name(::ScalarParameterRef)\nJuMP.name(::DependentParameterRef)\nJuMP.set_name(::ScalarParameterRef, ::String)\nJuMP.set_name(::DependentParameterRef, ::String)\nused_by_infinite_variable(::IndependentParameterRef)\nused_by_infinite_variable(::DependentParameterRef)\nused_by_measure(::ScalarParameterRef)\nused_by_measure(::DependentParameterRef)\nused_by_constraint(::ScalarParameterRef)\nused_by_constraint(::DependentParameterRef)\nused_by_objective(::FiniteParameterRef)\nis_used(::IndependentParameterRef)\nis_used(::DependentParameterRef)\nparameter_by_name(::InfiniteModel,::String)\ninfinite_set(::IndependentParameterRef)\ninfinite_set(::DependentParameterRef)\ninfinite_set(::AbstractArray{<:DependentParameterRef})\nset_infinite_set(::IndependentParameterRef,::InfiniteScalarSet)\nset_infinite_set(::DependentParameterRef,::InfiniteScalarSet)\nset_infinite_set(::AbstractArray{<:DependentParameterRef},::InfiniteArraySet)\nJuMP.has_lower_bound(::IndependentParameterRef)\nJuMP.has_lower_bound(::DependentParameterRef)\nJuMP.lower_bound(::IndependentParameterRef)\nJuMP.lower_bound(::DependentParameterRef)\nJuMP.set_lower_bound(::IndependentParameterRef, ::Real)\nJuMP.set_lower_bound(::DependentParameterRef,::Real)\nJuMP.has_upper_bound(::IndependentParameterRef)\nJuMP.has_upper_bound(::DependentParameterRef)\nJuMP.upper_bound(::IndependentParameterRef)\nJuMP.upper_bound(::DependentParameterRef)\nJuMP.set_upper_bound(::IndependentParameterRef,::Real)\nJuMP.set_upper_bound(::DependentParameterRef,::Real)\nsignificant_digits(::IndependentParameterRef)\nsignificant_digits(::DependentParameterRef)\nnum_supports(::IndependentParameterRef)\nnum_supports(::DependentParameterRef)\nnum_supports(::AbstractArray{<:DependentParameterRef})\nhas_supports(::IndependentParameterRef)\nhas_supports(::DependentParameterRef)\nhas_supports(::AbstractArray{<:DependentParameterRef})\nsupports(::IndependentParameterRef)\nsupports(::DependentParameterRef)\nsupports(::AbstractArray{<:DependentParameterRef})\nset_supports(::IndependentParameterRef, ::Vector{<:Real})\nset_supports(::AbstractArray{<:DependentParameterRef},::AbstractArray{<:Vector{<:Real}})\nadd_supports(::IndependentParameterRef,::Union{Real, Vector{<:Real}})\nadd_supports(::AbstractArray{<:DependentParameterRef},::AbstractArray{<:Vector{<:Real}})\ndelete_supports(::IndependentParameterRef)\ndelete_supports(::AbstractArray{<:DependentParameterRef})\ngenerate_and_add_supports!(::IndependentParameterRef,::AbstractInfiniteSet,::Union{Symbol, Nothing})\ngenerate_and_add_supports!(::AbstractArray{<:DependentParameterRef},::InfiniteArraySet,::Union{Symbol, Nothing})\nfill_in_supports!(::IndependentParameterRef)\nfill_in_supports!(::AbstractArray{<:DependentParameterRef})\nfill_in_supports!(::InfiniteModel)\nnum_parameters\nall_parameters\nJuMP.delete(::InfiniteModel, ::IndependentParameterRef)\nJuMP.delete(::InfiniteModel,::AbstractArray{<:DependentParameterRef})","category":"page"},{"location":"guide/parameter/#InfiniteOpt.@infinite_parameter","page":"Infinite Parameters","title":"InfiniteOpt.@infinite_parameter","text":"@infinite_parameter(model::InfiniteModel, kw_args...)::GeneralVariableRef\n\nAdd anonymous infinite parameter to the model model described by the keyword arguments kw_args and returns the parameter reference.\n\n@infinite_parameter(model::InfiniteModel, expr, kw_args...)::GeneralVariableRef\n\nAdd an infinite parameter to the model model described by the expression expr, and the keyword arguments kw_args. This is just a wrapper macro that will make the appropriate call to either @independent_parameter or @dependent_parameters. (Note that in the following the symbol <= can be used instead of ≤, the symbol >=can be used instead of ≥, and the symbol in can be used instead of ∈) The expression expr can be of the form:\n\nparamexpr creating parameters described by paramexpr.\nlb ≤ paramexpr ≤ ub creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ [lb, ub] creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ dist creating parameters described by paramexpr characterized  by the Distributions.jl distribution object dist.\nparamexpr ∈ set creating parameters described by paramexpr characterized by the AbstractInfiniteSet object set.\n\nThe expression paramexpr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the parameter lower bound for an interval set.\nupper_bound: Sets the value of the parameter upper bound for an interval set.\nset: The InfiniteSet characterizing the parameters see subtypes of        AbstractInfiniteSet.\ndistribution: Sets the Distributions.jl distribution object that characterizes the parameters.\nsupports: Sets the support points for the parameters.\nnum_supports: Specifies the number of supports to be automatically generated.                 Note that supports takes precedence. Defaults to DefaultNumSupports.\nsig_digits: Specifies the number of significant digits that should be used             in automatic support generation. Defaults to DefaultSigDigits.\nindependent: Specifies if the each parameter is independent from each other or not. Defaults to false.\ncontainer: Specify the container type. Defaults to automatic\n\nExamples\n\njulia> @infinite_parameter(m, x in [0, 1])\nx\n\njulia> @infinite_parameter(m, y[i = 1:2] in MvNormal(ones(2)), num_supports = 10)\n2-element Array{GeneralVariableRef,1}:\n y[1]\n y[2]\n\njulia> z = @infinite_parameter(m, [[\"a\", \"b\"]], distribution = Normal(),\n                               independent = true)\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n    Dimension 1, [\"a\", \"b\"]\nAnd data, a 2-element Array{GeneralVariableRef,1}:\n noname[a]\n noname[b]\n\n\n\n\n\n","category":"macro"},{"location":"guide/parameter/#InfiniteOpt.@independent_parameter","page":"Infinite Parameters","title":"InfiniteOpt.@independent_parameter","text":"@independent_parameter(model::InfiniteModel, kw_args...)::GeneralVariableRef\n\nAdd an anonymous infinite parameter to the model model described by the keyword arguments kw_args and returns the parameter reference.\n\n@independent_parameter(model::InfiniteModel, expr, kw_args...)::GeneralVariableRef\n\nAdd a parameter to the model model described by the expression expr and the keyword arguments kw_args. (note that in the following the symbol <= can be used instead of ≤, the symbol >=can be used instead of ≥, and the symbol in can be used instead of ∈) The expression expr can be of the form:\n\nparamexpr creating parameters described by paramexpr.\nlb ≤ paramexpr ≤ ub creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ [lb, ub] creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ dist creating parameters described by paramexpr characterized  by the Distributions.jl distribution object dist.\n\nThe expression paramexpr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the parameter lower bound for an interval set.\nupper_bound: Sets the value of the parameter upper bound for an interval set.\nset: The InfiniteSet characterizing the parameters see IntervalSet  and UniDistributionSet.\ndistribution: Sets the Distributions.jl distribution object that characterizes the parameters.\nsupports: Sets the support points for the parameters.\nnum_supports: Specifies the number of supports to be automatically generated.                 Note that supports takes precedence. Defaults to DefaultNumSupports.\nsig_digits: Specifies the number of significant digits that should be used             in automatic support generation. Defaults to DefaultSigDigits.\ncontainer: Specify the container type. Defaults to automatic\n\nExamples\n\njulia> @independent_parameter(m, x in [0, 1])\nx\n\njulia> @independent_parameter(m, y[i = 1:2] in Normal(), num_supports = 10)\n2-element Array{GeneralVariableRef,1}:\n y[1]\n y[2]\n\njulia> z = @independent_parameter(m, [[\"a\", \"b\"]], lower_bound = 0,\n                                  upper_bound = 1, supports = [0, 0.5, 1])\n1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:\n   Dimension 1, [\"a\", \"b\"]\nAnd data, a 2-element Array{GeneralVariableRef,1}:\nnoname[a]\nnoname[b]\n\n\n\n\n\n","category":"macro"},{"location":"guide/parameter/#InfiniteOpt.@dependent_parameters","page":"Infinite Parameters","title":"InfiniteOpt.@dependent_parameters","text":"@dependent_parameters(model::InfiniteModel, kw_args...)::GeneralVariableRef\n\nAdd anonymous dependent infinite parameters to the model model described by the keyword arguments kw_args and returns the container of parameter references.\n\n@dependent_parameters(model::InfiniteModel, expr, kw_args...)::GeneralVariableRef\n\nAdd a container of dependent infinite parameters to the model model described by the expression expr, and the keyword arguments kw_args. (note that in the following the symbol <= can be used instead of ≤, the symbol >=can be used instead of ≥, and the symbol in can be used instead of ∈) The expression expr can be of the form:\n\nparamexpr creating parameters described by paramexpr.\nlb ≤ paramexpr ≤ ub creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ [lb, ub] creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ dist creating parameters described by paramexpr characterized  by the Distributions.jl distribution object dist.\nparamexpr ∈ set creating parameters described by paramexpr characterized  by the AbstractInfiniteSet object set.\n\nThe expression paramexpr must be of the form:\n\nparamname[...] or [...] creating a container of parameters\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the parameter lower bound for an interval set.\nupper_bound: Sets the value of the parameter upper bound for an interval set.\nset: The InfiniteSet characterizing the parameters that are subtypes of        AbstractInfiniteSet.\ndistribution: Sets the Distributions.jl distribution object that characterizes the parameters.\nsupports: Sets the support points for the parameters.\nnum_supports: Specifies the number of supports to be automatically generated.                 Note that supports takes precedence. Defaults to DefaultNumSupports.\nsig_digits: Specifies the number of significant digits that should be used             in automatic support generation. Defaults to DefaultSigDigits.\ncontainer: Specify the container type. Defaults to automatic.\n\nExamples\n\njulia> @dependent_parameters(m, x[1:2] in [0, 1])\n2-element Array{GeneralVariableRef,1}:\n x[1]\n x[2]\n\njulia> @dependent_parameters(m, y[i = 1:2] in MvNormal(ones(2)), num_supports = 10)\n2-element Array{GeneralVariableRef,1}:\n y[1]\n y[2]\n\njulia> z = @dependent_parameters(m, [i = [\"a\", \"b\"], j = 1:2],\n                                 distribution = MatrixBeta(2, 2, 2))\n2-dimensional DenseAxisArray{GeneralVariableRef,2,...} with index sets:\n    Dimension 1, [\"a\", \"b\"]\n    Dimension 2, Base.OneTo(2)\nAnd data, a 2×2 Array{GeneralVariableRef,2}:\n noname[a,1]  noname[a,2]\n noname[b,1]  noname[b,2]\n\n\n\n\n\n","category":"macro"},{"location":"guide/parameter/#InfiniteOpt.build_parameter-Tuple{Function,InfiniteScalarSet}","page":"Infinite Parameters","title":"InfiniteOpt.build_parameter","text":"build_parameter(_error::Function, set::InfiniteScalarSet;\n                [num_supports::Int = 0,\n                supports::Union{Real, Vector{<:Real}} = Real[],\n                sig_digits::Int = DefaultSigDigits]\n                )::IndependentParameter\n\nReturns a IndependentParameter given the appropriate information. This is analagous to JuMP.build_variable. Errors if supports violate the bounds associated with set. This is meant to primarily serve as a helper method for @independent_parameter.\n\nExample\n\njulia> build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))\nIndependentParameter{IntervalSet}(IntervalSet(0.0, 3.0), DataStructures.SortedDict(0.0 => Set([]),1.0 => Set([]),2.0 => Set([]),3.0 => Set([])))\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.build_parameter-Tuple{Function,Real}","page":"Infinite Parameters","title":"InfiniteOpt.build_parameter","text":"build_parameter(_error::Function, value::Real)::FiniteParameter\n\nReturns a FiniteParameter given the appropriate information. This is analagous to JuMP.build_variable. This is meant to primarily serve as a helper method for @finite_parameter.\n\nExample\n\njulia> build_finite_parameter(error, 1)\nFiniteParameter(1.0)\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.add_parameter-Tuple{InfiniteModel,IndependentParameter,String}","page":"Infinite Parameters","title":"InfiniteOpt.add_parameter","text":"add_parameter(model::InfiniteModel,\n              p::Union{IndependentParameterRef, FiniteParameterRef},\n              [name::String = \"\"])::GeneralVariableRef\n\nReturns a GeneralVariableRef associated with the parameter p that is added to model. This adds a parameter to the model in a manner similar to JuMP.add_variable. This can be used to add parameters with the use of @infinite_parameter. build_parameter should be used to construct p.\n\nExample\n\njulia> p = build_independent_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))\nIndependentParameter{IntervalSet}(IntervalSet(0.0, 3.0), DataStructures.SortedDict(0.0 => Set([]),1.0 => Set([]),2.0 => Set([]),3.0 => Set([])))\n\njulia> param_ref = add_parameter(model, p, \"name\")\nname\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.add_parameters","page":"Infinite Parameters","title":"InfiniteOpt.add_parameters","text":"add_parameters(model::InfiniteModel,\n               params::DependentParameters,\n               names::Vector{String} = [\"noname\", \"noname\", ...],\n               indices = nothing\n               )::AbstractArray{<:GeneralVariableRef}\n\nAdd params to model and return an appropriate container of the dependent infinite parameter references. This is intended as an internal method for use with @dependent_parameters. However, if desired users can use this to create a container of infinite dependent parameter without the use of a macro. names denote the name of each parameter and indices denote the indices of the expected container as used by Containers._make_array (implemented by VectorTuples), by default a Vector is returned.\n\nExample\n\njulia> using Distributions\n\njulia> dist = MvNormal(ones(3)); # 3 dimensional\n\njulia> set = MultiDistributionSet(dist); # 3 dimensional\n\njulia> params = DependentParameters(set, Dict{Vector{Float64}, Set{Symbol}}(), 10);\n\njulia> prefs = add_parameters(model, params, [\"par1\", \"par2\", \"par3\"])\n3-element Array{GeneralVariableRef,1}:\n par1\n par2\n par3\n\n\n\n\n\n","category":"function"},{"location":"guide/parameter/#JuMP.name-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}","page":"Infinite Parameters","title":"JuMP.name","text":"JuMP.name(pref::Union{IndependentParameterRef, FiniteParameterRef})::String\n\nExtend the JuMP.name function to accomodate infinite parameters. Returns the name string associated with pref.\n\nExample\n\njulia> name(t)\n\"t\"\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.name-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.name","text":"JuMP.name(pref::DependentParameterRef)::String\n\nExtend JuMP.name to return the names of infinite dependent parameters.\n\nExample\n\njulia> name(pref)\n\"par_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_name-Tuple{Union{FiniteParameterRef, IndependentParameterRef},String}","page":"Infinite Parameters","title":"JuMP.set_name","text":"JuMP.set_name(pref::ScalarParameterRef, name::String)\n\nExtend the JuMP.set_name function to accomodate infinite parameters. Set a new base name to be associated with pref.\n\nExample\n\njulia> set_name(t, \"time\")\n\njulia> name(t)\n\"time\"\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_name-Tuple{DependentParameterRef,String}","page":"Infinite Parameters","title":"JuMP.set_name","text":"JuMP.set_name(pref::DependentParameterRef, name::String)::Nothing\n\nExtend JuMP.set_name to set names of dependent infinite parameters.\n\nExample\n\njulia> set_name(vref, \"par_name\")\n\njulia> name(vref)\n\"para_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_infinite_variable-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_infinite_variable","text":"used_by_infinite_variable(pref::IndependentParameterRef)::Bool\n\nReturn true if pref is used by an infinite variable or false otherwise.\n\nExample\n\njulia> used_by_variable(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_infinite_variable-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_infinite_variable","text":"used_by_infinite_variable(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used by an infinite variable.\n\nExample\n\njulia> used_by_objective(pref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_measure-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool\n\nReturn true if pref is used by a measure or false otherwise.\n\nExample\n\njulia> used_by_measure(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_measure-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used by a measure.\n\nExample\n\njulia> used_by_measure(pref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_constraint-Tuple{Union{FiniteParameterRef, IndependentParameterRef}}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool\n\nReturn true if pref is used by a constraint or false otherwise.\n\nExample\n\njulia> used_by_constraint(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_constraint-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(pref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_objective-Tuple{FiniteParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(pref::FiniteParameterRef)::Bool\n\nReturn true if pref is used by the objective function.\n\nExample\n\n\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.is_used-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.is_used","text":"is_used(pref::Union{IndependentParameterRef, FiniteParameterRef})::Bool\n\nReturn true if pref is used in the model or false otherwise.\n\nExample\n\njulia> is_used(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.is_used-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.is_used","text":"is_used(pref::DependentParameterRef)::Bool\n\nReturn a Bool indicating if the dependent infinite parameter pref is used in the model.\n\nExample\n\njulia> is_used(pref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}","page":"Infinite Parameters","title":"InfiniteOpt.parameter_by_name","text":"parameter_by_name(model::InfiniteModel,\n                  name::String)::Union{GeneralVariableRef, Nothing}\n\nReturn the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.\n\nExample\n\njulia> parameter_by_name(model, \"t\")\nt\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.infinite_set-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.infinite_set","text":"infinite_set(pref::IndependentParameterRef)::InfiniteScalarSet\n\nReturn the infinite set associated with pref.\n\nExample\n\njulia> infinite_set(t)\n[0, 1]\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.infinite_set-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.infinite_set","text":"infinite_set(pref::DependentParameterRef)::InfiniteScalarSet\n\nReturn the infinite set associated with the particular infinite dependent parameter pref if valid. Errors if the underlying DependentParameters object does not use a CollectionSet.\n\nExample\n\njulia> infinite_set(x[1])\n[-1, 1]\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.infinite_set-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.infinite_set","text":"infinite_set(prefs::AbstractArray{<:DependentParameterRef})::InfiniteArraySet\n\nReturn the infinite set associated with the container of infinite dependent parameters prefs. Errors if the container prefs is incomplete.\n\nExample\n\njulia> infinite_set(x)\nZeroMeanDiagNormal(\ndim: 2\nμ: [0.0, 0.0]\nΣ: [1.0 0.0; 0.0 1.0]\n)\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_infinite_set-Tuple{IndependentParameterRef,InfiniteScalarSet}","page":"Infinite Parameters","title":"InfiniteOpt.set_infinite_set","text":"set_infinite_set(pref::IndependentParameterRef,\n                 set::InfiniteScalarSet)::Nothing\n\nReset the infinite set of pref with set of the same type as the original set. An error will be thrown if pref is being used by some measure.\n\nExample\n\njulia> set_infinite_set(t, IntervalSet(0, 2))\n\njulia> infinite_set(t)\n[0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_infinite_set-Tuple{DependentParameterRef,InfiniteScalarSet}","page":"Infinite Parameters","title":"InfiniteOpt.set_infinite_set","text":"set_infinite_set(pref::DependentParameterRef,\n                 set::InfiniteScalarSet)::Nothing\n\nSpecify the scalar infinite set of the dependent infinite parameter pref to set if pref is part of a CollectionSet, otherwise an error is thrown. Note this will reset/delete all the supports contained in the underlying DependentParameters object. Also, errors if pref is used by a measure or if the new set type is different than the original.\n\nExample\n\njulia> set_infinite_set(x[1], IntervalSet(0, 2))\n\njulia> infinite_set(x[1])\n[0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_infinite_set-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef,InfiniteArraySet}","page":"Infinite Parameters","title":"InfiniteOpt.set_infinite_set","text":"set_infinite_set(prefs::AbstractArray{<:DependentParameterRef},\n                 set::InfiniteArraySet)::Nothing\n\nSpecify the multi-dimensional infinite set of the dependent infinite parameters prefs to set. Note this will reset/delete all the supports contained in the underlying DependentParameters object. This will error if the not all of the dependent infinite parameters are included, if any of them are used by measures, or if the new set type is different than the previous.\n\nExample\n\njulia> set_infinite_set(x, CollectionSet([IntervalSet(0, 1), IntervalSet(0, 2)]))\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.has_lower_bound-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(pref::IndependentParameterRef)::Bool\n\nExtend the JuMP.has_lower_bound function to accomodate infinite parameters. Return true if the set associated with pref has a defined lower bound or if a lower bound can be found. Extensions with user-defined infinite set types should extend JuMP.has_lower_bound(set::NewType).\n\nExample\n\njulia> has_lower_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.has_lower_bound-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(pref::DependentParameterRef)::Bool\n\nExtend the JuMP.has_lower_bound function to accomodate a single dependent infinite parameter. Return true if the set associated with pref has a defined lower bound or if a lower bound can be found. Extensions with user-defined scalar infinite set types should extend JuMP.has_lower_bound(set::NewType).\n\nExample\n\njulia> has_lower_bound(x[1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.lower_bound-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.lower_bound","text":"JuMP.lower_bound(pref::IndependentParameterRef)::Real\n\nExtend the JuMP.lower_bound function to accomodate infinite parameters. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> lower_bound(t)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.lower_bound-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.lower_bound","text":"JuMP.lower_bound(pref::DependentParameterRef)::Number\n\nExtend the JuMP.lower_bound function to accomodate a single dependent infinite parameter. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> lower_bound(x[1])\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_lower_bound-Tuple{IndependentParameterRef,Real}","page":"Infinite Parameters","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(pref::IndependentParameterRef, lower::Real)::Nothing\n\nExtend the JuMP.set_lower_bound function to accomodate infinite parameters. Updates the infinite set lower bound if such an operation is supported. Set extensions that seek to employ this should extend JuMP.set_lower_bound(set::NewType, lower::Number).\n\nExample\n\njulia> set_lower_bound(t, -1)\n\njulia> lower_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_lower_bound-Tuple{DependentParameterRef,Real}","page":"Infinite Parameters","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(pref::DependentParameterRef, lower::Real)::Nothing\n\nExtend the JuMP.set_lower_bound function to accomodate a single dependent infinite parameter. Updates the infinite set lower bound if such an operation is supported. Infinite scalar set extensions that seek to employ this should extend JuMP.set_lower_bound(set::NewType, lower::Number). This will call set_infinite_set and will error if this is not well-defined. Note that existing supports will be deleted.\n\nExample\n\njulia> set_lower_bound(t, -1)\n\njulia> lower_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.has_upper_bound-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(pref::IndependentParameterRef)::Bool\n\nExtend the JuMP.has_upper_bound function to accomodate infinite parameters. Return true if the set associated with pref has a defined upper bound or if a upper bound can be found. Extensions with user-defined sets should extend JuMP.has_upper_bound(set::NewType).\n\nExample\n\njulia> has_upper_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.has_upper_bound-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(pref::DependentParameterRef)::Bool\n\nExtend the JuMP.has_upper_bound function to accomodate a single dependent infinite parameter. Return true if the set associated with pref has a defined upper bound or if a upper bound can be found. Extensions with user-defined scalar infinite set types should extend JuMP.has_upper_bound(set::NewType).\n\nExample\n\njulia> has_upper_bound(x[1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.upper_bound-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.upper_bound","text":"JuMP.upper_bound(pref::IndependentParameterRef)::Real\n\nExtend the JuMP.upper_bound function to accomodate infinite parameters. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined. Extensions with user-defined set types should extend JuMP.has_upper_bound(set::NewType) and JuMP.upper_bound(set::NewType) if appropriate.\n\nExample\n\njulia> upper_bound(t)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.upper_bound-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.upper_bound","text":"JuMP.upper_bound(pref::DependentParameterRef)::Number\n\nExtend the JuMP.upper_bound function to accomodate a single dependent infinite parameter. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> upper_bound(x[1])\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_upper_bound-Tuple{IndependentParameterRef,Real}","page":"Infinite Parameters","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(pref::IndependentParameterRef, lower::Real)::Nothing\n\nExtend the JuMP.set_upper_bound function to accomodate infinite parameters. Updates the infinite set upper bound if and only if it is an IntervalSet. Errors otherwise. Extensions with user-defined infinite sets should extend JuMP.set_upper_bound(set::NewType, upper::Number) if appropriate.\n\nExample\n\njulia> set_upper_bound(t, 2)\n\njulia> upper_bound(t)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_upper_bound-Tuple{DependentParameterRef,Real}","page":"Infinite Parameters","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(pref::DependentParameterRef, upper::Real)::Nothing\n\nExtend the JuMP.set_upper_bound function to accomodate a single dependent infinite parameter. Updates the infinite set upper bound if such an operation is supported. Infinite scalar set extensions that seek to employ this should extend JuMP.set_upper_bound(set::NewType, upper::Number). This will call set_infinite_set and will error if this is not well-defined. Note that existing supports will be deleted.\n\nExample\n\njulia> set_upper_bound(t, -1)\n\njulia> upper_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.significant_digits-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.significant_digits","text":"significant_digits(pref::IndependentParameterRef)::Int\n\nReturn the number of significant digits enforced on the supports of pref.\n\nExample\n\njulia> significant_digits(t)\n12\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.significant_digits-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.significant_digits","text":"significant_digits(pref::DependentParameterRef)::Int\n\nReturn the number of significant digits enforced on the supports of pref.\n\nExample\n\njulia> significant_digits(x[1])\n12\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.num_supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.num_supports","text":"num_supports(pref::IndependentParameterRef; [label::Symbol = All])::Int\n\nReturn the number of support points associated with pref.\n\nExample\n\njulia> num_supports(t)\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.num_supports-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.num_supports","text":"num_supports(pref::DependentParameterRef; [label::Symbol = All])::Int\n\nReturn the number of support points associated with a single dependent infinite parameter pref. Specify a subset of supports via label to only count the supports with label.\n\nExample\n\njulia> num_supports(x[1])\n2\n\njulia> num_supports(x[1], label = MCSample)\n0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.num_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.num_supports","text":"num_supports(prefs::AbstractArray{<:DependentParameterRef};\n             [label::Symbol = All])::Int\n\nReturn the number of support points associated with dependent infinite parameters prefs. Errors if not all from the same underlying object. Specify a subset of supports via label to only count the supports with label.\n\nExample\n\njulia> num_supports(x)\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.has_supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.has_supports","text":"has_supports(pref::IndependentParameterRef)::Bool\n\nReturn true if pref has supports or false otherwise.\n\nExample\n\njulia> has_supports(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.has_supports-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.has_supports","text":"has_supports(pref::DependentParameterRef)::Bool\n\nReturn true if pref has supports or false otherwise.\n\nExample\n\njulia> has_supports(x[1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.has_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.has_supports","text":"has_supports(prefs::AbstractArray{<:DependentParameterRef})::Bool\n\nReturn true if prefs have supports or false otherwise. Errors if not all of the infinite dependent parameters are from the same object.\n\nExample\n\njulia> has_supports(x)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(pref::IndependentParameterRef; [label::Symbol = All])::Vector{Float64}\n\nReturn the support points associated with pref. Errors if there are no supports. Users can query just support points generated by a certain method using the keyword argument label. By default, the function returns all support points regardless of the associated label.\n\nExample\n\njulia> supports(t)\n2-element Array{Float64,1}:\n 0.0\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.supports-Tuple{DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(pref::DependentParameterRef; [label::Symbol = All])::Vector{Float64}\n\nReturn the support points associated with pref. A subset of supports can be returned via label to return just the supports associated with label.\n\nExample\n\njulia> supports(x[1])\n2-element Array{Float64,1}:\n 0.0\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.supports-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(prefs::AbstractArray{<:DependentParameterRef};\n         [label::Symbol = All]\n         )::Union{AbstractArray{<:Vector{<:Float64}}, Array{Float64, 2}}\n\nReturn the support points associated with prefs. Errors if not all of the infinite dependent parameters are from the same object. This will return a matrix if prefs is Vector, otherwise an array of vectors is returned by calling supports.(prefs). A subset of supports can be returned via label to return just the supports associated with label.\n\nExample\n\njulia> supports(x) # columns are supports\n2×2 Array{Float64,2}:\n 0.0  1.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_supports-Tuple{IndependentParameterRef,Array{#s38,1} where #s38<:Real}","page":"Infinite Parameters","title":"InfiniteOpt.set_supports","text":"set_supports(pref::IndependentParameterRef, supports::Vector{<:Real};\n             [force::Bool = false])::Nothing\n\nSpecify the support points for pref. Errors if the supports violate the bounds associated with the infinite set. Warns if the points are not unique. If force this will overwrite exisiting supports otherwise it will error if there are existing supports.\n\nExample\n\njulia> set_supports(t, [0, 1])\n\njulia> supports(t)\n2-element Array{Int64,1}:\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef,AbstractArray{#s9,N} where N where #s9<:(Array{#s5,1} where #s5<:Real)}","page":"Infinite Parameters","title":"InfiniteOpt.set_supports","text":"set_supports(prefs::AbstractArray{<:DependentParameterRef},\n             supports::AbstractArray{<:Vector{<:Real}};\n             [force::Bool = false])::Nothing\n\nSpecify the support points for prefs. Errors if the supports violate the domain of the infinite set, if the dimensions don't match up properly, if prefs and supports have different indices, not all of the prefs are from the same dependent infinite parameter container, there are existing supports and force = false. Note that it is strongly preferred to use add_supports if possible to avoid destroying measure dependencies.\n\n    set_supports(prefs::Vector{DependentParameterRef},\n                 supports::Array{<:Real, 2};\n                 [force::Bool = false])::Nothing\n\nSpecify the supports for a vector prefs of dependent infinite parameters. Here rows of supports correspond to prefs and the columns correspond to the supports. This is more efficient than the above method and will error for the same reasons.\n\nExample\n\njulia> set_supports(y, [[0, 1], [0, 1]])\n\njulia> set_supports(x, [0 1; 0 1])\n\njulia> supports(x)\n2×2 Array{Float64,2}:\n 0.0  1.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.add_supports-Tuple{IndependentParameterRef,Union{Real, Array{#s38,1} where #s38<:Real}}","page":"Infinite Parameters","title":"InfiniteOpt.add_supports","text":"add_supports(pref::IndependentParameterRef,\n             supports::Union{Real, Vector{<:Real}};\n             label::Symbol = UserDefined)::Nothing\n\nAdd additional support points for pref with identifying label label.\n\nExample\n\njulia> add_supports(t, 0.5)\n\njulia> supports(t)\n3-element Array{Float64,1}:\n 0.0\n 0.5\n 1.0\n\njulia> add_supports(t, [0.25, 1])\n\njulia> supports(t)\n4-element Array{Float64,1}:\n 0.0\n 0.25\n 0.5\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.add_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef,AbstractArray{#s9,N} where N where #s9<:(Array{#s5,1} where #s5<:Real)}","page":"Infinite Parameters","title":"InfiniteOpt.add_supports","text":"add_supports(prefs::AbstractArray{<:DependentParameterRef},\n             supports::AbstractArray{<:Vector{<:Real}})::Nothing\n\nAdd additional support points for prefs. Errors if the supports violate the domain of the infinite set, if the dimensions don't match up properly, if prefs and supports have different indices, or not all of the prefs are from the same dependent infinite parameter container.\n\n    add_supports(prefs::Vector{DependentParameterRef},\n                 supports::Array{<:Real, 2})::Nothing\n\nSpecify the supports for a vector prefs of dependent infinite parameters. Here rows of supports correspond to prefs and the columns correspond to the supports. This is more efficient than the above method and will error for the same reasons.\n\nExample\n\njulia> add_supports(x, [[1], [1]])\n\njulia> supports(x)\n2×2 Array{Float64,2}:\n 0.0  1.0\n 0.0  1.0\n\njulia> add_supports(x, ones(2, 1) * 0.5)\n\njulia> supports(t)\n2×3 Array{Float64,2}:\n 0.0  1.0  0.5\n 0.0  1.0  0.5\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.delete_supports-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.delete_supports","text":"delete_supports(pref::IndependentParameterRef)\n\nDelete the support points for pref.\n\nExample\n\njulia> delete_supports(t)\n\njulia> supports(t)\nERROR: Parameter t does not have supports.\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.delete_supports-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.delete_supports","text":"delete_supports(prefs::AbstractArray{<:DependentParameterRef})::Nothing\n\nDelete the support points for prefs. Errors if any of the parameters are used by a measure or if not all belong to the same set of dependent parameters.\n\nExample\n\njulia> delete_supports(w)\n\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.generate_and_add_supports!-Tuple{IndependentParameterRef,AbstractInfiniteSet,Union{Nothing, Symbol}}","page":"Infinite Parameters","title":"InfiniteOpt.generate_and_add_supports!","text":"generate_and_add_supports!(pref::IndependentParameterRef,\n                           set::AbstractInfiniteSet,\n                           method::Union{Symbol, Nothing} = nothing;\n                           [num_supports::Int = DefaultNumSupports])::Nothing\n\nGenerate supports for independent parameter pref via generate_support_values and add them to pref. This is intended as an extendable internal method for fill_in_supports!. Most extensions that empoy user-defined infinite sets can typically enable this by extending generate_support_values. Errors if the infinite set type is not recognized.\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.generate_and_add_supports!-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef,InfiniteArraySet,Union{Nothing, Symbol}}","page":"Infinite Parameters","title":"InfiniteOpt.generate_and_add_supports!","text":"generate_and_add_supports!(prefs::AbstractArray{<:DependentParameterRef},\n                           set::InfiniteArraySet,\n                           method::Union{Symbol, Nothing} = nothing;\n                           [num_supports::Int = DefaultNumSupports])::Nothing\n\nGenerate supports for prefs via generate_support_values and add them to pref. This is intended as an extendable internal method for fill_in_supports!. Most extensions that employ user-defined infinite sets can typically enable this by extending generate_support_values. However, in some cases it may be necessary to extend this when more complex operations need to take place then just adding supports to a set of infinite parameters. Errors if the infinite set type is not recognized.\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.fill_in_supports!-Tuple{IndependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(pref::IndependentParameterRef;\n                  [num_supports::Int = DefaultNumSupports])::Nothing\n\nAutomatically generate support points for a particular independent parameter pref. Generating num_supports for the parameter. The supports are generated uniformly if the underlying infinite set is an IntervalSet or they are generating randomly accordingly to the distribution if the set is a UniDistributionSet. Will add nothing if there are supports and modify = false. Extensions that use user defined set types should extend generate_and_add_supports! and/or generate_support_values as needed. Errors if the infinite set type is not recognized.\n\nExample\n\njulia> fill_in_supports!(x, num_supports = 4)\n\njulia> supports(x)\n4-element Array{Number,1}:\n 0.0\n 0.333\n 0.667\n 1.0\n\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.fill_in_supports!-Tuple{AbstractArray{#s38,N} where N where #s38<:DependentParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(prefs::AbstractArray{<:DependentParameterRef};\n                  [num_supports::Int = DefaultNumSupports,\n                   modify::Bool = true])::Nothing\n\nAutomatically generate support points for a container of dependent infinite parameters prefs. Generating up to num_supports for the parameters in accordance with generate_and_add_supports!. Will add nothing if there are supports and modify = false. Extensions that use user defined set types should extend generate_and_add_supports! and/or generate_support_values as needed. Errors if the infinite set type is not recognized.\n\nExample\n\njulia> fill_in_supports!(x, num_supports = 4)\n\njulia> supports(x)\n2×4 Array{Float64,2}:\n 0.0  0.333  0.667  1.0\n 0.0  0.333  0.667  1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}","page":"Infinite Parameters","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(model::InfiniteModel; [num_supports::Int = DefaultNumSupports,\n                  modify::Bool = true])::Nothing\n\nAutomatically generate support points for all infinite parameters in model. This calls fill_in_supports! for each parameter in the model. See fill_in_supports! for more information. Errors if one of the infinite set types is unrecognized. Note that no supports will be added to a particular parameter if it already has some and modify = false.\n\nExample\n\njulia> fill_in_supports!(model, num_supports = 4)\n\njulia> supports(t)\n4-element Array{Float64,1}:\n 0.0\n 0.333\n 0.667\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.num_parameters","page":"Infinite Parameters","title":"InfiniteOpt.num_parameters","text":"num_parameters(model::InfiniteModel,\n               [type::Type{InfOptParameter} = InfOptParameter])::Int\n\nReturn the number of InfiniteOpt parameters assigned to model. By default, the total number of infinite and finite parameters is returned. The amount of a particular type is obtained by specifying the concrete parameter type of InfOptParameter via type. Type options include:\n\nInfOptParameter: all parameters\nScalarParameter: all scalar parameters\nInfiniteParameter: all infinite parameters\nFiniteParameter: all finite parameters\nIndependentParameter: all independent infinite parameters\nDependentParameters: all dependent infinite parameters\n\nExample\n\njulia> num_parameters(model)\n3\n\njulia> num_parameters(model, IndependentParameter)\n2\n\n\n\n\n\n","category":"function"},{"location":"guide/parameter/#InfiniteOpt.all_parameters","page":"Infinite Parameters","title":"InfiniteOpt.all_parameters","text":"all_parameters(model::InfiniteModel,\n               type::Type{InfOptParameter} = InfOptParameter\n               )::Vector{GeneralVariableRef}\n\nReturn a list of all the InfiniteOpt parameters assigned to model. By default, all of the infinite and finite parameters is returned. The search is reduced to a particular type is obtained by specifying the concrete parameter type of InfOptParameter via type. Type options include:\n\nInfOptParameter: all parameters\nScalarParameter: all scalar parameters\nInfiniteParameter: all infinite parameters\nFiniteParameter: all finite parameters\nIndependentParameter: all independent infinite parameters\nDependentParameters: all dependent infinite parameters\n\nExamples\n\njulia> all_parameters(model)\n4-element Array{GeneralVariableRef,1}:\n t\n x[1]\n x[2]\n alpha\n\njulia> all_parameters(model, FiniteParameter)\n1-element Array{GeneralVariableRef,1}:\n alpha\n\n\n\n\n\n","category":"function"},{"location":"guide/parameter/#JuMP.delete-Tuple{InfiniteModel,IndependentParameterRef}","page":"Infinite Parameters","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, pref::ScalarParameterRef)::Nothing\n\nExtend JuMP.delete to delete scalar parameters and their dependencies. All variables, constraints, and measure functions that depend on pref are updated to exclude it. Errors if the parameter is contained in an AbstractMeasureData datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that parameter_refs needs to be extended to allow deletion of parameters when custom AbstractMeasureData datatypes are used. Note that any dependent infinite variables will have their start values reset via reset_start_value_function.\n\nExample\n\njulia> print(model)\nMin measure(g(t, x)*t + x) + z\nSubject to\n z ≥ 0.0\n g(t, x) + z ≥ 42.0, ∀ t ∈ [0, 6], x ∈ [-1, 1]\n g(0.5, x) = 0, ∀ x ∈ [-1, 1]\n\njulia> delete(model, x)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]\n g(0.5) = 0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.delete-Tuple{InfiniteModel,AbstractArray{#s38,N} where N where #s38<:DependentParameterRef}","page":"Infinite Parameters","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel,\n            prefs::AbstractArray{<:DependentParameterRef})::Nothing\n\nExtend JuMP.delete to delete dependent infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on prefs are updated to exclude them. Errors if the parameters are contained in an AbstractMeasureData datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that parameter_refs needs to be extended to allow deletion of parameters when custom AbstractMeasureData datatypes are used. Note that any dependent infinite variables will have their start values reset to the default via reset_start_value_function.\n\nExample\n\njulia> print(model)\nMin measure(g(t, x)*t + x) + z\nSubject to\n z ≥ 0.0\n g(t, x) + z ≥ 42.0, ∀ t ∈ [0, 6], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]\n g(0.5, x) = 0, x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]\n\njulia> delete(model, x)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]\n g(0.5) = 0\n\n\n\n\n\n","category":"method"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"JuMP/#JuMP-Documentation","page":"JuMP Docs","title":"JuMP Documentation","text":"","category":"section"},{"location":"JuMP/#Model","page":"JuMP Docs","title":"Model","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.Model\nJuMP.Model()\nJuMP.Model(::Any)\nJuMP.NoOptimizer\nJuMP.optimizer_with_attributes(::Any, ::Pair)\nJuMP.direct_model","category":"page"},{"location":"JuMP/#JuMP.Model","page":"JuMP Docs","title":"JuMP.Model","text":"Model\n\nA mathematical model of an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.Model-Tuple{}","page":"JuMP Docs","title":"JuMP.Model","text":"Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC)\n\nReturn a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the CachingOptimizer storing this cache is caching_mode. Use set_optimizer to set the optimizer before calling optimize!.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.Model-Tuple{Any}","page":"JuMP Docs","title":"JuMP.Model","text":"Model(optimizer_factory;\n      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,\n      bridge_constraints::Bool=true)\n\nReturn a new JuMP model with the provided optimizer and bridge settings. This function is equivalent to:\n\n    model = Model()\n    set_optimizer(model, optimizer_factory,\n                  bridge_constraints=bridge_constraints)\n    return model\n\nSee set_optimizer for the description of the optimizer_factory and bridge_constraints arguments.\n\nExamples\n\nThe following creates a model with the optimizer set to Ipopt:\n\nmodel = Model(Ipopt.Optimizer)\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.NoOptimizer","page":"JuMP Docs","title":"JuMP.NoOptimizer","text":"struct NoOptimizer <: Exception end\n\nNo optimizer is set. The optimizer can be provided to the Model constructor or by calling set_optimizer.\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.optimizer_with_attributes-Tuple{Any,Pair}","page":"JuMP Docs","title":"JuMP.optimizer_with_attributes","text":"optimizer_with_attributes(optimizer_constructor, attrs::Pair...)\n\nGroups an optimizer constructor with the list of attributes attrs. Note that it is equivalent to MOI.OptimizerWithAttributes.\n\nWhen provided to the Model constructor or to set_optimizer, it creates an optimizer by calling optimizer_constructor(), and then sets the attributes using set_optimizer_attribute.\n\nExample\n\nmodel = Model(\n    optimizer_with_attributes(\n        Gurobi.Optimizer, \"Presolve\" => 0, \"OutputFlag\" => 1\n    )\n)\n\nis equivalent to:\n\nmodel = Model(Gurobi.Optimizer)\nset_optimizer_attribute(model, \"Presolve\", 0)\nset_optimizer_attribute(model, \"OutputFlag\", 1)\n\nNote\n\nThe string names of the attributes are specific to each solver. One should consult the solver's documentation to find the attributes of interest.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.direct_model","page":"JuMP Docs","title":"JuMP.direct_model","text":"direct_model(backend::MOI.ModelLike)\n\nReturn a new JuMP model using backend to store the model and solve it. As opposed to the Model constructor, no cache of the model is stored outside of backend and no bridges are automatically applied to backend. The absence of cache reduces the memory footprint but it is important to bear in mind the following implications of creating models using this direct mode:\n\nWhen backend does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the Model constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when optimize! is called.\nNo constraint bridging is supported by default.\nThe optimizer used cannot be changed the model is constructed.\nThe model created cannot be copied.\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#Variables","page":"JuMP Docs","title":"Variables","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.AbstractVariableRef\nJuMP.add_variable\nJuMP.@variable\nJuMP.delete(::JuMP.Model, ::JuMP.VariableRef)\nJuMP.is_valid(::JuMP.Model, ::JuMP.VariableRef)\nJuMP.set_name(::JuMP.VariableRef, ::String)\nJuMP.owner_model(::AbstractVariableRef)\nJuMP.index(::JuMP.VariableRef)\nJuMP.num_variables(::JuMP.Model)\nJuMP.name(::JuMP.VariableRef)\nJuMP.variable_by_name(::JuMP.Model, ::String)\nJuMP.all_variables(::JuMP.Model)\nJuMP.has_lower_bound(::JuMP.VariableRef)\nJuMP.lower_bound(::JuMP.VariableRef)\nJuMP.set_lower_bound(::JuMP.VariableRef, ::Number)\nJuMP.LowerBoundRef(::JuMP.VariableRef)\nJuMP.delete_lower_bound(::JuMP.VariableRef)\nJuMP.has_upper_bound(::JuMP.VariableRef)\nJuMP.upper_bound(::JuMP.VariableRef)\nJuMP.set_upper_bound(::JuMP.VariableRef, ::Number)\nJuMP.UpperBoundRef(::JuMP.VariableRef)\nJuMP.delete_upper_bound(::JuMP.VariableRef)\nJuMP.is_fixed(::JuMP.VariableRef)\nJuMP.fix_value(::JuMP.VariableRef)\nJuMP.fix(::JuMP.VariableRef, ::Number)\nJuMP.FixRef(::JuMP.VariableRef)\nJuMP.unfix(::JuMP.VariableRef)\nJuMP.start_value(::JuMP.VariableRef)\nJuMP.set_start_value(::JuMP.VariableRef, ::Number)\nJuMP.is_binary(::JuMP.VariableRef)\nJuMP.set_binary(::JuMP.VariableRef)\nJuMP.BinaryRef(::JuMP.VariableRef)\nJuMP.unset_binary(::JuMP.VariableRef)\nJuMP.is_integer(::JuMP.VariableRef)\nJuMP.set_integer(::JuMP.VariableRef)\nJuMP.IntegerRef(::JuMP.VariableRef)\nJuMP.unset_integer(::JuMP.VariableRef)","category":"page"},{"location":"JuMP/#JuMP.AbstractVariableRef","page":"JuMP Docs","title":"JuMP.AbstractVariableRef","text":"AbstractVariableRef\n\nVariable returned by add_variable. Affine (resp. quadratic) operations with variables of type V<:AbstractVariableRef and coefficients of type T     create a GenericAffExpr{T,V} (resp. GenericQuadExpr{T,V}).\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.add_variable","page":"JuMP Docs","title":"JuMP.add_variable","text":"add_variable(m::Model, v::AbstractVariable, name::String=\"\")\n\nAdd a variable v to Model m and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.@variable","page":"JuMP Docs","title":"JuMP.@variable","text":"@variable(model, kw_args...)\n\nAdd an anonymous variable to the model model described by the keyword arguments kw_args and returns the variable.\n\n@variable(model, expr, args..., kw_args...)\n\nAdd a variable to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. The expression expr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥)\n\nof the form varexpr creating variables described by varexpr;\nof the form varexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb);\nof the form varexpr == value creating variables described by varexpr with fixed values given by value; or\nof the form lb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub.\nof the form varexpr in set creating variables described by varexpr constrained to belong to set, see Variables constrained on creation.\n\nThe expression varexpr can either be\n\nof the form varname creating a scalar real variable of name varname;\nof the form varname[...] or [...] creating a container of variables (see Containers in macros).\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\nSymmetric: Only available when creating a square matrix of variables, i.e. when varexpr is of the form varname[1:n,1:n] or varname[i=1:n,j=1:n]. It creates a symmetric matrix of variable, that is, it only creates a new variable for varname[i,j] with i ≤ j and sets varname[j,i] to the same variable as varname[i,j]. It is equivalent to using varexpr in SymMatrixSpace() as expr.\nPSD: The square matrix of variable is both Symmetric and constrained to be positive semidefinite. It is equivalent to using varexpr in PSDCone() as expr.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\nvariable_type: See the \"Note for extending the variable macro\" section below.\nset: Equivalent to using varexpr in value as expr where value is the value of the keyword argument.\ncontainer: Specify the container type, see Containers in macros.\n\nExamples\n\nThe following are equivalent ways of creating a variable x of name x with lower bound 0:\n\n# Specify everything in `expr`\n@variable(model, x >= 0)\n# Specify the lower bound using a keyword argument\n@variable(model, x, lower_bound=0)\n# Specify everything in `kw_args`\nx = @variable(model, base_name=\"x\", lower_bound=0)\n\nThe following are equivalent ways of creating a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b]. The upper bound can either be specified in expr:\n\nub = Dict(:a => 2, :b => 3)\n@variable(model, x[i=keys(ub)] <= ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nor it can be specified with the upper_bound keyword argument:\n\n@variable(model, y[i=keys(ub)], upper_bound=ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n y[a]\n y[b]\n\nNote for extending the variable macro\n\nThe single scalar variable or each scalar variable of the container are created using add_variable(model, build_variable(_error, info, extra_args...; extra_kw_args...)) where\n\nmodel is the model passed to the @variable macro;\n_error is an error function with a single String argument showing the @variable call in addition to the error message given as argument;\ninfo is the VariableInfo struct containing the information gathered in expr, the recognized keyword arguments (except base_name and variable_type) and the recognized positional arguments (except Symmetric and PSD);\nextra_args are the unrecognized positional arguments of args plus the value of the variable_type keyword argument if present. The variable_type keyword argument allows the user to pass a position argument to build_variable without the need to give a positional argument to @variable. In particular, this allows the user to give a positional argument to the build_variable call when using the anonymous single variable syntax @variable(model, kw_args...); and\nextra_kw_args are the unrecognized keyword argument of kw_args.\n\nExamples\n\nThe following creates a variable x of name x with lower_bound 0 as with the first example above but does it without using the @variable macro\n\ninfo = VariableInfo(true, 0, false, NaN, false, NaN, false, NaN, false, false)\nJuMP.add_variable(model, JuMP.build_variable(error, info), \"x\")\n\nThe following creates a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b] as with the second example above but does it without using the @variable macro\n\n# Without the `@variable` macro\nx = JuMP.Containers.container(i -> begin\n        info = VariableInfo(false, NaN, true, ub[i], false, NaN, false, NaN, false, false)\n        x[i] = JuMP.add_variable(model, JuMP.build_variable(error, info), \"x[$i]\")\n    end, JuMP.Containers.vectorized_product(keys(ub)))\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nThe following are equivalent ways of creating a Matrix of size N x N with variables custom variables created with a JuMP extension using the Poly(X) positional argument to specify its variables:\n\n# Using the `@variable` macro\n@variable(model, x[1:N,1:N], Symmetric, Poly(X))\n# Without the `@variable` macro\nx = Matrix{JuMP.variable_type(model, Poly(X))}(N, N)\ninfo = VariableInfo(false, NaN, false, NaN, false, NaN, false, NaN, false, false)\nfor i in 1:N, j in i:N\n    x[i,j] = x[j,i] = JuMP.add_variable(model, build_variable(error, info, Poly(X)), \"x[$i,$j]\")\nend\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/#JuMP.delete-Tuple{Model,VariableRef}","page":"JuMP Docs","title":"JuMP.delete","text":"delete(model::Model, variable_ref::VariableRef)\n\nDelete the variable associated with variable_ref from the model model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}","page":"JuMP Docs","title":"JuMP.is_valid","text":"is_valid(model::Model, variable_ref::VariableRef)\n\nReturn true if variable refers to a valid variable in model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_name-Tuple{VariableRef,String}","page":"JuMP Docs","title":"JuMP.set_name","text":"set_name(v::VariableRef, s::AbstractString)\n\nSet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.owner_model-Tuple{AbstractVariableRef}","page":"JuMP Docs","title":"JuMP.owner_model","text":"owner_model(v::AbstractVariableRef)\n\nReturns the model to which v belongs.\n\nExample\n\njulia> model = Model()\n\njulia> x = @variable(model)\n\njulia> owner_model(x) === model\ntrue\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.index-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.index","text":"index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.num_variables-Tuple{Model}","page":"JuMP Docs","title":"JuMP.num_variables","text":"num_variables(model::Model)::Int64\n\nReturns number of variables in model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.name-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.name","text":"name(v::VariableRef)::String\n\nGet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.variable_by_name-Tuple{Model,String}","page":"JuMP Docs","title":"JuMP.variable_by_name","text":"variable_by_name(model::AbstractModel,\n                 name::String)::Union{AbstractVariableRef, Nothing}\n\nReturns the reference of the variable with name attribute name or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute.\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> variable_by_name(model, \"x\")\nx\n\njulia> @variable(model, base_name=\"x\")\nx\n\njulia> variable_by_name(model, \"x\")\nERROR: Multiple variables have the name x.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222\n [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]\n [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490\n [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268\n [6] top-level scope at none:0\n\njulia> var = @variable(model, base_name=\"y\")\ny\n\njulia> variable_by_name(model, \"y\")\ny\n\njulia> set_name(var, \"z\")\n\njulia> variable_by_name(model, \"y\")\n\njulia> variable_by_name(model, \"z\")\nz\n\njulia> @variable(model, u[1:2])\n2-element Array{VariableRef,1}:\n u[1]\n u[2]\n\njulia> variable_by_name(model, \"u[2]\")\nu[2]\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.all_variables-Tuple{Model}","page":"JuMP Docs","title":"JuMP.all_variables","text":"all_variables(model::Model)::Vector{VariableRef}\n\nReturns a list of all variables currently in the model. The variables are ordered by creation time.\n\nExample\n\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\nall_variables(model)\n\n# output\n\n2-element Array{VariableRef,1}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.has_lower_bound","text":"has_lower_bound(v::VariableRef)\n\nReturn true if v has a lower bound. If true, the lower bound can be queried with lower_bound. See also LowerBoundRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.lower_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.lower_bound","text":"lower_bound(v::VariableRef)\n\nReturn the lower bound of a variable. Error if one does not exist. See also has_lower_bound.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_lower_bound-Tuple{VariableRef,Number}","page":"JuMP Docs","title":"JuMP.set_lower_bound","text":"set_lower_bound(v::VariableRef, lower::Number)\n\nSet the lower bound of a variable. If one does not exist, create a new lower bound constraint. See also delete_lower_bound.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.LowerBoundRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(v::VariableRef)\n\nReturn a constraint reference to the lower bound constraint of v. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.delete_lower_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(v::VariableRef)\n\nDelete the lower bound constraint of a variable.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.has_upper_bound","text":"has_upper_bound(v::VariableRef)\n\nReturn true if v has a upper bound. If true, the upper bound can be queried with upper_bound. See also UpperBoundRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.upper_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.upper_bound","text":"upper_bound(v::VariableRef)\n\nReturn the upper bound of a variable. Error if one does not exist. See also has_upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_upper_bound-Tuple{VariableRef,Number}","page":"JuMP Docs","title":"JuMP.set_upper_bound","text":"set_upper_bound(v::VariableRef,upper::Number)\n\nSet the upper bound of a variable. If one does not exist, create an upper bound constraint. See also delete_upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.UpperBoundRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.UpperBoundRef","text":"UpperBoundRef(v::VariableRef)\n\nReturn a constraint reference to the upper bound constraint of v. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.delete_upper_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(v::VariableRef)\n\nDelete the upper bound constraint of a variable.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_fixed-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.is_fixed","text":"is_fixed(v::VariableRef)\n\nReturn true if v is a fixed variable. If true, the fixed value can be queried with fix_value. See also FixRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.fix_value-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.fix_value","text":"fix_value(v::VariableRef)\n\nReturn the value to which a variable is fixed. Error if one does not exist. See also is_fixed.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.fix-Tuple{VariableRef,Number}","page":"JuMP Docs","title":"JuMP.fix","text":"fix(v::VariableRef, value::Number; force::Bool = false)\n\nFix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one. See also unfix.\n\nIf the variable already has variable bounds and force=false, calling fix will throw an error. If force=true, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to unfix.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.FixRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.FixRef","text":"FixRef(v::VariableRef)\n\nReturn a constraint reference to the constraint fixing the value of v. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.unfix-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.unfix","text":"unfix(v::VariableRef)\n\nDelete the fixing constraint of a variable.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.start_value-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.start_value","text":"start_value(v::VariableRef)\n\nReturn the start value (MOI attribute VariablePrimalStart) of the variable v. See also set_start_value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_start_value-Tuple{VariableRef,Number}","page":"JuMP Docs","title":"JuMP.set_start_value","text":"set_start_value(variable::VariableRef, value::Number)\n\nSet the start value (MOI attribute VariablePrimalStart) of the variable v to value. See also start_value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_binary-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.is_binary","text":"is_binary(v::VariableRef)\n\nReturn true if v is constrained to be binary. See also BinaryRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_binary-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.set_binary","text":"set_binary(v::VariableRef)\n\nAdd a constraint on the variable v that it must take values in the set 01. See also unset_binary.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.BinaryRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.BinaryRef","text":"BinaryRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constrainting v to be binary. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.unset_binary-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.unset_binary","text":"unset_binary(variable_ref::VariableRef)\n\nRemove the binary constraint on the variable variable_ref.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_integer-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.is_integer","text":"is_integer(v::VariableRef)\n\nReturn true if v is constrained to be integer. See also IntegerRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_integer-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.set_integer","text":"set_integer(variable_ref::VariableRef)\n\nAdd an integrality constraint on the variable variable_ref. See also unset_integer.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.IntegerRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.IntegerRef","text":"IntegerRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constrainting v to be integer. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.unset_integer-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.unset_integer","text":"unset_integer(variable_ref::VariableRef)\n\nRemove the integrality constraint on the variable variable_ref.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#Containers","page":"JuMP Docs","title":"Containers","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.Containers.SparseAxisArray\nJuMP.Containers.DenseAxisArray","category":"page"},{"location":"JuMP/#JuMP.Containers.SparseAxisArray","page":"JuMP Docs","title":"JuMP.Containers.SparseAxisArray","text":"struct SparseAxisArray{T,N,K<:NTuple{N, Any}} <: AbstractArray{T,N}\n    data::Dict{K,T}\nend\n\nN-dimensional array with elements of type T where only a subset of the entries are defined. The entries with indices idx = (i1, i2, ..., iN) in keys(data) has value data[idx]. Note that as opposed to SparseArrays.AbstractSparseArray, the missing entries are not assumed to be zero(T), they are simply not part of the array. This means that the result of map(f, sa::SparseAxisArray) or f.(sa::SparseAxisArray) has the same sparsity structure than sa even if f(zero(T)) is not zero.\n\nExample\n\njulia> dict = Dict((:a, 2) => 1.0, (:a, 3) => 2.0, (:b, 3) => 3.0)\nDict{Tuple{Symbol,Int64},Float64} with 3 entries:\n  (:b, 3) => 3.0\n  (:a, 2) => 1.0\n  (:a, 3) => 2.0\n\njulia> array = JuMP.Containers.SparseAxisArray(dict)\nJuMP.Containers.SparseAxisArray{Float64,2,Tuple{Symbol,Int64}} with 3 entries:\n  [b, 3]  =  3.0\n  [a, 2]  =  1.0\n  [a, 3]  =  2.0\n\njulia> array[:b, 3]\n3.0\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.Containers.DenseAxisArray","page":"JuMP Docs","title":"JuMP.Containers.DenseAxisArray","text":"DenseAxisArray(data::Array{T, N}, axes...) where {T, N}\n\nConstruct a JuMP array with the underlying data specified by the data array and the given axes. Exactly N axes must be provided, and their lengths must match size(data) in the corresponding dimensions.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray([1 2; 3 4], [:a, :b], 2:3)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 2:3\nAnd data, a 2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> array[:b, 3]\n4\n\n\n\n\n\nDenseAxisArray{T}(undef, axes...) where T\n\nConstruct an uninitialized DenseAxisArray with element-type T indexed over the given axes.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray{Float64}(undef, [:a, :b], 1:2);\n\njulia> fill!(array, 1.0)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Array{Float64,2}:\n 1.0  1.0\n 1.0  1.0\n\njulia> array[:a, 2] = 5.0\n5.0\n\njulia> array[:a, 2]\n5.0\n\njulia> array\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2×2 Array{Float64,2}:\n 1.0  5.0\n 1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#Expressions","page":"JuMP Docs","title":"Expressions","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.@expression\nJuMP.add_to_expression!","category":"page"},{"location":"JuMP/#JuMP.@expression","page":"JuMP Docs","title":"JuMP.@expression","text":"@expression(args...)\n\nEfficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:\n\n@expression(m, shared, sum(i*x[i] for i=1:5))\n@constraint(m, shared + y >= 5)\n@constraint(m, shared + z <= 10)\n\nThe ref accepts index sets in the same way as @variable, and those indices can be used in the construction of the expressions:\n\n@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))\n\nAnonymous syntax is also supported:\n\nexpr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/#JuMP.add_to_expression!","page":"JuMP Docs","title":"JuMP.add_to_expression!","text":"add_to_expression!(expression, terms...)\n\nUpdates expression in place to expression + (*)(terms...). This is typically much more efficient than expression += (*)(terms...). For example, add_to_expression!(expression, a, b) produces the same result as expression += a*b, and add_to_expression!(expression, a) produces the same result as expression += a.\n\nOnly a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) expression is capable of storing the result. For example, add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef) is not defined because a GenericAffExpr cannot store the product of two variables.\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#Objectives","page":"JuMP Docs","title":"Objectives","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.@objective\nJuMP.set_objective_function\nJuMP.set_objective_sense(::JuMP.Model, ::MOI.OptimizationSense)\nJuMP.objective_function(::JuMP.Model)\nJuMP.objective_function_type(::JuMP.Model)\nJuMP.objective_sense(::JuMP.Model)\nJuMP.set_objective_coefficient(::JuMP.Model, ::JuMP.VariableRef, ::Real)","category":"page"},{"location":"JuMP/#JuMP.@objective","page":"JuMP Docs","title":"JuMP.@objective","text":"@objective(model::Model, sense, func)\n\nSet the objective sense to sense and objective function to func. The objective sense can be either Min, Max, MathOptInterface.MIN_SENSE, MathOptInterface.MAX_SENSE or MathOptInterface.FEASIBILITY_SENSE; see MathOptInterface.ObjectiveSense. In order to set the sense programatically, i.e., when sense is a Julia variable whose value is the sense, one of the three MathOptInterface.ObjectiveSense values should be used. The function func can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.\n\nExamples\n\nTo minimize the value of the variable x, do as follows:\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, x)\nx\n\nTo maximize the value of the affine expression 2x - 1, do as follows:\n\njulia> @objective(model, Max, 2x - 1)\n2 x - 1\n\nTo set a quadratic objective and set the objective sense programatically, do as follows:\n\njulia> sense = MOI.MIN_SENSE\nMIN_SENSE::OptimizationSense = 0\n\njulia> @objective(model, sense, x^2 - 2x + 1)\nx² - 2 x + 1\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/#JuMP.set_objective_function","page":"JuMP Docs","title":"JuMP.set_objective_function","text":"set_objective_function(\n    model::Model,\n    func::Union{AbstractJuMPScalar, MathOptInterface.AbstractScalarFunction})\n\nSets the objective function of the model to the given function. See set_objective_sense to set the objective sense. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.set_objective_sense-Tuple{Model,MathOptInterface.OptimizationSense}","page":"JuMP Docs","title":"JuMP.set_objective_sense","text":"set_objective_sense(model::Model, sense::MathOptInterface.OptimizationSense)\n\nSets the objective sense of the model to the given sense. See set_objective_function to set the objective function. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.objective_function-Tuple{Model}","page":"JuMP Docs","title":"JuMP.objective_function","text":"objective_function(model::Model,\n               T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the objective function. Error if the objective is not convertible to type T.\n\nExamples\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model, AffExpr)\n2 x + 1\n\njulia> objective_function(model, QuadExpr)\n2 x + 1\n\njulia> typeof(objective_function(model, QuadExpr))\nGenericQuadExpr{Float64,VariableRef}\n\nWe see with the last two commands that even if the objective function is affine, as it is convertible to a quadratic function, it can be queried as a quadratic function and the result is quadratic.\n\nHowever, it is not convertible to a variable.\n\njulia> objective_function(model, VariableRef)\nERROR: InexactError: convert(MathOptInterface.SingleVariable, MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 1.0))\n[...]\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.objective_function_type-Tuple{Model}","page":"JuMP Docs","title":"JuMP.objective_function_type","text":"objective_function_type(model::Model)::AbstractJuMPScalar\n\nReturn the type of the objective function.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.objective_sense-Tuple{Model}","page":"JuMP Docs","title":"JuMP.objective_sense","text":"objective_sense(model::Model)::MathOptInterface.OptimizationSense\n\nReturn the objective sense.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_objective_coefficient-Tuple{Model,VariableRef,Real}","page":"JuMP Docs","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(model::Model, variable::VariableRef, coefficient::Real)\n\nSet the linear objective coefficient associated with Variable to coefficient.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#jump_constrs","page":"JuMP Docs","title":"Constraints","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.ScalarConstraint\nJuMP.add_constraint(::JuMP.Model, ::JuMP.AbstractConstraint, ::String)\nJuMP.@constraint\nJuMP.owner_model(::JuMP.ConstraintRef)\nJuMP.index(::JuMP.ConstraintRef)\nJuMP.delete(::JuMP.Model, ::JuMP.ConstraintRef{JuMP.Model})\nJuMP.is_valid(::JuMP.Model, ::JuMP.ConstraintRef{JuMP.Model})\nJuMP.constraint_object\nJuMP.name(::JuMP.ConstraintRef{JuMP.Model,<:JuMP._MOICON})\nJuMP.set_name(::JuMP.ConstraintRef{JuMP.Model,<:JuMP._MOICON}, ::String)\nJuMP.constraint_by_name\nJuMP.num_constraints(::JuMP.Model, ::Type{<:Union{JuMP.AbstractJuMPScalar, Vector{<:JuMP.AbstractJuMPScalar}}}, ::Type{<:MOI.AbstractSet})\nJuMP.all_constraints(::JuMP.Model, ::Type{<:Union{JuMP.AbstractJuMPScalar, Vector{<:JuMP.AbstractJuMPScalar}}}, ::Type{<:MOI.AbstractSet})\nJuMP.list_of_constraint_types(::JuMP.Model)\nJuMP.SecondOrderCone\nJuMP.RotatedSecondOrderCone\nJuMP.PSDCone","category":"page"},{"location":"JuMP/#JuMP.ScalarConstraint","page":"JuMP Docs","title":"JuMP.ScalarConstraint","text":"struct ScalarConstraint\n\nThe data for a scalar constraint. The func field containts a JuMP object representing the function and the set field contains the MOI set. See also the documentation on JuMP's representation of constraints for more background.\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.add_constraint-Tuple{Model,AbstractConstraint,String}","page":"JuMP Docs","title":"JuMP.add_constraint","text":"add_constraint(model::Model, con::AbstractConstraint, name::String=\"\")\n\nAdd a constraint con to Model model and sets its name.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.@constraint","page":"JuMP Docs","title":"JuMP.@constraint","text":"@constraint(m::Model, expr)\n\nAdd a constraint described by the expression expr.\n\n@constraint(m::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr can either be\n\nof the form func in set constraining the function func to belong to the set set which is either a MOI.AbstractSet or one of the JuMP shortcuts SecondOrderCone, RotatedSecondOrderCone and PSDCone, e.g. @constraint(model, [1, x-1, y-2] in SecondOrderCone()) constrains the norm of [x-1, y-2] be less than 1;\nof the form a sign b, where sign is one of ==, ≥, >=, ≤ and <= building the single constraint enforcing the comparison to hold for the expression a and b, e.g. @constraint(m, x^2 + y^2 == 1) constrains x and y to lie on the unit circle;\nof the form a ≤ b ≤ c or a ≥ b ≥ c (where ≤ and <= (resp. ≥ and >=) can be used interchangeably) constraining the paired the expression b to lie between a and c;\nof the forms @constraint(m, a .sign b) or @constraint(m, a .sign b .sign c) which broadcast the constraint creation to each element of the vectors.\n\nNote for extending the constraint macro\n\nEach constraint will be created using add_constraint(m, build_constraint(_error, func, set)) where\n\n_error is an error function showing the constraint call in addition to the error message given as argument,\nfunc is the expression that is constrained\nand set is the set in which it is constrained to belong.\n\nFor expr of the first type (i.e. @constraint(m, func in set)), func and set are passed unchanged to build_constraint but for the other types, they are determined from the expressions and signs. For instance, @constraint(m, x^2 + y^2 == 1) is transformed into add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0))).\n\nTo extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to build_constraint. Note that this will likely mean that either func or set will be some custom type, rather than e.g. a Symbol, since we will likely want to dispatch on the type of the function or set appearing in the constraint.\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/#JuMP.owner_model-Tuple{ConstraintRef}","page":"JuMP Docs","title":"JuMP.owner_model","text":"owner_model(con_ref::ConstraintRef)\n\nReturns the model to which con_ref belongs.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.index-Tuple{ConstraintRef}","page":"JuMP Docs","title":"JuMP.index","text":"index(cr::ConstraintRef)::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.delete-Tuple{Model,ConstraintRef{Model,C,Shape} where Shape<:AbstractShape where C}","page":"JuMP Docs","title":"JuMP.delete","text":"delete(model::Model, con_ref::ConstraintRef)\n\nDelete the constraint associated with constraint_ref from the model model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_valid-Tuple{Model,ConstraintRef{Model,C,Shape} where Shape<:AbstractShape where C}","page":"JuMP Docs","title":"JuMP.is_valid","text":"is_valid(model::Model, con_ref::ConstraintRef{Model})\n\nReturn true if constraint_ref refers to a valid constraint in model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.constraint_object","page":"JuMP Docs","title":"JuMP.constraint_object","text":"constraint_object(con_ref::ConstraintRef)\n\nReturn the underlying constraint data for the constraint referenced by ref.\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.name-Tuple{ConstraintRef{Model,#s38,Shape} where Shape<:AbstractShape where #s38<:MathOptInterface.ConstraintIndex}","page":"JuMP Docs","title":"JuMP.name","text":"name(con_ref::ConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_name-Tuple{ConstraintRef{Model,#s38,Shape} where Shape<:AbstractShape where #s38<:MathOptInterface.ConstraintIndex,String}","page":"JuMP Docs","title":"JuMP.set_name","text":"set_name(con_ref::ConstraintRef, s::AbstractString)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.constraint_by_name","page":"JuMP Docs","title":"JuMP.constraint_by_name","text":"constraint_by_name(model::AbstractModel,\n                   name::String)::Union{ConstraintRef, Nothing}\n\nReturns the reference of the constraint with name attribute name or Nothing if no constraint has this name attribute. Throws an error if several constraints have name as their name attribute.\n\nconstraint_by_name(model::AbstractModel,\n                   name::String,\n                   F::Type{<:Union{AbstractJuMPScalar,\n                                   Vector{<:AbstractJuMPScalar},\n                                   MOI.AbstactFunction}},\n                   S::Type{<:MOI.AbstractSet})::Union{ConstraintRef, Nothing}\n\nSimilar to the method above, except that it throws an error if the constraint is not an F-in-S contraint where F is either the JuMP or MOI type of the function, and S is the MOI type of the set. This method is recommended if you know the type of the function and set since its returned type can be inferred while for the method above (i.e. without F and S), the exact return type of the constraint index cannot be inferred.\n\njulia> using JuMP\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x^2 == 1)\ncon : x² = 1.0\n\njulia> constraint_by_name(model, \"kon\")\n\njulia> constraint_by_name(model, \"con\")\ncon : x² = 1.0\n\njulia> constraint_by_name(model, \"con\", AffExpr, MOI.EqualTo{Float64})\n\njulia> constraint_by_name(model, \"con\", QuadExpr, MOI.EqualTo{Float64})\ncon : x² = 1.0\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.num_constraints-Tuple{Model,Type{#s38} where #s38<:Union{AbstractJuMPScalar, Array{#s9,1} where #s9<:AbstractJuMPScalar},Type{#s5} where #s5<:MathOptInterface.AbstractSet}","page":"JuMP Docs","title":"JuMP.num_constraints","text":"num_constraints(model::Model, function_type, set_type)::Int64\n\nReturn the number of constraints currently in the model where the function has type function_type and the set has type set_type.\n\nSee also list_of_constraint_types and all_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, y in MOI.GreaterThan(1.0));\n\njulia> @constraint(model, y <= 1.0);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> num_constraints(model, VariableRef, MOI.ZeroOne)\n1\n\njulia> num_constraints(model, AffExpr, MOI.LessThan{Float64})\n2\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.all_constraints-Tuple{Model,Type{#s38} where #s38<:Union{AbstractJuMPScalar, Array{#s9,1} where #s9<:AbstractJuMPScalar},Type{#s5} where #s5<:MathOptInterface.AbstractSet}","page":"JuMP Docs","title":"JuMP.all_constraints","text":"all_constraints(model::Model, function_type, set_type)::Vector{<:ConstraintRef}\n\nReturn a list of all constraints currently in the model where the function has type function_type and the set has type set_type. The constraints are ordered by creation time.\n\nSee also list_of_constraint_types and num_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x ≥ 0.0\n\njulia> all_constraints(model, VariableRef, MOI.ZeroOne)\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.ZeroOne},ScalarShape},1}:\n x binary\n\njulia> all_constraints(model, AffExpr, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n 2 x ≤ 1.0\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.list_of_constraint_types-Tuple{Model}","page":"JuMP Docs","title":"JuMP.list_of_constraint_types","text":"list_of_constraint_types(model::Model)\n\nReturn a list of tuples of the form (F, S) where F is a JuMP function type and S is an MOI set type such that all_constraints(model, F, S) returns a nonempty list.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.ZeroOne)\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.SecondOrderCone","page":"JuMP Docs","title":"JuMP.SecondOrderCone","text":"SecondOrderCone\n\nSecond order cone object that can be used to constrain the euclidean norm of a vector x to be less than or equal to a nonnegative scalar t. This is a shortcut for the MOI.SecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le t and t ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x-1, x-2] in SecondOrderCone())\n[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.RotatedSecondOrderCone","page":"JuMP Docs","title":"JuMP.RotatedSecondOrderCone","text":"RotatedSecondOrderCone\n\nRotated second order cone object that can be used to constrain the square of the euclidean norm of a vector x to be less than or equal to 2tu where t and u are nonnegative scalars. This is a shortcut for the MOI.RotatedSecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le 2tx and t x ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())\n[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.PSDCone","page":"JuMP Docs","title":"JuMP.PSDCone","text":"PSDCone\n\nPositive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the @constraint macro. If the matrix has type Symmetric then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the MOI.PositiveSemidefiniteConeTriangle set, otherwise its column vectorization is constrained to belong to the MOI.PositiveSemidefiniteConeSquare set.\n\nExamples\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [ x 2x\n            2x  x];\n\njulia> b = [1 2\n            2 4];\n\njulia> cref = @SDconstraint(model, a ⪰ b)\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nWe see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\njulia> using LinearAlgebra # For Symmetric\n\njulia> cref = @constraint(model, Symmetric(a - b) in PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\nAs we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#Optimization","page":"JuMP Docs","title":"Optimization","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.optimize!(::JuMP.Model, ::Any)\nJuMP.set_silent(::JuMP.Model)\nJuMP.unset_silent(::JuMP.Model)\nJuMP.set_time_limit_sec(::JuMP.Model, ::Any)\nJuMP.unset_time_limit_sec(::JuMP.Model)\nJuMP.time_limit_sec(::JuMP.Model)\nJuMP.bridge_constraints(::JuMP.Model)\nJuMP.add_bridge(::JuMP.Model, ::Type{<:MOI.Bridges.AbstractBridge})\nJuMP.backend(::JuMP.Model)\nJuMP.mode(::JuMP.Model)\nJuMP.solver_name(::JuMP.Model)\nJuMP.set_optimizer_attribute(::JuMP.Model, ::String, ::Any)\nJuMP.set_optimizer_attribute(::JuMP.Model, ::MOI.AbstractOptimizerAttribute, ::Any)\nJuMP.set_optimizer_attributes(::JuMP.Model, ::Pair)\nJuMP.get_optimizer_attribute(::JuMP.Model, ::String)\nJuMP.get_optimizer_attribute(::JuMP.Model, ::MOI.AbstractOptimizerAttribute)\nJuMP.set_optimizer(::JuMP.Model, ::Any)\nJuMP.result_count(::JuMP.Model)","category":"page"},{"location":"JuMP/#JuMP.optimize!-Tuple{Model,Any}","page":"JuMP Docs","title":"JuMP.optimize!","text":"optimize!(model::Model;\n          ignore_optimize_hook=(model.optimize_hook === nothing),\n          kwargs...)\n\nOptimize the model. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nKeyword arguments kwargs are passed to the optimize_hook. An error is thrown if optimize_hook is nothing and keyword arguments are provided.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_silent-Tuple{Model}","page":"JuMP Docs","title":"JuMP.set_silent","text":"set_silent(model::Model)\n\nTakes precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.unset_silent-Tuple{Model}","page":"JuMP Docs","title":"JuMP.unset_silent","text":"unset_silent(model::Model)\n\nNeutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_time_limit_sec-Tuple{Model,Any}","page":"JuMP Docs","title":"JuMP.set_time_limit_sec","text":"set_time_limit_sec(model::Model, limit)\n\nSets the time limit (in seconds) of the solver. Can be unset using unset_time_limit_sec or with limit set to nothing.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.unset_time_limit_sec-Tuple{Model}","page":"JuMP Docs","title":"JuMP.unset_time_limit_sec","text":"unset_time_limit_sec(model::Model)\n\nUnsets the time limit of the solver. Can be set using set_time_limit_sec.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.time_limit_sec-Tuple{Model}","page":"JuMP Docs","title":"JuMP.time_limit_sec","text":"time_limit_sec(model::Model)\n\nGets the time limit (in seconds) of the model (nothing if unset). Can be set using set_time_limit_sec.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.bridge_constraints-Tuple{Model}","page":"JuMP Docs","title":"JuMP.bridge_constraints","text":"bridge_constraints(model::Model)\n\nWhen in direct mode, return false. When in manual or automatic mode, return a Bool indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.add_bridge-Tuple{Model,Type{#s38} where #s38<:MathOptInterface.Bridges.AbstractBridge}","page":"JuMP Docs","title":"JuMP.add_bridge","text":" add_bridge(model::Model,\n            BridgeType::Type{<:MOI.Bridges.AbstractBridge})\n\nAdd BridgeType to the list of bridges that can be used to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.backend-Tuple{Model}","page":"JuMP Docs","title":"JuMP.backend","text":"backend(model::Model)\n\nReturn the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (manual, automatic, or direct), and whether there are any bridges in the model.\n\nIf JuMP is in direct mode (i.e., the model was created using direct_model), the backend with be the optimizer passed to direct_model. If JuMP is in manual or automatic mode, the backend is a MOI.Utilities.CachingOptimizer.\n\nThis function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.mode-Tuple{Model}","page":"JuMP Docs","title":"JuMP.mode","text":"mode(model::Model)\n\nReturn mode (DIRECT, AUTOMATIC, MANUAL) of model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.solver_name-Tuple{Model}","page":"JuMP Docs","title":"JuMP.solver_name","text":"solver_name(model::Model)\n\nIf available, returns the SolverName property of the underlying optimizer. Returns \"No optimizer attached\" in AUTOMATIC or MANUAL modes when no optimizer is attached. Returns \"SolverName() attribute not implemented by the optimizer.\" if the attribute is not implemented.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_optimizer_attribute-Tuple{Model,String,Any}","page":"JuMP Docs","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(model::Model, name::String, value)\n\nSets solver-specific attribute identified by name to value.\n\nNote that this is equivalent to set_optimizer_attribute(model, MOI.RawParameter(name), value).\n\nExample\n\nset_optimizer_attribute(model, \"SolverSpecificAttributeName\", true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_optimizer_attribute-Tuple{Model,MathOptInterface.AbstractOptimizerAttribute,Any}","page":"JuMP Docs","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute, value\n)\n\nSet the solver-specific attribute attr in model to value.\n\nExample\n\nset_optimizer_attribute(model, MOI.Silent(), true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_optimizer_attributes-Tuple{Model,Pair}","page":"JuMP Docs","title":"JuMP.set_optimizer_attributes","text":"set_optimizer_attributes(model::Model, pairs::Pair...)\n\nGiven a list of attribute => value pairs, calls set_optimizer_attribute(model, attribute, value) for each pair.\n\nExample\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attribute(model, \"tol\", 1e-4)\nset_optimizer_attribute(model, \"max_iter\", 100)\n\nSee also: set_optimizer_attribute, get_optimizer_attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.get_optimizer_attribute-Tuple{Model,String}","page":"JuMP Docs","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(model, name::String)\n\nReturn the value associated with the solver-specific attribute named name.\n\nNote that this is equivalent to get_optimizer_attribute(model, MOI.RawParameter(name)).\n\nExample\n\nget_optimizer_attribute(model, \"SolverSpecificAttributeName\")\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.get_optimizer_attribute-Tuple{Model,MathOptInterface.AbstractOptimizerAttribute}","page":"JuMP Docs","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute\n)\n\nReturn the value of the solver-specific attribute attr in model.\n\nExample\n\nget_optimizer_attribute(model, MOI.Silent())\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_optimizer-Tuple{Model,Any}","page":"JuMP Docs","title":"JuMP.set_optimizer","text":"set_optimizer(model::Model, optimizer_factory;\n              bridge_constraints::Bool=true)\n\nCreates an empty MathOptInterface.AbstractOptimizer instance by calling optimizer_factory() and sets it as the optimizer of model. Specifically, optimizer_factory must be callable with zero arguments and return an empty MathOptInterface.AbstractOptimizer.\n\nIf bridge_constraints is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the MathOptInterface.Bridges module or is defined in another module and is explicitly added.\n\nSee set_optimizer_attributes and set_optimizer_attribute for setting solver-specific parameters of the optimizer.\n\nExamples\n\nmodel = Model()\nset_optimizer(model, GLPK.Optimizer)\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.result_count-Tuple{Model}","page":"JuMP Docs","title":"JuMP.result_count","text":"result_count(model::Model)\n\nReturn the number of results available to query after a call to optimize!.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#Queries","page":"JuMP Docs","title":"Queries","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.termination_status(::JuMP.Model)\nJuMP.raw_status(::JuMP.Model)\nJuMP.primal_status(::JuMP.Model)\nJuMP.dual_status(::JuMP.Model)\nJuMP.solve_time(::JuMP.Model)\nJuMP.has_values(::JuMP.Model)\nJuMP.has_duals(::JuMP.Model)\nJuMP.objective_bound(::JuMP.Model)\nJuMP.objective_value(::JuMP.Model)\nJuMP.dual_objective_value(::JuMP.Model)\nJuMP.value(::JuMP.VariableRef)\nJuMP.value(::JuMP.ConstraintRef{JuMP.Model, <:JuMP._MOICON})\nJuMP.dual(::JuMP.ConstraintRef{JuMP.Model, <:JuMP._MOICON})\nJuMP.shadow_price(::JuMP.ConstraintRef{JuMP.Model, <:JuMP._MOICON})\nJuMP.optimizer_index(::JuMP.VariableRef)\nJuMP.optimizer_index(::JuMP.ConstraintRef{JuMP.Model})\nJuMP.lp_rhs_perturbation_range(::JuMP.ConstraintRef{JuMP.Model, <:JuMP._MOICON})\nJuMP.lp_objective_perturbation_range(::JuMP.VariableRef)\nJuMP.reduced_cost(::VariableRef)","category":"page"},{"location":"JuMP/#JuMP.termination_status-Tuple{Model}","page":"JuMP Docs","title":"JuMP.termination_status","text":"termination_status(model::Model)\n\nReturn the reason why the solver stopped (i.e., the MathOptInterface model attribute TerminationStatus).\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.raw_status-Tuple{Model}","page":"JuMP Docs","title":"JuMP.raw_status","text":"raw_status(model::Model)\n\nReturn the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute RawStatusString).\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.primal_status-Tuple{Model}","page":"JuMP Docs","title":"JuMP.primal_status","text":"primal_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute PrimalStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.dual_status-Tuple{Model}","page":"JuMP Docs","title":"JuMP.dual_status","text":"dual_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute DualStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.solve_time-Tuple{Model}","page":"JuMP Docs","title":"JuMP.solve_time","text":"solve_time(model::Model)\n\nIf available, returns the solve time reported by the solver. Returns \"ArgumentError: ModelLike of type Solver.Optimizer does not support accessing the attribute MathOptInterface.SolveTime()\" if the attribute is not implemented.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.has_values-Tuple{Model}","page":"JuMP Docs","title":"JuMP.has_values","text":"has_values(model::Model; result::Int = 1)\n\nReturn true if the solver has a primal solution in result index result available to query, otherwise return false.\n\nSee also value and result_count.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.has_duals-Tuple{Model}","page":"JuMP Docs","title":"JuMP.has_duals","text":"has_duals(model::Model; result::Int = 1)\n\nReturn true if the solver has a dual solution in result index result available to query, otherwise return false.\n\nSee also dual, shadow_price, and result_count.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.objective_bound-Tuple{Model}","page":"JuMP Docs","title":"JuMP.objective_bound","text":"objective_bound(model::Model)\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.objective_value-Tuple{Model}","page":"JuMP Docs","title":"JuMP.objective_value","text":"objective_value(model::Model; result::Int = 1)\n\nReturn the objective value associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.dual_objective_value-Tuple{Model}","page":"JuMP Docs","title":"JuMP.dual_objective_value","text":"dual_objective_value(model::Model; result::Int = 1)\n\nReturn the value of the objective of the dual problem associated with result index result of the most-recent solution returned by the solver.\n\nThrows MOI.UnsupportedAttribute{MOI.DualObjectiveValue} if the solver does not support this attribute.\n\nSee also: result_count.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.value-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.value","text":"value(v::VariableRef; result = 1)\n\nReturn the value of variable v associated with result index result of the most-recent returned by the solver.\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.value-Tuple{ConstraintRef{Model,#s38,Shape} where Shape<:AbstractShape where #s38<:MathOptInterface.ConstraintIndex}","page":"JuMP Docs","title":"JuMP.value","text":"value(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the primal value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nThat is, if con_ref is the reference of a constraint func-in-set, it returns the value of func evaluated at the value of the variables (given by value(::VariableRef)).\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\nNote\n\nFor scalar contraints, the constant is moved to the set so it is not taken into account in the primal value of the constraint. For instance, the constraint @constraint(model, 2x + 3y + 1 == 5) is transformed into 2x + 3y-in-MOI.EqualTo(4) so the value returned by this function is the evaluation of 2x + 3y. ```\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.dual-Tuple{ConstraintRef{Model,#s38,Shape} where Shape<:AbstractShape where #s38<:MathOptInterface.ConstraintIndex}","page":"JuMP Docs","title":"JuMP.dual","text":"dual(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the dual value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nUse has_dual to check if a result exists before asking for values.\n\nSee also: result_count, shadow_price.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.shadow_price-Tuple{ConstraintRef{Model,#s38,Shape} where Shape<:AbstractShape where #s38<:MathOptInterface.ConstraintIndex}","page":"JuMP Docs","title":"JuMP.shadow_price","text":"shadow_price(con_ref::ConstraintRef)\n\nReturn the change in the objective from an infinitesimal relaxation of the constraint.\n\nThis value is computed from dual and can be queried only when has_duals is true and the objective sense is MIN_SENSE or MAX_SENSE (not FEASIBILITY_SENSE). For linear constraints, the shadow prices differ at most in sign from the dual value depending on the objective sense.\n\nSee also reduced_cost.\n\nNotes\n\nThe function simply translates signs from dual and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.\nThe computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.\nRelaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.optimizer_index-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.optimizer_index","text":"optimizer_index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.optimizer_index-Tuple{ConstraintRef{Model,C,Shape} where Shape<:AbstractShape where C}","page":"JuMP Docs","title":"JuMP.optimizer_index","text":"optimizer_index(cr::ConstraintRef{Model})::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached or if the constraint is bridged.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.lp_rhs_perturbation_range-Tuple{ConstraintRef{Model,#s38,Shape} where Shape<:AbstractShape where #s38<:MathOptInterface.ConstraintIndex}","page":"JuMP Docs","title":"JuMP.lp_rhs_perturbation_range","text":"lp_rhs_perturbation_range(constraint::ConstraintRef;\n                          feasibility_tolerance::Float64)\n                          ::Tuple{Float64, Float64}\n\nGives the range by which the rhs coefficient can change and the current LP basis remains feasible, i.e., where the shadow prices apply.\n\nNotes\n\nThe rhs coefficient is the value right of the relation, i.e., b for the constraint when of the form a*x □ b, where □ is ≤, =, or ≥.\nThe range denotes valid changes, e.g., for a*x <= b + Δ, the LP basis remains feasible for all Δ ∈ [l, u].\nfeasibility_tolerance is the primal feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by István Maros, section 9.3.4).\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.lp_objective_perturbation_range-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.lp_objective_perturbation_range","text":"lp_objective_perturbation_range(var::VariableRef;\n                                optimality_tolerance::Float64)\n                                ::Tuple{Float64, Float64}\n\nGives the range by which the cost coefficient can change and the current LP basis remains optimal, i.e., the reduced costs remain valid.\n\nNotes\n\nThe range denotes valid changes, Δ ∈ [l, u], for which cost[var] += Δ do not violate the current optimality conditions.\noptimality_tolerance is the dual feasibility tolerance, this should preferably match the tolerance used by the solver. The defualt tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by István Maros, section 9.3.4).\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.reduced_cost-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.reduced_cost","text":"reduced_cost(x::VariableRef)::Float64\n\nReturn the reduced cost associated with variable x.\n\nEquivalent to querying the shadow price of the active variable bound (if one exists and is active).\n\nSee also: shadow_price.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP-Section-References","page":"JuMP Docs","title":"JuMP Section References","text":"","category":"section"},{"location":"JuMP/#Containers-in-macros","page":"JuMP Docs","title":"Containers in macros","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"The container function encodes the logic for how containers are constructed in JuMP's macros. The @container macro is available to create containers independently of any JuMP model.","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.Containers.container\nJuMP.Containers.default_container\nJuMP.Containers.VectorizedProductIterator\nJuMP.Containers.NestedIterator\nJuMP.Containers.@container","category":"page"},{"location":"JuMP/#JuMP.Containers.container","page":"JuMP Docs","title":"JuMP.Containers.container","text":"container(f::Function, indices, ::Type{C})\n\nCreate a container of type C with indices indices and values at given indices given by f.\n\ncontainer(f::Function, indices)\n\nCreate a container with indices indices and values at given indices given by f. The type of container used is determined by default_container.\n\nExamples\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(Base.OneTo(3), Base.OneTo(3)))\n3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(1:3, 1:3))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(2:3, Base.OneTo(3)))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.nested(() -> 1:3, i -> i:3, condition = (i, j) -> isodd(i) || isodd(j)))\nSparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 5 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.Containers.default_container","page":"JuMP Docs","title":"JuMP.Containers.default_container","text":"default_container(indices)\n\nIf indices is a NestedIterator, return a SparseAxisArray. Otherwise, indices should be a VectorizedProductIterator and the function returns Array if all iterators of the product are Base.OneTo and retunrs DenseAxisArray otherwise.\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.Containers.VectorizedProductIterator","page":"JuMP Docs","title":"JuMP.Containers.VectorizedProductIterator","text":"struct VectorizedProductIterator{T}\n    prod::Iterators.ProductIterator{T}\nend\n\nCartesian product of the iterators prod.iterators. It is the same iterator as Base.Iterators.ProductIterator except that it is independent of the IteratorSize of the elements of prod.iterators. For instance:\n\nsize(Iterators.product(1, 2)) is tuple() while size(VectorizedProductIterator(1, 2)) is (1, 1).\nsize(Iterators.product(ones(2, 3))) is (2, 3) while size(VectorizedProductIterator(ones(2, 3))) is (1, 1).\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.Containers.NestedIterator","page":"JuMP Docs","title":"JuMP.Containers.NestedIterator","text":"struct NestedIterator{T}\n    iterators::T # Tuple of functions\n    condition::Function\nend\n\nIterators over the tuples that are produced by a nested for loop. For instance, if length(iterators) == 3 , this corresponds to the tuples (i1, i2, i3) produced by:\n\nfor i1 in iterators[1]()\n    for i2 in iterator[2](i1)\n        for i3 in iterator[3](i1, i2)\n            if condition(i1, i2, i3)\n                # produces (i1, i2, i3)\n            end\n        end\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.Containers.@container","page":"JuMP Docs","title":"JuMP.Containers.@container","text":"@container([i=..., j=..., ...], expr)\n\nCreate a container with indices i, j, ... and values given by expr that may depend on the value of the indices.\n\n@container(ref[i=..., j=..., ...], expr)\n\nSame as above but the container is assigned to the variable of name ref.\n\nThe type of container can be controlled by the container keyword. See Containers in macros. Note that when the index set is explicitly given as 1:n for any expression n, it is transformed to Base.OneTo(n) before being given to container.\n\nExamples\n\njulia> Containers.@container([i = 1:3, j = 1:3], i + j)\n3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> I = 1:3\n1:3\n\njulia> Containers.@container([i = I, j = I], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3×3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 2:3, j = 1:3], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2×3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 1:3, j = 1:3; i <= j], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 6 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [2, 2]  =  4\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"In the @variable (resp. @constraint) macro, containers of variables (resp. constraints) can be created with the following syntax:","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"name[index_set_1, index_set_2, ..., index_set_n] creating an n-dimensional container of name name; or\n[index_set_1, index_set_2, ..., index_set_n] creating an anonymous n-dimensional container.","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"Each expression index_set_i can either be","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"of the form index_set specifying that the ith index set of the container is index_set; or\nof the form index_name=index_set specifying that the ith index set of the container is index_set and allowing values used in the macro expression and keyword arguments to be expressions depending on the index_name.","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"The macro then creates the container using the JuMP.Containers.container function with the following arguments:","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"A function taking as argument the value of the indices and returning the value to be stored in the container, e.g. a variable for the @variable macro and a constraint for the @constraint macro.\nAn iterator over the indices of the container.\nThe value of the container keyword argument if given.","category":"page"},{"location":"JuMP/#Variables-constrained-on-creation","page":"JuMP Docs","title":"Variables constrained on creation","text":"","category":"section"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"info: Info\nWhen using JuMP in Direct mode, it may be required to constrain variables on creation instead of constraining free variables as the solver may only support variables constrained on creation. In Automatic and Manual modes, both ways of adding constraints on variables are equivalent. Indeed, during the copy of the cache to the optimizer, the choice of the constraints on variables that are copied as variables constrained on creation does not depend on how it was added to the cache.","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"All uses of the @variable macro documented so far translate to a separate call for variable creation and adding of constraints.","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"For example, @variable(model, x >= 0, Int), is equivalent to:","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"@variable(model, x)\nset_lower_bound(x, 0.0)\n@constraint(model, x in MOI.Integer())","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"Importantly, the bound and integrality constraints are added after the variable has been created.","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"However, some solvers require a constraining set at creation time. We say that these variables are constrained on creation.","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"Use in within @variable to access the special syntax for constraining variables on creation. For example, the following creates a vector of variables constrained on creation to belong to the SecondOrderCone:","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"julia> @variable(model, y[1:3] in SecondOrderCone())\n3-element Array{VariableRef,1}:\n y[1]\n y[2]\n y[3]","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"For contrast, the more standard approach is as follows:","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SecondOrderCone())\n[x[1], x[2], x[3]] ∈ MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"JuMP/","page":"JuMP Docs","title":"JuMP Docs","text":"The technical difference between the former and the latter is that the former calls MOI.add_constrained_variables while the latter calls MOI.add_variables and then MOI.add_constraint. This distinction is important only in Direct mode, depending on the solver being used. It's often not possible to delete the SecondOrderCone constraint if it was specified at variable creation time.","category":"page"},{"location":"guide/optimize/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"A guide and manual for optimizing (solving) InfiniteOpt models. The Methods section at the end comprise the manual, and the above sections comprise the guide.","category":"page"},{"location":"guide/optimize/#Overview","page":"Optimization","title":"Overview","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Fundamentally, we seek to optimize a given infinite optimization model that we have defined and this is the very reason why InfiniteOpt was created. Thus, InfiniteOpt offers a general and intuitive platform to do just this. This is made up of transforming the InfiniteModel into a standard optimization problem stored as a JuMP.Model (referred to as the optimizer_model) that is then optimized via a compatible optimizer. By default this is done via a TranscriptionModel as described on the previous page. However, user-defined reformulation strategies can readily be implemented as described in the Optimizer Models section on the extensions page.","category":"page"},{"location":"guide/optimize/#Basic-Usage","page":"Optimization","title":"Basic Usage","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"For most users, optimize! is the only method required to optimize an InfiniteModel. This is exactly analogous to that of any JuMP.Model and is designed to provide a similar user experience. Let's first define an InfiniteModel with an appropriate optimizer:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> using InfiniteOpt, JuMP, Ipopt;\n\njulia> model = InfiniteModel(Ipopt.Optimizer);\n\njulia> set_optimizer_attribute(model, \"print_level\", 0);\n\njulia> @infinite_parameter(model, t in [0, 10], num_supports = 10);\n\njulia> @infinite_variable(model, x(t) >= 0);\n\njulia> @hold_variable(model, z >= 0);\n\njulia> @objective(model, Min, 2z);\n\njulia> @constraint(model, c1, z >= x);\n\njulia> @BDconstraint(model, c2(t == 0), x == 42);\n\njulia> print(model)\nMin 2 z\nSubject to\n x(t) ≥ 0.0, ∀ t ∈ [0, 10]\n z ≥ 0.0\n c1 : z - x(t) ≥ 0.0, ∀ t ∈ [0, 10]\n c2 : x(t) = 42.0, ∀ t = 0","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Now we optimize the model using optimize!:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> optimize!(model);\n\njulia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Now our model has been solved and we can query the solution. How to query the solution is explained on the Results page.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"If no optimizer has been specified for the InfiniteModel, one can be provided via set_optimizer:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_optimizer(model, Ipopt.Optimizer)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"A number of methods also exist to adjust the optimizer settings such as suppressing output. This is explained below in the Optimizer Settings section.","category":"page"},{"location":"guide/optimize/#Optimizer-Models","page":"Optimization","title":"Optimizer Models","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"As discussed previously, InfiniteModels contain an optimizer_model field which stores a transformed finite version of the model in a JuMP.Model that contains a data struct (that stores a mapping between the transformed model and the infinite model) in the Model.ext dictionary with an associated key. By default a JuMP.Model using TranscriptionData stored under the key :TransData is used and is referred to as a TranscriptionModel. The optimizer model is then what is used to optimize the infinite model and it provides the information exacted by solution queries mapped back to the infinite model using the mapping data structure.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"The process for optimizing an InfiniteModel is summarized in the following steps:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"fully define the InfiniteModel\nbuild the optimizer model via build_optimizer_model!\noptimize the optimizer_model via optimize!.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Here build_optimizer_model! creates a reformulated finite version of the InfiniteModel, stores it in InfiniteModel.optimizer_model via set_optimizer_model, and indicates that the optimizer model is ready via set_optimizer_model_ready. These steps are all automated when optimize! is invoked on the InfiniteModel.","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"The optimizer_model can be queried/extracted at any time from an InfiniteModel via optimizer_model. For example, let's extract the optimizer model from the example above in the basic usage section:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> trans_model = optimizer_model(model)\nA JuMP Model\nMinimization problem with:\nVariables: 11\nObjective function type: GenericAffExpr{Float64,VariableRef}\n`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.GreaterThan{Float64}`: 10 constraints\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 11 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: Ipopt","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"The JuMP variable(s) stored in the optimizer model that correspond to a particular InfiniteOpt variable can be queried via optimizer_model_variable. Using a TranscriptionModel this equivalent to calling transcription_variable. Thus, using the going example we get:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> optimizer_model_variable(x) # infinite variable\n10-element Array{VariableRef,1}:\n x(support: 1)\n x(support: 2)\n x(support: 3)\n x(support: 4)\n x(support: 5)\n x(support: 6)\n x(support: 7)\n x(support: 8)\n x(support: 9)\n x(support: 10)\n\njulia> optimizer_model_variable(z) # hold variable\nz","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"In like manner, we get the JuMP constraints corresponding to a particular InfiniteOpt constraint via optimizer_model_constraint. Using a TranscriptionModel this equivalent to calling transcription_constraint. Thus, using going example we get:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> optimizer_model_constraint(c1) # infinite constraint\n10-element Array{ConstraintRef,1}:\n c1(support: 1) : z - x(support: 1) ≥ 0.0\n c1(support: 2) : z - x(support: 2) ≥ 0.0\n c1(support: 3) : z - x(support: 3) ≥ 0.0\n c1(support: 4) : z - x(support: 4) ≥ 0.0\n c1(support: 5) : z - x(support: 5) ≥ 0.0\n c1(support: 6) : z - x(support: 6) ≥ 0.0\n c1(support: 7) : z - x(support: 7) ≥ 0.0\n c1(support: 8) : z - x(support: 8) ≥ 0.0\n c1(support: 9) : z - x(support: 9) ≥ 0.0\n c1(support: 10) : z - x(support: 10) ≥ 0.0","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"We can also query the expressions via optimizer_model_expression:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> optimizer_model_expression(z - x^2 + 3) # infinite expression\n10-element Array{AbstractJuMPScalar,1}:\n -x(support: 1)² + z + 3\n -x(support: 2)² + z + 3\n -x(support: 3)² + z + 3\n -x(support: 4)² + z + 3\n -x(support: 5)² + z + 3\n -x(support: 6)² + z + 3\n -x(support: 7)² + z + 3\n -x(support: 8)² + z + 3\n -x(support: 9)² + z + 3\n -x(support: 10)² + z + 3","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"The purpose of this optimizer_model abstraction is to readily enable user-defined reformulation extensions (e.g., using polynomial chaos expansion theory). However, this is all handled behind the scenes such that most users can interact with InfiniteModels like any JuMP.Model.","category":"page"},{"location":"guide/optimize/#Optimizer-Settings","page":"Optimization","title":"Optimizer Settings","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"A few optimizer settings can be set in a consistent way agnostic of particular solver keywords. One such setting is that of suppressing and unsuppressing optimizer verbose output. This is accomplished via set_silent and unset_silent. The syntax is exemplified below:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_silent(model)\ntrue\n\njulia> unset_silent(model)\nfalse","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"We can also adjust the time limit in a solver independent fashion via set_time_limit_sec, unset_time_limit_sec, and time_limit_sec. These methods are illustrated below:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_time_limit_sec(model, 100)\n100\n\njulia> time_limit_sec(model)\n100.0\n\njulia> unset_time_limit_sec(model)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Other optimizer specific settings can be set via set_optimizer_attribute. For example, let's set the maximum CPU time for Ipopt:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_optimizer_attribute(model, \"max_cpu_time\", 60.)\n60.0","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Multiple settings  can be specified via set_optimizer_attributes. For example, let's specify the tolerance and the maximum number of iterations:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> set_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Finally, we can query optimizer settings via get_optimizer_attribute. For example, let's query the maximum number of iterations:","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"julia> get_optimizer_attribute(model, \"max_iter\")\n100","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Note this only works if the attribute has been previously specified.","category":"page"},{"location":"guide/optimize/#Methods","page":"Optimization","title":"Methods","text":"","category":"section"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"Pages   = [\"optimize.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:function]","category":"page"},{"location":"guide/optimize/","page":"Optimization","title":"Optimization","text":"JuMP.optimize!(::InfiniteModel)\nJuMP.set_optimizer(::InfiniteModel, ::Any)\nJuMP.set_silent(::InfiniteModel)\nJuMP.unset_silent(::InfiniteModel)\nJuMP.set_time_limit_sec(::InfiniteModel, ::Any)\nJuMP.unset_time_limit_sec(::InfiniteModel)\nJuMP.time_limit_sec(::InfiniteModel)\nJuMP.set_optimizer_attribute(::InfiniteModel, ::String, ::Any)\nJuMP.set_optimizer_attribute(::InfiniteModel,::MOI.AbstractOptimizerAttribute,::Any)\nJuMP.set_optimizer_attributes(::InfiniteModel, ::Pair)\nJuMP.get_optimizer_attribute(::InfiniteModel, ::String)\nJuMP.get_optimizer_attribute(::InfiniteModel,::MOI.AbstractOptimizerAttribute)\nJuMP.solver_name(model::InfiniteModel)\nJuMP.backend(model::InfiniteModel)\nJuMP.mode(model::InfiniteModel)\noptimizer_model\nset_optimizer_model\noptimizer_model_key(::InfiniteModel)\noptimizer_model_key(::JuMP.Model)\nbuild_optimizer_model!(::InfiniteModel)\nbuild_optimizer_model!\nclear_optimizer_model_build!(::InfiniteModel)\nclear_optimizer_model_build!(::JuMP.Model)\nInfiniteOpt.add_infinite_model_optimizer\noptimizer_model_variable(::GeneralVariableRef)\noptimizer_model_variable\nsupports(::Union{DecisionVariableRef, MeasureRef})\nInfiniteOpt.variable_supports\noptimizer_model_expression(::JuMP.AbstractJuMPScalar)\noptimizer_model_expression\nsupports(::JuMP.AbstractJuMPScalar)\nInfiniteOpt.expression_supports\nInfiniteOpt.optimizer_model_constraint(::InfOptConstraintRef)\noptimizer_model_constraint\nsupports(::InfOptConstraintRef)\nInfiniteOpt.constraint_supports\noptimizer_model_ready\nset_optimizer_model_ready\nJuMP.bridge_constraints(::InfiniteModel)\nJuMP.add_bridge(::InfiniteModel, ::Type{<:MOI.Bridges.AbstractBridge})","category":"page"},{"location":"guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.optimize!","text":"JuMP.optimize!(model::InfiniteModel;\n               bridge_constraints::Bool=true, kwargs...])\n\nExtend JuMP.optimize! to optimize infinite models using the internal optimizer model. Will call build_optimizer_model! if the optimizer model isn't up to date. The kwargs correspond to keyword arguments passed to build_optimizer_model! if any are defined.\n\nExample\n\njulia> optimize!(model)\n\njulia> has_values(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_optimizer-Tuple{InfiniteModel,Any}","page":"Optimization","title":"JuMP.set_optimizer","text":"JuMP.set_optimizer(model::InfiniteModel,\n                   [optimizer_constructor;\n                   bridge_constraints::Bool = true])\n\nExtend JuMP.set_optimizer to set optimizer of infinite models. Specifically, the optimizer of the optimizer model is modified.\n\nExample\n\njulia> set_optimizer(model, Clp.Optimizer)\n\njulia> optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: SolverName() attribute not implemented by the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_silent-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.set_silent","text":"JuMP.set_silent(model::InfiniteModel)\n\nExtend JuMP.set_silent for infinite models to take precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\nExample\n\njulia> set_silent(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.unset_silent-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.unset_silent","text":"JuMP.unset_silent(model::InfiniteModel)\n\nExtend JuMP.unset_silent for infinite models to neutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\nExample\n\njulia> unset_silent(model)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_time_limit_sec-Tuple{InfiniteModel,Any}","page":"Optimization","title":"JuMP.set_time_limit_sec","text":"JuMP.set_time_limit_sec(model::InfiniteModel, limit)\n\nExtend set_time_limit_sec to set the time limit (in seconds) of the solver. Can be unset using unset_time_limit_sec or with limit set to nothing.\n\nExample\n\njulia> set_time_limit_sec(model, 100)\n100\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.unset_time_limit_sec-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.unset_time_limit_sec","text":"JuMP.unset_time_limit_sec(model::InfiniteModel)\n\nExtend unset_time_limit_sec to unset the time limit of the solver. Can be set using set_time_limit_sec.\n\nExample\n\njulia> unset_time_limit_sec(model)\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.time_limit_sec-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.time_limit_sec","text":"JuMP.time_limit_sec(model::InfiniteModel)\n\nExtend [time_limit_sec](@ref JuMP.timelimitsec(::JuMP.Model) to get the time limit (in seconds) of the solve used by the optimizer model (nothing if unset). Can be set using set_time_limit_sec.\n\nExample\n\njulia> time_limit_sec(model)\n100\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_optimizer_attribute-Tuple{InfiniteModel,String,Any}","page":"Optimization","title":"JuMP.set_optimizer_attribute","text":"JuMP.set_optimizer_attribute(model::InfiniteModel, name::String, value)\n\nExtend set_optimizer_attribute to specify a solver-specific attribute identified by name to value.\n\nExample\n\njulia> set_optimizer_attribute(model, \"SolverSpecificAttributeName\", true)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_optimizer_attribute-Tuple{InfiniteModel,MathOptInterface.AbstractOptimizerAttribute,Any}","page":"Optimization","title":"JuMP.set_optimizer_attribute","text":"JuMP.set_optimizer_attribute(model::InfiniteModel,\n                             attr::MOI.AbstractOptimizerAttribute,\n                             value)\n\nExtend set_optimizer_attribute to set the solver-specific attribute attr in model to value.\n\nExample\n\njulia> set_optimizer_attribute(model, MOI.Silent(), true)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_optimizer_attributes-Tuple{InfiniteModel,Pair}","page":"Optimization","title":"JuMP.set_optimizer_attributes","text":"JuMP.set_optimizer_attributes(model::InfiniteModel, pairs::Pair...)\n\nExtend set_optimizer_attributes to set multiple solver attributes given a list of attribute => value pairs. Calls set_optimizer_attribute(model, attribute, value) for each pair.\n\nExample\n\njulia> model = Model(Ipopt.Optimizer);\n\njulia> set_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\njulia> set_optimizer_attribute(model, \"tol\", 1e-4);\n\njulia> set_optimizer_attribute(model, \"max_iter\", 100);\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.get_optimizer_attribute-Tuple{InfiniteModel,String}","page":"Optimization","title":"JuMP.get_optimizer_attribute","text":"JuMP.get_optimizer_attribute(model::InfiniteModel, name::String)\n\nExtend get_optimizer_attribute to return the value associated with the solver-specific attribute named name.\n\nExample julia-repl julia> get_optimizer_attribute(model, \"tol\") 0.0001`\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.get_optimizer_attribute-Tuple{InfiniteModel,MathOptInterface.AbstractOptimizerAttribute}","page":"Optimization","title":"JuMP.get_optimizer_attribute","text":"JuMP.get_optimizer_attribute(model::InfiniteModel,\n                             attr::MOI.AbstractOptimizerAttribute)\n\nExtend get_optimizer_attribute to return the value of the solver-specific attribute attr in model.\n\nExample julia-repl julia> get_optimizer_attribute(model, MOI.Silent()) true`\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.solver_name-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.solver_name","text":"JuMP.solver_name(model::InfiniteModel)\n\nExtend solver_name to return the name of the solver being used if there is an optimizer selected and it has a name attribute. Otherwise, an error is thrown.\n\nExample\n\njulia> solver_name(model)\n\"Gurobi\"\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.backend-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.backend","text":"JuMP.backend(model::InfiniteModel)\n\nExtend backend to return the MathOptInterface backend associated with the optimizer model. Note this will be empty if the optimizer model has not been build yet.\n\nExample\n\njulia> moi_model = backend(model);\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.mode-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.mode","text":"JuMP.mode(model::InfiniteModel)\n\nExtend mode to return the MathOptInterface mode the optimizer model is in.\n\nExample\n\njulia> mode(model)\nAUTOMATIC::ModelMode = 0\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model","page":"Optimization","title":"InfiniteOpt.optimizer_model","text":"optimizer_model(model::InfiniteModel)::JuMP.Model\n\nReturn the JuMP model stored in model that is used to solve it.\n\nExample\n\njulia> opt_model = optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.set_optimizer_model","page":"Optimization","title":"InfiniteOpt.set_optimizer_model","text":"set_optimizer_model(inf_model::InfiniteModel, opt_model::JuMP.Model;\n                    inherit_optimizer::Bool = true)\n\nSpecify the JuMP model that is used to solve inf_model. This is intended for internal use and extensions. Note that opt_model should contain extension data to allow it to map to inf_model in a manner similar to TranscriptionModel. inherit_optimizer indicates whether add_infinite_model_optimizer should be invoked on the new optimizer mode to inherit the optimizer constuctor and attributes currently stored in inf_model.\n\nExample\n\njulia> set_optimizer_model(model, TranscriptionModel())\n\njulia> optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}","page":"Optimization","title":"InfiniteOpt.optimizer_model_key","text":"optimizer_model_key(model::InfiniteModel)::Any\n\nReturn the extension key used in the optimizer model of model. Errors if optimizer_model.ext contains more than one key. This is intended for internal use and extensions. For extensions this is used to dispatch to the appropriate optmizer model functions such as extensions to build_optimizer_model!.\n\nExample\n\njulia> optimizer_model_key(model)\n:TransData\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_key-Tuple{Model}","page":"Optimization","title":"InfiniteOpt.optimizer_model_key","text":"optimizer_model_key(model::JuMP.Model)::Any\n\nReturn the extension key used in the optimizer model model. Errors if model.ext contains more than one key. This is intended for internal use and extensions. For extensions this is used to dispatch to the appropriate optmizer model functions such as extensions to build_optimizer_model!. This is intended as an internal method. See optimizer_model_key for the public method\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}","page":"Optimization","title":"InfiniteOpt.build_optimizer_model!","text":"build_optimizer_model!(model::InfiniteModel; [kwargs...])\n\nBuild the optimizer model stored in model such that it can be treated as a normal JuMP model. Specifically, translate the variables and constraints stored in model into ones that are stored in the optimizer model and can be solved. This is provided generally to accomodate extensions that use custom optimizer model types in accordance with optimizer_model_key. However, it may be useful in certain applications when the user desires to force a build without calling optimize!. Extensions will need to implement their own version of the function build_optimizer_model!(model::InfiniteModel, key::Val{ext_key_name}; kwargs...).\n\nExample\n\njulia> build_optimizer_model!(model)\n\njulia> optimizer_model_ready(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.build_optimizer_model!","page":"Optimization","title":"InfiniteOpt.build_optimizer_model!","text":"build_optimizer_model!(model::InfiniteModel, key::Val{ext_key_name};\n                       [kwargs...])\n\nBuild the optimizer model stored in model such that it can be treated as a normal JuMP model, where the Model.ext field contains a key that points to a datastructure that appropriately maps the data between the two models. The key argument should be be typed to Val{ext_key_name}. This should also use clear_optimizer_model_build! to empty the out the current optimizer model. Ultimately, set_optimizer_model should be called to insert the build optimizer model into model and set_optimizer_model_ready should be used to update the optimizer model's status.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.clear_optimizer_model_build!-Tuple{InfiniteModel}","page":"Optimization","title":"InfiniteOpt.clear_optimizer_model_build!","text":"clear_optimizer_model_build!(model::InfiniteModel)::JuMP.Model\n\nEmpty the optimizer model using appropriate calls of Base.empty!. This effectively resets model.optimizer_model except the optimizer, its attributes, and an an emptied optimizer model data struct are maintained. This is intended as an internal method for use by build_optimizer_model!.\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.clear_optimizer_model_build!-Tuple{Model}","page":"Optimization","title":"InfiniteOpt.clear_optimizer_model_build!","text":"clear_optimizer_model_build!(model::JuMP.Model)::JuMP.Model\n\nEmpty the optimizer model using appropriate calls of Base.empty!. This effectively resets model except the optimizer, its attributes, and an an emptied optimizer model data struct are maintained. This is intended as an internal method for use by build_optimizer_model!.\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.add_infinite_model_optimizer","page":"Optimization","title":"InfiniteOpt.add_infinite_model_optimizer","text":"add_infinite_model_optimizer(opt_model::JuMP.Model, inf_model::InfiniteModel)\n\nParse the current optimizer and its attributes associated with inf_model and load them into opt_model. This is intended to be used as an internal method for set_optimizer_model.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_variable-Tuple{GeneralVariableRef}","page":"Optimization","title":"InfiniteOpt.optimizer_model_variable","text":"optimizer_model_variable(vref::GeneralVariableRef; [kwargs...])\n\nReturn the reformulation variable(s) stored in the optimizer model that correspond to vref. By default, no keyword arguments kwargs are employed by TranscriptionOpt, but extensions may employ kwargs in accordance with their implementation of optimizer_model_variable. Errors if such an extension has not been written. Also errors if no such variable can be found in the optimizer model.\n\nExample\n\njulia> optimizer_model_variable(x) # infinite variable\n2-element Array{VariableRef,1}:\n x(support: 1)\n x(support: 2)\n\njulia> optimizer_model_variable(z) # hold variable\nz\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_variable","page":"Optimization","title":"InfiniteOpt.optimizer_model_variable","text":"optimizer_model_variable(vref::GeneralVariableRef, key::Val{ext_key_name};\n                         [kwargs...])\n\nReturn the reformulation variable(s) stored in the optimizer model that correspond to vref. This needs to be defined for extensions that implement a custom optimizer model type. Principally, this is accomplished by typed the key argument to Val{ext_key_name}. Keyword arguments can be added as needed.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.supports-Tuple{Union{HoldVariableRef, InfiniteVariableRef, MeasureRef, PointVariableRef, ReducedVariableRef}}","page":"Optimization","title":"InfiniteOpt.supports","text":"supports(vref::DecisionVariableRef; [kwargs...])\n\nReturn the supports associated with vref in the optimizer model. Errors if InfiniteOpt.variable_supports has not been extended for the optimizer model type or if vref is not be reformulated in the optimizer model. By default, keyword arugments are not used, but may employed by extensions.\n\nExample\n\njulia> supports(vref)\n2-element Array{Tuple{Float64},1}:\n (0.0,)\n (1.0,)\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.variable_supports","page":"Optimization","title":"InfiniteOpt.variable_supports","text":"variable_supports(optimizer_model::JuMP.Model, vref,\n                  key::Val{ext_key_name}; [kwargs...])::Vector\n\nReturn the supports associated with the mappings of vref in optimizer_model. This dispatches off of key which permits optimizer model extensions. This should throw an error if vref is not associated with the variable mappings stored in optimizer_model. Keyword arguments can be added as needed. Note that no extension is necessary for point or hold variables.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_expression-Tuple{AbstractJuMPScalar}","page":"Optimization","title":"InfiniteOpt.optimizer_model_expression","text":"optimizer_model_expression(expr::JuMP.AbstractJuMPScalar; [kwargs...])\n\nReturn the reformulation expression(s) stored in the optimizer model that correspond to expr. By default, no keyword arguments kwargs are employed by TranscriptionOpt, but extensions may employ kwargs in accordance with their implementation of optimizer_model_expression. Errors if such an extension has not been written. Also errors if no such expression can be found in the optimizer model (meaning one or more of the underlying variables have not been transcribed).\n\nExample\n\njulia> optimizer_model_expression(my_expr) # finite expression\nx(support: 1) - y\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_expression","page":"Optimization","title":"InfiniteOpt.optimizer_model_expression","text":"optimizer_model_expression(expr, key::Val{ext_key_name}; [kwargs...])\n\nReturn the reformulation expression(s) stored in the optimizer model that correspond to expr. This needs to be defined for extensions that implement a custom optimizer model type. Principally, this is accomplished by typed the key argument to Val{ext_key_name}. Keyword arguments can be added as needed. Note that if expr is a GeneralVariableRef this just dispatches to optimizer_model_variable.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.supports-Tuple{AbstractJuMPScalar}","page":"Optimization","title":"InfiniteOpt.supports","text":"supports(expr::JuMP.AbstractJuMPScalar; [kwargs...])\n\nReturn the support associated with expr. Errors if expr is not associated with the constraint mappings stored in optimizer_model or if InfiniteOpt.expression_supports has not been extended. By default, no keyword arguments are accepted, but extensions may employ some.\n\nExample\n\njulia> supports(cref)\n2-element Array{Tuple{Float64},1}:\n (0.0,)\n (1.0,)\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.expression_supports","page":"Optimization","title":"InfiniteOpt.expression_supports","text":"expression_supports(optimizer_model::JuMP.Model, expr,\n                    key::Val{ext_key_name}; [kwargs...])\n\nReturn the supports associated with the mappings of expr in optimizer_model. This dispatches off of key which permits optimizer model extensions. This should throw an error if expr is not associated with the variable mappings stored in optimizer_model. Keyword arguments can be added as needed. Note that if expr is a GeneralVariableRef this just dispatches to variable_supports.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_constraint-Tuple{InfOptConstraintRef}","page":"Optimization","title":"InfiniteOpt.optimizer_model_constraint","text":"optimizer_model_constraint(cref::InfOptConstraintRef; [kwargs...])\n\nReturn the reformulation constraint(s) stored in the optimizer model that correspond to cref. By default, no keyword arguments kwargs are employed by TranscriptionOpt, but extensions may employ kwargs in accordance with their implementation of optimizer_model_constraint. Errors if such an extension has not been written. Also errors if no such constraint can be found in the optimizer model.\n\nExample\n\njulia> optimizer_model_constraint(c1) # finite constraint\nc1 : x(support: 1) - y <= 3.0\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_constraint","page":"Optimization","title":"InfiniteOpt.optimizer_model_constraint","text":"optimizer_model_constraint(cref::InfOptConstraintRef,\n                           key::Val{ext_key_name}; [kwargs...])\n\nReturn the reformulation constraint(s) stored in the optimizer model that correspond to cref. This needs to be defined for extensions that implement a custom optimizer model type. Principally, this is accomplished by typed the key argument to Val{ext_key_name}. Keyword arguments can be added as needed.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.supports-Tuple{InfOptConstraintRef}","page":"Optimization","title":"InfiniteOpt.supports","text":"supports(cref::InfOptConstraintRef; [kwargs...])\n\nReturn the support associated with cref. Errors if cref is not associated with the constraint mappings stored in optimizer_model or if InfiniteOpt.constraint_supports has not been extended. By default, no keyword arguments are accepted, but extensions may employ some.\n\nExample\n\njulia> supports(cref)\n2-element Array{Tuple{Float64},1}:\n (0.0,)\n (1.0,)\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.constraint_supports","page":"Optimization","title":"InfiniteOpt.constraint_supports","text":"constraint_supports(optimizer_model::JuMP.Model, cref::InfOptConstraintRef,\n                    key::Val{ext_key_name}; [kwargs...])\n\nReturn the supports associated with the mappings of cref in optimizer_model. This dispatches off of key which permits optimizer model extensions. This should throw an error if cref is not associated with the variable mappings stored in optimizer_model. Keyword arguments can be added as needed.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_ready","page":"Optimization","title":"InfiniteOpt.optimizer_model_ready","text":"optimizer_model_ready(model::InfiniteModel)::Bool\n\nReturn Bool if the optimizer model is up to date with model.\n\nExample\n\njulia> optimizer_model_ready(model)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.set_optimizer_model_ready","page":"Optimization","title":"InfiniteOpt.set_optimizer_model_ready","text":"set_optimizer_model_ready(model::InfiniteModel, status::Bool)\n\nSet the status of the optimizer model to whether it is up to date or not. Note is more intended as an internal function, but is useful for extensions.\n\nExample\n\njulia> set_optimizer_model_ready(model, true)\n\njulia> optimizer_model_ready(model)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#JuMP.bridge_constraints-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.bridge_constraints","text":"JuMP.bridge_constraints(model::InfiniteModel)::Bool\n\nExtend JuMP.bridge_constraints to return if an infinite model model has an optimizer model where the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\nExample\n\njulia> bridge_constraints(model)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.add_bridge-Tuple{InfiniteModel,Type{#s38} where #s38<:MathOptInterface.Bridges.AbstractBridge}","page":"Optimization","title":"JuMP.add_bridge","text":"JuMP.add_bridge(model::InfiniteModel,\n                BridgeType::Type{<:MOI.Bridges.AbstractBridge})\n\nExtend JuMP.add_bridge to add BridgeType to the list of bridges that can be used by the optimizer model to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#transcription_docs","page":"Model Transcription","title":"Model Transcription","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"A guide and manual for transcribing infinite models using InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.","category":"page"},{"location":"guide/transcribe/#Overview","page":"Model Transcription","title":"Overview","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"All infinite models need to be reformulated in such a way that they can be solved using traditional optimization methods. Typically, this involves discretization of the infinite domain via particular parameter support points. By default, InfiniteOpt employs this methodology via the use of transcription models (which comprise the optimizer_model as discussed in the Infinite Models section). InfiniteOpt is built modularly to readily accept other user defined techniques and this is discussed in further detail on the Extensions page. This page will detail transcription models based in InfiniteOpt.TranscriptionOpt which provide the default transcription (reformulation) capabilities of InfiniteOpt.","category":"page"},{"location":"guide/transcribe/#Basic-Usage","page":"Model Transcription","title":"Basic Usage","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Most users will not need to employ the capabilities of TranscriptionOpt directly since they are employed implicitly with the call of optimize! on an infinite model. This occurs since TranscriptionModels are the default optimizer model type that is employed.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"However, some users may wish to use TranscriptionOpt to extract a fully discretized/transcribed version of an infinite model that is conveniently output as a typical JuMP model and can then be treated as such. This is principally accomplished via build_optimizer_model!. To illustrate how this is done,  let's first define a basic infinite model with a simple support structure for the sake of example:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> using InfiniteOpt, JuMP\n\njulia> inf_model = InfiniteModel();\n\njulia> @infinite_parameter(inf_model, t in [0, 10], supports = [0, 5, 10])\nt\n\njulia> @infinite_variable(inf_model, g(t) >= 0)\ng(t)\n\njulia> @hold_variable(inf_model, z, Bin)\nz\n\njulia> @objective(inf_model, Min, 2z + support_sum(g, t))\n2 z + support_sum{t}[g(t)]\n\njulia> @BDconstraint(inf_model, initial(t == 0), g == 1)\ninitial : g(t) = 1.0, ∀ t = 0\n\njulia> @constraint(inf_model, constr, g^2 - z <= 42)\nconstr : g(t)² - z ≤ 42.0, ∀ t ∈ [0, 10]\n\njulia> print(inf_model)\nMin 2 z + support_sum{t}[g(t)]\nSubject to\n g(t) ≥ 0.0, ∀ t ∈ [0, 10]\n z binary\n initial : g(t) = 1.0, ∀ t = 0\n constr : g(t)² - z ≤ 42.0, ∀ t ∈ [0, 10]","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now we can make JuMP model containing the transcribed version of inf_model via build_optimizer_model! and then extract it via optimizer_model:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> build_optimizer_model!(inf_model)\n\njulia> trans_model = optimizer_model(inf_model)\nA JuMP Model\nMinimization problem with:\nVariables: 4\nObjective function type: GenericAffExpr{Float64,VariableRef}\n`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n`GenericQuadExpr{Float64,VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 3 constraints\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints\n`VariableRef`-in-`MathOptInterface.ZeroOne`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> print(trans_model)\nMin 2 z + g(support: 1) + g(support: 2) + g(support: 3)\nSubject to\n initial(support: 1) : g(support: 1) = 1.0\n constr(support: 1) : g(support: 1)² - z ≤ 42.0\n constr(support: 2) : g(support: 2)² - z ≤ 42.0\n constr(support: 3) : g(support: 3)² - z ≤ 42.0\n g(support: 1) ≥ 0.0\n g(support: 2) ≥ 0.0\n g(support: 3) ≥ 0.0\n z binary","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"note: Note\nPrevious versions of InfiniteOpt, employed a TranscriptionModel(model::InfiniteModel)  constructor to build transcription models independently of the optimizer model.  This has functionality has been removed in favor of internal optimizer model  based builds for efficiency reasons and to properly manage MOI optimizer  attributes.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Thus, we have a transcribed JuMP model. To be precise this is actually a TranscriptionModel which is a JuMP.Model with some extra data stored in the ext field that retains the mapping between the transcribed variables/constraints  and their infinite counterparts. Notice, that multiple finite variables have been introduced to discretize g(t) at supports 1, 2, and 3 which correspond to 0, 5, and 10 as can be queried by supports:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> supports(g)\n3-element Array{Tuple,1}:\n (0.0,)\n (5.0,)\n (10.0,)","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Also, notice how the constraints are transcribed in accordance with these supports except the initial condition which naturally is only invoked for the first support point. Furthermore, the transcription variable(s) of any variable associated with the infinite model can be determined via transcription_variable:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> transcription_variable(g)\n3-element Array{VariableRef,1}:\n g(support: 1)\n g(support: 2)\n g(support: 3)\n\njulia> transcription_variable(trans_model, z)\nz","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Similarly, the transcription constraints associated with infinite model constraints can be queried via transcription_constraint and the associated supports and infinite parameters can be found via supports and parameter_refs:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> transcription_constraint(initial)\ninitial(support: 1) : g(support: 1) = 1.0\n\njulia> transcription_constraint(constr)\n3-element Array{ConstraintRef,1}:\n constr(support: 1) : g(support: 1)² - z ≤ 42.0\n constr(support: 2) : g(support: 2)² - z ≤ 42.0\n constr(support: 3) : g(support: 3)² - z ≤ 42.0\n\njulia> supports(constr)\n3-element Array{Tuple,1}:\n (0.0,)\n (5.0,)\n (10.0,)\n\njulia> parameter_refs(constr)\n(t,)","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Note the parameter reference tuple corresponds to the support tuples.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now we have a transcribed JuMP model that can be optimized via traditional JuMP methods whose variables and constraints can be accessed using the methods mentioned above.","category":"page"},{"location":"guide/transcribe/#Transcription-Theory","page":"Model Transcription","title":"Transcription Theory","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"A given infinite dimensional optimization problem is parameterized according to infinite parameters following our abstraction. In general, most solution strategies transcribe the problem according to certain finite parameter values (supports) and thus represent the problem in terms of these supports (e.g., using discrete time points in dynamic optimization). This methodology can be generalized into the following steps:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"define supports for each infinite parameter if not already defined,\nexpand any measures according to their underlying numerical representation using transcribed infinite variables as appropriate,\nreplace any remaining infinite variables with transcribed variables supported over each unique combination of the underlying parameter supports,\nreplace any remaining infinite constraints with transcribed ones supported over all the unique support combinations stemming from the infinite parameters they depend on.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"For example, let's consider a space-time optimization problem of the form:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"beginaligned\n\tmin_y(t) g(t x)  int_0^10 y^2(t) dt \n\ttextst  y(0) = 1 \n\t int_x in -1 1^2 g(t x) dx = 42  forall t in 0 10 \n     3g(t x) + 2y^2(t) leq 2  forall t in T  x in -1 1^2 \nendaligned","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Thus, we have an optimization problem whose decision space is infinite with respect to time t and position x. Now let's transcribe it following the above steps. First, we need to specify the infinite parameter supports and for simplicity let's choose the following sparse sets:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"t in 0 10\nx in -1 -1^T -1 1^T 1 -1^T 1 1^T.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now we expand the two integrals (measures) via a finite approximation using only the above supports and term coefficients of 1 (note this is not numerically correct but is done for conciseness in example). Doing this, we obtain the form:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"beginaligned\n\tmin_y(t) g(t x)  y^2(0) + y^2(10) \n\ttextst  y(0) = 1 \n\t g(t -1 -1) + g(t -1 1) + g(t 1 -1) + g(t 1 1) = 42  forall t in 0 10 \n     3g(t x) + 2y^2(t) leq 2  forall t in T  x in -1 1^2 \nendaligned","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Notice that the infinite variable y(t) in the objective measure has been replaced with finite transcribed variables y(0) and y(10). Also, the infinite variable g(t x) was replaced with partially transcribed variables in the second constraint in accordance with the measure over the positional domain x.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now we need to transcribe the remaining infinite and semi-infinite variables with finite variables and duplicate the remaining infinite constraints accordingly. This means that the second constraint needs to be transcribed over the time domain and the third constraint needs to be transcribed for each unique combination of the time and position supports. Applying this transcription yields:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"beginaligned\n\tmin_y(t) g(t x)  y^2(0) + y^2(10) \n\ttextst  y(0) = 1 \n\t g(0 -1 -1) + g(0 -1 1) + g(0 1 -1) + g(0 1 1) = 42\n     g(10 -1 -1) + g(10 -1 1) + g(10 1 -1) + g(10 1 1) = 42\n     3g(0 -1 -1) + 2y^2(0) leq 2 \n     3g(0 -1 1) + 2y^2(0) leq 2 \n     vdots \n     3g(10 1 1) + 2y^2(10) leq 2\nendaligned","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Now the problem is fully transcribed (discretized) and can be solved as a standard optimization problem. Note that with realistic measure evaluation schemes more supports might be added to the support sets and these will need to be incorporated when transcribing variables and constraints.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"It is easy to imagine how the above procedure can get quite involved to do manually, but this is precisely what InfiniteOpt automates behind the scenes. Let's highlight this by repeating the same example using InfiniteOpt (again using the incorrect simple representation for the integrals for conciseness).","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"using JuMP, InfiniteOpt\n\n# Initialize model\ninf_model = InfiniteModel()\n\n# Define parameters and supports\n@infinite_parameter(inf_model, t in [0, 10], supports = [0, 10])\n@infinite_parameter(inf_model, x[1:2] in [-1, 1], supports = [-1, 1], independent = true)\n\n# Define variables\n@infinite_variable(inf_model, y(t))\n@infinite_variable(inf_model, g(t, x))\n\n# Set the objective (using support_sum for the integral given our simple example)\n# Note: In real problems measure should be used\n@objective(inf_model, Min, support_sum(y^2, t))\n\n# Define the constraints\n@BDconstraint(inf_model, t == 0, y == 1)\n@constraint(inf_model, support_sum(g, x) == 42) # support_sum for simplicity\n@constraint(inf_model, 3g + y^2 <= 2)\n\n# Print the infinite model\nprint(inf_model)\n\n# output\nMin support_sum{t}[y(t)²]\nSubject to\n y(t) = 1.0, ∀ t = 0\n support_sum{x}[g(t, x)] = 42.0, ∀ t ∈ [0, 10]\n y(t)² + 3 g(t, x) ≤ 2.0, ∀ t ∈ [0, 10], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Thus, we obtain the infinite problem in InfiniteOpt. As previously noted, transcription would be handled automatically behind the scenes when the model is optimized. However, we can directly extract the transcribed version by building a TranscriptionModel:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> build_optimizer_model!(inf_model)\n\njulia> trans_model = optimizer_model(inf_model);\n\njulia> print(trans_model)\nMin y(support: 1)² + y(support: 2)²\nSubject to\n (support: 1) : y(support: 1) = 1.0\n (support: 1) : g(support: 1) + g(support: 3) + g(support: 5) + g(support: 7) = 42.0\n (support: 2) : g(support: 2) + g(support: 4) + g(support: 6) + g(support: 8) = 42.0\n (support: 1) : y(support: 1)² + 3 g(support: 1) ≤ 2.0\n (support: 2) : y(support: 2)² + 3 g(support: 2) ≤ 2.0\n (support: 3) : y(support: 1)² + 3 g(support: 3) ≤ 2.0\n (support: 4) : y(support: 2)² + 3 g(support: 4) ≤ 2.0\n (support: 5) : y(support: 1)² + 3 g(support: 5) ≤ 2.0\n (support: 6) : y(support: 2)² + 3 g(support: 6) ≤ 2.0\n (support: 7) : y(support: 1)² + 3 g(support: 7) ≤ 2.0\n (support: 8) : y(support: 2)² + 3 g(support: 8) ≤ 2.0","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"This precisely matches what we found analytically. Note that the unique support combinations are determined automatically and are represented visually as support: #. The precise support values can be looked up via supports:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> supports(y)\n2-element Array{Tuple,1}:\n (0.0,)\n (10.0,)\n\njulia> supports(g)\n8-element Array{Tuple,1}:\n (0.0, [-1.0, -1.0])\n (10.0, [-1.0, -1.0])\n (0.0, [1.0, -1.0])\n (10.0, [1.0, -1.0])\n (0.0, [-1.0, 1.0])\n (10.0, [-1.0, 1.0])\n (0.0, [1.0, 1.0])\n (10.0, [1.0, 1.0])","category":"page"},{"location":"guide/transcribe/#TranscriptionOpt","page":"Model Transcription","title":"TranscriptionOpt","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"InfiniteOpt.TranscriptionOpt is a sub-module which principally implements TranscriptionModels and its related access/modification methods. Thus, this section will detail what these are and how they work.","category":"page"},{"location":"guide/transcribe/#TranscriptionModels","page":"Model Transcription","title":"TranscriptionModels","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"A TranscriptionModel is simply a JuMP.Model whose ext field contains TranscriptionData which acts to map the transcribed model back to the original infinite model (e.g., map the variables and constraints). Such models are constructed via a default version of build_optimizer_model!  which wraps build_transcription_model!:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> model1 = TranscriptionModel() # make an empty model\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> build_optimizer_model!(inf_model); \n\njulia> model2 = optimizer_model(inf_model) # generate from an InfiniteModel\nA JuMP Model\nMinimization problem with:\nVariables: 4\nObjective function type: GenericAffExpr{Float64,VariableRef}\n`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n`GenericQuadExpr{Float64,VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 3 constraints\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints\n`VariableRef`-in-`MathOptInterface.ZeroOne`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Note that the all the normal JuMP.Model arguments can be used with both constructor when making an empty model and they are simply inherited from those  specified in the InfiniteModel. The call to build_optimizer_model! is the backbone  behind infinite model transcription and is what encapsulates all of the methods to  transcribe measures, variables, and constraints. This is also the method that  enables the use of optimize!.","category":"page"},{"location":"guide/transcribe/#Queries","page":"Model Transcription","title":"Queries","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"In this section we highlight a number of query methods that pertain TranscriptionModels and their mappings. First, if the optimizer_model of an InfiniteModel is a TranscriptionModel it can be extracted via transcription_model:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> transcription_model(inf_model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Here we observe that such a model is currently empty and hasn't been populated yet. Furthermore, we check that a Model is an TranscriptionModel via is_transcription_model:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> is_transcription_model(optimizer_model(inf_model))\ntrue\n\njulia> is_transcription_model(Model())\nfalse","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"We can also extract the raw TranscriptionData object from a TranscriptionModel via transcription_data.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> transcription_data(trans_model);","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Next we can retrieve the JuMP variable(s) for a particular InfiniteOpt variable via transcription_variable. For finite variables, this will be a one to one mapping, and for infinite variables a list of supported variables will be returned in the order of the supports. Following the initial example in the basic usage section, this is done:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> build_optimizer_model!(inf_model); trans_model = optimizer_model(inf_model);\n\njulia> transcription_variable(trans_model, g)\n3-element Array{VariableRef,1}:\n g(support: 1)\n g(support: 2)\n g(support: 3)\n\njulia> transcription_variable(trans_model, z)\nz","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Note that if the TranscriptionModel is stored as the current optimizer_model then the first argument (specifying the TranscriptionModel can be omitted). Thus,  in this case the first argument can be omitted as it was above, but is shown for  completeness.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Similarly, the parameter supports corresponding to the transcription variables (in the case of transcribed infinite variables) can be queried via supports:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> supports(g)\n3-element Array{Tuple,1}:\n (0.0,)\n (5.0,)\n (10.0,)","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Likewise, transcription_constraint and supports(@ref) can be used with constraints to find their transcribed  equivalents in the JuMP model and determine their supports.","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"We can also do this with measures and expressions:","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"julia> meas = support_sum(g^2, t)\nsupport_sum{t}[g(t)²]\n\njulia> build_optimizer_model!(inf_model)\n\njulia> transcription_variable(meas)\ng(support: 1)² + g(support: 2)² + g(support: 3)²\n\njulia> supports(meas)\n()\n\njulia> transcription_expression(g^2 + z - 42)\n3-element Array{AbstractJuMPScalar,1}:\n g(support: 1)² + z - 42\n g(support: 2)² + z - 42\n g(support: 3)² + z - 42\n\njulia> supports(g^2 + z - 42)\n3-element Array{Tuple,1}:\n (0.0,)\n (5.0,)\n (10.0,)\n\njulia> parameter_refs(g^2 + z - 42)\n(t,)","category":"page"},{"location":"guide/transcribe/#Datatypes","page":"Model Transcription","title":"Datatypes","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Pages   = [\"transcribe.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"InfiniteOpt.TranscriptionOpt.TranscriptionData","category":"page"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionData","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.TranscriptionData","text":"TranscriptionData\n\nA DataType for storing the data mapping an InfiniteOpt.InfiniteModel that has been transcribed to a regular JuMP.Model that contains the transcribed variables. This is stored in the ext field of a JuMP.Model to make what is called a TranscriptionModel via the TranscriptionModel constructor.\n\nFields\n\ninfvar_lookup::Dict{InfiniteOpt.GeneralVariableRef, Dict{Vector{Float64}, Int}}:  A lookup table of infinite variable transcriptions via support value.\ninfvar_mappings::Dict{InfiniteOpt.GeneralVariableRef, Vector{JuMP.VariableRef}}:  Map infinite variables to their transcription variables.\ninfvar_supports::Dict{InfiniteOpt.GeneralVariableRef, Vector{Tuple}}:  Map infinite variables to their support values.\nfinvar_mappings::Dict{InfiniteOpt.GeneralVariableRef, JuMP.VariableRef}:  Map finite variables to their transcription variables.\nreduced_vars::Vector{InfiniteOpt.ReducedVariable{InfiniteOpt.GeneralVariableRef}}:  Store the core reduced variable objects of reduced variables formed on transcription.\nlast_point_index::Int: The last internal point variable index added.\nmeasure_lookup::Dict{InfiniteOpt.GeneralVariableRef, Dict{Vector{Float64}, Int}}:  A lookup table of measure transcriptions via support value.\nmeasure_mappings::Dict{InfiniteOpt.GeneralVariableRef, Vector{JuMP.AbstractJuMPScalar}}:  Map measures to transcription expressions.\nmeasure_supports::Dict{InfiniteOpt.GeneralVariableRef, Vector{Tuple}}:  Map measures to their supports values (if the transcribed measure is still infinite).\nconstr_mappings::Dict{InfiniteOpt.InfOptConstraintRef, Vector{JuMP.ConstraintRef}}:  Map constraints to their transcriptions.\nconstr_supports::Dict{InfiniteOpt.InfOptConstraintRef, Vector{Tuple}}:  Map constraints to their support values.\nsupports::Tuple: Store the collected parameter supports here.\n\n\n\n\n\n","category":"type"},{"location":"guide/transcribe/#Methods","page":"Model Transcription","title":"Methods","text":"","category":"section"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"Pages   = [\"transcribe.md\"]\nModules = [InfiniteOpt, InfiniteOpt.TranscriptionOpt]\nOrder   = [:function]","category":"page"},{"location":"guide/transcribe/","page":"Model Transcription","title":"Model Transcription","text":"InfiniteOpt.TranscriptionOpt.TranscriptionModel\nInfiniteOpt.TranscriptionOpt.is_transcription_model\nInfiniteOpt.TranscriptionOpt.transcription_data\nInfiniteOpt.TranscriptionOpt.transcription_model\nInfiniteOpt.TranscriptionOpt.transcription_variable(::JuMP.Model,::InfiniteOpt.GeneralVariableRef)\nInfiniteOpt.optimizer_model_variable(::InfiniteOpt.GeneralVariableRef,::Val{:TransData})\nInfiniteOpt.variable_supports(::JuMP.Model,::Union{InfiniteOpt.InfiniteVariableRef, InfiniteOpt.ReducedVariableRef},::Val{:TransData})\nInfiniteOpt.TranscriptionOpt.lookup_by_support(::JuMP.Model,::InfiniteOpt.GeneralVariableRef,::Vector)\nInfiniteOpt.internal_reduced_variable(::InfiniteOpt.ReducedVariableRef,::Val{:TransData})\nInfiniteOpt.TranscriptionOpt.transcription_expression(::JuMP.Model,::Union{JuMP.GenericAffExpr, JuMP.GenericQuadExpr})\nInfiniteOpt.optimizer_model_expression(::Union{JuMP.GenericAffExpr, JuMP.GenericQuadExpr},::Val{:TransData})\nInfiniteOpt.expression_supports(::JuMP.Model,::Union{JuMP.GenericAffExpr, JuMP.GenericQuadExpr}, ::Val{:TransData})\nInfiniteOpt.TranscriptionOpt.transcription_constraint(::JuMP.Model,::InfiniteOpt.InfOptConstraintRef)\nInfiniteOpt.optimizer_model_constraint(::InfiniteOpt.InfOptConstraintRef,::Val{:TransData})\nInfiniteOpt.constraint_supports(::JuMP.Model,::InfiniteOpt.InfOptConstraintRef,::Val{:TransData})\nInfiniteOpt.TranscriptionOpt.parameter_supports(::JuMP.Model)\nInfiniteOpt.TranscriptionOpt.support_index_iterator\nInfiniteOpt.TranscriptionOpt.index_to_support\nInfiniteOpt.TranscriptionOpt.set_parameter_supports\nInfiniteOpt.TranscriptionOpt.transcribe_hold_variables!\nInfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!\nInfiniteOpt.TranscriptionOpt.transcribe_reduced_variables!\nInfiniteOpt.TranscriptionOpt.transcribe_point_variables!\nInfiniteOpt.TranscriptionOpt.transcription_expression\nInfiniteOpt.TranscriptionOpt.transcribe_measures!\nInfiniteOpt.TranscriptionOpt.transcribe_objective!\nInfiniteOpt.TranscriptionOpt.transcribe_constraints!\nInfiniteOpt.TranscriptionOpt.build_transcription_model!\nInfiniteOpt.add_measure_variable(::JuMP.Model,::InfiniteOpt.PointVariable,::Val{:TransData})\nInfiniteOpt.add_measure_variable(::JuMP.Model,::InfiniteOpt.ReducedVariable,::Val{:TransData})\nInfiniteOpt.delete_reduced_variable(::JuMP.Model,::InfiniteOpt.ReducedVariableRef,::Val{:TransData})\nInfiniteOpt.build_optimizer_model!(::InfiniteOpt.InfiniteModel,::Val{:TransData})","category":"page"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionModel","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.TranscriptionModel","text":"TranscriptionModel([optimizer_constructor;\n                   caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,\n                   bridge_constraints::Bool = true])::JuMP.Model\n\nReturn a JuMP.Model with TranscriptionData included in the ext data field. Accepts the same arguments as a typical JuMP Model. More detailed variable and constraint naming can be enabled via verbose_naming.\n\nExample\n\njulia> TranscriptionModel()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.is_transcription_model","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.is_transcription_model","text":"is_transcription_model(model::JuMP.Model)::Bool\n\nReturn true if model is a TranscriptionModel or false otherwise.\n\nExample\n\njulia> is_transcription_model(model)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_data","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_data","text":"transcription_data(model::JuMP.Model)::TranscriptionData\n\nReturn the TranscriptionData from a TranscriptionModel. Errors if it is not a TranscriptionModel.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_model","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_model","text":"transcription_model(model::InfiniteOpt.InfiniteModel)::JuMP.Model\n\nReturn the transcription model stored in model if that is what is stored in model.optimizer_model.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_variable","text":"transcription_variable(model::JuMP.Model,\n                       vref::InfiniteOpt.GeneralVariableRef)\n\nReturn the transcribed variable reference(s) corresponding to vref. Errors if no transcription variable is found. Also can query via the syntax:\n\ntranscription_variable(vref::InfiniteOpt.GeneralVariableRef)\n\nIf the infinite model contains a built transcription model.\n\nExample\n\njulia> transcription_variable(trans_model, infvar)\n2-element Array{VariableRef,1}:\n infvar(support: 1)\n infvar(support: 2)\n\njulia> transcription_variable(trans_model, hdvar)\nhdvar\n\njulia> transcription_variable(infvar)\n2-element Array{VariableRef,1}:\n infvar(support: 1)\n infvar(support: 2)\n\njulia> transcription_variable(hdvar)\nhdvar\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.optimizer_model_variable-Tuple{GeneralVariableRef,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.optimizer_model_variable","text":"InfiniteOpt.optimizer_model_variable(vref::InfiniteOpt.GeneralVariableRef,\n                                     ::Val{:TransData})\n\nProper extension of InfiniteOpt.optimizer_model_variable for TranscriptionModels. This simply dispatches to transcription_variable.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.variable_supports-Tuple{Model,Union{InfiniteVariableRef, ReducedVariableRef},Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.variable_supports","text":"InfiniteOpt.variable_supports(model::JuMP.Model,\n                              vref::InfiniteOpt.DecisionVariableRef,\n                              key::Val{:TransData} = Val(:TransData))\n\nReturn the support alias mapping associated with vref in the transcription model. Errors if vref does not have transcripted variables.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.lookup_by_support","text":"lookup_by_support(model::JuMP.Model,\n                  vref::InfiniteOpt.GeneralVariableRef,\n                  support::Vector)\n\nReturn the transcription expression of vref defined at its support. This is intended as a helper method for automated transcription.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.internal_reduced_variable-Tuple{ReducedVariableRef,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.internal_reduced_variable","text":"InfiniteOpt.internal_reduced_variable(\n    vref::InfiniteOpt.ReducedVariableRef,\n    ::Val{:TransData}\n    )::InfiniteOpt.ReducedVariable{InfiniteOpt.GeneralVariableRef}\n\nReturn the internal reduced variable associated with vref, assuming it was added internally during measure expansion at the transcription step. This extends InfiniteOpt.internal_reduced_variable as described in its docstring. Errors, if no such variable can be found.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_expression-Tuple{Model,Union{GenericAffExpr, GenericQuadExpr}}","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_expression","text":"transcription_expression(model::JuMP.Model,\n                         expr::JuMP.AbstractJuMPScalar)\n\nReturn the transcribed expression(s) corresponding to expr. Errors if expr cannot be transcribed. Also can query via the syntax:\n\ntranscription_expression(expr::JuMP.AbstractJuMPScalar)\n\nIf the infinite model contains a built transcription model.\n\nExample\n\njulia> transcription_expression(trans_model, my_expr)\nx(support: 1) - y\n\njulia> transcription_expression(my_expr)\nx(support: 1) - y\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.optimizer_model_expression-Tuple{Union{GenericAffExpr, GenericQuadExpr},Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.optimizer_model_expression","text":"InfiniteOpt.optimizer_model_expression(expr::JuMP.AbstractJuMPScalar,\n                                       ::Val{:TransData})\n\nProper extension of InfiniteOpt.optimizer_model_expression for TranscriptionModels. This simply dispatches to transcription_expression.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.expression_supports-Tuple{Model,Union{GenericAffExpr, GenericQuadExpr},Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.expression_supports","text":"InfiniteOpt.expression_supports(model::JuMP.Model,\n                                expr::JuMP.AbstractJuMPScalar,\n                                key::Val{:TransData} = Val(:TransData))\n\nReturn the support alias mappings associated with expr. Errors if expr cannot be transcribed.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model,InfOptConstraintRef}","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_constraint","text":"transcription_constraint(model::JuMP.Model,\n                         cref::InfiniteOpt.InfOptConstraintRef)\n\nReturn the transcribed constraint reference(s) corresponding to cref. Errors if cref has not been transcribed. Also can query via the syntax:\n\ntranscription_constraint(cref::InfiniteOpt.InfOptConstraintRef)\n\nIf the infinite model contains a built transcription model.\n\nExample\n\njulia> transcription_constraint(trans_model, fin_con)\nfin_con : x(support: 1) - y <= 3.0\n\njulia> transcription_constraint(fin_con)\nfin_con : x(support: 1) - y <= 3.0\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.optimizer_model_constraint-Tuple{InfOptConstraintRef,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.optimizer_model_constraint","text":"InfiniteOpt.optimizer_model_constraint(cref::InfiniteOpt.InfOptConstraintRef,\n                                       ::Val{:TransData})\n\nProper extension of InfiniteOpt.optimizer_model_constraint for TranscriptionModels. This simply dispatches to transcription_constraint.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.constraint_supports-Tuple{Model,InfOptConstraintRef,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.constraint_supports","text":"InfiniteOpt.constraint_supports(model::JuMP.Model,\n                                cref::InfiniteOpt.InfOptConstraintRef,\n                                key::Val{:TransData} = Val(:TransData))\n\nReturn the support alias mappings associated with cref. Errors if cref is not transcribed.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.parameter_supports-Tuple{Model}","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.parameter_supports","text":"parameter_supports(model::JuMP.Model)::Tuple\n\nReturn the collected parameter support tuple that is stored in TranscriptionData.supports.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.support_index_iterator","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.support_index_iterator","text":"support_index_iterator(model::JuMP.Model, [obj_nums::Vector{Int}])::CartesianIndices\n\nReturn the CartesianIndices that determine the indices of the unique combinations of TranscriptionData.supports stored in model. If obj_nums is specified, then the indices will only include the tuple elements uses indices are included in the object numbers obj_nums and all others will be assigned the last index which should correspond to an appropriately sized placeholder comprised of NaNs. Note this method assumes that set_parameter_supports has already been called and that the last elements of each support vector contains a placeholder value.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.index_to_support","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.index_to_support","text":"index_to_support(model::JuMP.Model, index::CartesianIndex)::Vector{Float64}\n\nGiven a particular support index generated via support_index_iterator using model, return the corresponding support from TranscriptionData.supports using placeholder NaNs as appropriate for tuple elements that are unneeded.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.set_parameter_supports","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.set_parameter_supports","text":"set_parameter_supports(trans_model::JuMP.Model,\n                       inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nCollect the infinite parameter supports stored in their respective dictionaries form inf_model and process them into a tuple of vectors where each vector contains the collected supports of a particular infinite parameter. These support collections are ordered in accordance with the definition order of the parameters (i.e., their object numbers). A support collection assocciated with an independent will be a Vector{Float64} and a support collection associated with a group of dependent parameters will be a Vector{Vector{Float64}}. Note that each collection vector will include an extra final placeholder element comprised of NaNs for convenience in generating support indices via support_index_iterator.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_hold_variables!","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcribe_hold_variables!","text":"transcribe_hold_variables!(trans_model::JuMP.Model,\n                           inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nCreate a transcription variable (i.e., a JuMP variable) for each HoldVariable stored in inf_model and add it to trans_model. The variable mapping is also stored in TranscriptionData.finvar_mappings which enables transcription_variable and lookup_by_support.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!","text":"transcribe_infinite_variables!(trans_model::JuMP.Model,\n                               inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nCreate transcription variables (i.e., JuMP variables) for each InfiniteVariable stored in inf_model and add them to trans_model. The variable mappings are also stored in TranscriptionData.infvar_mappings in accordance with TranscriptionData.infvar_lookup which enable transcription_variable and lookup_by_support. Note that the supports will not be generated until InfiniteOpt.variable_supports is invoked via InfiniteOpt.supports.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_reduced_variables!","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcribe_reduced_variables!","text":"transcribe_reduced_variables!(trans_model::JuMP.Model,\n                              inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nMap each ReducedVariable in inf_model to transcription variables stored in trans_model. The variable mappings are also stored in TranscriptionData.infvar_mappings in accordance with TranscriptionData.infvar_lookup which enable transcription_variable and lookup_by_support. Note that transcribe_infinite_variables! must be called first. Note that the supports will not be generated until InfiniteOpt.variable_supports is invoked via InfiniteOpt.supports.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_point_variables!","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcribe_point_variables!","text":"transcribe_point_variables!(trans_model::JuMP.Model,\n                           inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nMap each PointVariable in inf_model to a transcription variable stored in trans_model. The variable mapping is also stored in TranscriptionData.finvar_mappings which enables transcription_variable and lookup_by_support. Note that transcribe_infinite_variables! must be called first and that the info constraints associated with the transcription variable will be updated in accordance with the point variable.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_expression","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_expression","text":"transcription_expression(model::JuMP.Model,\n                         expr::JuMP.AbstractJuMPScalar)\n\nReturn the transcribed expression(s) corresponding to expr. Errors if expr cannot be transcribed. Also can query via the syntax:\n\ntranscription_expression(expr::JuMP.AbstractJuMPScalar)\n\nIf the infinite model contains a built transcription model.\n\nExample\n\njulia> transcription_expression(trans_model, my_expr)\nx(support: 1) - y\n\njulia> transcription_expression(my_expr)\nx(support: 1) - y\n\n\n\n\n\ntranscription_expression(trans_model::JuMP.Model, expr, support::Vector{Float64})\n\nGiven the expr from an InfiniteModel, form its transcripted version in accordance with the variable mappings available in trans_model defined at support. This should only be used once all variables and measures have been transcribed (e.g., via transcribe_hold_variables!).\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_measures!","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcribe_measures!","text":"transcribe_measures!(trans_model::JuMP.Model,\n                     inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nFor each Measure in inf_model expand it via InfiniteOpt.expand_measure or analytic_expansion as appropriate and transcribe the expanded expression via transcription_expression. Then store the measure to transcripted expression mappings in TranscriptionData.measure_mappings and TranscriptionData.measure_lookup to enable transcription_variable and lookup_by_support. Note that the supports will not be generated until InfiniteOpt.variable_supports is invoked via InfiniteOpt.supports.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_objective!","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcribe_objective!","text":"transcribe_objective!(trans_model::JuMP.Model,\n                      inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nForm the transcripted version of the objective stored in inf_model and add it to trans_model. Note that all the variables and measures in inf_model must by transcripted first (e.g., via transcribe_infinite_variables!).\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcribe_constraints!","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcribe_constraints!","text":"transcribe_constraints!(trans_model::JuMP.Model,\n                        inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nFor each constraint in inf_model form its transcripted version(s) and add them to trans_model. The mappings are stored in TranscriptionData.constr_mappings and the associated supports are stored in TranscriptionData.constr_supports to enable transcription_constraint and InfiniteOpt.constraint_supports. Note that variable info constraints are simply mapped to the existing info constraints already generated along with the transcription variables. Note that the variables and measures must all first be transcripted (e.g., via transcribe_measures!).\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.build_transcription_model!","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.build_transcription_model!","text":"build_transcription_model!(trans_model::JuMP.Model,\n                           inf_model::InfiniteOpt.InfiniteModel)::Nothing\n\nGiven an empty trans_model build it using the information stored in inf_model. This is intended for a TranscriptionModel that serves as a internal optimizer model of inf_model. This detail is important to correctly enable internally generated reduced variables during the transcription process such that inf_model is not modified. Note that this will add supports to inf_model via InfiniteOpt.fill_in_supports! for infinite parameters that contain no supports. Also a warning is thrown when the transcription model contains more than 15,000 support points to alert users when they may naively have a few independent supports whose product quickly yields a very large grid. For example having 3 independent parameters with 100 supports each would result in 1,000,000 supports. This behavior can be overcome using dependent parameters.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.add_measure_variable-Tuple{Model,PointVariable,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.add_measure_variable","text":"InfiniteOpt.add_measure_variable(model::JuMP.Model,\n                                 var::InfiniteOpt.PointVariable,\n                                 key::Val{:TransData}\n                                 )::InfiniteOpt.GeneralVariableRef\n\nMake a PointVariableRef and map it to the appropriate transcription variable and return the GeneralVariableRef. This is an extension of add_measure_variable for TranscriptionOpt.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.add_measure_variable-Tuple{Model,ReducedVariable,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.add_measure_variable","text":"InfiniteOpt.add_measure_variable(model::JuMP.Model,\n                                 var::InfiniteOpt.ReducedVariable,\n                                 key::Val{:TransData}\n                                 )::InfiniteOpt.GeneralVariableRef\n\nMake a ReducedVariableRef and add var to the transcription data and return the GeneralVariableRef. This is an extension of add_measure_variable for TranscriptionOpt. Note that internal_reduced_variable is also extended to be able to access the var.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.delete_reduced_variable-Tuple{Model,ReducedVariableRef,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.delete_reduced_variable","text":"InfiniteOpt.delete_reduced_variable(model::JuMP.Model,\n                                    vref::InfiniteOpt.ReducedVariableRef,\n                                    key::Val{:TransData})::Nothing\n\nThis is an extension of delete_reduced_variable for use in TranscriptionOpt. Here we do not delete reduced variables once they have been used since there is no performance gain for this paradigm and the memory saving is small. Note this may change in the future.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.build_optimizer_model!","text":"InfiniteOpt.build_optimizer_model!(model::InfiniteOpt.InfiniteModel,\n                                   key::Val{:TransData})::Nothing\n\nTranscribe model and store it as a TranscriptionModel in the model.optimizer_model field which can be accessed with transcription_model. Ths clears the existing TranscriptionModel via InfiniteOpt.clear_optimizer_model_build! and then builds a new one using build_transcription_model!.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#measure_page","page":"Measures","title":"Measures","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"A guide and manual for the definition and use of measures in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/measure/#Overview","page":"Measures","title":"Overview","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Measures are objects that capture the integration of an expression with respect to parameters, which is a distinct feature of optimization problems with infinite decision spaces. In dynamic optimization measures can represent integral terms such as the total cost over time, and in stochastic optimization measures can represent integrals over the uncertain parameters, such as expectations. In InfiniteOpt, measures are evaluated by some discretization scheme, which evaluates the expression at a set of points over the parameter space and approximates the measures based on the expression values at these points.","category":"page"},{"location":"guide/measure/#measure_basic_usage","page":"Measures","title":"Basic Usage","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"First, we consider a dynamic optimization problem with the time parameter t from 0 to 10. We also consider a state variable y(t) and a control variable u(t) that are parameterized by t:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_variable(model, y(t))\ny(t)\n\njulia> @infinite_variable(model, u(t))\nu(t)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now suppose we want to evaluate the integral int_2^8y(t)^2 + u(t)^2 dt. We can construct a measure to represent this integral using the integral function","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref1 = integral(y^2 + u^2, t, 2, 8)\nintegral{t ∈ [2, 8]}[y(t)² + u(t)²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The four positional arguments of integral are the integrand expression,  the parameter of integration, the lower bound, and the upper bound, respectively.  Specifying the integrand expression and the parameter of integration is required. If the lower and upper bounds are not specified, then the integration will be over the entire domain, which is [0, 10] in this case.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The integral function uses trapezoid rule as the default discretization scheme for univariate parameters in finite IntervalSets. In addition, the user can also  use quadrature methods for univariate parameters in all IntervalSets by setting the keyword argument eval_method as Quadrature:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref2 = integral(y^2 + u^2, t, eval_method = Quadrature)\nintegral{t ∈ [0, 10]}[y(t)² + u(t)²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The integral function also allows for specifying the number of points for the discretization scheme using the keyword argument num_supports. The default value of num_supports is 10.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref3 = integral(y^2 + u^2, t, num_supports = 20)\nintegral{t ∈ [0, 10]}[y(t)² + u(t)²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Two other explicit measure type methods include expect for expectations  and support_sum for summing an expression over the support points of  selected infinite parameters. The syntax for these is analogous to that of integral  except that there are no lower/upper bounds. For example, we can define the following  expectation of a random expression:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> m = InfiniteModel();\n\njulia> @infinite_parameter(m, ξ in Normal(), num_supports = 100);\n\njulia> @infinite_variable(m, x(ξ));\n\njulia> expect_x = expect(x^2, ξ)\nexpect{ξ}[x(ξ)²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"note: Note\nFor integrals, expectations, and support sums involving moderate to large  expressions, the macro versions @integral, @expect, and  @support_sum should be used instead of their functional equivalents  for better performance. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Depending on the type of measures created, support points may be generated at the time of creating the measures. In these cases, the new support points will be added to the support list of the integrated parameter.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Once a measure is created, the evaluation of that measure is stored in a measure data object. Users can query the measure data object using the measure_data function as follows","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> measure_data(mref2)\nDiscreteMeasureData{GeneralVariableRef,1,Float64}(t, [0.333357, 0.747257, 1.09543, 1.34633, 1.47762, 1.47762, 1.34633, 1.09543, 0.747257, 0.333357], [0.130467, 0.674683, 1.60295, 2.83302, 4.25563, 5.74437, 7.16698, 8.39705, 9.32532, 9.86953], Symbol(\"##703\"), InfiniteOpt.default_weight, 0.0, 10.0, false)\n\njulia> measure_data(mref3)\nFunctionalDiscreteMeasureData{GeneralVariableRef,Float64}(t, InfiniteOpt.MeasureToolbox._trapezoid_coeff, 0, :all, InfiniteOpt.default_weight, 0.0, 10.0, false)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Note that in InfiniteOpt, two types of measure data objects are used to store the measure data information depending on the nature of the measures created: DiscreteMeasureData and FunctionalDiscreteMeasureData. For more details on the measure data object,  refer to Measure Data Generation.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Similarly, one can also query the integrand function using measure_function:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> measure_function(mref3)\ny(t)² + u(t)²","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In addition to eval_method and num_supports as shown above, integral function  also accepts weight_func as keyword argument, which dictates the weight function of the measure. The default value of these keyword arguments can be queried using uni_integral_defaults and multi_integral_defaults as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> uni_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :num_supports => 10\n  :eval_method  => Automatic\n  :weight_func  => default_weight\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :num_supports => 10\n  :eval_method  => Automatic\n  :weight_func  => default_weight","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Automatic dictates that the integral is created using the default method depending on the type of integral, and default_weight is assigning weights of 1 for all points.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now suppose we want to create multiple measures that share the same keyword argument  values that are different from the defaults. We don't have to input the keyword argument values every time we construct a new measure. Instead, we can modify the default values of measure keyword arguments, and construct measures using the new  default values. To do that, we use the functions set_uni_integral_defaults and set_multi_integral_defaults. Adding new keyword arguments will be useful if users want to extend the measure  functions with their custom discretization/evaluation schemes that need to take  additional arguments somehow. See Extensions for more details.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now we can add integrals to the constraints and objective functions in our model using these measures. For more detailed information, please review the information below.","category":"page"},{"location":"guide/measure/#Theoretical-Abstraction","page":"Measures","title":"Theoretical Abstraction","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In InfiniteOpt, measures represent integrals of the form","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"int_tau in mathcalT f(tau)w(tau) dtau","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"where tau is a (possibly multivariate) infinite parameter, f(tau) is an expression parameterized by tau, w(tau) is a weight function, and mathcalT is a subset of the domain of tau. The measures approximate the integrals by taking a discretization scheme","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"int_tau in mathcalT f(tau)w(tau) dtau approx sum_i=1^N alpha_i f(tau_i) w(tau_i)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"where tau_i are the grid points where the expression f(tau) is evaluated, and N is the total number of points taken.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"This is the abstraction behind both DiscreteMeasureData and  FunctionalDiscreteMeasureData which are the native measure data types  in InfiniteOpt. The Measure Data Generation section below details how  these can be implemented to enable schemes that fit this mathematical paradigm, but  lie out of the realm of the supported features behind integral, expect, and  support_sum.","category":"page"},{"location":"guide/measure/#Measure-Data-Generation","page":"Measures","title":"Measure Data Generation","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The most general form of measure function takes two arguments: the integrand expression and a measure data object that contains the details of the discretization scheme. Measure data objects can be constructed using DiscreteMeasureData, where the parameter of integration, the coefficients alpha_i, and the support points need to be defined explicitly. For example, if we want to evaluate a function at each integer time point between 0 and 10, we can construct the following measure data object to record this discretization scheme:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> md_t = DiscreteMeasureData(t, ones(10), [i for i in 1:10])\nDiscreteMeasureData{GeneralVariableRef,1,Float64}(t, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0], Symbol(\"##707\"), InfiniteOpt.default_weight, NaN, NaN, false)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The arguments of DiscreteMeasureData are parameter, coefficients, and supports. The default weight function is w(tau) = 1 for any tau, which can be overwritten by the keyword argument weight_function. The weight_function should take a function that returns a number for any value that is well defined for the integrated infinite parameter. The data type is DiscreteMeasureData, which is a subtype of the abstract data type AbstractMeasureData.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"With DiscreteMeasureData, a measure can be generated in a custom and quick manner. For example, using the measure data above, we can define a measure for y^2 as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref = measure(y^2, md_t)\nmeasure{t}[y(t)²]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In the same way, we can define measure data for multivariate infinite parameter. For example, we can define a discretization scheme for a 2D position parameter x in 0 1 times 0 1 as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> @infinite_parameter(model, x[1:2] in [0, 1])\n2-element Array{GeneralVariableRef,1}:\n x[1]\n x[2]\n\njulia> md_x = DiscreteMeasureData(x, 0.25 * ones(4), [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]])\nDiscreteMeasureData{Array{GeneralVariableRef,1},2,Array{Float64,1}}(GeneralVariableRef[x[1], x[2]], [0.25, 0.25, 0.25, 0.25], [0.25 0.25 0.75 0.75; 0.25 0.75 0.25 0.75], Symbol(\"##712\"), InfiniteOpt.default_weight, [NaN, NaN], [NaN, NaN], false)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"where md_x cuts the domain into four 0.5-by-0.5 squares, and evaluates the integrand on the center of these squares. Note that for multivariate parameters,  each support point should be an AbstractArray that stores the value at each dimension.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In addition to the intuitive [DiscreteMeasureData], another type of measure data  object is FunctionalDiscreteMeasureData. This type captures measure data where the support points are not known at the time of measure data creation. Instead of  storing the specific support and coefficient values, FunctionalDiscreteMeasureData stores the minimum number of supports required for the measure, and a coefficient function that maps supports to coefficients. When the measure is built on a FunctionalDiscreteMeasureData  is evaluated (expanded), supports will be generated based on the functions stored in  the data object. The method of support generation is recorded as a label in the measure object. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"For example, suppose we want to uniformly generate at least 20 Monte Carlo samples  over the interval that t is in. A build-in label UniformGrid can be used to  signify the use of this method. A FunctionalDiscreteMeasureData can be created as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> coeff_f(supports) = [(10 - 0) / length(supports) for i in supports]\ncoeff_f (generic function with 1 method)\n\njulia> fmd_t = FunctionalDiscreteMeasureData(t, coeff_f, 20, UniformGrid)\nFunctionalDiscreteMeasureData{GeneralVariableRef,Float64}(t, coeff_f, 20, :uniform_grid, InfiniteOpt.default_weight, NaN, NaN, false)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"For more details see FunctionalDiscreteMeasureData. ","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The integral function shown in Basic Usage,  which does not require explicit construction of the measure data object, calls the measure function at the lower level. To do that, [integral]  constructs the appropriate measure data object according to the values of the positional and keyword arguments.","category":"page"},{"location":"guide/measure/#Evaluation-Methods","page":"Measures","title":"Evaluation Methods","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"The integral function calls generate_integral_data under the hood to construct the measure data object. generate_integral_data takes as positional arguments the integrated parameter, lower bound, upper bound, and method, and returns a measure data object of type AbstractMeasureData.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"generate_integral_data applies multiple dispatch to encode different support generation methods depending on the input eval_method. Each dispatch is distingushed by  the method, which takes a concrete subtype of AbstractIntegralMethod.  Each dispatch of generate_integral_data implements the specified method and returns the resulting measure data, which will be used by [@integral] to create the measure. A table of available method options in our package is listed below. Each method is limited on the dimension of parameter and/or the type of set that it can apply for. For the details of what each method type means, refer to the corresponding docstrings.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Evaluation Method Uni/Multi-Variate? Set Type\nAutomatic Both All\nUniTrapezoid Both IntervalSet\nUniMCSampling Univariate Finite IntervalSet\nUniIndepMCSampling Univariate Finite IntervalSet\nQuadrature Univariate IntervalSet\nGaussLegendre Univariate Finite IntervalSet\nGaussLaguerre Univariate Semi-infinite IntervalSet\nGaussHermite Univariate Infinite IntervalSet\nMultiMCSampling Multivariate Finite IntervalSet\nMultiIndepMCSampling Multivariate Finite IntervalSet","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In summary, the package supports trapezoid rule, Gaussian quadrature methods for univariate parameters, and Monte Carlo sampling for both univariate and multivariate parameters. For extension purposes, users may define their own generate_integral_data to encode custom evaluation methods. See Extensions for more details.","category":"page"},{"location":"guide/measure/#Expansion","page":"Measures","title":"Expansion","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In a model, each measure records the integrand expression and an evaluation scheme that details the discretization scheme to approximate the integral. The model will not expand the measures until the transcription stage, at which a JuMP.AbstractJuMPScalar is created for each measure to represent how the measure is modeled in a transcription model based on the stored discretization scheme (see Model Transcription for details on transcription). Additional point variables will be created in the expansion process if the measure is evaluated at infinite parameter points that do not have corresponding point variables yet.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Sometimes for extension purposes, one might want to expand a specific measure before reaching the transcription stage. Alternatively, one might want to use custom reformulation instead of the transcription encoded in this package, in which expanding measures will also be useful. This can be done using the expand function, which takes a MeasureRef object and returns a JuMP.AbstractJuMPScalar based on the AbstractMeasureData. For example, suppose we want to integrate y^2 in t, with two supports t = 25 and t = 75. We can set up and expand this measure as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> tdata = DiscreteMeasureData(t, [5, 5], [2.5, 7.5])\nDiscreteMeasureData{GeneralVariableRef,1,Float64}(t, [5.0, 5.0], [2.5, 7.5], Symbol(\"##713\"), InfiniteOpt.default_weight, NaN, NaN, false)\n\njulia> mref4 = measure(y^2, tdata)\nmeasure{t}[y(t)²]\n\njulia> expanded_measure = expand(mref4)\n5 y(2.5)² + 5 y(7.5)²\n\njulia> typeof(expanded_measure)\nGenericQuadExpr{Float64,GeneralVariableRef}","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"In the expand call, two point variables, y(2.5) and y(7.5), are created because they are not defined in the model before the expand call. One can use the expand_all_measures! function to expand all measures in a model, which simply applies the expand to all measures stored in the model.","category":"page"},{"location":"guide/measure/#Reduced-Infinite-Variables","page":"Measures","title":"Reduced Infinite Variables","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Expanding measures that cover a subset of infinite parameter dependencies present  in an expression will introduce reduced infinite variables to the model. To see what this means, suppose we have an infinite variable that is parameterized by multiple infinite parameters defined as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> @infinite_variable(model, T(x, t))\nT(x, t)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now say we want to integrate T over t. We can define a measure for the integral similar to how we have defined other measures:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> mref5 = measure(T, tdata)\nmeasure{t}[T(x, t)]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Now if we expand this measure, the measure data object tdata records the supports for t, but no supports for x because T is not evaluated over x in this measure. Therefore, point variables cannot be defined in the measure expansion.","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Instead of point variables, each new variable in the measure expansion will be represented using reduced infinite variables. Reduced infinite variables are \"reduced\" from their original infinite variables in that they are parameterized by less infinite parameters. In the example above, in the expansion each reduced infinite variable for T should only be parameterized by x since the value of t is fixed. The expanded measure now looks like this:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> expanded_measure = expand(mref5)\n5 T([x[1], x[2]], 2.5) + 5 T([x[1], x[2]], 7.5)","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"where the expanded measure is a JuMP.GenericAffExpr that takes in its terms GeneralVariableRefs pointing to ReducedVariables created on the fly. ReducedVariable refers to the information of the reduced infinite variable stored in its model. The reduced variable records a reference for its original infinite variable, and the value of the fixed infinite parameter. One can query this information using infinite_variable_ref and eval_supports function as follows:","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"julia> T1 = first(keys(expanded_measure.terms))\nT([x[1], x[2]], 2.5)\n\njulia> infinite_variable_ref(T1)\nT(x, t)\n\njulia> eval_supports(T1)\nDict{Int64,Float64} with 1 entry:\n  3 => 2.5","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"All the JuMP functions extended for infinite variables are also extended for reduced infinite variables, e.g. JuMP.lower_bound.","category":"page"},{"location":"guide/measure/#Datatypes","page":"Measures","title":"Datatypes","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Pages   = [\"measure.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"AbstractMeasureData\nDiscreteMeasureData\nFunctionalDiscreteMeasureData\nMeasure\nMeasureIndex\nMeasureData\nMeasureRef\nReducedVariable\nReducedVariableIndex\nReducedVariableRef","category":"page"},{"location":"guide/measure/#InfiniteOpt.AbstractMeasureData","page":"Measures","title":"InfiniteOpt.AbstractMeasureData","text":"AbstractMeasureData\n\nAn abstract type to define data for measures to define the behavior of Measure.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.DiscreteMeasureData","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData{P <: Union{JuMP.AbstractVariableRef,\n                    Vector{<:JuMP.AbstractVariableRef}},\n                    N, B <: Union{Float64, Vector{Float64}}\n                    } <: AbstractMeasureData\n\nA DataType for immutable measure abstraction data where the abstraction is of the form: measure = int_tau in T f(tau) w(tau) dtau approx sum_i = 1^N alpha_i f(tau_i) w(tau_i). The supports and coefficients are immutable (i.e., they will not change even if supports are changed for the underlying infinite parameter.) This type can be used for both 1-dimensional and multi-dimensional measures.\n\nFields\n\nparameter_refs::P: The infinite parameter(s) over which the integration occurs.                      These can be comprised of multiple independent parameters,                      but dependent parameters cannot be mixed with other types.\ncoefficients::Vector{Float64}: Coefficients alpha_i for the above                                  measure abstraction.\nsupports::Array{Float64, N}: Supports points tau_i. This is a Vector                                if only one parameter is given, otherwise it is                                a Matrix where the supports are stored column-wise.\nlabel::Symbol: Label for the support points tau_i when stored in the                  infinite parameter(s).\nweight_function::Function: Weighting function w must map an individual                              support value to a Real scalar value.\nlower_bounds::B: Lower bound in accordance with T, this denotes the                   intended interval of the measure and should be NaN if ignored\nupper_bounds::B: Same as above but the upper bound.\nis_expect::Bool: Is this data associated with an expectation call?\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.FunctionalDiscreteMeasureData","page":"Measures","title":"InfiniteOpt.FunctionalDiscreteMeasureData","text":"FunctionalDiscreteMeasureData{P <: Union{JuMP.AbstractVariableRef,\n                              Vector{<:JuMP.AbstractVariableRef}},\n                              B <: Union{Float64, Vector{Float64}}\n                              } <: AbstractMeasureData\n\nA DataType for mutable measure abstraction data where the abstraction is of the form: measure = int_tau in T f(tau) w(tau) dtau approx sum_i = 1^N alpha_i f(tau_i) w(tau_i). This abstraction is equivalent to that of DiscreteMeasureData, but the difference is that the supports are not fully known at the time of measure creation. Thus, functions are stored that will be used to generate the concrete support points tau_i and their coefficients alpha_i when the measure is evaluated (expanded). These supports are identified/generated in accordance with the label with a gaurantee that at least num_supports are generated. For example, if label = MCSample and num_supports = 100 then the measure will use all of the supports stored in the parameter_refs with the label MCSample and will ensure there are at least 100 are generated. This type can be used for both 1-dimensional and multi-dimensional measures.\n\nFields\n\nparameter_refs::P: The infinite parameter(s) over which the integration occurs.                    These can be comprised of multiple independent parameters,                    but dependent parameters cannot be mixed with other types.\ncoeff_function::Function: Coefficient generation function making alpha_i                             for the above measure abstraction. It should take                             all the supports as input (formatted as an Array)                             and return the corresponding vector of coefficients.\nmin_num_supports::Int: Specifies the minimum number of supports tau_i                      desired in association with parameter_refs and label.\nlabel::Symbol: Label for the support points tau_i which are/will be                  stored in the infinite parameter(s).\nweight_function::Function: Weighting function w must map an individual                             support value to a Real scalar value.\nlower_bounds::B: Lower bounds in accordance with T, this denotes the                 intended interval of the measure and should be NaN if ignored\nupper_bounds::B: Same as above but the upper bounds.\nis_expect::Bool: Is this data associated with an expectation call?\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.Measure","page":"Measures","title":"InfiniteOpt.Measure","text":"Measure{T <: JuMP.AbstractJuMPScalar, V <: AbstractMeasureData}\n\nA DataType for measure abstractions. The abstraction is determined by data and is enacted on func when the measure is evaluated (expended).\n\nFields\n\nfunc::T The InfiniteOpt expression to be measured.\ndata::V Data of the abstraction as described in a AbstractMeasureData           concrete subtype.\nobject_nums::Vector{Int}: The parameter object numbers of the evaluated                             measure expression (i.e., the object numbers of                             func excluding those that belong to data).\nparameter_nums::Vector{Int}: The parameter numbers that parameterize the                                evaluated measure expression. (i.e., the                                parameter numbers of func excluding those                                that belong to data).\nconstant_func::Bool: Indicates if func is not parameterized by the infinite                        parameters in data. (i.e., do the object numbers of                        func and data have no intersection?) This is useful                        to enable analytic evaluations if possible.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureIndex","page":"Measures","title":"InfiniteOpt.MeasureIndex","text":"MeasureIndex <: ObjectIndex\n\nA DataType for storing the index of a Measure.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureData","page":"Measures","title":"InfiniteOpt.MeasureData","text":"MeasureData <: AbstractDataObject\n\nA mutable DataType for storing Measures and their data.\n\nFields\n\nmeasure::Measure: The measure structure.\nname::String: The base name used for printing name(meas_expr d(par)).\nmeasure_indices::Vector{MeasureIndex}: Indices of dependent measures.\nconstraint_indices::Vector{ConstraintIndex}: Indices of dependent constraints.\nin_objective::Bool: Is this used in objective?\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureRef","page":"Measures","title":"InfiniteOpt.MeasureRef","text":"MeasureRef <: FiniteVariableRef\n\nA DataType for referring to measure abstractions.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::MeasureIndex: Index of the measure in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.ReducedVariable","page":"Measures","title":"InfiniteOpt.ReducedVariable","text":"ReducedVariable{I <: GeneralVariableRef} <: InfOptVariable\n\nA DataType for storing reduced infinite variables which partially support an infinite variable.\n\nFields\n\ninfinite_variable_index::I: The original infinite variable.\neval_supports::Dict{Int, Float64}: The original parameter tuple linear indices                                    to the evaluation supports.\nparameter_nums::Vector{Int}: The parameter numbers associated with the reduced                                parameter_refs.\nobject_nums::Vector{Int}: The parameter object numbers associated with the                             reduced parameter_refs.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.ReducedVariableIndex","page":"Measures","title":"InfiniteOpt.ReducedVariableIndex","text":"ReducedVariableIndex <: ObjectIndex\n\nA DataType for storing the index of a ReducedVariable.\n\nFields\n\nvalue::Int: The index value.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.ReducedVariableRef","page":"Measures","title":"InfiniteOpt.ReducedVariableRef","text":"ReducedVariableRef <: DispatchVariableRef\n\nA DataType for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.\n\nFields\n\nmodel::InfiniteModel: Infinite model.\nindex::ReducedVariableIndex: Index of the variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#Methods","page":"Measures","title":"Methods","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Pages   = [\"measure.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"default_weight\nDiscreteMeasureData(::GeneralVariableRef, ::Vector{<:Real}, ::Vector{<:Real})\nDiscreteMeasureData(::AbstractArray{GeneralVariableRef}, ::Vector{<:Real}, ::Vector{<:AbstractArray{<:Real}})\nFunctionalDiscreteMeasureData(::GeneralVariableRef,::Function,::Int,::Symbol)\nFunctionalDiscreteMeasureData(::AbstractArray{GeneralVariableRef},::Function,::Int,::Symbol)\nparameter_refs(::AbstractMeasureData)\nsupport_label(::AbstractMeasureData)\nJuMP.lower_bound(::AbstractMeasureData)\nJuMP.upper_bound(::AbstractMeasureData)\nsupports(::AbstractMeasureData)\nnum_supports(::AbstractMeasureData)\nmin_num_supports(::AbstractMeasureData)\ncoefficient_function(::AbstractMeasureData)\ncoefficients(::AbstractMeasureData)\nweight_function(::AbstractMeasureData)\nbuild_measure\nInfiniteOpt.measure_data_in_hold_bounds(::AbstractMeasureData,::ParameterBounds)\nadd_measure\nInfiniteOpt.add_supports_to_parameters(::AbstractMeasureData)\nmeasure_function\nmeasure_data\nis_analytic\nparameter_refs(::MeasureRef)\nmeasure\n@measure\nused_by_constraint(::MeasureRef)\nused_by_measure(::MeasureRef)\nused_by_objective(::MeasureRef)\nis_used(::MeasureRef)\nJuMP.name(::MeasureRef)\nJuMP.set_name(::MeasureRef, ::String)\nnum_measures\nall_measures\nJuMP.delete(::InfiniteModel, ::MeasureRef)\nexpand\nexpand_all_measures!\nInfiniteOpt.expand_measure\nInfiniteOpt.analytic_expansion\nInfiniteOpt.expand_measures\nmake_point_variable_ref\nmake_reduced_variable_ref\nadd_measure_variable(::JuMP.Model, ::Any, ::Any)\ndelete_internal_reduced_variable\ndelete_reduced_variable(::JuMP.Model, ::Any, ::Any)\ninternal_reduced_variable\nJuMP.build_variable(::Function, ::GeneralVariableRef,::Dict{Int, Float64})\nJuMP.add_variable(::InfiniteModel, ::ReducedVariable,::String)\ninfinite_variable_ref(::ReducedVariableRef)\neval_supports(::ReducedVariableRef)\nparameter_refs(::ReducedVariableRef)\nparameter_list(::ReducedVariableRef)\nraw_parameter_refs(::ReducedVariableRef)\nJuMP.set_name(::ReducedVariableRef,::String)\nJuMP.has_lower_bound(::ReducedVariableRef)\nJuMP.lower_bound(::ReducedVariableRef)\nJuMP.LowerBoundRef(::ReducedVariableRef)\nJuMP.has_upper_bound(::ReducedVariableRef)\nJuMP.upper_bound(::ReducedVariableRef)\nJuMP.UpperBoundRef(::ReducedVariableRef)\nJuMP.is_fixed(::ReducedVariableRef)\nJuMP.fix_value(::ReducedVariableRef)\nJuMP.FixRef(::ReducedVariableRef)\nstart_value_function(::ReducedVariableRef)\nJuMP.is_binary(::ReducedVariableRef)\nJuMP.BinaryRef(::ReducedVariableRef)\nJuMP.is_integer(::ReducedVariableRef)\nJuMP.IntegerRef(::ReducedVariableRef)","category":"page"},{"location":"guide/measure/#InfiniteOpt.default_weight","page":"Measures","title":"InfiniteOpt.default_weight","text":"default_weight(t) = 1\n\nDefault weight function for DiscreteMeasureData and FunctionalDiscreteMeasureData. Returns 1 regardless of the input value.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.DiscreteMeasureData-Tuple{GeneralVariableRef,Array{#s38,1} where #s38<:Real,Array{#s9,1} where #s9<:Real}","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData(pref::GeneralVariableRef,\n                    coefficients::Vector{<:Real},\n                    supports::Vector{<:Real};\n                    [label::Symbol = gensym(),\n                    weight_function::Function = [`default_weight`](@ref),\n                    lower_bound::Real = NaN,\n                    upper_bound::Real = NaN,\n                    is_expect::Bool = false]\n                    )::DiscreteMeasureData\n\nReturns a 1-dimensional DiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for DiscreteMeasureData. Errors if supports are out bounds or an unequal number of supports and coefficients are given. Note that by default a unique label is generated via gensym to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.\n\nExample\n\njulia> data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2])\nDiscreteMeasureData{GeneralVariableRef,1,Float64}(pref, [0.5, 0.5], [1.0, 2.0], Symbol(\"##373\"), default_weight, NaN, NaN, false)\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Array{#s38,1} where #s38<:Real,Array{#s9,1} where #s9<:(AbstractArray{#s5,N} where N where #s5<:Real)}","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData(prefs::AbstractArray{GeneralVariableRef},\n                    coefficients::Vector{<:Real},\n                    supports::Vector{<:AbstractArray{<:Real}};\n                    label::Symbol = gensym(),\n                    weight_function::Function = [`default_weight`](@ref),\n                    lower_bounds::AbstractArray{<:Real} = [NaN...],\n                    upper_bounds::AbstractArray{<:Real} = [NaN...],\n                    is_expect::Bool = false\n                    )::DiscreteMeasureData\n\nReturns a DiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for parameter_refs. A description of the other arguments is provided in the documentation for DiscreteMeasureData. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or if mixed infinite parameter types are given. Note that by default a unique label is generated via gensym to ensure the supports can be located in the infinite parameter support storage. Advanced implementations, may choose a different behavior but should do so with caution.\n\nExample\n\njulia> data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]]);\n\njulia> typeof(data)\nDiscreteMeasureData{Array{GeneralVariableRef,1},2,Array{Float64,1}}\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{GeneralVariableRef,Function,Int64,Symbol}","page":"Measures","title":"InfiniteOpt.FunctionalDiscreteMeasureData","text":"FunctionalDiscreteMeasureData(pref::GeneralVariableRef,\n                              coeff_func::Function,\n                              min_num_supports::Int,\n                              label::Symbol;\n                              [weight_function::Function = [`default_weight`](@ref),\n                              lower_bound::Real = NaN,\n                              upper_bound::Real = NaN,\n                              is_expect::Bool = false]\n                              )::FunctionalDiscreteMeasureData\n\nReturns a 1-dimensional FunctionalDiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for a scalar (single) infinite parameter. A description of the other arguments is provided in the documentation for FunctionalDiscreteMeasureData. Errors if pref is not an infinite parameter. Built-in choices for label include:\n\nAll: Use all of the supports stored in pref\nMCSample: Use Monte Carlo samples associated with pref\nWeightedSample: Use weighted Monte Carlo samples associated with pref\nUniformGrid: Use uniform grid points associated with pref.\n\nExample\n\njulia> data = FunctionalDiscreteMeasureData(pref, my_func, 20, UniformGrid)\nFunctionalDiscreteMeasureData{GeneralVariableRef,Float64}(pref, my_func, 20, UniformGrid, default_weight, NaN, NaN, false)\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.FunctionalDiscreteMeasureData-Tuple{AbstractArray{GeneralVariableRef,N} where N,Function,Int64,Symbol}","page":"Measures","title":"InfiniteOpt.FunctionalDiscreteMeasureData","text":"FunctionalDiscreteMeasureData(prefs::AbstractArray{GeneralVariableRef},\n                              coeff_func::Function,\n                              min_num_supports::Int,\n                              label::Symbol;\n                              [weight_function::Function = [`default_weight`](@ref),\n                              lower_bounds::AbstractArray{<:Real} = [NaN...],\n                              upper_bounds::AbstractArray{<:Real} = [NaN...],\n                              is_expect::Bool = false]\n                              )::FunctionalDiscreteMeasureData\n\nReturns a multi-dimensional FunctionalDiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for an array of infinite parameters. A description of the other arguments is provided in the documentation for FunctionalDiscreteMeasureData. Errors if prefs are not infinite parameters or if the mixed parameter types are provided. Built-in choices for label include:\n\nAll: Use all of the supports stored in prefs\nMCSample: Use Monte Carlo samples associated with prefs\nWeightedSample: Use weighted Monte Carlo samples associated with prefs\nUniformGrid: Use uniform grid points associated with prefs.\n\nExample\n\njulia> data = FunctionalDiscreteMeasureData(prefs, my_func, 20, MCSample);\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(data::AbstractMeasureData)::Union{GeneralVariableRef,\n                                                 AbstractArray{GeneralVariableRef}}\n\nReturn the infinite parameter reference(s) in data. This is intended as an internal function to be used with measure addition. User-defined measure data types will need to extend this function otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.support_label-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.support_label","text":"support_label(data::AbstractMeasureData)::Symbol\n\nReturn the label stored in data associated with its supports. This is intended as en internal method for measure creation and ensures any new supports are added to parameters with such a label. User-defined measure data types should extend this functionif supports are used, otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.lower_bound-Tuple{AbstractMeasureData}","page":"Measures","title":"JuMP.lower_bound","text":"JuMP.lower_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}\n\nReturn the lower bound associated with data that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise NaN is returned\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.upper_bound-Tuple{AbstractMeasureData}","page":"Measures","title":"JuMP.upper_bound","text":"JuMP.upper_bound(data::AbstractMeasureData)::Union{Float64, Vector{Float64}}\n\nReturn the lower bound associated with data that defines its domain. This is intended as an internal method, but may be useful for extensions. User-defined measure data types should extend this function if desired, otherwise NaN is returned.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.supports-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.supports","text":"supports(data::AbstractMeasureData)::Array{Float64}\n\nReturn the supports associated with data and its infinite parameters. This is intended as en internal method for measure creation and ensures any new supports are added to parameters. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.num_supports-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.num_supports","text":"num_supports(data::AbstractMeasureData)::Int\n\nReturn the number supports associated with data and its infinite parameters. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.min_num_supports-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.min_num_supports","text":"min_num_supports(data::AbstractMeasureData)::Int\n\nReturn the minimum number of supports associated with data. By fallback, this will just return num_supports(data). This is primarily intended for internal queries of FunctionalDiscreteMeasureData, but can be extended for other measure data types if needed.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.coefficient_function-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.coefficient_function","text":"coefficient_function(data::AbstractMeasureData)::Function\n\nReturn the coefficient function stored in data associated with its expansion abstraction is there is such a function. This is intended as an internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown for unsupported types.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.coefficients-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.coefficients","text":"coefficients(data::AbstractMeasureData)::Vector{<:Real}\n\nReturn the coefficients associated with data associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an empty vector is returned.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.weight_function-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.weight_function","text":"weight_function(data::AbstractMeasureData)::Function\n\nReturn the weight function stored in data associated with its expansion abstraction. This is intended as en internal method for measure creation. User-defined measure data types should extend this function if appropriate, otherwise an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.build_measure","page":"Measures","title":"InfiniteOpt.build_measure","text":"build_measure(expr::JuMP.AbstractJuMPScalar,\n              data::AbstractMeasureData)::Measure\n\nBuild and return a Measure given the expression to be measured expr using measure data data. This principally serves as an internal method for measure definition. Errors if the supports associated with data violate an hold variable parameter bounds of hold variables that are included in the measure.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.measure_data_in_hold_bounds-Tuple{AbstractMeasureData,ParameterBounds}","page":"Measures","title":"InfiniteOpt.measure_data_in_hold_bounds","text":"measure_data_in_hold_bounds(data::AbstractMeasureData,\n                            bounds::ParameterBounds)::Bool\n\nReturn a Bool whether the domain of data is valid in accordance with bounds. This is intended as an internal method and is used to check hold variables used in measures. User-defined measure data types will need to extend this function to enable this error checking, otherwise it is skipped and a warning is given.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.add_measure","page":"Measures","title":"InfiniteOpt.add_measure","text":"add_measure(model::InfiniteModel, meas::Measure,\n            name::String = \"measure\")::GeneralVariableRef\n\nAdd a measure to model and return the corresponding measure reference. This operates in a manner similar to JuMP.add_variable. Note this intended as an internal method.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.add_supports_to_parameters-Tuple{AbstractMeasureData}","page":"Measures","title":"InfiniteOpt.add_supports_to_parameters","text":"add_supports_to_parameters(data::AbstractMeasureData)::Nothing\n\nAdd supports as appropriate with data to the underlying infinite parameters. This is an internal method with by add_measure and should be defined for user-defined measure data types.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.measure_function","page":"Measures","title":"InfiniteOpt.measure_function","text":"measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar\n\nReturn the function associated with mref.\n\nExample\n\njulia> measure_function(meas)\ny(x, t) + 2\n\n\n\n\n\nInfiniteOpt.measure_function(mref::GeneralVariableRef)\n\nDefine InfiniteOpt.measure_function for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.measure_data","page":"Measures","title":"InfiniteOpt.measure_data","text":"measure_data(mref::MeasureRef)::AbstractMeasureData\n\nReturn the measure data associated with mref.\n\nExample\n\njulia> data = measure_data(meas);\n\njulia> typeof(data)\nFunctionalDiscreteMeasureData{Vector{GeneralVariableRef},Vector{Float64}}\n\n\n\n\n\nInfiniteOpt.measure_data(mref::GeneralVariableRef)\n\nDefine InfiniteOpt.measure_data for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.is_analytic","page":"Measures","title":"InfiniteOpt.is_analytic","text":"is_analytic(mref::MeasureRef)::Bool\n\nReturn if mref is evaluated analytically.\n\nExample\n\njulia> is_analytic(meas)\nfalse\n\n\n\n\n\nInfiniteOpt.is_analytic(mref::GeneralVariableRef)\n\nDefine InfiniteOpt.is_analytic for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.parameter_refs-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(mref::MeasureRef)::Tuple\n\nReturn the tuple of infinite parameters that the measured expression associated mref depends on once the measure has been evaluated. Note that this will correspond to the parameter dependencies of the measure function excluding those included in the measure data.\n\nExample\n\njulia> parameter_refs(meas)\n(t,)\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.measure","page":"Measures","title":"InfiniteOpt.measure","text":"measure(expr::JuMP.AbstractJuMPScalar,\n        data::AbstractMeasureData;\n        [name::String = \"measure\"])::GeneralVariableRef\n\nReturn a measure reference that evaluates expr using according to data. The measure data data determines how the measure is to be evaluated. Typically, the DiscreteMeasureData and the FunctionalDiscreteMeasureData constructors can be used to for data. The variable expression expr can contain InfiniteOpt variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Typically, this is called inside of JuMP.@expression, JuMP.@objective, and JuMP.@constraint in a manner similar to sum. Note measures are not explicitly evaluated until build_optimizer_model! is called or unless they are expanded via expand or expand_all_measures!.\n\nExample\n\njulia> tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2]);\n\njulia> xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]]);\n\njulia> constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)\nmeasure{t}[g(t) - s + 2] + s²\n\njulia> @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))\nmeasure{xs}[g(t) - 1 + measure{xs}[T(t, x)]]\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.@measure","page":"Measures","title":"InfiniteOpt.@measure","text":"@measure(expr::JuMP.AbstractJuMPScalar,\n         data::AbstractMeasureData;\n         [name::String = \"measure\"])::GeneralVariableRef\n\nAn efficient wrapper for measure, please see its doc string for more information.\n\n\n\n\n\n","category":"macro"},{"location":"guide/measure/#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(mref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.used_by_measure-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a measure.\n\nExample\n\njulia> used_by_measure(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.used_by_objective-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vmref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by the objective.\n\nExample\n\njulia> used_by_objective(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.is_used-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.is_used","text":"is_used(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used in the model.\n\nExample\n\njulia> is_used(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.name-Tuple{MeasureRef}","page":"Measures","title":"JuMP.name","text":"JuMP.name(mref::MeasureRef)::String\n\nExtend JuMP.name to return the name associated with a measure reference.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.set_name-Tuple{MeasureRef,String}","page":"Measures","title":"JuMP.set_name","text":"JuMP.set_name(mref::MeasureRef, name::String)::Nothing\n\nExtend JuMP.set_name to specify the name of a measure reference.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.num_measures","page":"Measures","title":"InfiniteOpt.num_measures","text":"num_measures(model::InfiniteModel)::Int\n\nReturn the number of measures defined in model.\n\nExample\n\njulia> num_measures(model)\n2\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.all_measures","page":"Measures","title":"InfiniteOpt.all_measures","text":"all_measures(model::InfiniteModel)::Vector{GeneralVariableRef}\n\nReturn the list of all measures added to model.\n\nExamples\n\njulia> all_measures(model)\n2-element Array{GeneralVariableRef,1}:\n integral{t ∈ [0, 6]}[w(t, x)]\n expect{x}[w(t, x)]\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#JuMP.delete-Tuple{InfiniteModel,MeasureRef}","page":"Measures","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, mref::MeasureRef)::Nothing\n\nExtend JuMP.delete to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.\n\nExample\n\njulia> print(model)\nMin integral{t ∈ [0, 6]}[g(t)] + z\nSubject to\n z ≥ 0.0\n integral{t ∈ [0, 6]}[g(t)] = 0\n g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]\n g(0.5) = 0\n\njulia> delete(model, meas)\n\njulia> print(model)\nMin z\nSubject to\n z ≥ 0.0\n 0 = 0\n g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]\n g(0.5) = 0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.expand","page":"Measures","title":"InfiniteOpt.expand","text":"expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar\n\nReturn a JuMP scalar function containing the explicit expansion of the measure mref. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with measure to expand measures on the fly.\n\nThis is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending expand_measure. Optionally, analytic_expansion can also be extended which is triggered by is_analytic for such types if analytic expansion is possible in certain cases.\n\nExample\n\njulia> tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])\n\njulia> expr = expand(measure(g + z + T - h - 2, tdata))\n0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2\n\n\n\n\n\nInfiniteOpt.expand(mref::GeneralVariableRef)\n\nDefine InfiniteOpt.expand for general variable references. Errors if mref does not correspond to a MeasureRef. See the underlying docstrings for more information.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.expand_all_measures!","page":"Measures","title":"InfiniteOpt.expand_all_measures!","text":"expand_all_measures!(model::InfiniteModel)::Nothing\n\nExpand all of the measures used in the objective and/or constraints of model. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression.\n\nThis is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before model is translated into the new model. This method can also be extended to handle custom measure data types by extending expand_measure. Note that this method leverages expand_measure via expand_measures. Optionally, analytic_expansion can also be extended which is triggered by is_analytic for such types if analytic expansion is possible in certain cases.\n\nExample\n\njulia> print(model)\nMin integral{t ∈ [0, 6]}[g(t)*t] + z\nSubject to\n T(t, x) ≥ 0.0, ∀ t ∈ [0, 6], xi ∈ [-1, 1]\n z ≥ 0.0\n g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]\n integral{t ∈ [0, 6]}[T(t, x)] ≥ 0.0, ∀ x ∈ [-1, 1]\n\njulia> expand_all_measures!(model)\n\njulia> print(model)\nMin 3 g(6) + z\nSubject to\n T(t, x) ≥ 0.0, ∀ t ∈ [0, 6], xi ∈ [-1, 1]\n z ≥ 0.0\n g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]\n 0.5 T(0, x) + 0.5 T(6, xi) ≥ 0.0, ∀ x ∈ [-1, 1]\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.expand_measure","page":"Measures","title":"InfiniteOpt.expand_measure","text":"expand_measure(expr, data::AbstractMeasureData,\n               write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar\n\nReturn the finite reformulation of a measure containing a variable/parameter expression expr with measure data data. Here write_model is the target model where this expanded expression will be used. Thus, any variables that need to be created will be added to write_model. The methods make_point_variable_ref and make_reduced_variable_ref should be used as appropriate to create these variables. Developers might also choose to use delete_internal_reduced_variable in order to remove reduced variables once they are no longer needed. Note this is intended as an internal function, but will need to be extended for unsupported expr types and for user-defined measure data types. Principally, this is leveraged to enable the user methods expand and expand_all_measures!.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.analytic_expansion","page":"Measures","title":"InfiniteOpt.analytic_expansion","text":"analytic_expansion(expr, data::AbstractMeasureData,\n                   write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar\n\nAnalytically, evaluate measure in the simple case where the measure expression expr doesn't depend on data and thus expr can be treated as a constant in conjunction with an analytic result of the data. This is intended as an internal method that is used by expand and expand_measures. For unrecognized data types, expand_measure is called instead. User defined measure data type may choose to extend this method if desired. This is triggered when is_analytic(mref) = true.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.expand_measures","page":"Measures","title":"InfiniteOpt.expand_measures","text":"expand_measures(expr, write_model::JuMP.AbstractModel)::JuMP.AbstractJuMPScalar\n\nExpand all MeasureRefs in expr in-place via expand_measure and return the expanded expression. This is an internal method used by expand_all_measures! and TranscriptionOpt but can be useful for user-defined optimizer model extensions that add implement add_measure_variable in combination with expand_measure. write_model is the model that the measure variables are added to as described in expand_measure.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.make_point_variable_ref","page":"Measures","title":"InfiniteOpt.make_point_variable_ref","text":"make_point_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},\n                        ivref::GeneralVariableRef,\n                        support::Vector{Float64}\n                        )::GenealVariableRef\n\nMake a point variable for infinite variable ivref at support, add it to the write_model, and return the GeneralVariableRef. This is an internal method for point variables produced by expanding measures via expand_measure. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the InfiniteModel. In such cases, write_model should be the optimizer model and add_measure_variable should be extended appropriately for point variables. Errors if write_model is an optimizer model and add_measure_variable is not properly extended.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.make_reduced_variable_ref","page":"Measures","title":"InfiniteOpt.make_reduced_variable_ref","text":"make_reduced_variable_ref(write_model::Union{InfiniteModel, JuMP.Model},\n                          ivref::GeneralVariableRef,\n                          indices::Vector{Int},\n                          values::Vector{Float64}\n                          )::GeneralVariableRef\n\nMake a reduced variable for infinite variable ivref at support, add it to the write_model, and return the GeneralVariableRef. This is an internal method for reduced variables produced by expanding measures via expand_measure. This is also useful for those writing extension optimizer models and wish to expand measures without modifiying the InfiniteModel. In such cases, write_model should be the optimizer model and add_measure_variable should be extended appropriately for reduced variables. Errors if write_model is an optimizer model and add_measure_variable is not properly extended. Note this is only intended for optimizer models that are currently stored in InfiniteModel.optimizer_model.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}","page":"Measures","title":"InfiniteOpt.add_measure_variable","text":"add_measure_variable(model::JuMP.Model, var,\n                     key::Val{:ext_key_name})::GeneralVariableRef\n\nAdd a measure variable var to the optimizer model model (with key) and return the correct InfiniteOpt variable reference. This is an internal method used by make_point_variable_ref and make_reduced_variable_ref to make point variables and reduced variables when the write_model is an optimizer model. This is useful for extensions that wish to expand measures, but without changing the original InfiniteModel. Thus, this should be extended for adding PointVariables and ReducedVariables for such extensions. Otherwise, an error is thrown for unextended variable and/or optimizer model types. Note if this is extended, than internal_reduced_variable should also be extended in order to direct reduced variables references to the underlying ReducedVariable.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.delete_internal_reduced_variable","page":"Measures","title":"InfiniteOpt.delete_internal_reduced_variable","text":"delete_internal_reduced_variable(write_model::Union{InfiniteModel, JuMP.Model},\n                                 rvref::ReducedVariableRef)::Nothing\n\nDelete the variable associated with rvref from write_model if it is purely an internal variable only used for measure expansion and is no longer needed. For write_models that are an optimizer model, delete_reduced_variable will need to be extended for this this to work. Otherwise, a warning will be thrown. Note that this is intended as an internal method to assist with extensions to expand_measure.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}","page":"Measures","title":"InfiniteOpt.delete_reduced_variable","text":"delete_reduced_variable(model::JuMP.Model, vref, key::Val{:ext_key_name})::Nothing\n\nDelete the reduced variable associated with vref from the optimizer model model with associated extension key :ext_key_name. A warning is thrown if this is not properly extended. This is intended as a helper function for delete_internal_reduced_variable which is used by expand_measure.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.internal_reduced_variable","page":"Measures","title":"InfiniteOpt.internal_reduced_variable","text":"internal_reduced_variable(vref::ReducedVariableRef,\n                          key::Val{:my_ext_key})::ReducedVariable\n\nReturn the reduced variable object of vref assuming it is an internal variable made during measure expansion within an optimizer model. This will apply to optimizer model extensions that utilize add_measure_variable in combination with expand_measure.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}","page":"Measures","title":"JuMP.build_variable","text":"JuMP.build_variable(_error::Function, ivref::GeneralVariableRef,\n                    eval_supports::Dict{Int, Float64}; [check::Bool = true]\n                    )::ReducedVariable{GeneralVariableRef}\n\nExtend the JuMP.build_variable function to build a reduced infinite variable based on the infinite variable ivref with reduction support eval_supports. Will check that input is appropriate if check = true. Errors if ivref is not an infinite variable, eval_supports violate infinite parameter domains, or if the support dimensions don't match the infinite parameter dimensions of ivref. This is intended an internal method for use in evaluating measures.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.add_variable-Tuple{InfiniteModel,ReducedVariable,String}","page":"Measures","title":"JuMP.add_variable","text":"JuMP.add_variable(model::InfiniteModel, var::InfOptVariable,\n                  [name::String = \"\"])::GeneralVariableRef\n\nExtend the JuMP.add_variable function to accomodate InfiniteOpt variable types. Adds a variable to an infinite model model and returns a GeneralVariableRef. Primarily intended to be an internal function of the constructor macros @infinite_variable, @point_variable, and @hold_variable. However, it can be used in combination with JuMP.build_variable to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in var.\n\nExamples\n\njulia> @infinite_parameter(m, t in [0, 10]);\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t);\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5);\n\njulia> pvref = add_variable(m, pt_var, \"var_alias\")\nvar_alias\n\njulia> hd_var = build_variable(error, info, Hold);\n\njulia> hvref = add_variable(m, hd_var, \"var_name\")\nvar_name\n\n\n\n\n\nJuMP.add_variable(model::InfiniteModel, var::ReducedVariable,\n                  [name::String = \"\"])::GeneralVariableRef\n\nExtend the JuMP.add_variable function to accomodate InfiniteOpt reduced variable types. Adds var to the infinite model model and returns a GeneralVariableRef. Primarily intended to be an internal function used in evaluating measures.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.infinite_variable_ref-Tuple{ReducedVariableRef}","page":"Measures","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::ReducedVariableRef)::GeneralVariableRef\n\nReturn the infinite variable reference associated with the reduced infinite variable vref.\n\nExample\n\njulia> infinite_variable_ref(vref)\ng(t, x)\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.eval_supports-Tuple{ReducedVariableRef}","page":"Measures","title":"InfiniteOpt.eval_supports","text":"eval_supports(vref::ReducedVariableRef)::Dict{Int, Float64}\n\nReturn the evaluation supports associated with the reduced infinite variable vref.\n\nExample\n\njulia> eval_supports(vref)\nDict{Int64,Float64} with 1 entry:\n  1 => 0.5\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.parameter_refs-Tuple{ReducedVariableRef}","page":"Measures","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::ReducedVariableRef)::Tuple\n\nReturn the infinite parameter references associated with the reduced infinite variable vref. This is formatted as a Tuple of containing the parameter references as they were inputted to define the untranscripted infinite variable except, the evaluated parameters are excluded.\n\nExample\n\njulia> parameter_refs(vref)\n(t, [x[1], x[2]])\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.parameter_list-Tuple{ReducedVariableRef}","page":"Measures","title":"InfiniteOpt.parameter_list","text":"parameter_list(vref::ReducedVariableRef)::Vector{GeneralVariableRef}\n\nReturn a vector of the parameter references that vref depends on. This is primarily an internal method where parameter_refs is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.raw_parameter_refs-Tuple{ReducedVariableRef}","page":"Measures","title":"InfiniteOpt.raw_parameter_refs","text":"raw_parameter_refs(vref::ReducedVariableRef)::VectorTuple{GeneralVariableRef}\n\nReturn the raw VectorTuple of the parameter references that vref depends on. This is primarily an internal method where parameter_refs is intended as the preferred user function.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.set_name-Tuple{ReducedVariableRef,String}","page":"Measures","title":"JuMP.set_name","text":"JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing\n\nExtend JuMP.set_name to set names of decision variables.\n\nExample\n\njulia> set_name(vref, \"var_name\")\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.has_lower_bound-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::ReducedVariableRef)::Bool\n\nExtend JuMP.has_lower_bound to return a Bool whether the original infinite variable of vref has a lower bound.\n\nExample\n\njulia> has_lower_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.lower_bound-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::ReducedVariableRef)::Float64\n\nExtend JuMP.lower_bound to return the lower bound of the original infinite variable of vref. Errors if vref doesn't have a lower bound.\n\nExample\n\njulia> lower_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.LowerBoundRef-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::ReducedVariableRef)::InfOptConstraintRef\n\nExtend JuMP.LowerBoundRef to extract a constraint reference for the lower bound of the original infinite variable of vref.\n\nExample\n\njulia> cref = LowerBoundRef(vref)\nvar >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.has_upper_bound-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::ReducedVariableRef)::Bool\n\nExtend JuMP.has_upper_bound to return a Bool whether the original infinite variable of vref has an upper bound.\n\nExample\n\njulia> has_upper_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.upper_bound-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::ReducedVariableRef)::Float64\n\nExtend JuMP.upper_bound to return the upper bound of the original infinite variable of vref. Errors if vref doesn't have a upper bound.\n\nExample\n\njulia> upper_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.UpperBoundRef-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::ReducedVariableRef)::InfOptConstraintRef\n\nExtend JuMP.UpperBoundRef to extract a constraint reference for the upper bound of the original infinite variable of vref.\n\nExample\n\njulia> cref = UpperBoundRef(vref)\nvar <= 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.is_fixed-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::ReducedVariableRef)::Bool\n\nExtend JuMP.is_fixed to return Bool whether the original infinite variable of vref is fixed.\n\nExample\n\njulia> is_fixed(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.fix_value-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::ReducedVariableRef)::Float64\n\nExtend JuMP.fix_value to return the fix value of the original infinite variable of vref. Errors if variable is not fixed.\n\nExample\n\njulia> fix_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.FixRef-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::ReducedVariableRef)::InfOptConstraintRef\n\nExtend JuMP.FixRef to return the constraint reference of the fix constraint associated with the original infinite variable of vref. Errors vref is not fixed.\n\nExamples\n\njulia> cref = FixRef(vref)\nvar == 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.start_value_function-Tuple{ReducedVariableRef}","page":"Measures","title":"InfiniteOpt.start_value_function","text":"start_value_function(vref::ReducedVariableRef)::Union{Nothing, Function}\n\nReturn the function that is used to generate the start values of vref for particular support values. Returns nothing if no start behavior has been specified.\n\nExample\n\njulia> start_value_func(vref)\nmy_func\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.is_binary-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::ReducedVariableRef)::Bool\n\nExtend JuMP.is_binary to return Bool whether the original infinite variable of vref is binary.\n\nExample\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.BinaryRef-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::ReducedVariableRef)::InfOptConstraintRef\n\nExtend JuMP.BinaryRef to return a constraint reference to the constraint constrainting the original infinite variable of vref to be binary. Errors if one does not exist.\n\nExample\n\njulia> cref = BinaryRef(vref)\nvar binary\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.is_integer-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::ReducedVariableRef)::Bool\n\nExtend JuMP.is_integer to return Bool whether the original infinite variable of vref is integer.\n\nExample\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.IntegerRef-Tuple{ReducedVariableRef}","page":"Measures","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::ReducedVariableRef)::InfOptConstraintRef\n\nExtend JuMP.IntegerRef to return a constraint reference to the constraint constrainting the original infinite variable of vref to be integer. Errors if one does not exist.\n\nExample\n\njulia> cref = IntegerRef(vref)\nvar integer\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#MeasureToolbox-Datatypes","page":"Measures","title":"MeasureToolbox Datatypes","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Pages   = [\"measure.md\"]\nModules = [InfiniteOpt.MeasureToolbox]\nOrder   = [:type]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"InfiniteOpt.MeasureToolbox.AbstractIntegralMethod\nInfiniteOpt.MeasureToolbox.Automatic\nInfiniteOpt.MeasureToolbox.AbstractUnivariateMethod\nInfiniteOpt.MeasureToolbox.UniTrapezoid\nInfiniteOpt.MeasureToolbox.UniMCSampling\nInfiniteOpt.MeasureToolbox.UniIndepMCSampling\nInfiniteOpt.MeasureToolbox.Quadrature\nInfiniteOpt.MeasureToolbox.GaussHermite\nInfiniteOpt.MeasureToolbox.GaussLegendre\nInfiniteOpt.MeasureToolbox.GaussLaguerre\nInfiniteOpt.MeasureToolbox.AbstractMultivariateMethod\nInfiniteOpt.MeasureToolbox.MultiMCSampling\nInfiniteOpt.MeasureToolbox.MultiIndepMCSampling","category":"page"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.AbstractIntegralMethod","page":"Measures","title":"InfiniteOpt.MeasureToolbox.AbstractIntegralMethod","text":"AbstractIntegralMethod\n\nAn abstract type for integral evaluation methods use in combination with integral and generate_integral_data.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.Automatic","page":"Measures","title":"InfiniteOpt.MeasureToolbox.Automatic","text":"Automatic <: AbstractIntegralMethod\n\nAn integral evaluation type for automically selecting an appropriate integral evaluation method.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod","page":"Measures","title":"InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod","text":"AbstractUnivariateMethod <: AbstractIntegralMethod\n\nAn abstract type for integral evaluation methods for 1-dimensional integrals.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.UniTrapezoid","page":"Measures","title":"InfiniteOpt.MeasureToolbox.UniTrapezoid","text":"UniTrapezoid <: AbstractUnivariateMethod\n\nAn integral evalution method that uses the trapezoid rule to in combination with all parameter supports available when the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this method will ignore the num_supports keyword argument. Note this is valid only for finite integral domains.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.UniMCSampling","page":"Measures","title":"InfiniteOpt.MeasureToolbox.UniMCSampling","text":"UniMCSampling <: AbstractUnivariateMethod\n\nAn integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy num_supports and it will include all supports with the MCSample label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.UniIndepMCSampling","page":"Measures","title":"InfiniteOpt.MeasureToolbox.UniIndepMCSampling","text":"UniIndepMCSampling <: AbstractUnivariateMethod\n\nAn integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to UniMCSampling. However, this variant will generate its own set of supports and ignore all other supports with the MCSample label. Note this is valid only for finite integral domains. This is not compatible with individual dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.Quadrature","page":"Measures","title":"InfiniteOpt.MeasureToolbox.Quadrature","text":"Quadrature <: AbstractUnivariateMethod\n\nA general integral evaluation method that will automatically select the appropriate quadrature method to approximate the integral. Please note that this will generate a unique set of parameter supports and will ignore existing supports when the integral is evaluated and thus should be used with caution. However, this method is able to handle infinite and semi-infinite integral domains. This is not compatible with individual dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.GaussHermite","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussHermite","text":"GaussHermite <: AbstractUnivariateMethod\n\nAn integral evaulation method that uses Gauss-Hermite quadrature to evaluate integrals. This is valid for infinite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.GaussLegendre","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussLegendre","text":"GaussLegendre <: AbstractUnivariateMethod\n\nAn integral evaulation method that uses Gauss-Legendre quadrature to evaluate integrals. This is valid for finite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.GaussLaguerre","page":"Measures","title":"InfiniteOpt.MeasureToolbox.GaussLaguerre","text":"GaussLaguerre <: AbstractUnivariateMethod\n\nAn integral evaulation method that uses Gauss-Laguerre quadrature to evaluate integrals. This is valid for semi-infinite integral domains. Note this will generate its own set of supports and will ignore other parameter supports. This is not compatible with individual dependent parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod","page":"Measures","title":"InfiniteOpt.MeasureToolbox.AbstractMultivariateMethod","text":"AbstractMultivariateMethod <: AbstractIntegralMethod\n\nAn abstract type for integral evaluation methods for multi-dimensional integrals.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.MultiMCSampling","page":"Measures","title":"InfiniteOpt.MeasureToolbox.MultiMCSampling","text":"MultiMCSampling <: AbstractMultivariateMethod\n\nAn integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral. This variant will add more supports to the model as needed to satisfy num_supports and it will include all supports with the MCSample label up till the integral is expanded and/or when the infinite model is optimized, whichever comes first. Note this is valid only for finite integral domains. If an array of independent infinite parameters is specified, they must use the same amount of supports.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.MultiIndepMCSampling","page":"Measures","title":"InfiniteOpt.MeasureToolbox.MultiIndepMCSampling","text":"MultiIndepMCSampling <: AbstractMultivariateMethod\n\nAn integral evaluation method that uses uniform Monte Carlo sampling to approximate the integral similar to MultiMCSampling. However, this variant will generate its own set of supports and ignore all other supports with the MCSample label. Note this is valid only for finite integral domains.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#MeasureToolbox-Methods","page":"Measures","title":"MeasureToolbox Methods","text":"","category":"section"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"Pages   = [\"measure.md\"]\nModules = [InfiniteOpt.MeasureToolbox]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/measure/","page":"Measures","title":"Measures","text":"InfiniteOpt.MeasureToolbox.@integral\nInfiniteOpt.MeasureToolbox.integral(::JuMP.AbstractJuMPScalar,::InfiniteOpt.GeneralVariableRef,::Real,::Real)\nInfiniteOpt.MeasureToolbox.integral(::JuMP.AbstractJuMPScalar,::AbstractArray{InfiniteOpt.GeneralVariableRef},::Union{Real, AbstractArray{<:Real}},::Union{Real, AbstractArray{<:Real}})\nInfiniteOpt.MeasureToolbox.@expect\nInfiniteOpt.MeasureToolbox.expect\nInfiniteOpt.MeasureToolbox.@support_sum\nInfiniteOpt.MeasureToolbox.support_sum\nInfiniteOpt.MeasureToolbox.uni_integral_defaults\nInfiniteOpt.MeasureToolbox.set_uni_integral_defaults\nInfiniteOpt.MeasureToolbox.multi_integral_defaults\nInfiniteOpt.MeasureToolbox.set_multi_integral_defaults\nInfiniteOpt.MeasureToolbox.generate_integral_data","category":"page"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.@integral","page":"Measures","title":"InfiniteOpt.MeasureToolbox.@integral","text":"@integral(expr::JuMP.AbstractJuMPScalar,\n          prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}},\n          [lower_bounds::Union{Real, AbstractArray{<:Real}} = default_bounds,\n          upper_bounds::Union{Real, AbstractArray{<:Real}} = default_bounds;\n          kwargs...])::GeneralVariableRef\n\nAn efficient wrapper for integral and integral. Please see the above doc strings for more information.\n\n\n\n\n\n","category":"macro"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,GeneralVariableRef,Real,Real}","page":"Measures","title":"InfiniteOpt.MeasureToolbox.integral","text":"integral(expr::JuMP.AbstractJuMPScalar,\n         pref::GeneralVariableRef,\n         [lower_bound::Real = lower_bound(pref),\n         upper_bound::Real = upper_bound(pref);\n         kwargs...])::GeneralVariableRef\n\nReturns a measure reference that evaluates the integral of expr with respect to infinite parameter pref from lower_bound to upper_bound. This thus considers integrals of the form: int_p in P expr(p) w(p) dp where p is an infinite parameter and w is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of AbstractMeasureData via generate_integral_data in accordance with the keyword arugment eval_method that is then used with measure. Note that it is preferred to call @integral when expr is not just a single variable reference. Errors for bad bound input.\n\nThe keyword arguments are as follows:\n\neval_method::Type{<:AbstractUnivariateMethod}: Used to determine the   numerical evaluation scheme\nAutomatic\nUniTrapezoid\nUniMCSampling\nUniIndepMCSampling\nQuadrature\nGaussHermite\nGaussLegendre\nGaussLaguerre\nnum_supports: The minimum number of supports to be generated (if used by   eval_method)\nweight_func: w(p) above with parameter value inputs and scalar output\n\nSee set_uni_integral_defaults to update the default keyword argument values for all one-dimensional integral calls.\n\nExample\n\njulia> @infinite_parameter(model, x in [0, 1])\nx\n\njulia> @infinite_variable(model, f(x))\nf(x)\n\njulia> int = integral(f, x)\nintegral{x ∈ [0, 1]}[f(x)]\n\njulia> expand(int)\n0.2 f(0.8236475079774124) + 0.2 f(0.9103565379264364) + 0.2 f(0.16456579813368521) + 0.2 f(0.17732884646626457) + 0.2 f(0.278880109331201)\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.integral-Tuple{AbstractJuMPScalar,AbstractArray{GeneralVariableRef,N} where N,Union{Real, AbstractArray{#s38,N} where N where #s38<:Real},Union{Real, AbstractArray{#s9,N} where N where #s9<:Real}}","page":"Measures","title":"InfiniteOpt.MeasureToolbox.integral","text":"integral(expr::JuMP.AbstractJuMPScalar,\n         prefs::AbstractArray{GeneralVariableRef},\n         [lower_bounds::Union{Real, AbstractArray{<:Real}} = [lower_bound(pref)...],\n         upper_bounds::Union{Real, AbstractArray{<:Real}} = [upper_bound(pref)...];\n         kwargs...])::GeneralVariableRef\n\nReturns a measure reference that evaluates the integral of expr with respect to infinite parameters prefs from lower_bounds to upper_bounds. This thus considers integrals of the form: int_p in P expr(p) w(p) dp where p is an infinite parameter and w is the weight function is 1 by default. This function provides a high-level interface that ultimately constructs an appropriate concrete form of AbstractMeasureData via generate_integral_data in accordance with the keyword arugment eval_method that is then used with measure. Note that it is preferred to call @integral when expr is not just a single variable reference. Errors when the container types and dimensions do not match or the bounds are invalid.\n\nThe keyword arguments are as follows:\n\neval_method::Type{<:AbstractMultivariateMethod}: Used to determine the   numerical evaluation scheme\nAutomatic\nMultiMCSampling\nMultiIndepMCSampling\nnum_supports: The minimum number of supports to be generated (if used by   eval_method)\nweight_func: w(p) above with parameter value inputs and scalar output\n\nSee set_multi_integral_defaults to update the default keyword argument values for all multi-dimensional integral calls.\n\nExample\n\njulia> @infinite_parameter(model, x[1:2] in [0, 1], independent = true);\n\njulia> @infinite_variable(model, f(x));\n\njulia> int = integral(f, x)\nintegral{x ∈ [0, 1]^2}[f(x)]\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.@expect","page":"Measures","title":"InfiniteOpt.MeasureToolbox.@expect","text":"@expect(expr::JuMP.AbstractJuMPScalar,\n        prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};\n        [min_num_supports::Int = DefaultNumSupports])::GeneralVariableRef\n\nAn efficient wrapper for expect. Please see its doc string more information.\n\n\n\n\n\n","category":"macro"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.expect","page":"Measures","title":"InfiniteOpt.MeasureToolbox.expect","text":"expect(expr::JuMP.AbstractJuMPScalar,\n       prefs::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef};\n       [min_num_supports::Int = DefaultNumSupports])::GeneralVariableRef\n\nCreates a measure that represents the expected value of an expression based on prefs. If prefs are not random parameters then this will be equivalent to the following call:\n\n1/total_num_supports * support_sum(expr, prefs)\n\nNote that minnumsupports should be 0 if a single dependent parameter is given. Also, note that it is preferred to call @expect when expr is not just a single variable reference.\n\nExample\n\njulia> @infinite_parameter(model, x in Normal())\nx\n\njulia> @infinite_variable(model, f(x))\nf(x)\n\njulia> meas = expect(f, min_num_supports = 2)\nexpect{x}[f(x)]\n\njulia> expand(meas)\n0.5 f(0.6791074260357777) + 0.5 f(0.8284134829000359)\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.@support_sum","page":"Measures","title":"InfiniteOpt.MeasureToolbox.@support_sum","text":"@support_sum(expr::JuMP.AbstractJuMPScalar,\n             params::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}}\n             )::GeneralVariableRef\n\nAn efficient wrapper for support_sum please see its doc string for more information.\n\n\n\n\n\n","category":"macro"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.support_sum","page":"Measures","title":"InfiniteOpt.MeasureToolbox.support_sum","text":"support_sum(expr::JuMP.AbstractJuMPScalar,\n            params::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}}\n            )::GeneralVariableRef\n\nCreates a measure that represents the sum of the expression over a parameter(s) using all of its supports. Also, note that it is preferred to call @support_sum when expr is not just a single variable reference.\n\nExample\n\njulia> @infinite_parameter(model, x in [0, 1], supports = [0.3, 0.7])\nx\n\njulia> @infinite_variable(model, f(x))\nf(x)\n\njulia> meas = support_sum(f, x)\nsupport_sum{x}[f(x)]\n\njulia> expand(meas)\nf(0.3) + f(0.7)\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.uni_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.uni_integral_defaults","text":"uni_integral_defaults()::Dict{Symbol, Any}\n\nGet the default keyword argument values for defining one-dimensional integrals.\n\njulia> uni_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :num_supports          => 10\n  :eval_method           => Automatic\n  :weight_func           => default_weight\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.set_uni_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.set_uni_integral_defaults","text":"set_uni_integral_defaults(; kwargs...)::Nothing\n\nSet the default keyword argument settings for one-dimensional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling integral with a single infinite parameter.\n\nExample\n\njulia> uni_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :num_supports          => 10\n  :eval_method           => Automatic\n  :weight_func           => default_weight\n\njulia> set_uni_integral_defaults(num_supports = 5, eval_method = Quadrature,\n                                 new_kwarg = true)\n\njulia> uni_integral_defaults()\nDict{Symbol,Any} with 4 entries:\n  :new_kwarg             => true\n  :num_supports          => 5\n  :eval_method           => Quadrature\n  :weight_func           => default_weight\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.multi_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.multi_integral_defaults","text":"multi_integral_defaults()::Dict{Symbol, Any}\n\nGet the default keyword argument values for defining multi-dimensional integrals.\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :num_supports          => 10\n  :eval_method           => Automatic\n  :weight_func           => default_weight\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.set_multi_integral_defaults","page":"Measures","title":"InfiniteOpt.MeasureToolbox.set_multi_integral_defaults","text":"set_multi_integral_defaults(; kwargs...)::Nothing\n\nSet the default keyword argument settings for multi-dimesnional integrals. The keyword arguments of this function will be recorded in the default keyword argument dictionary. These will determine the default keyword argument values when calling integral with an array of infinite parameters.\n\nExample\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 3 entries:\n  :num_supports          => 10\n  :eval_method           => Automatic\n  :weight_func           => default_weight\n\njulia> set_multi_integral_defaults(num_supports = 5, new_kwarg = true)\n\njulia> multi_integral_defaults()\nDict{Symbol,Any} with 4 entries:\n  :new_kwarg             => true\n  :num_supports          => 5\n  :eval_method           => Automatic\n  :weight_func           => default_weight\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.MeasureToolbox.generate_integral_data","page":"Measures","title":"InfiniteOpt.MeasureToolbox.generate_integral_data","text":"generate_integral_data(\n    prefs::Union{InfiniteOpt.GeneralVariableRef, Vector{InfiniteOpt.GeneralVariableRef}},\n    lower_bounds::Union{Real, Vector{<:Real}},\n    upper_bounds::Union{Real, Vector{<:Real}},\n    method::Type{V}; [num_supports::Int = InfiniteOpt.DefaultNumSupports,\n    weight_func::Function = InfiniteOpt.default_weight,\n    extra_kwargs...]\n    )::InfiniteOpt.AbstractMeasureData where {V <: AbstractIntegralMethod}\n\nGenerate the appropriate concrete realization of AbstractMeasureData using method. Here prefs, lower_bounds, and upper_bounds will always have a 1 to 1 correspondence when this is called from integral. Please refer to the method docstrings for an explanation of each one.\n\nUser-defined method extensions should first define a concrete method type inheriting from AbstractUnivariateMethod or AbstractMultivariateMethod as appropriate and then implement extend this method using that type for method.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we exemplify the use of InfiniteOpt via a few case studies:","category":"page"},{"location":"examples/#Two-Stage-Stochastic-Program","page":"Examples","title":"Two-Stage Stochastic Program","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First let's consider a standard two-stage stochastic program. Such problems consider 1st stage variables x in X subseteq mathbbR^n_x which denote upfront (hear-and-now) decisions made before any realization of the random parameters xi in mathbbR^n_xi is observed, and 2nd stage variables y(xi) in mathbbR^n_y which denote recourse (wait-and-see) decisions that are made in response to realizations of xi. Moreover, the objective seeks to optimize 1st stage costs f_1(x) and second stage costs f_2(x y(xi)) which are evaluated over the uncertain domain via a risk measure R_xicdot (e.g., the expectation mathbbE_xicdot). Putting this together, we obtain the two-stage stochastic program:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\n\tmin_x y(xi)  f_1(x) + R_xif_2(x y(xi)) \n\ttextst   g_i(x y(xi)) = 0  i in I\n\t h_j(x y(xi)) leq 0  j in J\n      x in X\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g_i(x y(xi))  i in I denote 2nd stage equality constraints, h_j(x y(xi))  j in J are 2nd stage inequality constraints, and X denotes the set of feasible 1st stage decisions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For an example, we consider the classic farmer problem. Here the farmer must allocate farmland x_c for each crop c in C with random yields per acre xi_c such that he minimizes expenses (i.e., maximizes profit) while fulfilling contractual demand d_c. If needed he can purchase crops from other farmers to satisfy his contracts. He can also sell extra crop yield that exceeds his contractual obligations. Thus, here we have 1st stage variables x_c and 2nd stage variables of crops sold w_c(xi) and crops purchased y_c(xi). Putting this together using the expectation mathbbE_xicdot as our risk measure we obtain:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\n\tundersetx y(xi) w(xi)textmin  sum_c in C alpha_c x_c + mathbbE_xileftsum_c in Cbeta_c y_c(xi) - lambda_c w_c(xi)right \n\ttextst   sum_c in C x_c leq barx\n\t xi_c x_c + y_c(xi) - w_c(xi) geq d_c  c in C \n     0 leq x_c leq barx  c in C \n     0 leq y_c(xi) leq bary_c  c in C \n     0 leq w_c(xi) leq barw_c  c in C \n     xi_c in Xi_c  c in C\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where alpha_c are production costs, beta_c are the purchase prices, lambda_c are the selling prices, barx is the total acreage, bary_c are purchases limits, barw_c are selling limits, and Xi_c are the underlying distributions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now let's implement this first by defining the problem parameters:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Distributions\n\n# Model parameters\nnum_scenarios = 10\nC = 1:3\n\n# Data\nα = [150, 230, 260] # land cost\nβ = [238, 210, 0]   # purchasing cost\nλ = [170, 150, 36]  # selling price\nd = [200, 240, 0]   # contract demand\nxbar = 500          # total land\nwbar3 = 6000        # no upper bound on the other crops\nybar3 = 0           # no upper bound on the other crops\n\n# Define the distributions\nΞ = [Uniform(0, 5), Uniform(0, 5), Uniform(10, 30)]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Great now we can formulate and solve the problem using InfiniteOpt:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using InfiniteOpt, JuMP, Ipopt, Random\n\n# Seed for repeatability\nRandom.seed!(0)\n\n# Initialize the model\nmodel = InfiniteModel(Ipopt.Optimizer) # seed to test output\nset_optimizer_attribute(model, \"print_level\", 0)\n\n# Define the random parameters\n@infinite_parameter(model, ξ[c in C] in Ξ[c], num_supports = num_scenarios)\n\n# Define the variables and bounds\n@hold_variable(model, 0 <= x[C] <= xbar)\n@infinite_variable(model, 0 <= y[C](ξ))\n@infinite_variable(model, 0 <= w[C](ξ))\n\n# Define the objective\n@objective(model, Min, sum(α[c] * x[c] for c in C) +\n           expect(sum(β[c] * y[c] - λ[c] * w[c] for c in C), ξ))\n\n# Define the constraints\n@constraint(model, capacity, sum(x[c] for c in C) <= xbar)\n@constraint(model, balance[c in C], ξ[c] * x[c] + y[c] - w[c] >= d[c])\n@constraint(model, w[3] <= wbar3)\n@constraint(model, y[3] <= ybar3)\n\n# Optimize and get the results\noptimize!(model)\nx_opt = value.(x)\nprofit = -objective_value(model)\n\n# Print the results\nprintln(\"Land Allocations: \", [round(x_opt[k], digits = 2) for k in keys(x_opt)])\nprintln(\"Expected Profit: \\$\", round(profit, digits = 2))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Land Allocations: [48.56, 214.77, 236.67]\nExpected Profit: $57099.53","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We did it! An interesting modification would be to use a CVaR risk measure instead of an expectation. This also can be readily achieved via InfiniteOpt. The CVaR measure is defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CVaR_epsilon(X) = undersett in mathbbRtextinfleftt + frac11-epsilon mathbbEtextmax(0 X - t) right","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where epsilon is the confidence level. Inserting this into the formulation, we now obtain:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\n\tundersetx y(xi) w(xi) t q(xi)textmin  sum_c in C alpha_c x_c + t + frac11-epsilon mathbbE_xiq(xi) \n\ttextst  sum_c in C x_c leq barx\n\t xi_c x_c + y_c(xi) - w_c(xi) geq d_c  c in C \n     0 leq x_c leq barx  c in C \n     0 leq y_c(xi) leq bary_c  c in C \n     0 leq w_c(xi) leq barw_c  c in C \n     xi_c in Xi_c  c in C \n     q(xi) geq sum_c in Cbeta_c y_c(xi) - lambda_c w_c(xi) - t \n     q(xi) geq 0\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where q(xi) is introduced to handle the max operator. Let's update and resolve our InfiniteOpt model using epsilon = 095:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define the additional variables\n@hold_variable(model, t)\n@infinite_variable(model, q(ξ) >= 0)\n\n# Redefine the objective\n@objective(model, Min, sum(α[c] * x[c] for c in C) + t + 1 \\ (1 - 0.95) * expect(q, ξ))\n\n# Add the max constraint\n@constraint(model, max, q >= sum(β[c] * y[c] - λ[c] * w[c] for c in C) - t)\n\n# Optimize and get the results\noptimize!(model)\nx_opt = value.(x)\ny_opt = value.(y)\nw_opt = value.(w)\nprofit = -sum(α[c] * x_opt[c] for c in C) - 1 / num_scenarios *\n         sum(β[c] * y_opt[c][k] - λ[c] * w_opt[c][k] for c in C, k in 1:num_scenarios)\n\n# Print the results\nprintln(\"Land Allocations: \", [round(x_opt[k], digits = 2) for k in keys(x_opt)])\nprintln(\"Expected Profit: \\$\", round(profit, digits = 2))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Land Allocations: [58.5, 199.25, 242.26]\nExpected Profit: $32918.89","category":"page"},{"location":"examples/#Optimal-Control","page":"Examples","title":"Optimal Control","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this case study, we seek to determine an optimal control policy for the trajectory of a hovercraft that travels to a set of dynamic waypoints while trying to minimize the thrust input. The corresponding dynamic optimization problem is expressed:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\n\tundersetx(t) v(t) u(t)textmin  int_t in T u(t)_2^2 dt  \n\ttextst  v(0) = v0\n\t fracdxdt = v(t)  t in T\n     fracdvdt = u(t)  t in T\n     x(t_i) = xw_i  i in I\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where x(t) is the Cartesian position, v(t) is the velocity, u(t) is the thrust input, xw_i  i in I are the waypoints, and T is the time horizon. This contains two ordinary differential equations which aren't currently supported by InfiniteOpt, so we'll need to reformulate them. This can be achieved via a simple Euler integration. Thus, we define a set of time points T_m subseteq T with an equal time step Delta t and apply Euler's method to obtain:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\n\tundersetx(t) v(t) u(t)textmin  int_t in T u(t)_2^2 dt  \n\ttextst  v(0) = v0\n\t x(t_j+1) = v(t_j) Delta t + x(t_j)  j in T_m setminus T_mf\n     v(t_j+1) = u(t_j) Delta t + v(t_j)  j in T_m setminus T_mf\n     x(t_i) = xw_i  i in I\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where T_mf is the final time point in T_m.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's implement this in InfiniteOpt by first defining our problem parameters:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Initial condition\nv0 = [0, 0]\n\n# Time horizon\nmax_time = 60\n\n# Euler parameters\nΔt = 1\ntime_points = Vector(0:Δt:max_time)\n\n# Waypoints\nxw = [1 4 6 1; 1 3 0 1] # positions\ntw = [0, 25, 50, 60]    # times","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"With our parameters set, let's now construct the InfiniteModel and solve it:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using InfiniteOpt, JuMP, Ipopt\n\n# Initialize the model\nm = InfiniteModel(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0))\n\n# Set the parameters and variables\n@infinite_parameter(m, t in [0, max_time])\n@infinite_variable(m, x[1:2](t), start = 1) # position\n@infinite_variable(m, v[1:2](t), start = 0) # velocity\n@infinite_variable(m, u[1:2](t), start = 0) # thruster input\n\n# Set the initial conditions\n@BDconstraint(m, initial_velocity[i = 1:2](t == 0), v[i] == 0)\n\n# Manually implement euler scheme for motion equations\n@point_variable(m, x[i](time_points[j]), xp[i = 1:2, j = 1:length(time_points)])\n@point_variable(m, v[i](time_points[j]), vp[i = 1:2, j = 1:length(time_points)])\n@point_variable(m, u[i](time_points[j]), up[i = 1:2, j = 1:length(time_points)])\n@constraint(m, [i = 1:2, j = 1:length(time_points)-1], xp[i, j+1] == xp[i, j] + vp[i, j])\n@constraint(m, [i = 1:2, j = 1:length(time_points)-1], vp[i, j+1] == vp[i, j] + up[i, j])\n\n# Hit all the waypoints\n@BDconstraint(m, [i = 1:2, j = 1:length(tw)](t == tw[j]), x[i] == xw[i, j])\n\n# Specify the objective\n@objective(m, Min, integral(u[1]^2 + u[2]^2, t))\n\n# Optimize the model\noptimize!(m)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This thus demonstrates how point variables can be used to enable functionality that is not built in InfinitOpt. Finally, let's extract the solution and plot it to see the finalized trajectory:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Get the results\nif has_values(m)\n    x_opt = value.(x)\nend\n\n# Plot the results\nscatter(xw[1,:], xw[2,:], label = \"Waypoints\")\nplot!(x_opt[1,:], x_opt[2,:], label = \"Trajectory\")\nxlabel!(\"x1\")\nylabel!(\"x2\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: answer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Logo)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A JuMP extension for expressing and solving infinite-dimensional optimization problems.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt.jl provides a mathematical interface to express and solve optimization problems that entail an infinite-dimensional decision space. Such problems stem from areas such as dynamic programming, state-space models, and stochastic programming. InfiniteOpt is meant to facilitate intuitive model definition, automatic transcription into solvable models, permit a wide range of user-defined extensions/behavior, and more. Currently, its capabilities include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"JuMP-like symbolic macro interface\nInfinite set abstractions for parameterization of variables/constraints\nFinite parameters support and use (similar to ParameterJuMP)\nDirect support of infinite, point, and hold variables\nSymbolic measure (integral) expression\nInfinite/finite constraint definition\nOrdinary differential equation support (coming soon with v0.3.0)\nAutomated model transcription/reformulation and solution\nCompatible with all JuMP-supported solvers\nReadily extendable to accommodate user defined abstractions and solution techniques.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nCurrently, InfiniteOpt only accepts linear and quadratic expressions. Development is planned to allow for general nonlinear expressions. Please visit Expressions for more details.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt.jl is a registered Julia and can be added simply by inputting the following in the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.5) pkg> add InfiniteOpt","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please visit our Installation Guide for more details and information on how to get started.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Moreover, InfiniteOpt is under constant develop with new features being added often. Thus, the latest pre-release experimental version can be obtained via the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.5) pkg> add https://github.com/pulsipher/InfiniteOpt.jl","category":"page"},{"location":"#How-to-Use-the-Documentation","page":"Home","title":"How to Use the Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt is intended to serve both as a high-level interface for infinite-dimensional optimization and as a highly customizable/extendable platform for implementing advanced techniques. With this in mind, we provide the User Guide sections to walk through the ins and outs of InfiniteOpt. Each page in the User Guide typically contains the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Overview section describing the purpose of the page (at the top)\nA Basic Usage section to guide using InfiniteOpt at a high level (near the top)\nMethods and/or DataTypes sections serving as a technical manual for all the public methods and datatypes (at the bottom)\nOther sections offering more in-depth information/guidance beyond basic usage (in the middle)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Details, instructions, templates, and tutorials on how to write user-defined extensions in InfiniteOpt are provided on the Extensions page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, case study examples are provided on the Examples page.","category":"page"},{"location":"#Contribution","page":"Home","title":"Contribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InfiniteOpt is a powerful tool with a broad scope lending to a large realm of possible feature additions and enhancements. So, we are thrilled to support anyone who would like to contribute to this project in any way big or small.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For small documentation fixes (such as typos or wording clarifications) please do the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Click on Edit on GitHub at the top of the documentation page\nMake the desired changes\nSubmit a pull request","category":"page"},{"location":"","page":"Home","title":"Home","text":"For other contributions, please visit our Developers Guide for step by step instructions and to review our style guide.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We acknowledge our support from the Department of Energy under grant DE-SC0014114.","category":"page"},{"location":"extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Here we provide guidance to various ways InfinitOpt can be extended.","category":"page"},{"location":"extensions/#Overview","page":"Extensions","title":"Overview","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Extendibility is one of the core ideas of InfinitOpt so that it can serve as a convenient tool for those developing and implementing advanced techniques for infinite dimensional optimization problems. Thus, InfiniteOpt is developed in a modular manner to readily accommodate user-defined functionality and/or to serve as useful base in writing a JuMP extension. Admittedly, this modularity might be imperfect and comments/suggestions are welcomed to help us improve this.","category":"page"},{"location":"extensions/#Infinite-Sets","page":"Extensions","title":"Infinite Sets","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Infinite sets are used to characterize the behavior of infinite parameters and used to govern the behavior of supports in InfiniteOpt. Here we walk through how user-defined sets can be added to various degrees of functionality. A template is provided in ./test/extensions/infinite_set.jl. The extension steps employed are:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Define the new struct infinite set type (only thing required as bare minimum)\nExtend InfiniteOpt.supports_in_set (enables error checking of supports)\nExtend InfiniteOpt.generate_support_values (enables support generation via num_supports keyword arguments)\nIf a lower bound and upper bound can be reported, extend JuMP lower bound and upper bound methods (enables automatic bound detection in integral)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"As an example, let's create a univariate disjoint interval set as an infinite set type. This corresponds to the set lb_1 ub_1 cup lb_2 ub_2 where ub_1 leq lb_2. First, we need to create the DataType with inheritance from InfiniteScalarSet:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using InfiniteOpt, JuMP\n\nstruct DisjointSet <: InfiniteOpt.InfiniteScalarSet\n    lb1::Float64\n    ub1::Float64\n    lb2::Float64\n    ub2::Float64\n    # constructor\n    function DisjointSet(lb1::Number, ub1::Number, lb2::Number, ub2::Number)\n        if lb1 > ub1 || lb2 > ub2 || ub1 > lb2\n            error(\"Invalid bounds\")\n        end\n        return new(convert(Float64, lb1), convert(Float64, ub1),\n                   convert(Float64, lb2), convert(Float64, ub2))\n    end\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Notice that we also define the constructor function to error check and convert as needed (this is recommended, but not required). For basic functionality this is all we have to do to add a set in InfiniteOpt.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"We can now define infinite parameters using this set via @infinite_parameter both anonymously and explicitly:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> model = InfiniteModel();\n\njulia> t = @infinite_parameter(model, set = DisjointSet(0, 1, 3, 4), base_name = \"t\")\nt\n\njulia> @infinite_parameter(model, t in DisjointSet(0, 1, 3, 4))\nt","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Once defined (without further extension), these parameters can be used as normal with the following limitations:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Supports must be specified manually (num_supports is not enabled)\nSupports will not be checked if they are in the domain of the infinite set\nSet bounds cannot be queried.\nThe DiscreteMeasureData or FunctionalDiscreteMeasureData must be provided explicitly to evaluate measures","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"However, all of these limitations except for the last one can be eliminated by  extending a few functions as outlined above. To address the last one, we need  to extend generate_integral_data. See [Measure Evaluation Techniques] for details. ","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"To enable support domain checking which is useful to avoid strange bugs, we will extend InfiniteOpt.supports_in_set. This returns a Bool to indicate if a vector of supports are in the set's domain:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.supports_in_set(supports::Union{Number, Vector{<:Number}},\n                                     set::DisjointSet)::Bool\n    return all((set.lb1 .<= supports .<= set.ub1) .| (set.lb2 .<= supports .<= set.ub2))\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now the checks are enabled so, the following would yield an error because the support is not in the set domain:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> @infinite_parameter(model, set = DisjointSet(0, 1, 3, 4), supports = 2)\nERROR: At none:1: `@infinite_parameter(model, set = DisjointSet(0, 1, 3, 4), supports = 2)`: Supports violate the set domain bounds.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"To enable automatic support generation via the num_supports keyword and with functions such as fill_in_supports!, we will extend InfiniteOpt.generate_support_values:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.generate_support_values(set::DisjointSet;\n                                             num_supports::Int = InfiniteOpt.DefaultNumSupports,\n                                             sig_digits::Int = InfiniteOpt.DefaultSigDigits)::Tuple{Vector{<:Real}, Symbol}\n    length_ratio = (set.ub1 - set.lb1) / (set.ub1 - set.lb1 + set.ub2 - set.lb2)\n    num_supports1 = Int64(ceil(length_ratio * num_supports))\n    num_supports2 = num_supports - num_supports1\n    supports1 = collect(range(set.lb1, stop = set.ub1, length = num_supports1))\n    supports2 = collect(range(set.lb2, stop = set.ub2, length = num_supports2))\n    return round.([supports1; supports2], sigdigits = sig_digits), :disjoint_grid\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now automatic support generation is enabled, for example:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> par = @infinite_parameter(model, set = DisjointSet(0, 2, 3, 4), num_supports = 10)\nnoname\n\njulia> supports(par)\n10-element Array{Float64,1}:\n 0.0\n 0.333333333333\n 0.666666666667\n 1.0\n 1.33333333333\n 1.66666666667\n 2.0\n 3.0\n 3.5\n 4.0","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Finally, we can extend the appropriate JuMP upper and lower bound functions if desired which are:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"JuMP.has_lower_bound\nJuMP.lower_bound\nJuMP.set_lower_bound\nJuMP.has_upper_bound\nJuMP.upper_bound\nJuMP.set_upper_bound","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"However, if we want has_lower_bound = false and has_upper_bound = false then no extension is needed. For our current example we won't do this since lower and upper bounds aren't exactly clear for a disjoint interval. Please refer to the template in ./InfiniteOpt/test/extensions/infinite_set.jl to see how this is done.","category":"page"},{"location":"extensions/#Measure-Evaluation-Techniques","page":"Extensions","title":"Measure Evaluation Techniques","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Measure evaluation methods are used to dictate how to evaluate measures. Users may wish to apply evaluation methods other than Monte Carlo sampling and/or Gaussian quadrature methods. To create multiple measures using the same new evaluation methods, users may want to embed the new evaluation method under the integral function that does not require explicit construction of AbstractMeasureData.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"The basic way to do that is to write a function that creates AbstractMeasureData object, and pass the object to the measure. For instance, let's consider defining a function that enables the definition of a uniform grid for a univariate or multivariate infinite parameter in IntervalSet. The function, denoted uniform_grid, generates uniform grid points as supports for univariate parameter and each component of independent multivariate parameter. The univariate version of this function can be defined as follows:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function uniform_grid(param::GeneralVariableRef, lb::Real, ub::Real, num_supports::Int)::DiscreteMeasureData\n    increment = (ub - lb) / (num_supports - 1)\n    supps = [lb + (i - 1) * increment for i in 1:num_supports]\n    coeffs = ones(num_supports) / num_supports * (ub - lb)\n    return DiscreteMeasureData(param, coeffs, supps, lower_bound = lb, upper_bound = ub)\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"It is necessary to pass infinite parameter reference since the construction of measure data object needs parameter information. Now let's apply the new uniform_grid function to infinite parameters in intervals. We consider a time parameter t and 2D spatial parameter x, and two variables f(t) and g(x) parameterized by t and x, respectively:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> m = InfiniteModel();\n\njulia> @infinite_parameter(m, t in [0, 5]);\n\njulia> @infinite_variable(m, f(t));","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now we can use uniform_grid to construct a DiscreteMeasureData and create a measure using the measure data, as shown below:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> tdata = uniform_grid(t, 0, 5, 6)\nDiscreteMeasureData{GeneralVariableRef,1,Float64}(t, [0.833333, 0.833333, 0.833333, 0.833333, 0.833333, 0.833333], [0.0, 1.0, 2.0, 3.0, 4.0, 5.0], Symbol(\"##815\"), InfiniteOpt.default_weight, 0.0, 5.0, false)\n\njulia> f_meas = measure(f, tdata)\nmeasure{t ∈ [0, 5]}[f(t)]\n\njulia> expand(f_meas)\n0.8333333333333333 f(0) + 0.8333333333333333 f(1) + 0.8333333333333333 f(2) + 0.8333333333333333 f(3) + 0.8333333333333333 f(4) + 0.8333333333333333 f(5)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"An alternate way of extending new measure evaluation methods is to extend InfiniteOpt.MeasureToolbox.generate_integral_data. This will allow users to use their custom measure evaluation methods in the integral function that does not explicitly require a measure data object. A template for how such an extension is accomplished is provided in ./test/extensions/measure_eval.jl. In general, such an extension can be created as follows:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Define a new empty struct (e.g. my_new_fn) that dispatches your function\nExtend InfiniteOpt.MeasureToolbox.generate_integral_data,","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"where method is of the type my_new_fn, and set needs to be a subtype of AbstractInfiniteSet that you wish to apply the new evaluation method to. Note that this procedure can be used to generate new measure evaluation methods not only for existing infinite sets, but also for user-defined infinite sets. ","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"For example, an extension of InfiniteOpt.MeasureToolbox.generate_integral_data that implements uniform grid for univariate and multivariate parameters in IntervalSet can be created as follows:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"const JuMPC = JuMP.Containers\nstruct UnifGrid <: InfiniteOpt.MeasureToolbox.AbstractUnivariateMethod end\nfunction InfiniteOpt.MeasureToolbox.generate_integral_data(\n    pref::InfiniteOpt.GeneralVariableRef,\n    lower_bound::Real,\n    upper_bound::Real,\n    method::Type{UnifGrid};\n    num_supports::Int = InfiniteOpt.DefaultNumSupports,\n    weight_func::Function = InfiniteOpt.default_weight\n    )::InfiniteOpt.AbstractMeasureData # REPLACE WITH ACTUAL ALIAS\n    increment = (upper_bound - lower_bound) / (num_supports - 1)\n    supports = [lower_bound + (i - 1) * increment for i in 1:num_supports]\n    coeffs = ones(num_supports) / num_supports * (upper_bound - lower_bound)\n    return InfiniteOpt.DiscreteMeasureData(\n        pref, coeffs, supports,\n        weight_function = weight_func,\n        lower_bound = lower_bound, \n        upper_bound = upper_bound)\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Also notice that users are free to pass keyword arguments for their new functions in addition to the required positional arguments. This might be needed in case if the new evaluation method requires additional information not captured in the default positional arguments. For example, the multivariate parameter version above needs to know if the multivariate parameter is independent in order to throw a warning when needed.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"We create measure for f and g using the uniform_grid method","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> f_int = integral(f, t, num_supports = 6, eval_method = UnifGrid)\nintegral{t ∈ [0, 5]}[f(t)]\n\njulia> expand(f_int)\n0.8333333333333333 f(0) + 0.8333333333333333 f(1) + 0.8333333333333333 f(2) + 0.8333333333333333 f(3) + 0.8333333333333333 f(4) + 0.8333333333333333 f(5)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Here we go! We can freely use UnifGrid for infinite parameters in IntervalSet now.","category":"page"},{"location":"extensions/#Measure-Data","page":"Extensions","title":"Measure Data","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Measures are used to evaluate over infinite domains. Users may wish to employ measure abstractions that cannot be readily represented with coefficients and discretized supports, and thus may wish to extend InfiniteOpt's measure framework to accommodate other paradigms. This can be accomplished my implementing a user-defined measure data structure that inherits from AbstractMeasureData. A template for how such an extension is accomplished is provided in ./test/extensions/measure_data.jl. The extension steps employed are:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Define the new data struct inheriting from AbstractMeasureData (required)\nExtend InfiniteOpt.parameter_refs (required)\nExtend InfiniteOpt.expand_measure (required)\nExtend InfiniteOpt.supports (required if parameter supports are employed in any way)\nExtend InfiniteOpt.add_supports_to_parameters (required if parameter supports are employed in measure evaluation)\nExtend InfiniteOpt.measure_data_in_hold_bounds (enables hold variable bound checking with measures)\nExtend InfiniteOpt.coefficients (useful getter method if applicable)\nExtend InfiniteOpt.weight_function (useful getter method if applicable)\nMake simple measure constructor wrapper of measure to ease definition.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"To illustrate how this process can be done, let's consider extending InfiniteOpt to include measure support for assessing the variance of random expressions. The variance of an expression f(x xi) where x in mathbbR^n are hold variables and xi in mathbbR^m are random infinite parameters is defined:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"mathbbVf(x xi) = mathbbEleft(f(x xi) - mathbbEf(x xi))^2 right","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Note, we could just accomplish this by nested use of expect, but we implement this example to illustrate the mechanics of extension.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"First, let's define our new struct inheriting from AbstractMeasureData:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using InfiniteOpt, JuMP, Distributions\n\nconst JuMPC = JuMP.Containers\n\nstruct DiscreteVarianceData <: AbstractMeasureData\n    parameter_refs::Union{GeneralVariableRef, Vector{GeneralVariableRef}}\n    supports::Vector\n    # constructor\n    function DiscreteVarianceData(\n        parameter_refs::Union{GeneralVariableRef, AbstractArray{<:GeneralVariableRef}},\n        supports::Vector)\n        # convert input as necessary to proper array format\n        if parameter_refs isa AbstractArray\n            parameter_refs = convert(Vector, parameter_refs)\n            supports = [convert(Vector, arr) for arr in supports]\n        end\n        return new(parameter_refs, supports)\n    end\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"We have defined our data type, so let's extend the measure data query methods to enable its definition. These include parameter_refs and  supports:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.parameter_refs(data::DiscreteVarianceData)\n    return data.parameter_refs\nend\n\nfunction InfiniteOpt.supports(data::DiscreteVarianceData)::Vector\n    return data.supports\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"We also need to extend InfiniteOpt.add_supports_to_parameters since support points will be used for measure evaluation later:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.add_supports_to_parameters(data::DiscreteVarianceData)::Nothing\n    pref = parameter_refs(data)\n    supps = supports(data)\n    add_supports(pref, supps)\n    return\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Note that extending supports is not needed for abstractions that don't involve discretization of the infinite parameter(s), such as the case for certain outer approximation techniques.  Our extension is now sufficiently constructed to allow us to define out the new variance measure via measure. For example,","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"# Setup the infinite model\nmodel = InfiniteModel()\n@infinite_parameter(model, xi in Normal(), num_supports = 2) # few for simplicity\n@infinite_variable(model, y(xi))\n@hold_variable(model, z)\n\n# Define out new variance measure\ndata = DiscreteVarianceData(xi, supports(xi))\nmref = measure(2y + z, data, name = \"Var\")\n\n# output\nVar{xi}[2 y(xi) + z]","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Thus, we can define measure references that employ this our new data type.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"We can define variance measures now, but now let's extend expand_measure so that they can be expanded into finite expressions:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.expand_measure(expr::JuMP.AbstractJuMPScalar,\n                                    data::DiscreteVarianceData,\n                                    write_model::JuMP.AbstractModel\n                                    )::JuMP.AbstractJuMPScalar\n    # define the expectation data\n    expect_data = DiscreteMeasureData(\n                      data.parameter_refs,\n                      1 / length(data.supports) * ones(length(data.supports)),\n                      data.supports, is_expect = true)\n    # define the mean\n    mean = measure(expr, expect_data)\n    # return the expansion of the variance using the data mean\n    return expand_measure((copy(expr) - mean)^2, expect_data, write_model)\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Notice that we reformulated our abstraction in terms of measures with DiscreteMeasureData so that we could leverage the existing expand_measure library. Now, new the measure type can be expanded and moreover infinite models using this new type can be optimized. Let's try expanding the measure we already defined:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> expand(mref)\n2 y(-0.556026876146)² + 2 z*y(-0.556026876146) - 2 y(-0.556026876146)² - 2 y(-0.44438335711)*y(-0.556026876146) - 2 z*y(-0.556026876146) + 0 z² - y(-0.556026876146)*z - y(-0.44438335711)*z + 0.5 y(-0.556026876146)² + 0.5 y(-0.556026876146)*y(-0.44438335711) + 0.5 y(-0.556026876146)*z + 0.5 y(-0.44438335711)*y(-0.556026876146) + 0.5 y(-0.44438335711)² + 0.5 y(-0.44438335711)*z + 0.5 z*y(-0.556026876146) + 0.5 z*y(-0.44438335711) + 2 y(-0.44438335711)² + 2 z*y(-0.44438335711) - 2 y(-0.556026876146)*y(-0.44438335711) - 2 y(-0.44438335711)² - 2 z*y(-0.44438335711) - y(-0.556026876146)*z - y(-0.44438335711)*z + 0.5 y(-0.556026876146)² + 0.5 y(-0.556026876146)*y(-0.44438335711) + 0.5 y(-0.556026876146)*z + 0.5 y(-0.44438335711)*y(-0.556026876146) + 0.5 y(-0.44438335711)² + 0.5 y(-0.44438335711)*z + 0.5 z*y(-0.556026876146) + 0.5 z*y(-0.44438335711)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Finally, as per recommendation let's make a wrapper method to make defining variance measures more convenient:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function variance(expr::Union{JuMP.GenericAffExpr, GeneralVariableRef},\n                  params::Union{GeneralVariableRef, AbstractArray{GeneralVariableRef}};\n                  name::String = \"Var\", num_supports::Int = 10,\n                  use_existing::Bool = false)::GeneralVariableRef\n    # get the supports\n    if use_existing\n        supps = supports.(params)\n    else\n        supps = generate_support_values(infinite_set(first(params)),\n                                           num_supports = num_supports)\n    end\n    # make the data\n    data = DiscreteVarianceData(params, supps)\n    # built the measure\n    return measure(expr, data, name = name)\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Notice in this case that we only permit linear expressions for expr since it will be squared by our new measure and we currently only support quadratic expressions. (This could be overcome by defining place a place holder variable for expr.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now let's use our constructor to repeat the above measure example:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> expand(variance(2y + z, xi, use_existing = true))\n2 y(-0.556026876146)² + 2 z*y(-0.556026876146) - 2 y(-0.556026876146)² - 2 y(-0.44438335711)*y(-0.556026876146) - 2 z*y(-0.556026876146) + 0 z² - y(-0.556026876146)*z - y(-0.44438335711)*z + 0.5 y(-0.556026876146)² + 0.5 y(-0.556026876146)*y(-0.44438335711) + 0.5 y(-0.556026876146)*z + 0.5 y(-0.44438335711)*y(-0.556026876146) + 0.5 y(-0.44438335711)² + 0.5 y(-0.44438335711)*z + 0.5 z*y(-0.556026876146) + 0.5 z*y(-0.44438335711) + 2 y(-0.44438335711)² + 2 z*y(-0.44438335711) - 2 y(-0.556026876146)*y(-0.44438335711) - 2 y(-0.44438335711)² - 2 z*y(-0.44438335711) - y(-0.556026876146)*z - y(-0.44438335711)*z + 0.5 y(-0.556026876146)² + 0.5 y(-0.556026876146)*y(-0.44438335711) + 0.5 y(-0.556026876146)*z + 0.5 y(-0.44438335711)*y(-0.556026876146) + 0.5 y(-0.44438335711)² + 0.5 y(-0.44438335711)*z + 0.5 z*y(-0.556026876146) + 0.5 z*y(-0.44438335711)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"We have done it! Now go and extend away!","category":"page"},{"location":"extensions/#extend_optimizer_model","page":"Extensions","title":"Optimizer Models","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"InfiniteOpt provides a convenient interface and abstraction for modeling infinite-dimensional optimization problems. By default, InfiniteModels are reformulated into a solvable JuMP.Model (referred to as an optimizer model) via TranscriptionOpt which discretizes the model in accordance with the infinite parameter supports. However, users may wish to employ some other reformulation method to produce the optimizer model. This section will explain how this can be done in InfiniteOpt. A template for implementing this extension is provided in ./test/extensions/optimizer_model.jl. Our default sub-module InfiniteOpt.TranscriptionOpt also serves as a good example.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"A new reformulation method and its corresponding optimizer model can be extended using the following steps:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Define a mutable struct for variable/constraint mappings and other needed info (required)\nDefine a JuMP.Model constructor that uses (1.) in Model.ext[:my_ext_key] (recommended)\nExtend build_optimizer_model! to in accordance with the new optimizer model (required)\nExtend optimizer_model_variable if possible (enables result queries)\nExtend optimizer_model_expression if possible (enables result queries)\nExtend optimizer_model_constraint if possible (enables result queries)\nExtend InfiniteOpt.variable_supports if appropriate\nExtend InfiniteOpt.expression_supports if appropriate\nExtend InfiniteOpt.constraint_supports if appropriate\nIf steps 4-6 are skipped then extend the following:\nInfiniteOpt.map_value (enables JuMP.value)\nInfiniteOpt.map_optimizer_index (enables JuMP.optimizer_index)\nInfiniteOpt.map_dual (enables JuMP.dual)\nInfiniteOpt.map_shadow_price (enables JuMP.shadow_price)\nInfiniteOpt.map_lp_rhs_perturbation_range (enables JuMP.lp_rhs_perturbation_range)\nInfiniteOpt.map_lp_objective_perturbation_range (enables JuMP.lp_objective_perturbation_range)\nExtend InfiniteOpt.add_measure_variable to use expand_measure without modifying the infinite model\nExtend InfiniteOpt.delete_reduced_variable to use expand_measure without modifying the infinite model and delete unneeded reduced variables.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"For the sake of example, let's suppose we want to define a reformulation method for InfiniteModels that are 2-stage stochastic programs (i.e., only DistributionSets are used, infinite variables are random 2nd stage variables, and hold variables are 1st stage variables). In particular, let's make a simple method that replaces the infinite parameters with their mean values, giving us the deterministic mean-valued problem.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"First, let's define the mutable struct that will be used to store our variable and constraint mappings. This case it is quite simple since our deterministic model will have a 1-to-1 mapping:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using InfiniteOpt, JuMP, Distributions\n\nmutable struct DeterministicData\n    # variable and constraint mapping\n    infvar_to_detvar::Dict{GeneralVariableRef, VariableRef}\n    infconstr_to_detconstr::Dict{InfOptConstraintRef, ConstraintRef}\n    # constructor\n    function DeterministicData()\n        return new(Dict{GeneralVariableRef, VariableRef}(),\n                   Dict{InfOptConstraintRef, ConstraintRef}())\n    end\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now let's define a constructor for optimizer models that will use DeterministicData and let's define a method to access that data:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"const DetermKey = :DetermData\n\nfunction DeterministicModel(args...; kwargs...)::Model\n    # initialize the JuMP Model\n    model = Model(args...; kwargs...)\n    model.ext[DetermKey] = DeterministicData()\n    return model\nend\n\nfunction deterministic_data(model::Model)::DeterministicData\n    haskey(model.ext, DetermKey) || error(\"Model is not a DeterministicModel.\")\n    return model.ext[DetermKey]\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"note: Note\nThe use of an extension key such as DetermKey is required since it used to dispatch reformulation and querying methods making optimizer model extensions possible.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"With the constructor we can now specify that a given InfiniteModel uses a DeterministicModel instead of a TranscriptionModel using the OptimizerModel keyword argument or via set_optimizer_model:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using Ipopt\n\n# Make model using Ipopt and DeterministicModels\nmodel = InfiniteModel(optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0),\n                      OptimizerModel = DeterministicModel)\n\n# Or equivalently\nmodel = InfiniteModel()\nset_optimizer_model(model, DeterministicModel())\nset_optimizer(model, optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0))","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now model uses a DeterministicModel as its optimizer model! With that we can build our InfiniteModel as normal, for example:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"@infinite_parameter(model, ξ in Uniform())\n@infinite_variable(model, y[1:2](ξ) >= 0)\n@hold_variable(model, x)\n@objective(model, Min, x + expect(y[1] + y[2], ξ))\n@constraint(model, 2y[1] - x <= 42)\n@constraint(model, y[2]^2 + ξ == 2)\nprint(model)\n\n# output\nMin x + expect{ξ}[y[1](ξ) + y[2](ξ)]\nSubject to\n y[1](ξ) ≥ 0.0, ∀ ξ ~ Uniform\n y[2](ξ) ≥ 0.0, ∀ ξ ~ Uniform\n 2 y[1](ξ) - x ≤ 42.0, ∀ ξ ~ Uniform\n y[2](ξ)² + ξ = 2.0, ∀ ξ ~ Uniform","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"We have defined our InfiniteModel, but now we need to specify how to reformulate it into a DeterministicModel. This is accomplished by extending build_optimizer_model!. This will enable the use of optimize!. First, let's define an internal function _make_expression that will use dispatch to convert and InfiniteOpt expression into a JuMP expression using the mappings stored in opt_model in its DeterministicData:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"## Make dispatch methods for converting InfiniteOpt expressions\n# GeneralVariableRef\nfunction _make_expression(opt_model::Model, expr::GeneralVariableRef)\n    return _make_expression(opt_model, expr, index(expr))\nend\n# IndependentParameterRef\nfunction _make_expression(opt_model::Model, expr::GeneralVariableRef, \n                          ::IndependentParameterIndex)\n    return mean(infinite_set(expr).distribution) # assuming univariate\nend\n# FiniteParameterRef\nfunction _make_expression(opt_model::Model, expr::GeneralVariableRef, \n                          ::FiniteParameterIndex)\n    return parameter_value(expr)\nend\n# DependentParameterRef\nfunction _make_expression(opt_model::Model, expr::GeneralVariableRef, \n                          ::DependentParameterIndex)\n    return mean(infinite_set(expr).distribution) # assuming valid dist.\nend\n# DecisionVariableRef\nfunction _make_expression(opt_model::Model, expr::GeneralVariableRef, \n                          ::Union{InfiniteVariableIndex, HoldVariableIndex})\n    return deterministic_data(opt_model).infvar_to_detvar[expr]\nend\n# MeasureRef --> assume is expectation\nfunction _make_expression(opt_model::Model, expr::GeneralVariableRef,\n                          ::MeasureIndex)\n    return _make_expression(opt_model, measure_function(expr))\nend\n# AffExpr\nfunction _make_expression(opt_model::Model, expr::GenericAffExpr)\n    return @expression(opt_model, sum(c * _make_expression(opt_model, v) \n                       for (c, v) in linear_terms(expr)) + constant(expr))\nend\n# QuadExpr\nfunction _make_expression(opt_model::Model, expr::GenericQuadExpr)\n    return @expression(opt_model, sum(c * _make_expression(opt_model, v1) * \n                       _make_expression(opt_model, v2) for (c, v1, v2) in quad_terms(expr)) + \n                       _make_expression(opt_model, expr.aff))\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"For simplicity in example, above we assume that only DistributionSets are used, there are not any PointVariableRefs, and all MeasureRefs correspond to expectations. Naturally, a full extension should include checks to enforce that such assumptions hold.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now let's extend build_optimizer_model! for DeterministicModels. Such extensions should build an optimizer model in place and in general should employ the following:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"clear_optimizer_model_build!\nset_optimizer_model_ready.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In place builds without the use of clear_optimizer_model_build! are also possible, but will require some sort of active mapping scheme to update in accordance with the InfiniteModel in the case that the optimizer model is built more than once. Thus, for simplicity we extend build_optimizer_model! below using an initial clearing scheme:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.build_optimizer_model!(model::InfiniteModel,\n                                            key::Val{DetermKey})\n    # TODO check that `model` is a stochastic model\n    # clear the model for a build/rebuild\n    determ_model = InfiniteOpt.clear_optimizer_model_build!(model)\n\n    # add variables\n    for vref in all_variables(model)\n        dvref = dispatch_variable_ref(vref)\n        if dvref isa InfiniteVariableRef # have to handle the infinite variable functional start value\n            inf_var = InfiniteOpt._core_variable_object(dvref)\n            info = InfiniteOpt.TranscriptionOpt._format_infinite_info(inf_var, zeros(length(raw_parameter_refs(dvref))))\n        else\n            info = InfiniteOpt._variable_info(dvref)\n        end\n        new_vref = add_variable(determ_model, ScalarVariable(info),\n                                name(dvref)) # TODO update infinite variable names\n        deterministic_data(determ_model).infvar_to_detvar[vref] = new_vref\n    end\n\n    # add the objective\n    set_objective(determ_model, objective_sense(model),\n                   _make_expression(determ_model, objective_function(model)))\n\n    # add the constraints\n    for cref in all_constraints(model)\n        if !InfiniteOpt._is_info_constraint(cref)\n            constr = constraint_object(cref)\n            new_constr = build_constraint(error, _make_expression(determ_model, constr.func),\n                                          constr.set)\n            new_cref = add_constraint(determ_model, new_constr, name(cref))\n            deterministic_data(determ_model).infconstr_to_detconstr[cref] = new_cref\n        end\n    end\n\n    # update the status\n    set_optimizer_model_ready(model, true)\n    return\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now we can build our optimizer model to obtain a DeterministicModel which can be leveraged to call optimize!","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"optimize!(model)\nprint(optimizer_model(model))\n\n# output\nMin x + y[1] + y[2]\nSubject to\n 2 y[1] - x ≤ 42.0\n y[2]² = 1.5\n y[1] ≥ 0.0\n y[2] ≥ 0.0","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Note that batter variable naming could be used with the reformulated infinite variables. Moreover, in general extensions of build_optimizer_model! should account for the possibility that InfiniteModel contains HoldVariables and/or ScalarConstraints that contain ParameterBounds as accessed via parameter_bounds.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Now that we have optimized out InfiniteModel via the use the of a DeterministicModel, we probably will want to access the results. All queries are enabled when we extend optimizer_model_variable,  optimizer_model_expression, and optimizer_model_constraint  to return the variable(s)/expression(s)/constraint(s) in the optimizer model corresponding to their InfiniteModel counterparts. These will use the mutable struct of mapping data and should error if no mapping can be found, Let's continue our example using DeterministicModels:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"function InfiniteOpt.optimizer_model_variable(vref::GeneralVariableRef,\n                                              key::Val{DetermKey})\n    model = optimizer_model(JuMP.owner_model(vref))\n    map_dict = deterministic_data(model).infvar_to_detvar\n    haskey(map_dict, vref) || error(\"Variable $vref not used in the optimizer model.\")\n    return map_dict[vref]\nend\n\nfunction InfiniteOpt.optimizer_model_expression(expr::JuMP.AbstractJuMPScalar,\n                                                key::Val{DetermKey})\n    model = optimizer_model(JuMP.owner_model(vref))\n    return _make_expression(model, expr)\nend\n\nfunction InfiniteOpt.optimizer_model_constraint(cref::InfOptConstraintRef,\n                                                key::Val{DetermKey})\n    model = optimizer_model(JuMP.owner_model(cref))\n    map_dict = deterministic_data(model).infconstr_to_detconstr\n    haskey(map_dict, cref) || error(\"Constraint $cref not used in the optimizer model.\")\n    return map_dict[cref]\nend","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"With these extensions we can now access all the result queries. For example,","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"julia> termination_status(model)\nLOCALLY_SOLVED::TerminationStatusCode = 4\n\njulia> result_count(model)\n1\n\njulia> value.(y)\n2-element Array{Float64,1}:\n 0.0\n 1.224744871391589\n\njulia> optimizer_index(x)\nMathOptInterface.VariableIndex(3)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"note: Note\nIf optimizer_model_variable, optimizer_model_expression,  and/or optimizer_model_constraint cannot be extended due to the nature of the reformulation then please refer to step 10 of the extension steps listed at the beginning of this section.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Furthermore, if appropriate for the given reformulation the following should be extended:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"InfiniteOpt.variable_supports to enable supports on variables)\nInfiniteOpt.expression_supports to enable supports on expressions)\nInfiniteOpt.constraint_supports to enable supports on constraints)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"That's it!","category":"page"},{"location":"extensions/#Wrapper-Packages","page":"Extensions","title":"Wrapper Packages","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"InfiniteOpt provides a convenient modular interface for defining infinite dimensional optimization problems, implementing many tedious JuMP extensions such as facilitating mixed variable expressions. Thus, InfiniteOpt can serve as a base package for specific types of infinite dimensional problems and/or solution techniques. These extension packages can implement any of the extensions shown above and likely will want to introduce wrapper functions and macros to use package specific terminology (e.g., using random variables instead of infinite variables).","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"TODO refer to example packages that do this (e.g., an update of FlexibilityAnalysis.jl)","category":"page"}]
}
