<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li class="is-active"><a class="tocitem" href>Constraints</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Data-Structure"><span>Data Structure</span></a></li><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#Modification"><span>Modification</span></a></li></ul></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../manual/optimize/">Optimization</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constraints</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/constraint.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="constr_docs"><a class="docs-heading-anchor" href="#constr_docs">Constraints</a><a id="constr_docs-1"></a><a class="docs-heading-anchor-permalink" href="#constr_docs" title="Permalink"></a></h1><p>A guide for constraints in <code>InfiniteOpt</code>. See the respective  <a href="../../manual/constraint/#constr_manual">technical manual</a> for more details.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Constraints are a key part of infinite dimensional problems and serve  as a fundamental utility of <code>InfiniteOpt</code>. In particular, <code>InfiniteOpt</code> supports  finite constraints that entail finite variables and/or measures that fully remove any  infinite parameter dependencies (e.g., first stage constraints), infinite  constraints that are enforced over the entire domain of its infinite parameter  dependencies (e.g., path constraints), and restricted constraints which  are enforced over some specified sub-domain of its infinite parameter  dependencies (e.g., boundary conditions). This page will highlight how to  implement these types of constraints in <code>InfiniteOpt</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Nonlinear constraints as defined by <code>JuMP.@NLconstraint</code> are not currently  supported by <code>InfiniteOpt</code>. See <a href="../expression/#Nonlinear-Expressions">Nonlinear Expressions</a> for more  information and possible workarounds. </p></div></div><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Principally, the  <a href="https://jump.dev/JuMP.jl/v0.21.9/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>  macro is used to define constraints. First, let&#39;s setup an infinite model with  variables that we can add constraints to:</p><pre><code class="language-julia-repl hljs">julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @infinite_parameter(model, x[1:2] in [-2, 2]);

julia&gt; @variable(model, ya, Infinite(t, x));

julia&gt; @variable(model, yb, Infinite(t));

julia&gt; @variable(model, z[1:2]);</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike previous versions, <code>InfiniteOpt</code> now supports all of the constraints  offered by <code>JuMP</code>, including vector and semi-definite constraints! Please  see <a href="https://jump.dev/JuMP.jl/v0.21.9/manual/constraints/#Constraints">JuMP&#39;s constraint documentation</a>  for a thorough explanation of the supported types and syntax.</p></div></div><h3 id="Scalar-Constraints"><a class="docs-heading-anchor" href="#Scalar-Constraints">Scalar Constraints</a><a id="Scalar-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Constraints" title="Permalink"></a></h3><p>Scalar constraints use scalar functions of variables. For example, let&#39;s define  the constraint  <span>$||z||^2 + 2y_a(t, x) \leq 0, \ \forall t \in [0, 10], x \in [-2, 2]^2$</span>  using <code>@constraint</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, c1, sum(z[i]^2 for i = 1:2) + 2ya &lt;= 0)
c1 : z[1]² + z[2]² + 2 ya(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ∈ [-2, 2], x[2] ∈ [-2, 2]</code></pre><p>Thus, we added an infinite constraint (which infinite with respect to <code>t</code> and <code>x</code>)  to <code>model</code> and stored the corresponding constraint reference to <code>c1</code>. Note that   this is enforced over the full infinite domains of the infinite parameters <code>t</code>  and <code>x</code> which are implicitly used by <code>c1</code>. For scalar constraints like this one,  the allowed constraint operators are <code>==</code>, <code>&lt;=</code>, <code>≤</code>, <code>&gt;=</code>, and <code>≥</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Linear algebra constraints can also be used when defining constraints  when <code>.</code> is added in front of the constraint operators (e.g., <code>.&lt;=</code>). This  behavior is further explained in  <a href="https://jump.dev/JuMP.jl/v0.21.9/manual/constraints/#Vectorized-constraints"><code>JuMP</code>&#39;s constraint documentation</a>. </p></div></div><p>Similarly, we can define an array of constraints with varied indexes by including  an additional argument before the constraint expression. For example,  let&#39;s define <span>$3z_i - 14 = 0, \ \forall i \in \{1,2\}$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, c2[i = 1:2], 3z[i] - 14 == 0)
2-element Vector{InfOptConstraintRef}:
 c2[1] : 3 z[1] = 14.0
 c2[2] : 3 z[2] = 14.0</code></pre><p>Thus, we added two constraints to <code>model</code> and stored a vector of the corresponding  constraint references to the <code>Julia</code> variable <code>c2</code>. To learn more about building  containers of constraints please see  <a href="https://jump.dev/JuMP.jl/v0.21.9/manual/constraints/#Constraint-containers"><code>JuMP</code>&#39;s constraint container documentation</a>.</p><h3 id="Multi-Dimensional-Constraints"><a class="docs-heading-anchor" href="#Multi-Dimensional-Constraints">Multi-Dimensional Constraints</a><a id="Multi-Dimensional-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Dimensional-Constraints" title="Permalink"></a></h3><p>Building upon <code>JuMP</code> we support a variety of multi-dimensional constraint types.  For example, we can define the vector constraint:</p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; b = [5, 6]
2-element Vector{Int64}:
 5
 6

julia&gt; @constraint(model, A * z - b in MOI.Nonnegatives(2))
[z[1] + 2 z[2] - 5, 3 z[1] + 4 z[2] - 6] ∈ MathOptInterface.Nonnegatives(2)</code></pre><p>See <a href="https://jump.dev/JuMP.jl/v0.21.9/manual/constraints/"><code>JuMP</code>&#39;s constraint documentation</a>  for a thorough tutorial on the accepted syntax and constraint types.</p><h3 id="Restricted-Constraints"><a class="docs-heading-anchor" href="#Restricted-Constraints">Restricted Constraints</a><a id="Restricted-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Restricted-Constraints" title="Permalink"></a></h3><p>Restricted constraints entail an infinite domain (determined by the infinite  parameters they explicitly/implicitly depend on) that is restricted to a certain  sub-domain. Such constraints are common for enforcing initial/boundary conditions  and for enforcing path constraints over a certain sub-domain.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Previous versions of <code>InfiniteOpt</code> referred to restricted constraints as  &quot;bounded constraints&quot; and used <code>@BDconstraint</code> to define them. This has been  deprecated in favor of the more intuitive domain restricted nomenclature.</p><pre><code class="language-julia hljs"># Old syntax
@BDconstraint(model, name_expr(restricts...), constr_expr)

# New syntax
@constraint(model, name_expr, constr_expr, DomainRestrictions(restricts...))</code></pre></div></div><p>These types of constraints are defined adding <a href="../../manual/constraint/#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a>. For  example, let&#39;s add the initial condition <span>$y_b(0) = 0$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, initial, yb == 0, DomainRestrictions(t =&gt; 0))
initial : yb(t) = 0.0, ∀ t = 0</code></pre><p>Thus, we have added a constraint to <code>model</code> defined over the sub-domain <span>$t = 0$</span>  in accordance with the initial condition.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Boundary conditions can often be more efficiently defined using  <a href="../variable/#Restricted-Variables">Restricted Variables</a>. For example, the above initial condition  can be expressed:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, yb(0) == 0)
yb(0) = 0.0</code></pre></div></div><p>More complex sub-domains can be specified by simply adding more restrictions. To  illustrate this, let&#39;s define the constraint  <span>$2y_b^2(t, x) + z_1 \geq 3, \ \forall t = 0, \ x \in [-1, 1]^2$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, 2ya^2 + z[1] &gt;= 3, DomainRestrictions(t =&gt; 0, x =&gt; [-1, 1]))
2 ya(t, x)² + z[1] ≥ 3.0, ∀ t = 0, x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]</code></pre><p>Now we have added constraints to our model and it is ready to be solved!</p><h2 id="Data-Structure"><a class="docs-heading-anchor" href="#Data-Structure">Data Structure</a><a id="Data-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structure" title="Permalink"></a></h2><p>Here we detail the data structures used to store constraints in <code>InfiniteOpt</code>.  In general, constraints in <code>JuMP</code> are of the form: <code>function in set</code> where  <code>function</code> corresponds to a <code>JuMP</code> expression and <code>set</code> corresponds to a <code>MOI</code>  set. This leads to the following data structures:</p><table><tr><th style="text-align: center">Constraint Type</th><th style="text-align: center">Function Type</th><th style="text-align: center">Set Type</th></tr><tr><td style="text-align: center">Scalar</td><td style="text-align: center"><code>JuMP.AbstractJuMPScalar</code></td><td style="text-align: center"><a href="https://jump.dev/MathOptInterface.jl/v0.9.22/reference/standard_form/#MathOptInterface.AbstractScalarSet"><code>MOI.AbstractScalarSet</code></a></td></tr><tr><td style="text-align: center">Vector</td><td style="text-align: center"><code>Vector{&lt;:JuMP.AbstractJuMPScalar}</code></td><td style="text-align: center"><a href="https://jump.dev/MathOptInterface.jl/v0.9.22/reference/standard_form/#MathOptInterface.AbstractVectorSet"><code>MOI.AbstractVectorSet</code></a></td></tr><tr><td style="text-align: center">Matrix</td><td style="text-align: center"><code>Matrix{&lt;:JuMP.AbstractJuMPScalar}</code></td><td style="text-align: center"><code>MOI.AbstractVectorSet</code> <a href="https://jump.dev/MathOptInterface.jl/v0.9.22/reference/standard_form/#Matrix-sets">via vectorization</a></td></tr></table><p>The above combos are then stored in  <a href="https://jump.dev/JuMP.jl/v0.21.9/reference/constraints/#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a>s  and <a href="https://jump.dev/JuMP.jl/v0.21.9/reference/constraints/#JuMP.VectorConstraint">`JuMP.VectorConstraint</a>s. </p><p>Restricted constraints are built upon this data structure where the underlying  constraint is created in the same manner. Then the specified  <a href="../../manual/constraint/#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> are added by creating a  <a href="../../manual/constraint/#InfiniteOpt.DomainRestrictedConstraint"><code>DomainRestrictedConstraint</code></a> which stores the <code>JuMP.AbstractConstraint</code>  and the restrictions.</p><p>These constraint objects are what store constraints in <code>InfiniteModel</code>s. And  these are pointed to by <a href="../../manual/constraint/#InfiniteOpt.InfOptConstraintRef"><code>InfOptConstraintRef</code></a>s.</p><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><p>In this section, we describe the ins and outs of defining constraints. Note that  this process is analogous to the manner in which variables are defined and added  to the model.</p><h3 id="Manual-Definition"><a class="docs-heading-anchor" href="#Manual-Definition">Manual Definition</a><a id="Manual-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Definition" title="Permalink"></a></h3><p>Defining a constraint principally involves the following steps:</p><ul><li>Define the constraint information (i.e., function, set, and domain restrictions)</li><li>Construct a concrete subtype of <code>JuMP.AbstractConstraint</code> to store the  constraint information</li><li>Add the <code>AbstractConstraint</code> object to an <code>InfiniteModel</code> and assign a name</li><li>Create an <a href="../../manual/constraint/#InfiniteOpt.InfOptConstraintRef"><code>InfOptConstraintRef</code></a> that points to the constraint object  stored in the model.</li></ul><p>The constraint objects are specified via <code>JuMP.build_constraint</code> which requires  that the user provides a function, set, and optionally include domain  restrictions. For example, let&#39;s build a scalar constraint  <span>$3y_a(t, x) - y_b^2(t) \leq 0, \ \forall t \in [0, 10], x \in [-2, 2]^2$</span> over  its full infinite domain (i.e., have no <code>DomainRestrictions</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; constr = build_constraint(error, 3ya - yb^2, MOI.LessThan(0.0));</code></pre><p>Now the built constraint object can be added to the infinite model via  <a href="../../manual/constraint/#JuMP.add_constraint-Tuple{InfiniteModel, AbstractConstraint, String}"><code>add_constraint</code></a>. Let&#39;s do so with our example and assign it the name of  <code>c3</code> (note that adding a name is optional):</p><pre><code class="language-julia-repl hljs">julia&gt; cref = add_constraint(model, constr, &quot;c3&quot;)
c3 : -yb(t)² + 3 ya(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ∈ [-2, 2], x[2] ∈ [-2, 2]</code></pre><p>Thus, we have made our constraint and added it <code>model</code> and now have a constraint  reference <code>cref</code> that we can use to access it.</p><p>The <a href="https://jump.dev/JuMP.jl/v0.21.9/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>  and <a href="https://jump.dev/JuMP.jl/v0.21.9/reference/constraints/#JuMP.@SDconstraint"><code>@SDconstraint</code></a>  macros automate the above steps.</p><h3 id="Macro-Definition"><a class="docs-heading-anchor" href="#Macro-Definition">Macro Definition</a><a id="Macro-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-Definition" title="Permalink"></a></h3><p>As mentioned above in the Basic Usage section, the  <a href="https://jump.dev/JuMP.jl/v0.21.9/reference/constraints/#JuMP.@constraint"><code>@constraint</code></a>  macro should be used to define constraints with the syntax:  <code>@constraint(model::InfiniteModel, [container/name_expr], constr_expr, [rs::DomainRestrictions])</code>.</p><p>The second argument is optional and is used to assign a name and/or define  indexing variables to be used in the constraint expr. When a name is provided it  is registered and cannot be used again for another constraint or variable name.  The indexing expression can be used to produce an array of constraints as shown  below (notice this is equivalent to looping over individual <code>@constraint</code> calls):</p><pre><code class="language-julia-repl hljs">julia&gt; crefs = @constraint(model, [i = 1:2], 2z[i] - yb == 0)
2-element Vector{InfOptConstraintRef}:
 2 z[1] - yb(t) = 0.0, ∀ t ∈ [0, 10]
 2 z[2] - yb(t) = 0.0, ∀ t ∈ [0, 10]

julia&gt; crefs = Vector{InfOptConstraintRef}(undef, 2);

julia&gt; for i = 1:2
           crefs[i] = @constraint(model, 2z[i] - yb == 0)
       end

julia&gt; crefs
2-element Vector{InfOptConstraintRef}:
 2 z[1] - yb(t) = 0.0, ∀ t ∈ [0, 10]
 2 z[2] - yb(t) = 0.0, ∀ t ∈ [0, 10]</code></pre><p>Please refer to  <a href="https://jump.dev/JuMP.jl/v0.21.9/manual/constraints/#Constraint-containers"><code>JuMP</code>&#39;s constraint container documentation</a>  for a thorough tutorial on creating containers of constraints.</p><p>Any constraint type supported by <code>JuMP</code> can be specified in the <code>constr_expr</code>  argument. This includes a wealth of constraint types including:</p><ul><li>Variable constraints</li><li>Scalar constraints</li><li>Vector constraints</li><li>Conic constraints </li><li>Indicator constraints</li><li>Semi-definite constraints</li></ul><p>For example, we could define the following semi-definite constraint using  <code>@SDconstraint</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @SDconstraint(model, [yb 2yb; 3yb 4yb] &gt;= ones(2, 2))
[yb(t) - 1    2 yb(t) - 1;
 3 yb(t) - 1  4 yb(t) - 1] ∈ PSDCone(), ∀ t ∈ [0, 10]</code></pre><p>See <a href="https://jump.dev/JuMP.jl/v0.21.9/manual/constraints/"><code>JuMP</code>&#39;s constraint documentation</a>  for a thorough tutorial on the accepted syntax and constraint types.</p><p>Finally, restrictions on the inherent infinite domain of a constraint can be  specified via <a href="../../manual/constraint/#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> with the <code>rs</code> argument. The accepted  syntax is <code>DomainRestrictions(restricts...)</code> where each argument of <code>restricts</code>  can be any of the following forms:</p><ul><li><code>pref =&gt; value</code></li><li><code>pref =&gt; [lb, ub]</code></li><li><code>pref =&gt; IntervalDomain(lb, ub)</code></li><li><code>prefs =&gt; value</code></li><li><code>prefs =&gt; [lb, ub]</code></li><li><code>prefs =&gt; IntervalDomain(lb, ub)</code>.</li></ul><p>Note that <code>pref</code> and <code>prefs</code> must correspond to infinite parameters.</p><p>For example, we can define the constraint <span>$y_a^2(t, x) + z_i \leq 1$</span> and  restrict the infinite domain of <span>$x_i$</span> to be <span>$[0, 1]$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, [i = 1:2], ya^2 + z[i] &lt;= 1, DomainRestrictions(x[i] =&gt; [0, 1]))
2-element Vector{InfOptConstraintRef}:
 ya(t, x)² + z[1] ≤ 1.0, ∀ t ∈ [0, 10], x[1] ∈ [0, 1], x[2] ∈ [-2, 2]
 ya(t, x)² + z[2] ≤ 1.0, ∀ t ∈ [0, 10], x[1] ∈ [-2, 2], x[2] ∈ [0, 1]</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Where possible, using <a href="../variable/#Restricted-Variables">Restricted Variables</a> will tend to be more  performant than using <code>DomainRestrictions</code> instead.</p></div></div><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><p>In this section, we describe a variety of methods to extract constraint information.</p><h3 id="Basic"><a class="docs-heading-anchor" href="#Basic">Basic</a><a id="Basic-1"></a><a class="docs-heading-anchor-permalink" href="#Basic" title="Permalink"></a></h3><p>A number of constraint properties can be extracted via constraint references.  Principally, the validity, name, model, index, and constraint object can be queried  via <a href="../../manual/constraint/#JuMP.is_valid-Tuple{InfiniteModel, InfOptConstraintRef}"><code>is_valid</code></a>,  <a href="../../manual/constraint/#JuMP.name-Tuple{InfOptConstraintRef}"><code>name</code></a>,  <a href="../../manual/constraint/#JuMP.owner_model-Tuple{InfOptConstraintRef}"><code>owner_model</code></a>,  <a href="../../manual/constraint/#JuMP.index-Tuple{InfOptConstraintRef}"><code>index</code></a>,  and <a href="../../manual/constraint/#JuMP.constraint_object-Tuple{InfOptConstraintRef}"><code>constraint_object</code></a>, respectively. These methods all constitute   extensions of <code>JuMP</code> methods and follow exactly the same behavior. Let&#39;s try  them out with the following example:</p><pre><code class="language-julia-repl hljs">julia&gt; is_valid(model, c1) # check if contained in model
true

julia&gt; name(c1) # get the name
&quot;c1&quot;

julia&gt; m = owner_model(c1); # get the model it is added to

julia&gt; index(c1) # get the constraint&#39;s index
InfOptConstraintIndex(1)

julia&gt; constr = constraint_object(c1); # get the raw constraint datatype</code></pre><p>Also, <a href="../../manual/constraint/#JuMP.constraint_by_name-Tuple{InfiniteModel, String}"><code>constraint_by_name</code></a> can be used to retrieve a constraint reference  if only the name is known and its name is unique. For example, let&#39;s extract the  reference for <code>&quot;c1&quot;</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; cref = constraint_by_name(model, &quot;c1&quot;)
c1 : z[1]² + z[2]² + 2 ya(t, x) ≤ 0.0, ∀ t ∈ [0, 10], x[1] ∈ [-2, 2], x[2] ∈ [-2, 2]</code></pre><h3 id="Domain-Restrictions"><a class="docs-heading-anchor" href="#Domain-Restrictions">Domain Restrictions</a><a id="Domain-Restrictions-1"></a><a class="docs-heading-anchor-permalink" href="#Domain-Restrictions" title="Permalink"></a></h3><p>As explained above, restricted constraints serve as a key capability of  <code>InfiniteOpt</code>. Information about domain restrictions can be obtained via  <a href="../../manual/constraint/#InfiniteOpt.has_domain_restrictions"><code>has_domain_restrictions</code></a> and <a href="../../manual/constraint/#InfiniteOpt.domain_restrictions"><code>domain_restrictions</code></a> which indicate  if a constraint is restricted and what its <a href="../../manual/constraint/#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> are,  respectively. These are exemplified below:</p><pre><code class="language-julia-repl hljs">julia&gt; has_domain_restrictions(c1) # check if constraint is bounded
false

julia&gt; has_domain_restrictions(initial)
true

julia&gt; domain_restrictions(initial)
Subdomain restrictions (1): t = 0</code></pre><h3 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h3><p>Constraints can be defined in a number of ways symbolically that differ from  how it is actually stored in the model. This principally occurs since like terms  and constants are combined together where possible with the variable terms on the  left hand side and the constant on the right hand side. For instance, the  constraint <span>$2y_b(t) + 3y_b(t) - 2 \leq 1 + z_1$</span> would be normalized   <span>$5y_b(t) - z_1 \leq 3$</span>. In accordance with this behavior,   <a href="../../manual/constraint/#JuMP.normalized_rhs-Tuple{InfOptConstraintRef}"><code>normalized_rhs</code></a> and <a href="../../manual/constraint/#JuMP.normalized_coefficient-Tuple{InfOptConstraintRef, GeneralVariableRef}"><code>normalized_coefficient</code></a>  can be used to query the normalized right hand side and the coefficient of a  particular variable reference, respectively. Let&#39;s employ the above example to  illustrate this:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, constr, 2yb + 3yb - 2 &lt;= 1 + z[1])
constr : 5 yb(t) - z[1] ≤ 3.0, ∀ t ∈ [0, 10]

julia&gt; normalized_rhs(constr)
3.0

julia&gt; normalized_coefficient(constr, yb)
5.0</code></pre><p>There also exist a number of methods for querying an infinite model about what  constraints it contains.  <a href="../../manual/constraint/#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>list_of_constraint_types</code></a> can be used query what types of constraints   have been added to a model. This is provided as a list of tuples where the first  element is the expression type and the second element is the set type (recall  that constraints are stored in the form <code>func-in-set</code>). Thus, for our current  model we obtain:</p><pre><code class="language-julia-repl hljs">julia&gt; list_of_constraint_types(model)
4-element Vector{Tuple{DataType,DataType}}:
 (GenericQuadExpr{Float64, GeneralVariableRef}, MathOptInterface.LessThan{Float64})
 (GenericQuadExpr{Float64, GeneralVariableRef}, MathOptInterface.GreaterThan{Float64})
 (GenericAffExpr{Float64, GeneralVariableRef}, MathOptInterface.LessThan{Float64})
 (GenericAffExpr{Float64, GeneralVariableRef}, MathOptInterface.EqualTo{Float64})</code></pre><p>This information is useful when used in combination with the  <a href="../../manual/constraint/#JuMP.num_constraints-Tuple{InfiniteModel, Any, Any}"><code>num_constraints</code></a> and <a href="../../manual/constraint/#JuMP.all_constraints-Tuple{InfiniteModel, Any, Any}"><code>all_constraints</code></a> methods which can take  the expression type and/or the set type as inputs. Here <code>num_constraints</code>  provides the number of constraints that match a certain type  and <code>all_constraints</code>  returns a list of constraint references matching the criteria provided. These have  been extended beyond <code>JuMP</code> functionality such additional methods have been  provided for the cases in which one wants to query solely off of set or off  expression type. Let&#39;s illustrate this with <code>num_constraints</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; num_constraints(model) # total number of constraints
16

julia&gt; num_constraints(model, GenericQuadExpr{Float64, GeneralVariableRef})
5

julia&gt; num_constraints(model, MOI.LessThan{Float64})
5

julia&gt; num_constraints(model, GenericQuadExpr{Float64, GeneralVariableRef},
                       MOI.LessThan{Float64})
4                   </code></pre><h2 id="Modification"><a class="docs-heading-anchor" href="#Modification">Modification</a><a id="Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Modification" title="Permalink"></a></h2><p>In this section, we highlight a number of methods that can be used to modify  existing constraints.</p><h3 id="Deletion"><a class="docs-heading-anchor" href="#Deletion">Deletion</a><a id="Deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Deletion" title="Permalink"></a></h3><p>All constraints in <code>InfiniteOpt</code> can be removed in like manner to typical <code>JuMP</code>  constraints with the appropriate extension of  <a href="../../manual/constraint/#JuMP.delete-Tuple{InfiniteModel, InfOptConstraintRef}"><code>delete</code></a>. This will  remove the corresponding constraint object from the model. However, please note  any registered names will remain registered in the infinite model. This means  that a constraint with a registered name cannot be repeatedly added and removed  using the same name. To exemplify this, let&#39;s delete the constraint <code>c1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; delete(model, c1)</code></pre><h3 id="General-2"><a class="docs-heading-anchor" href="#General-2">General</a><a class="docs-heading-anchor-permalink" href="#General-2" title="Permalink"></a></h3><p>There also are a number of ways to modify information and characteristics of  constraints. First, <a href="../../manual/constraint/#JuMP.set_name-Tuple{InfOptConstraintRef, String}"><code>set_name</code></a>  can be used to specify a new name for a particular constraint. For instance,  let&#39;s update the name of <code>initial</code> to <code>&quot;init_cond&quot;</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; set_name(initial, &quot;init_cond&quot;)

julia&gt; initial
init_cond : yb(t) = 0.0, ∀ t = 0</code></pre><p>We can also update the normalized right hand side constant value or normalized  left hand side variable coefficient value using  <a href="../../manual/constraint/#JuMP.set_normalized_rhs-Tuple{InfOptConstraintRef, Real}"><code>set_normalized_rhs</code></a> and <a href="../../manual/constraint/#JuMP.set_normalized_coefficient-Tuple{InfOptConstraintRef, GeneralVariableRef, Real}"><code>set_normalized_coefficient</code></a>,  respectively. Let&#39;s again consider the constraint <span>$5y_b(t) - z_1 \leq 3$</span> as an  example. Let&#39;s change the constant term to -1 and the <code>y_b(t)</code> coefficient to 2.5:</p><pre><code class="language-julia-repl hljs">julia&gt; set_normalized_rhs(constr, -1)

julia&gt; set_normalized_coefficient(constr, yb, 2.5)

julia&gt; constr
constr : 2.5 yb(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 10]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In some cases, it may be more convenient to dynamically modify coefficients  and other values via the use of finite parameters. This provides an avenue  to update parameters without having to be concerned about the normalized form.  For more information, see the <a href="../finite_parameter/#finite_param_docs">Finite Parameters</a> page. </p></div></div><h3 id="Domain-Restrictions-2"><a class="docs-heading-anchor" href="#Domain-Restrictions-2">Domain Restrictions</a><a class="docs-heading-anchor-permalink" href="#Domain-Restrictions-2" title="Permalink"></a></h3><p>Domain Restrictions can be added to, modified, or removed from any constraint in  <code>InfiniteOpt</code>. Principally, this is accomplished via   <a href="../../manual/constraint/#InfiniteOpt.add_domain_restrictions"><code>add_domain_restrictions</code></a>, <a href="../../manual/constraint/#InfiniteOpt.set_domain_restrictions"><code>set_domain_restrictions</code></a>,  and <a href="../../manual/constraint/#InfiniteOpt.delete_domain_restrictions"><code>delete_domain_restrictions</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Previous versions of <code>InfiniteOpt</code> used <code>@[set/add]_parameter_bounds</code> which  have been deprecated in favor of using <a href="../../manual/constraint/#InfiniteOpt.DomainRestrictions"><code>DomainRestrictions</code></a> with the  the methods described used in this section.</p></div></div><p>First, domain restrictions can be added to a constraint via  <a href="../../manual/constraint/#InfiniteOpt.add_domain_restrictions"><code>add_domain_restrictions</code></a>. For example, let&#39;s add the bound  <span>$t \in [0, 1]$</span> to <code>constr</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; add_domain_restrictions(constr, DomainRestrictions(t =&gt; [0, 1]))

julia&gt; constr
constr : 2.5 yb(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 1]</code></pre><p>In similar manner, <a href="../../manual/constraint/#InfiniteOpt.set_domain_restrictions"><code>set_domain_restrictions</code></a> can be employed to specify  what restrictions a constraint has (overwriting any existing ones if forced). It   follows the same syntax, so let&#39;s use it to change the bounds on <code>t</code> to <span>$t = 0$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; set_domain_restrictions(constr, DomainRestrictions(t =&gt; 0), force = true)

julia&gt; constr
constr : 2.5 yb(t) - z[1] ≤ -1.0, ∀ t = 0</code></pre><p>Finally, constraint restrictions can be deleted via  <a href="../../manual/constraint/#InfiniteOpt.delete_domain_restrictions"><code>delete_domain_restrictions</code></a>. Now let&#39;s delete the domain restrictions  associated with our example:</p><pre><code class="language-julia-repl hljs">julia&gt; delete_domain_restrictions(constr)

julia&gt; constr
constr : 2.5 yb(t) - z[1] ≤ -1.0, ∀ t ∈ [0, 10]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../objective/">« Objectives</a><a class="docs-footer-nextpage" href="../transcribe/">Model Transcription »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Monday 2 August 2021 21:04">Monday 2 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
