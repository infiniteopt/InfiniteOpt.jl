<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Transcription · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start Guide</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li class="is-active"><a class="tocitem" href>Model Transcription</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Transcription-Theory"><span>Transcription Theory</span></a></li><li><a class="tocitem" href="#TranscriptionOpt"><span>TranscriptionOpt</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Model Transcription</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Transcription</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/transcribe.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="transcription_docs"><a class="docs-heading-anchor" href="#transcription_docs">Model Transcription</a><a id="transcription_docs-1"></a><a class="docs-heading-anchor-permalink" href="#transcription_docs" title="Permalink"></a></h1><p>A guide and manual for transcribing infinite models using <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>All infinite models need to be reformulated in such a way that they can be solved using traditional optimization methods. Typically, this involves discretization of the infinite domain via particular parameter support points. By default, <code>InfiniteOpt</code> employs this methodology via the use of transcription models (which comprise the <code>optimizer_model</code> as discussed in the <a href="../model/#infinite_model_docs">Infinite Models</a> section). <code>InfiniteOpt</code> is built modularly to readily accept other user defined techniques and this is discussed in further detail on the <a href="../../extensions/#Extensions">Extensions</a> page. This page will detail transcription models based in <code>InfiniteOpt.TranscriptionOpt</code> which provide the default transcription (reformulation) capabilities of <code>InfiniteOpt</code>.</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Most users will not need to employ the capabilities of <code>TranscriptionOpt</code> directly since they are employed implicitly with the call of <a href="../optimize/#JuMP.optimize!-Tuple{InfiniteModel}"><code>optimize!</code></a> on an infinite model. This occurs since <code>TranscriptionModel</code>s are the default optimizer model type that is employed.</p><p>However, some users may wish to use <code>TranscriptionOpt</code> to extract a fully discretized/transcribed version of an infinite model that is conveniently output as a typical <code>JuMP</code> model and can then be treated as such. This is principally accomplished via <a href="../optimize/#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a>. To illustrate how this is done,  let&#39;s first define a basic infinite model with a simple support structure for the sake of example:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP

julia&gt; inf_model = InfiniteModel();

julia&gt; @infinite_parameter(inf_model, t in [0, 10], supports = [0, 5, 10])
t

julia&gt; @infinite_variable(inf_model, g(t) &gt;= 0)
g(t)

julia&gt; @hold_variable(inf_model, z, Bin)
z

julia&gt; @objective(inf_model, Min, 2z + support_sum(g, t))
2 z + support_sum{t}[g(t)]

julia&gt; @BDconstraint(inf_model, initial(t == 0), g == 1)
initial : g(t) = 1.0, ∀ t = 0

julia&gt; @constraint(inf_model, constr, g^2 - z &lt;= 42)
constr : g(t)² - z ≤ 42.0, ∀ t ∈ [0, 10]

julia&gt; print(inf_model)
Min 2 z + support_sum{t}[g(t)]
Subject to
 g(t) ≥ 0.0, ∀ t ∈ [0, 10]
 z binary
 initial : g(t) = 1.0, ∀ t = 0
 constr : g(t)² - z ≤ 42.0, ∀ t ∈ [0, 10]</code></pre><p>Now we can make <code>JuMP</code> model containing the transcribed version of <code>inf_model</code> via <a href="../optimize/#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> and then extract it via <a href="../optimize/#InfiniteOpt.optimizer_model"><code>optimizer_model</code></a>:</p><pre><code class="language-julia-repl">julia&gt; build_optimizer_model!(inf_model)

julia&gt; trans_model = optimizer_model(inf_model)
A JuMP Model
Minimization problem with:
Variables: 4
Objective function type: GenericAffExpr{Float64,VariableRef}
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
`GenericQuadExpr{Float64,VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 3 constraints
`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints
`VariableRef`-in-`MathOptInterface.ZeroOne`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; print(trans_model)
Min 2 z + g(support: 1) + g(support: 2) + g(support: 3)
Subject to
 initial(support: 1) : g(support: 1) = 1.0
 constr(support: 1) : g(support: 1)² - z ≤ 42.0
 constr(support: 2) : g(support: 2)² - z ≤ 42.0
 constr(support: 3) : g(support: 3)² - z ≤ 42.0
 g(support: 1) ≥ 0.0
 g(support: 2) ≥ 0.0
 g(support: 3) ≥ 0.0
 z binary</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Previous versions of InfiniteOpt, employed a <code>TranscriptionModel(model::InfiniteModel)</code>  constructor to build transcription models independently of the optimizer model.  This has functionality has been removed in favor of internal optimizer model  based builds for efficiency reasons and to properly manage MOI optimizer  attributes.</p></div></div><p>Thus, we have a transcribed <code>JuMP</code> model. To be precise this is actually a <code>TranscriptionModel</code> which is a <code>JuMP.Model</code> with some extra data stored in the <code>ext</code> field that retains the mapping between the transcribed variables/constraints  and their infinite counterparts. Notice, that multiple finite variables have been introduced to discretize <code>g(t)</code> at supports 1, 2, and 3 which correspond to 0, 5, and 10 as can be queried by <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; supports(g)
3-element Array{Tuple,1}:
 (0.0,)
 (5.0,)
 (10.0,)</code></pre><p>Also, notice how the constraints are transcribed in accordance with these supports except the initial condition which naturally is only invoked for the first support point. Furthermore, the transcription variable(s) of any variable associated with the infinite model can be determined via <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a>:</p><pre><code class="language-julia-repl">julia&gt; transcription_variable(g)
3-element Array{VariableRef,1}:
 g(support: 1)
 g(support: 2)
 g(support: 3)

julia&gt; transcription_variable(trans_model, z)
z</code></pre><p>Similarly, the transcription constraints associated with infinite model constraints can be queried via <a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model,InfOptConstraintRef}"><code>transcription_constraint</code></a> and the associated supports and infinite parameters can be found via <code>supports</code> and <code>parameter_refs</code>:</p><pre><code class="language-julia-repl">julia&gt; transcription_constraint(initial)
initial(support: 1) : g(support: 1) = 1.0

julia&gt; transcription_constraint(constr)
3-element Array{ConstraintRef,1}:
 constr(support: 1) : g(support: 1)² - z ≤ 42.0
 constr(support: 2) : g(support: 2)² - z ≤ 42.0
 constr(support: 3) : g(support: 3)² - z ≤ 42.0

julia&gt; supports(constr)
3-element Array{Tuple,1}:
 (0.0,)
 (5.0,)
 (10.0,)

julia&gt; parameter_refs(constr)
(t,)</code></pre><p>Note the parameter reference tuple corresponds to the support tuples.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Method that query the transcription surrogates (e.g., <code>transcription_variable</code>)  and the respective supports via <code>supports</code> also accept the keyword argument  <code>label</code> to specify which that transcription objects are desired in accordance  to the support labels that are inherited from and/or are equal to <code>label</code>. By  default, this will return any supports that are public (i.e., will hide anything  solely associated with internal supports). The full query response can always  be obtained via <code>label = All</code>.</p></div></div><p>Now we have a transcribed <code>JuMP</code> model that can be optimized via traditional <code>JuMP</code> methods whose variables and constraints can be accessed using the methods mentioned above.</p><h2 id="Transcription-Theory"><a class="docs-heading-anchor" href="#Transcription-Theory">Transcription Theory</a><a id="Transcription-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Transcription-Theory" title="Permalink"></a></h2><p>A given infinite dimensional optimization problem is parameterized according to infinite parameters following our abstraction. In general, most solution strategies transcribe the problem according to certain finite parameter values (supports) and thus represent the problem in terms of these supports (e.g., using discrete time points in dynamic optimization). This methodology can be generalized into the following steps:</p><ol><li>define supports for each infinite parameter if not already defined,</li><li>add any additional support needed for derivative evaluation,</li><li>expand any measures according to their underlying numerical representation</li></ol><p>using transcribed infinite variables as appropriate,</p><ol><li>replace any remaining infinite variables/derivatives with transcribed variables supported</li></ol><p>over each unique combination of the underlying parameter supports,</p><ol><li>replace any remaining infinite constraints with transcribed ones supported over</li></ol><p>all the unique support combinations stemming from the infinite parameters they    depend on,</p><ol><li>and add on the transcripted versions of the auxiliary derivative evaluation </li></ol><p>equations. </p><p>For example, let&#39;s consider a space-time optimization problem of the form:</p><div>\[\begin{aligned}
	&amp;&amp;\min_{y(t), g(t, x)} &amp;&amp;&amp; \int_0^{10} y^2(t) dt \\
	&amp;&amp;\text{s.t.} &amp;&amp;&amp; y(0) = 1 \\
	&amp;&amp;&amp;&amp;&amp; \int_{x \in [-1, 1]^2} \frac{\partial g(t, x)}{\partial t} dx = 42, &amp;&amp; \forall t \in [0, 10] \\
  &amp;&amp;&amp;&amp;&amp; 3g(t, x) + 2y^2(t) \leq 2, &amp;&amp; \forall t \in T, \ x \in [-1, 1]^2. \\
\end{aligned}\]</div><p>Thus, we have an optimization problem whose decision space is infinite with respect to time <span>$t$</span> and position <span>$x$</span>. Now let&#39;s transcript it following the above steps. First, we need to specify the infinite parameter supports and for simplicity let&#39;s choose the following sparse sets:</p><ul><li><span>$t \in \{0, 10\}$</span></li><li><span>$x \in \{[-1, -1]^T, [-1, 1]^T, [1, -1]^T, [1, 1]^T\}$</span>.</li></ul><p>To handle the derivative <span>$\frac{\partial g(t, x)}{\partial t}$</span>, we&#39;ll use   backward finite difference so no additional supports will need to be added.</p><p>Now we expand the two integrals (measures) via a finite approximation using only the above supports and term coefficients of 1 (note this is not numerically correct but is done for conciseness in example). Doing this, we obtain the form:</p><div>\[\begin{aligned}
	&amp;&amp;\min_{y(t), g(t, x)} &amp;&amp;&amp; y^2(0) + y^2(10) \\
	&amp;&amp;\text{s.t.} &amp;&amp;&amp; y(0) = 1 \\
  &amp;&amp;&amp;&amp;&amp; g(0, x) = 0 \\
	&amp;&amp;&amp;&amp;&amp; \frac{\partial g(t, [-1, -1])}{\partial t} + \frac{\partial g(t, [-1, 1])}{\partial t} + \frac{\partial g(t, [1, -1])}{\partial t} + \frac{\partial g(t, [1, 1])}{\partial t} = 42, &amp;&amp; \forall t \in [0, 10] \\
  &amp;&amp;&amp;&amp;&amp; 3g(t, x) + 2y^2(t) \leq 2, &amp;&amp; \forall t \in T, \ x \in [-1, 1]^2. \\
\end{aligned}\]</div><p>Notice that the infinite variable <span>$y(t)$</span> in the objective measure has been replaced with finite transcribed variables <span>$y(0)$</span> and <span>$y(10)$</span>. Also, the infinite derivative <span>$\frac{\partial g(t, x)}{\partial t}$</span> was replaced with  partially transcribed variables in the second constraint in accordance with the  measure over the positional domain <span>$x$</span>.</p><p>Now we need to transcribe the remaining infinite and semi-infinite variables with finite variables and duplicate the remaining infinite constraints accordingly. This means that the second constraint needs to be transcribed over the time domain and the third constraint needs to be transcribed for each unique combination of the time and position supports. Applying this transcription yields:</p><div>\[\begin{aligned}
	&amp;&amp;\min_{y(t), g(t, x)} &amp;&amp;&amp; y^2(0) + y^2(10) \\
	&amp;&amp;\text{s.t.} &amp;&amp;&amp; y(0) = 1 \\
  &amp;&amp;&amp;&amp;&amp; g(0, [-1, -1]) = 0 \\
  &amp;&amp;&amp;&amp;&amp; g(0, [-1, 1]) = 0 \\
  &amp;&amp;&amp;&amp;&amp; g(0, [1, -1]) = 0 \\
  &amp;&amp;&amp;&amp;&amp; g(0, [1, 1]) = 0 \\
	&amp;&amp;&amp;&amp;&amp; \frac{\partial g(0, [-1, -1])}{\partial t} + \frac{\partial g(0, [-1, 1])}{\partial t} + \frac{\partial g(0, [1, -1])}{\partial t} + \frac{\partial g(0, [1, 1])}{\partial t} = 42\\
  &amp;&amp;&amp;&amp;&amp; \frac{\partial g(10, [-1, -1])}{\partial t} + \frac{\partial g(10, [-1, 1])}{\partial t} + \frac{\partial g(10, [1, -1])}{\partial t} + \frac{\partial g(10, [1, 1])}{\partial t} = 42\\
  &amp;&amp;&amp;&amp;&amp; 3g(0, [-1, -1]) + 2y^2(0) \leq 2 \\
  &amp;&amp;&amp;&amp;&amp; 3g(0, [-1, 1]) + 2y^2(0) \leq 2 \\
  &amp;&amp;&amp;&amp;&amp; \vdots \\
  &amp;&amp;&amp;&amp;&amp; 3g(10, [1, 1]) + 2y^2(10) \leq 2.
\end{aligned}\]</div><p>Now that the variables and constraints are are transcripted, all that remains is  to add relations to define the behavior of the transcripted partial derivatives.  We can accomplish this via backward finite difference which will just add one  infinite equation in this case this we only have 2 supports in the time domain  is then transcripted over the spatial domain to yield:</p><div>\[\begin{aligned}
&amp;&amp;&amp; g(10, [-1, -1]) = g(0, [-1, -1]) + 10\frac{\partial g(10, [-1, -1])}{\partial t} \\
&amp;&amp;&amp; g(10, [-1, 1]) = g(0, [-1, 1]) + 10\frac{\partial g(10, [-1, 1])}{\partial t} \\
&amp;&amp;&amp; g(10, [1, -1]) = g(0, [1, -1]) + 10\frac{\partial g(10, [1, -1])}{\partial t} \\
&amp;&amp;&amp; g(10, [1, 1]) = g(0, [1, 1]) + 10\frac{\partial g(10, [1, 1])}{\partial t}
\end{aligned}\]</div><p>Now the problem is fully transcripted (discretized) and can be solved as a standard optimization problem. Note that with realistic measure evaluation schemes more supports might be added to the support sets and these will need to be incorporated when transcribing variables and constraints.</p><p>It is easy to imagine how the above procedure can get quite involved to do manually, but this is precisely what <code>InfiniteOpt</code> automates behind the scenes. Let&#39;s highlight this by repeating the same example using <code>InfiniteOpt</code> (again using the incorrect simple representation for the integrals for conciseness).</p><pre><code class="language-julia">using JuMP, InfiniteOpt

# Initialize model
inf_model = InfiniteModel()

# Define parameters and supports
@infinite_parameter(inf_model, t in [0, 10], supports = [0, 10])
@infinite_parameter(inf_model, x[1:2] in [-1, 1], supports = [-1, 1], independent = true)

# Define variables
@infinite_variable(inf_model, y(t))
@infinite_variable(inf_model, g(t, x))

# Set the objective (using support_sum for the integral given our simple example)
# Note: In real problems integral should be used
@objective(inf_model, Min, support_sum(y^2, t))

# Define the constraints
@BDconstraint(inf_model, t == 0, y == 1)
@BDconstraint(inf_model, t == 0, g == 0)
@constraint(inf_model, support_sum(deriv(g, t), x) == 42) # support_sum for simplicity
@constraint(inf_model, 3g + y^2 &lt;= 2)

# Print the infinite model
print(inf_model)

# output
Min support_sum{t}[y(t)²]
Subject to
 y(t) = 1.0, ∀ t = 0
 g(t, x) = 0.0, ∀ t = 0, x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]
 support_sum{x}[∂/∂t[g(t, x)]] = 42.0, ∀ t ∈ [0, 10]
 y(t)² + 3 g(t, x) ≤ 2.0, ∀ t ∈ [0, 10], x[1] ∈ [-1, 1], x[2] ∈ [-1, 1]</code></pre><p>Thus, we obtain the infinite problem in <code>InfiniteOpt</code>. As previously noted, transcription would be handled automatically behind the scenes when the model is optimized. However, we can directly extract the transcribed version by building a <code>TranscriptionModel</code>:</p><pre><code class="language-julia-repl">julia&gt; build_optimizer_model!(inf_model)

julia&gt; trans_model = optimizer_model(inf_model);

julia&gt; print(trans_model)
Min y(support: 1)² + y(support: 2)²
Subject to
 y(support: 1) = 1.0
 g(support: 1) = 0.0
 g(support: 3) = 0.0
 g(support: 5) = 0.0
 g(support: 7) = 0.0
 ∂/∂t[g(t, x)](support: 1) + ∂/∂t[g(t, x)](support: 3) + ∂/∂t[g(t, x)](support: 5) + ∂/∂t[g(t, x)](support: 7) = 42.0
 ∂/∂t[g(t, x)](support: 2) + ∂/∂t[g(t, x)](support: 4) + ∂/∂t[g(t, x)](support: 6) + ∂/∂t[g(t, x)](support: 8) = 42.0
 g(support: 1) - g(support: 2) + 10 ∂/∂t[g(t, x)](support: 2) = 0.0
 g(support: 3) - g(support: 4) + 10 ∂/∂t[g(t, x)](support: 4) = 0.0
 g(support: 5) - g(support: 6) + 10 ∂/∂t[g(t, x)](support: 6) = 0.0
 g(support: 7) - g(support: 8) + 10 ∂/∂t[g(t, x)](support: 8) = 0.0
 y(support: 1)² + 3 g(support: 1) ≤ 2.0
 y(support: 2)² + 3 g(support: 2) ≤ 2.0
 y(support: 1)² + 3 g(support: 3) ≤ 2.0
 y(support: 2)² + 3 g(support: 4) ≤ 2.0
 y(support: 1)² + 3 g(support: 5) ≤ 2.0
 y(support: 2)² + 3 g(support: 6) ≤ 2.0
 y(support: 1)² + 3 g(support: 7) ≤ 2.0
 y(support: 2)² + 3 g(support: 8) ≤ 2.0</code></pre><p>This precisely matches what we found analytically. Note that the unique support combinations are determined automatically and are represented visually as <code>support: #</code>. The precise support values can be looked up via <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; supports(y)
2-element Array{Tuple,1}:
 (0.0,)
 (10.0,)

julia&gt; supports(g)
8-element Array{Tuple,1}:
 (0.0, [-1.0, -1.0])
 (10.0, [-1.0, -1.0])
 (0.0, [1.0, -1.0])
 (10.0, [1.0, -1.0])
 (0.0, [-1.0, 1.0])
 (10.0, [-1.0, 1.0])
 (0.0, [1.0, 1.0])
 (10.0, [1.0, 1.0])

julia&gt; supports(g, ndarray = true) # format it as an n-dimensional array (t by x[1] by x[2])
2×2×2 Array{Tuple,3}:
[:, :, 1] =
 (0.0, [-1.0, -1.0])   (0.0, [1.0, -1.0])
 (10.0, [-1.0, -1.0])  (10.0, [1.0, -1.0])

[:, :, 2] =
 (0.0, [-1.0, 1.0])   (0.0, [1.0, 1.0])
 (10.0, [-1.0, 1.0])  (10.0, [1.0, 1.0])</code></pre><h2 id="TranscriptionOpt"><a class="docs-heading-anchor" href="#TranscriptionOpt">TranscriptionOpt</a><a id="TranscriptionOpt-1"></a><a class="docs-heading-anchor-permalink" href="#TranscriptionOpt" title="Permalink"></a></h2><p><code>InfiniteOpt.TranscriptionOpt</code> is a sub-module which principally implements <code>TranscriptionModel</code>s and its related access/modification methods. Thus, this section will detail what these are and how they work.</p><h3 id="TranscriptionModels"><a class="docs-heading-anchor" href="#TranscriptionModels">TranscriptionModels</a><a id="TranscriptionModels-1"></a><a class="docs-heading-anchor-permalink" href="#TranscriptionModels" title="Permalink"></a></h3><p>A <code>TranscriptionModel</code> is simply a <code>JuMP.Model</code> whose <code>ext</code> field contains <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>TranscriptionData</code></a> which acts to map the transcribed model back to the original infinite model (e.g., map the variables and constraints). Such models are constructed via a default version of <a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}"><code>build_optimizer_model!</code></a>  which wraps <a href="#InfiniteOpt.TranscriptionOpt.build_transcription_model!"><code>build_transcription_model!</code></a>:</p><pre><code class="language-julia-repl">julia&gt; model1 = TranscriptionModel() # make an empty model
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; build_optimizer_model!(inf_model); 

julia&gt; model2 = optimizer_model(inf_model) # generate from an InfiniteModel
A JuMP Model
Minimization problem with:
Variables: 4
Objective function type: GenericAffExpr{Float64,VariableRef}
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
`GenericQuadExpr{Float64,VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 3 constraints
`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints
`VariableRef`-in-`MathOptInterface.ZeroOne`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre><p>Note that the all the normal <code>JuMP.Model</code> arguments can be used with both constructor when making an empty model and they are simply inherited from those  specified in the <code>InfiniteModel</code>. The call to <code>build_optimizer_model!</code> is the backbone  behind infinite model transcription and is what encapsulates all of the methods to  transcribe measures, variables, derivatives, and constraints. This is also the  method that enables the use of <a href="../optimize/#JuMP.optimize!-Tuple{InfiniteModel}"><code>optimize!</code></a>.</p><h3 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h3><p>In this section we highlight a number of query methods that pertain to  <code>TranscriptionModel</code>s and their mappings. First, if the <code>optimizer_model</code> of an <code>InfiniteModel</code> is a <code>TranscriptionModel</code> it can be extracted via <a href="#InfiniteOpt.TranscriptionOpt.transcription_model"><code>transcription_model</code></a>:</p><pre><code class="language-julia-repl">julia&gt; transcription_model(inf_model)
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre><p>Here we observe that such a model is currently empty and hasn&#39;t been populated yet. Furthermore, we check that a <code>Model</code> is an <code>TranscriptionModel</code> via <a href="#InfiniteOpt.TranscriptionOpt.is_transcription_model"><code>is_transcription_model</code></a>:</p><pre><code class="language-julia-repl">julia&gt; is_transcription_model(optimizer_model(inf_model))
true

julia&gt; is_transcription_model(Model())
false</code></pre><p>We can also extract the raw <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>TranscriptionData</code></a> object from a <code>TranscriptionModel</code> via <a href="#InfiniteOpt.TranscriptionOpt.transcription_data"><code>transcription_data</code></a>.</p><pre><code class="language-julia-repl">julia&gt; transcription_data(trans_model);</code></pre><p>Next we can retrieve the <code>JuMP</code> variable(s) for a particular <code>InfiniteOpt</code> variable via <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a>. For finite variables, this will be a one to one mapping, and for infinite variables a list of supported variables will be returned in the order of the supports. Following the initial example in the basic usage section, this is done:</p><pre><code class="language-julia-repl">julia&gt; build_optimizer_model!(inf_model); trans_model = optimizer_model(inf_model);

julia&gt; transcription_variable(trans_model, g)
3-element Array{VariableRef,1}:
 g(support: 1)
 g(support: 2)
 g(support: 3)

julia&gt; transcription_variable(trans_model, z)
z</code></pre><p>Note that if the <code>TranscriptionModel</code> is stored as the current <code>optimizer_model</code> then the first argument (specifying the <code>TranscriptionModel</code> can be omitted). Thus,  in this case the first argument can be omitted as it was above, but is shown for  completeness.</p><p>Similarly, the parameter supports corresponding to the transcription variables (in the case of transcribed infinite variables) can be queried via <a href="../expression/#InfiniteOpt.supports-Tuple{GeneralVariableRef}"><code>supports</code></a>:</p><pre><code class="language-julia-repl">julia&gt; supports(g)
3-element Array{Tuple,1}:
 (0.0,)
 (5.0,)
 (10.0,)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Note that like <code>supports</code> the <code>transcription_[obj]</code> methods also employ the  <code>label::Type{AbstractSupportLabel} = PublicLabel</code> keyword argument that by  default will return variables/expressions/constraints associated with public  supports. The full set (e.g., ones corresponding to internal collocation nodes)  is obtained via <code>label = All</code>. </li><li>These methods also employ the <code>ndarray::Bool</code> keyword argument that will cause the  output to be formatted as a n-dimensional array where the dimensions  correspond to the infinite parameter dependencies. For example, if we have an  infinite variable <code>y(t, ξ)</code> and we invoke a query method with <code>ndarray = true</code>  then we&#39;ll get a matrix whose dimensions correspond to the supports of <code>t</code> and  <code>ξ</code>, respectively. Also, if <code>ndarray = true</code> then <code>label</code> correspond to the  intersection of supports labels in contrast to its default of invoking the union  of the labels.</li></ol></div></div><p>Likewise, <a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model,InfOptConstraintRef}"><code>transcription_constraint</code></a> and <code>supports</code>(@ref) can be used with constraints to find their transcribed  equivalents in the <code>JuMP</code> model and determine their supports.</p><p>We can also do this with measures and expressions:</p><pre><code class="language-julia-repl">julia&gt; meas = support_sum(g^2, t)
support_sum{t}[g(t)²]

julia&gt; build_optimizer_model!(inf_model)

julia&gt; transcription_variable(meas)
g(support: 1)² + g(support: 2)² + g(support: 3)²

julia&gt; supports(meas)
()

julia&gt; transcription_expression(g^2 + z - 42)
3-element Array{AbstractJuMPScalar,1}:
 g(support: 1)² + z - 42
 g(support: 2)² + z - 42
 g(support: 3)² + z - 42

julia&gt; supports(g^2 + z - 42)
3-element Array{Tuple,1}:
 (0.0,)
 (5.0,)
 (10.0,)

julia&gt; parameter_refs(g^2 + z - 42)
(t,)</code></pre><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.TranscriptionData" href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>InfiniteOpt.TranscriptionOpt.TranscriptionData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TranscriptionData</code></pre><p>A DataType for storing the data mapping an <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteOpt.InfiniteModel</code></a> that has been transcribed to a regular <a href="../../JuMP/#JuMP.Model"><code>JuMP.Model</code></a> that contains the transcribed variables. This is stored in the <code>ext</code> field of a <code>JuMP.Model</code> to make what is called a <code>TranscriptionModel</code> via the <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel"><code>TranscriptionModel</code></a> constructor.</p><p><strong>Fields</strong></p><ul><li><code>infvar_lookup::Dict{InfiniteOpt.GeneralVariableRef, Dict{Vector{Float64}, Int}}</code>:  A lookup table of infinite variable transcriptions via support value.</li><li><code>infvar_mappings::Dict{InfiniteOpt.GeneralVariableRef, Vector{JuMP.VariableRef}}</code>:  Map infinite variables to their transcription variables.</li><li><code>infvar_supports::Dict{InfiniteOpt.GeneralVariableRef, Vector{Tuple}}</code>:  Map infinite variables to their support values.</li><li><code>infvar_support_labels::Dict{InfiniteOpt.GeneralVariableRef, Vector{Set{DataType}}}</code>:   Map the infinite variables to their support labels.</li><li><code>finvar_mappings::Dict{InfiniteOpt.GeneralVariableRef, JuMP.VariableRef}</code>:  Map finite variables to their transcription variables.</li><li><code>reduced_vars::Vector{InfiniteOpt.ReducedVariable{InfiniteOpt.GeneralVariableRef}}</code>:  Store the core reduced variable objects of reduced variables formed on transcription.</li><li><code>last_point_index::Int</code>: The last internal point variable index added.</li><li><code>measure_lookup::Dict{InfiniteOpt.GeneralVariableRef, Dict{Vector{Float64}, Int}}</code>:  A lookup table of measure transcriptions via support value.</li><li><code>measure_mappings::Dict{InfiniteOpt.GeneralVariableRef, Vector{JuMP.AbstractJuMPScalar}}</code>:  Map measures to transcription expressions.</li><li><code>measure_supports::Dict{InfiniteOpt.GeneralVariableRef, Vector{Tuple}}</code>:  Map measures to their supports values (if the transcribed measure is still infinite).</li><li><code>measure_support_labels::Dict{InfiniteOpt.GeneralVariableRef, Vector{Set{DataType}}}</code>:   Map measures to their support labels if they have any.</li><li><code>constr_mappings::Dict{InfiniteOpt.InfOptConstraintRef, Vector{JuMP.ConstraintRef}}</code>:  Map constraints to their transcriptions.</li><li><code>constr_supports::Dict{InfiniteOpt.InfOptConstraintRef, Vector{Tuple}}</code>:  Map constraints to their support values.</li><li><code>constr_support_labels::Dict{InfiniteOpt.InfOptConstraintRef, Vector{Set{DataType}}}</code>:   Map constraints to their support labels.</li><li><code>supports::Tuple</code>: Store the collected parameter supports here.</li><li><code>support_labels::Tuple</code>: Store the collected parameter labels here.</li><li><code>has_internal_supports::Bool</code>: Where any internal supports collected?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL4-L44">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.add_measure_variable-Tuple{Model,PointVariable,Val{:TransData}}"><code>InfiniteOpt.add_measure_variable</code></a></li><li><a href="#InfiniteOpt.add_measure_variable-Tuple{Model,ReducedVariable,Val{:TransData}}"><code>InfiniteOpt.add_measure_variable</code></a></li><li><a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}"><code>InfiniteOpt.build_optimizer_model!</code></a></li><li><a href="#InfiniteOpt.constraint_supports-Tuple{Model,InfOptConstraintRef,Val{:TransData}}"><code>InfiniteOpt.constraint_supports</code></a></li><li><a href="#InfiniteOpt.delete_reduced_variable-Tuple{Model,ReducedVariableRef,Val{:TransData}}"><code>InfiniteOpt.delete_reduced_variable</code></a></li><li><a href="#InfiniteOpt.expression_supports-Tuple{Model,Union{GenericAffExpr, GenericQuadExpr},Val{:TransData}}"><code>InfiniteOpt.expression_supports</code></a></li><li><a href="#InfiniteOpt.internal_reduced_variable-Tuple{ReducedVariableRef,Val{:TransData}}"><code>InfiniteOpt.internal_reduced_variable</code></a></li><li><a href="#InfiniteOpt.optimizer_model_constraint-Tuple{InfOptConstraintRef,Val{:TransData}}"><code>InfiniteOpt.optimizer_model_constraint</code></a></li><li><a href="#InfiniteOpt.optimizer_model_expression-Tuple{Union{GenericAffExpr, GenericQuadExpr},Val{:TransData}}"><code>InfiniteOpt.optimizer_model_expression</code></a></li><li><a href="#InfiniteOpt.optimizer_model_variable-Tuple{GeneralVariableRef,Val{:TransData}}"><code>InfiniteOpt.optimizer_model_variable</code></a></li><li><a href="#InfiniteOpt.variable_supports-Tuple{Model,Union{InfiniteVariableRef, ReducedVariableRef},Val{:TransData}}"><code>InfiniteOpt.variable_supports</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.build_transcription_model!"><code>InfiniteOpt.TranscriptionOpt.build_transcription_model!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.has_internal_supports"><code>InfiniteOpt.TranscriptionOpt.has_internal_supports</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.index_to_labels"><code>InfiniteOpt.TranscriptionOpt.index_to_labels</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.index_to_support"><code>InfiniteOpt.TranscriptionOpt.index_to_support</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.is_transcription_model"><code>InfiniteOpt.TranscriptionOpt.is_transcription_model</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}"><code>InfiniteOpt.TranscriptionOpt.lookup_by_support</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.make_ndarray"><code>InfiniteOpt.TranscriptionOpt.make_ndarray</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.parameter_supports-Tuple{Model}"><code>InfiniteOpt.TranscriptionOpt.parameter_supports</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.set_parameter_supports"><code>InfiniteOpt.TranscriptionOpt.set_parameter_supports</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>InfiniteOpt.TranscriptionOpt.support_index_iterator</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_constraints!"><code>InfiniteOpt.TranscriptionOpt.transcribe_constraints!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!"><code>InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_hold_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_hold_variables!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_measures!"><code>InfiniteOpt.TranscriptionOpt.transcribe_measures!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_objective!"><code>InfiniteOpt.TranscriptionOpt.transcribe_objective!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_point_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_point_variables!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcribe_reduced_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_reduced_variables!</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model,InfOptConstraintRef}"><code>InfiniteOpt.TranscriptionOpt.transcription_constraint</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_data"><code>InfiniteOpt.TranscriptionOpt.transcription_data</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_expression"><code>InfiniteOpt.TranscriptionOpt.transcription_expression</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_expression-Tuple{Model,Union{GenericAffExpr, GenericQuadExpr}}"><code>InfiniteOpt.TranscriptionOpt.transcription_expression</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_model"><code>InfiniteOpt.TranscriptionOpt.transcription_model</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>InfiniteOpt.TranscriptionOpt.transcription_variable</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.TranscriptionModel" href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">TranscriptionModel([optimizer_constructor;
                   caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,
                   bridge_constraints::Bool = true])::JuMP.Model</code></pre><p>Return a <a href="../../JuMP/#JuMP.Model"><code>JuMP.Model</code></a> with <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>TranscriptionData</code></a> included in the <code>ext</code> data field. Accepts the same arguments as a typical JuMP <code>Model</code>. More detailed variable and constraint naming can be enabled via <code>verbose_naming</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; TranscriptionModel()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL101-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.is_transcription_model" href="#InfiniteOpt.TranscriptionOpt.is_transcription_model"><code>InfiniteOpt.TranscriptionOpt.is_transcription_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_transcription_model(model::JuMP.Model)::Bool</code></pre><p>Return true if <code>model</code> is a <code>TranscriptionModel</code> or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_transcription_model(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_data" href="#InfiniteOpt.TranscriptionOpt.transcription_data"><code>InfiniteOpt.TranscriptionOpt.transcription_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcription_data(model::JuMP.Model)::TranscriptionData</code></pre><p>Return the <code>TranscriptionData</code> from a <code>TranscriptionModel</code>. Errors if it is not a <code>TranscriptionModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.has_internal_supports" href="#InfiniteOpt.TranscriptionOpt.has_internal_supports"><code>InfiniteOpt.TranscriptionOpt.has_internal_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_internal_supports(model::JuMP.Model)::Bool</code></pre><p>Return a <code>Bool</code> whether <code>model</code> has any internal supports that were collected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_model" href="#InfiniteOpt.TranscriptionOpt.transcription_model"><code>InfiniteOpt.TranscriptionOpt.transcription_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcription_model(model::InfiniteOpt.InfiniteModel)::JuMP.Model</code></pre><p>Return the transcription model stored in <code>model</code> if that is what is stored in <code>model.optimizer_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/optimize.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}" href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>InfiniteOpt.TranscriptionOpt.transcription_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transcription_variable(model::JuMP.Model,
    vref::InfiniteOpt.GeneralVariableRef;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
     ndarray::Bool = false])</code></pre><p>Return the transcribed variable reference(s) corresponding to <code>vref</code>. Errors if no transcription variable is found. Also can query via the syntax:</p><pre><code class="language-julia">transcription_variable(vref::InfiniteOpt.GeneralVariableRef; 
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
     ndarray::Bool = false])</code></pre><p>If the infinite model contains a built transcription model. By default, this method returns only transcribed variables associated with public supports. All the  variables can be returned by setting <code>label = All</code>. </p><p>If <code>vref</code> is infinite and <code>ndarray = true</code> then an n-dimensional array will be  returned in accordance with the infinite parameters that have unique object  numbers. In this case, <code>label</code> will be used to search the intersection of variable  supports that use the label. This is defers from the default behavior which  considers the union.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; transcription_variable(trans_model, infvar)
2-element Array{VariableRef,1}:
 infvar(support: 1)
 infvar(support: 2)

julia&gt; transcription_variable(trans_model, hdvar)
hdvar

julia&gt; transcription_variable(infvar)
2-element Array{VariableRef,1}:
 infvar(support: 1)
 infvar(support: 2)

julia&gt; transcription_variable(hdvar)
hdvar</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL180-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_variable-Tuple{GeneralVariableRef,Val{:TransData}}" href="#InfiniteOpt.optimizer_model_variable-Tuple{GeneralVariableRef,Val{:TransData}}"><code>InfiniteOpt.optimizer_model_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.optimizer_model_variable(vref::InfiniteOpt.GeneralVariableRef,
    ::Val{:TransData};
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Proper extension of <a href="../optimize/#InfiniteOpt.optimizer_model_variable"><code>InfiniteOpt.optimizer_model_variable</code></a> for <code>TranscriptionModel</code>s. This simply dispatches to <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL294-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.variable_supports-Tuple{Model,Union{InfiniteVariableRef, ReducedVariableRef},Val{:TransData}}" href="#InfiniteOpt.variable_supports-Tuple{Model,Union{InfiniteVariableRef, ReducedVariableRef},Val{:TransData}}"><code>InfiniteOpt.variable_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.variable_supports(model::JuMP.Model,
    vref::InfiniteOpt.DecisionVariableRef,
    key::Val{:TransData} = Val(:TransData);
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the support alias mapping associated with <code>vref</code> in the transcription model. Errors if <code>vref</code> does not have transcripted variables. See <code>transcription_variable</code>  for an explanation of <code>ndarray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL310-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}" href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}"><code>InfiniteOpt.TranscriptionOpt.lookup_by_support</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lookup_by_support(model::JuMP.Model,
                  vref::InfiniteOpt.GeneralVariableRef,
                  support::Vector)</code></pre><p>Return the transcription expression of <code>vref</code> defined at its <code>support</code>. This is intended as a helper method for automated transcription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL353-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.internal_reduced_variable-Tuple{ReducedVariableRef,Val{:TransData}}" href="#InfiniteOpt.internal_reduced_variable-Tuple{ReducedVariableRef,Val{:TransData}}"><code>InfiniteOpt.internal_reduced_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.internal_reduced_variable(
    vref::InfiniteOpt.ReducedVariableRef,
    ::Val{:TransData}
    )::InfiniteOpt.ReducedVariable{InfiniteOpt.GeneralVariableRef}</code></pre><p>Return the internal reduced variable associated with <code>vref</code>, assuming it was added internally during measure expansion at the transcription step. This extends <a href="../measure/#InfiniteOpt.internal_reduced_variable"><code>InfiniteOpt.internal_reduced_variable</code></a> as described in its docstring. Errors, if no such variable can be found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL399-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_expression-Tuple{Model,Union{GenericAffExpr, GenericQuadExpr}}" href="#InfiniteOpt.TranscriptionOpt.transcription_expression-Tuple{Model,Union{GenericAffExpr, GenericQuadExpr}}"><code>InfiniteOpt.TranscriptionOpt.transcription_expression</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transcription_expression(model::JuMP.Model,
    expr::JuMP.AbstractJuMPScalar;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the transcribed expression(s) corresponding to <code>expr</code>. Errors if <code>expr</code> cannot be transcribed. Also can query via the syntax:</p><pre><code class="language-julia">transcription_expression(expr::JuMP.AbstractJuMPScalar;
                         [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
                         ndarray::Bool = false])</code></pre><p>If the infinite model contains a built transcription model. By default, this method returns only transcribed expressions associated with public supports. All the  expressions can be returned by setting <code>label = All</code>.</p><p>If <code>expr</code> is infinite and <code>ndarray = true</code> then an n-dimensional array will be  returned in accordance with the infinite parameters that have unique object  numbers. In this case, <code>label</code> will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; transcription_expression(trans_model, my_expr)
x(support: 1) - y

julia&gt; transcription_expression(my_expr)
x(support: 1) - y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL503-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_expression-Tuple{Union{GenericAffExpr, GenericQuadExpr},Val{:TransData}}" href="#InfiniteOpt.optimizer_model_expression-Tuple{Union{GenericAffExpr, GenericQuadExpr},Val{:TransData}}"><code>InfiniteOpt.optimizer_model_expression</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.optimizer_model_expression(expr::JuMP.AbstractJuMPScalar,
    ::Val{:TransData};
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Proper extension of <a href="../optimize/#InfiniteOpt.optimizer_model_expression"><code>InfiniteOpt.optimizer_model_expression</code></a> for <code>TranscriptionModel</code>s. This simply dispatches to <a href="#InfiniteOpt.TranscriptionOpt.transcription_expression"><code>transcription_expression</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL586-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expression_supports-Tuple{Model,Union{GenericAffExpr, GenericQuadExpr},Val{:TransData}}" href="#InfiniteOpt.expression_supports-Tuple{Model,Union{GenericAffExpr, GenericQuadExpr},Val{:TransData}}"><code>InfiniteOpt.expression_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.expression_supports(model::JuMP.Model,
    expr::JuMP.AbstractJuMPScalar,
    key::Val{:TransData} = Val(:TransData);
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the support alias mappings associated with <code>expr</code>. Errors if <code>expr</code> cannot be transcribed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL603-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model,InfOptConstraintRef}" href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model,InfOptConstraintRef}"><code>InfiniteOpt.TranscriptionOpt.transcription_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transcription_constraint(model::JuMP.Model,
    cref::InfiniteOpt.InfOptConstraintRef;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the transcribed constraint reference(s) corresponding to <code>cref</code>. Errors if <code>cref</code> has not been transcribed. Also can query via the syntax:</p><pre><code class="language-julia">transcription_constraint(cref::InfiniteOpt.InfOptConstraintRef;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>If the infinite model contains a built transcription model. By default, this method returns only transcribed constraints associated with public supports. All the  constraints can be returned by setting <code>label = All</code>.</p><p>If <code>cref</code> is infinite and <code>ndarray = true</code> then an n-dimensional array will be  returned in accordance with the infinite parameters that have unique object  numbers. In this case, <code>label</code> will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; transcription_constraint(trans_model, fin_con)
fin_con : x(support: 1) - y &lt;= 3.0

julia&gt; transcription_constraint(fin_con)
fin_con : x(support: 1) - y &lt;= 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL645-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.optimizer_model_constraint-Tuple{InfOptConstraintRef,Val{:TransData}}" href="#InfiniteOpt.optimizer_model_constraint-Tuple{InfOptConstraintRef,Val{:TransData}}"><code>InfiniteOpt.optimizer_model_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.optimizer_model_constraint(cref::InfiniteOpt.InfOptConstraintRef,
    ::Val{:TransData};
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel
    ndarray::Bool = false])</code></pre><p>Proper extension of <a href="../optimize/#InfiniteOpt.optimizer_model_constraint"><code>InfiniteOpt.optimizer_model_constraint</code></a> for <code>TranscriptionModel</code>s. This simply dispatches to <a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model,InfOptConstraintRef}"><code>transcription_constraint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL709-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.constraint_supports-Tuple{Model,InfOptConstraintRef,Val{:TransData}}" href="#InfiniteOpt.constraint_supports-Tuple{Model,InfOptConstraintRef,Val{:TransData}}"><code>InfiniteOpt.constraint_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.constraint_supports(model::JuMP.Model,
    cref::InfiniteOpt.InfOptConstraintRef,
    key::Val{:TransData} = Val(:TransData);
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the support alias mappings associated with <code>cref</code>. Errors if <code>cref</code> is not transcribed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL727-L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.parameter_supports-Tuple{Model}" href="#InfiniteOpt.TranscriptionOpt.parameter_supports-Tuple{Model}"><code>InfiniteOpt.TranscriptionOpt.parameter_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_supports(model::JuMP.Model)::Tuple</code></pre><p>Return the collected parameter support tuple that is stored in <code>TranscriptionData.supports</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL763-L768">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.support_index_iterator" href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>InfiniteOpt.TranscriptionOpt.support_index_iterator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support_index_iterator(model::JuMP.Model, [obj_nums::Vector{Int}])::CartesianIndices</code></pre><p>Return the <code>CartesianIndices</code> that determine the indices of the unique combinations of <code>TranscriptionData.supports</code> stored in <code>model</code>. If <code>obj_nums</code> is specified, then the indices will only include the tuple elements uses indices are included in the object numbers <code>obj_nums</code> and all others will be assigned the last index which should correspond to an appropriately sized placeholder comprised of <code>NaN</code>s. Note this method assumes that <a href="#InfiniteOpt.TranscriptionOpt.set_parameter_supports"><code>set_parameter_supports</code></a> has already been called and that the last elements of each support vector contains a placeholder value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL773-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.index_to_support" href="#InfiniteOpt.TranscriptionOpt.index_to_support"><code>InfiniteOpt.TranscriptionOpt.index_to_support</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">index_to_support(model::JuMP.Model, index::CartesianIndex)::Vector{Float64}</code></pre><p>Given a particular support <code>index</code> generated via <a href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>support_index_iterator</code></a> using <code>model</code>, return the corresponding support from <code>TranscriptionData.supports</code> using placeholder <code>NaN</code>s as appropriate for tuple elements that are unneeded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL801-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.index_to_labels" href="#InfiniteOpt.TranscriptionOpt.index_to_labels"><code>InfiniteOpt.TranscriptionOpt.index_to_labels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">index_to_labels(model::JuMP.Model, index::CartesianIndex)::Set{DataType}</code></pre><p>Given a particular support <code>index</code> generated via <a href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>support_index_iterator</code></a> using <code>model</code>, return the corresponding support label set from <code>TranscriptionData.support_labels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL814-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.make_ndarray" href="#InfiniteOpt.TranscriptionOpt.make_ndarray"><code>InfiniteOpt.TranscriptionOpt.make_ndarray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_narray(model::JuMP.Model, 
            ref::Union{JuMP.AbstractJuMPScalar, InfiniteOpt.InfOptConstraintRef}, 
            info::Vector, 
            label::Type{&lt;:InfiniteOpt.AbstractSupportLabel})::Array</code></pre><p>Take the results<code>info</code> associated with <code>ref</code> and rearrange them into an  n-dimensional array where the axes correspond to the infinite parameter dependencies  in accordance with their creation. Note that this works by querying the object  numbers. Thus, independent infinite parameters will each get their own dimension  (even if they are defined at the same time in an array) and each dependent infinite  parameter group will have its own dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL849-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.set_parameter_supports" href="#InfiniteOpt.TranscriptionOpt.set_parameter_supports"><code>InfiniteOpt.TranscriptionOpt.set_parameter_supports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_parameter_supports(trans_model::JuMP.Model,
                       inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Collect the infinite parameter supports stored in their respective dictionaries form <code>inf_model</code> and process them into a tuple of vectors where each vector contains the collected supports of a particular infinite parameter. These support collections are ordered in accordance with the definition order of the parameters (i.e., their object numbers). A support collection assocciated with an independent will be a <code>Vector{Float64}</code> and a support collection associated with a group of dependent parameters will be a <code>Vector{Vector{Float64}}</code>. Note that each collection vector will include an extra final placeholder element comprised of <code>NaN</code>s for convenience in generating support indices via <a href="#InfiniteOpt.TranscriptionOpt.support_index_iterator"><code>support_index_iterator</code></a>. This also gathers the associated support labels. </p><p>Before this is all done, <code>InfiniteOpt.add_derivative_supports</code> is invoked for  any parameter that has at least one derivative dependency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL40-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_hold_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_hold_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_hold_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_hold_variables!(trans_model::JuMP.Model,
                           inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Create a transcription variable (i.e., a JuMP variable) for each <code>HoldVariable</code> stored in <code>inf_model</code> and add it to <code>trans_model</code>. The variable mapping is also stored in <code>TranscriptionData.finvar_mappings</code> which enables <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}"><code>lookup_by_support</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_infinite_variables!(trans_model::JuMP.Model,
                               inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Create transcription variables (i.e., JuMP variables) for each <code>InfiniteVariable</code> stored in <code>inf_model</code> and add them to <code>trans_model</code>. The variable mappings are also stored in <code>TranscriptionData.infvar_mappings</code> in accordance with <code>TranscriptionData.infvar_lookup</code> which enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}"><code>lookup_by_support</code></a>. Note that the supports will not be generated until <code>InfiniteOpt.variable_supports</code> is invoked via <code>InfiniteOpt.supports</code>.  Note that <code>TranscriptionData.infvar_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL125-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_derivative_variables!(trans_model::JuMP.Model,
                                 inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Create transcription variables (i.e., JuMP variables) for each <code>Derivative</code> stored in <code>inf_model</code> and add them to <code>trans_model</code>. The variable mappings are also stored in <code>TranscriptionData.infvar_mappings</code> in accordance with <code>TranscriptionData.infvar_lookup</code> which enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}"><code>lookup_by_support</code></a>. Note that the supports will not be generated until <code>InfiniteOpt.variable_supports</code> is invoked via <code>InfiniteOpt.supports</code>. The  futher derivative evaluation constraints are added when  <code>transcribe_derivative_evaluations!</code> is invoked. Note that  <code>TranscriptionData.infvar_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL190-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_reduced_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_reduced_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_reduced_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_reduced_variables!(trans_model::JuMP.Model,
                              inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Map each <code>ReducedVariable</code> in <code>inf_model</code> to transcription variables stored in <code>trans_model</code>. The variable mappings are also stored in <code>TranscriptionData.infvar_mappings</code> in accordance with <code>TranscriptionData.infvar_lookup</code> which enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}"><code>lookup_by_support</code></a>. Note that <a href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>transcribe_infinite_variables!</code></a> must be called first. Note that the supports will not be generated until <code>InfiniteOpt.variable_supports</code> is invoked via <code>InfiniteOpt.supports</code>.  Note that <code>TranscriptionData.infvar_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL283-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_point_variables!" href="#InfiniteOpt.TranscriptionOpt.transcribe_point_variables!"><code>InfiniteOpt.TranscriptionOpt.transcribe_point_variables!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_point_variables!(trans_model::JuMP.Model,
                           inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Map each <code>PointVariable</code> in <code>inf_model</code> to a transcription variable stored in <code>trans_model</code>. The variable mapping is also stored in <code>TranscriptionData.finvar_mappings</code> which enables <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}"><code>lookup_by_support</code></a>. Note that <a href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>transcribe_infinite_variables!</code></a> must be called first and that the info constraints associated with the transcription variable will be updated in accordance with the point variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL346-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_expression" href="#InfiniteOpt.TranscriptionOpt.transcription_expression"><code>InfiniteOpt.TranscriptionOpt.transcription_expression</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcription_expression(model::JuMP.Model,
    expr::JuMP.AbstractJuMPScalar;
    [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
    ndarray::Bool = false])</code></pre><p>Return the transcribed expression(s) corresponding to <code>expr</code>. Errors if <code>expr</code> cannot be transcribed. Also can query via the syntax:</p><pre><code class="language-julia">transcription_expression(expr::JuMP.AbstractJuMPScalar;
                         [label::Type{&lt;:InfiniteOpt.AbstractSupportLabel} = InfiniteOpt.PublicLabel,
                         ndarray::Bool = false])</code></pre><p>If the infinite model contains a built transcription model. By default, this method returns only transcribed expressions associated with public supports. All the  expressions can be returned by setting <code>label = All</code>.</p><p>If <code>expr</code> is infinite and <code>ndarray = true</code> then an n-dimensional array will be  returned in accordance with the infinite parameters that have unique object  numbers. In this case, <code>label</code> will be used to search the intersection of the supports that use the label. This is defers from the default behavior which  considers the union.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; transcription_expression(trans_model, my_expr)
x(support: 1) - y

julia&gt; transcription_expression(my_expr)
x(support: 1) - y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/model.jl#LL503-L534">source</a></section><section><div><pre><code class="language-none">transcription_expression(trans_model::JuMP.Model, expr, support::Vector{Float64})</code></pre><p>Given the <code>expr</code> from an <code>InfiniteModel</code>, form its transcripted version in accordance with the variable mappings available in <code>trans_model</code> defined at <code>support</code>. This should only be used once all variables and measures have been transcribed (e.g., via <a href="#InfiniteOpt.TranscriptionOpt.transcribe_hold_variables!"><code>transcribe_hold_variables!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL380-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_measures!" href="#InfiniteOpt.TranscriptionOpt.transcribe_measures!"><code>InfiniteOpt.TranscriptionOpt.transcribe_measures!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_measures!(trans_model::JuMP.Model,
                     inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>For each <code>Measure</code> in <code>inf_model</code> expand it via <code>InfiniteOpt.expand_measure</code> or <code>analytic_expansion</code> as appropriate and transcribe the expanded expression via <a href="#InfiniteOpt.TranscriptionOpt.transcription_expression"><code>transcription_expression</code></a>. Then store the measure to transcripted expression mappings in <code>TranscriptionData.measure_mappings</code> and <code>TranscriptionData.measure_lookup</code> to enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable-Tuple{Model,GeneralVariableRef}"><code>transcription_variable</code></a> and <a href="#InfiniteOpt.TranscriptionOpt.lookup_by_support-Tuple{Model,GeneralVariableRef,Array{T,1} where T}"><code>lookup_by_support</code></a>. Note that the supports will not be generated until <code>InfiniteOpt.variable_supports</code> is invoked via <code>InfiniteOpt.supports</code>.  Note that <code>TranscriptionData.measure_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL473-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_objective!" href="#InfiniteOpt.TranscriptionOpt.transcribe_objective!"><code>InfiniteOpt.TranscriptionOpt.transcribe_objective!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_objective!(trans_model::JuMP.Model,
                      inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Form the transcripted version of the objective stored in <code>inf_model</code> and add it to <code>trans_model</code>. Note that all the variables and measures in <code>inf_model</code> must by transcripted first (e.g., via <a href="#InfiniteOpt.TranscriptionOpt.transcribe_infinite_variables!"><code>transcribe_infinite_variables!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL525-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_constraints!" href="#InfiniteOpt.TranscriptionOpt.transcribe_constraints!"><code>InfiniteOpt.TranscriptionOpt.transcribe_constraints!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_constraints!(trans_model::JuMP.Model,
                        inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>For each constraint in <code>inf_model</code> form its transcripted version(s) and add them to <code>trans_model</code>. The mappings are stored in <code>TranscriptionData.constr_mappings</code> and the associated supports are stored in <code>TranscriptionData.constr_supports</code> to enable <a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint-Tuple{Model,InfOptConstraintRef}"><code>transcription_constraint</code></a> and <code>InfiniteOpt.constraint_supports</code>. Note that variable info constraints are simply mapped to the existing info constraints already generated along with the transcription variables. Note that the variables and measures must all first be transcripted (e.g., via <a href="#InfiniteOpt.TranscriptionOpt.transcribe_measures!"><code>transcribe_measures!</code></a>). Note that  <code>TranscriptionData.constr_support_labels</code> is also populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL629-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!" href="#InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!"><code>InfiniteOpt.TranscriptionOpt.transcribe_derivative_evaluations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcribe_derivative_evaluations!(trans_model::JuMP.Model, 
                                   inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Generate the auxiliary derivative evaluation equations and transcribe them  appropriately for all the derivatives in <code>inf_model</code>. These are in turn added to  <code>trans_model</code>. Note that no mapping information is recorded since the InfiniteModel  won&#39;t have any constraints that correspond to these equations. Also Note that the variables and measures must all first be transcripted (e.g., via <a href="#InfiniteOpt.TranscriptionOpt.transcribe_derivative_variables!"><code>transcribe_derivative_variables!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL712-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.build_transcription_model!" href="#InfiniteOpt.TranscriptionOpt.build_transcription_model!"><code>InfiniteOpt.TranscriptionOpt.build_transcription_model!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_transcription_model!(trans_model::JuMP.Model,
                           inf_model::InfiniteOpt.InfiniteModel)::Nothing</code></pre><p>Given an empty <code>trans_model</code> build it using the information stored in <code>inf_model</code>. This is intended for a <code>TranscriptionModel</code> that serves as a internal optimizer model of <code>inf_model</code>. This detail is important to correctly enable internally generated reduced variables during the transcription process such that <code>inf_model</code> is not modified. Note that this will add supports to <code>inf_model</code> via <a href="../expression/#InfiniteOpt.fill_in_supports!-Tuple{GeneralVariableRef}"><code>InfiniteOpt.fill_in_supports!</code></a> for infinite parameters that contain no supports. Also a warning is thrown when the transcription model contains more than 15,000 support points to alert users when they may naively have a few independent supports whose product quickly yields a very large grid. For example having 3 independent parameters with 100 supports each would result in 1,000,000 supports. This behavior can be overcome using dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/transcribe.jl#LL757-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure_variable-Tuple{Model,PointVariable,Val{:TransData}}" href="#InfiniteOpt.add_measure_variable-Tuple{Model,PointVariable,Val{:TransData}}"><code>InfiniteOpt.add_measure_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.add_measure_variable(model::JuMP.Model,
                                 var::InfiniteOpt.PointVariable,
                                 key::Val{:TransData}
                                 )::InfiniteOpt.GeneralVariableRef</code></pre><p>Make a <code>PointVariableRef</code> and map it to the appropriate transcription variable and return the <code>GeneralVariableRef</code>. This is an extension of <a href="../measure/#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> for <code>TranscriptionOpt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/measures.jl#LL1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure_variable-Tuple{Model,ReducedVariable,Val{:TransData}}" href="#InfiniteOpt.add_measure_variable-Tuple{Model,ReducedVariable,Val{:TransData}}"><code>InfiniteOpt.add_measure_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.add_measure_variable(model::JuMP.Model,
                                 var::InfiniteOpt.ReducedVariable,
                                 key::Val{:TransData}
                                 )::InfiniteOpt.GeneralVariableRef</code></pre><p>Make a <code>ReducedVariableRef</code> and add <code>var</code> to the transcription data and return the <code>GeneralVariableRef</code>. This is an extension of <a href="../measure/#InfiniteOpt.add_measure_variable-Tuple{Model,Any,Any}"><code>add_measure_variable</code></a> for <code>TranscriptionOpt</code>. Note that <code>internal_reduced_variable</code> is also extended to be able to access the <code>var</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/measures.jl#LL27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_reduced_variable-Tuple{Model,ReducedVariableRef,Val{:TransData}}" href="#InfiniteOpt.delete_reduced_variable-Tuple{Model,ReducedVariableRef,Val{:TransData}}"><code>InfiniteOpt.delete_reduced_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.delete_reduced_variable(model::JuMP.Model,
                                    vref::InfiniteOpt.ReducedVariableRef,
                                    key::Val{:TransData})::Nothing</code></pre><p>This is an extension of <a href="../measure/#InfiniteOpt.delete_reduced_variable-Tuple{Model,Any,Any}"><code>delete_reduced_variable</code></a> for use in <code>TranscriptionOpt</code>. Here we do not delete reduced variables once they have been used since there is no performance gain for this paradigm and the memory saving is small. Note this may change in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/measures.jl#LL55-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}" href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}"><code>InfiniteOpt.build_optimizer_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.build_optimizer_model!(model::InfiniteOpt.InfiniteModel,
                                   key::Val{:TransData})::Nothing</code></pre><p>Transcribe <code>model</code> and store it as a <code>TranscriptionModel</code> in the <code>model.optimizer_model</code> field which can be accessed with <code>transcription_model</code>. Ths clears the existing <code>TranscriptionModel</code> via <a href="../optimize/#InfiniteOpt.clear_optimizer_model_build!-Tuple{InfiniteModel}"><code>InfiniteOpt.clear_optimizer_model_build!</code></a> and then builds a new one using <a href="#InfiniteOpt.TranscriptionOpt.build_transcription_model!"><code>build_transcription_model!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/TranscriptionOpt/optimize.jl#LL15-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constraint/">« Constraints</a><a class="docs-footer-nextpage" href="../optimize/">Optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 22 October 2020 03:43">Thursday 22 October 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
