<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variables · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start Guide</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li class="is-active"><a class="tocitem" href>Variables</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Variable-Definition-Methodology"><span>Variable Definition Methodology</span></a></li><li><a class="tocitem" href="#Macro-Variable-Definition"><span>Macro Variable Definition</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#Modification"><span>Modification</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#var_methods"><span>Methods/Macros</span></a></li></ul></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Variables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variables</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/variable.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h1><p>A guide and manual for the definition and use of variables in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Decision variables are at the very core of <code>InfiniteOpt</code> as its name alludes to mathematical programs that entail infinite decision spaces (i.e., contain infinite decision variables). Principally, three variable types are employed: infinite, point, and hold. Infinite variables encompass any decision variable that is parameterized by an infinite parameter (e.g., space-time variables and recourse variables). Point variables are infinite variables at a particular infinite parameter value (point). Finally, hold variables are decisions that are made irrespective of the infinite domain (e.g., first stage variables and design variables). Or in other words, they hold a particular value over the infinite domain or some sub-domain of it. We also employ reduced variables which correspond to partially transcribed infinite variables which are artifacts of measure evaluation and thus are discussed on the <a href="../measure/#measure_page">Measures</a> page.</p><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Infinite, point, and hold variables are summarized in the following table:</p><table><tr><th style="text-align: center">Variable Type</th><th style="text-align: center">Description</th><th style="text-align: center">Examples</th></tr><tr><td style="text-align: center">Infinite</td><td style="text-align: center">Functional variables with infinite co-domain</td><td style="text-align: center"><span>$y(t)$</span>, <span>$y(\xi)$</span>, <span>$y(t, x)$</span></td></tr><tr><td style="text-align: center">Point</td><td style="text-align: center">Infinite variable evaluated at parameter point</td><td style="text-align: center"><span>$y(0)$</span>, <span>$y(t_0, x_0)$</span></td></tr><tr><td style="text-align: center">Hold</td><td style="text-align: center">Held constant over infinite domain</td><td style="text-align: center"><span>$z$</span> (design and 1st stage variables)</td></tr></table><p>Infinite, point, and hold variables are typically defined via their respective macros: <a href="#InfiniteOpt.@infinite_variable"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a>. These macros generally emulate <a href="../../JuMP/#JuMP.@variable"><code>JuMP.@variable</code></a> except that they each employ additional syntax capabilities to employ their respective variable type.</p><p>Let&#39;s first setup a simple space-time model with infinite parameters time <code>t</code> and spatial position <code>x</code>:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_parameter(model, x[1:2] in [-1, 1], independent = true)
2-element Array{GeneralVariableRef,1}:
 x[1]
 x[2]</code></pre><h3 id="Infinite-Variables"><a class="docs-heading-anchor" href="#Infinite-Variables">Infinite Variables</a><a id="Infinite-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Infinite-Variables" title="Permalink"></a></h3><p>Now let&#39;s define a time dependent infinite variable <code>y(t)</code> with a lower bound of 0:</p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, y(t) &gt;= 0)
y(t)</code></pre><p>This creates a Julia variable <code>y</code> that points to the decision variable <code>y(t)</code> that is stored in <code>model</code> which is added to include a lower bound of 0. Another useful case is that of defining an array of variables <code>w</code> that depend on both position and time:</p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, w[i = 1:3](t, x), start = [0, 2, 1][i])
3-element Array{GeneralVariableRef,1}:
 w[1](t, x)
 w[2](t, x)
 w[3](t, x)</code></pre><p>Thus we create a Julia array variable <code>w</code> whose elements <code>w[i]</code> point to their respective infinite variables <code>w[i](t, x)</code> stored in <code>model</code>. Note that the <code>i</code> used in the array definition can be used to index attributes assigned to each variable in the array. In this case, we used <code>i</code> to assign different initial guess values for each variable via the <code>start</code> keyword argument.</p><p>Moreover, for infinite variables a function can be given to determine the start values over a range of support points (e.g., a guess trajectory). This is discussed further below in the Macro Definition section.</p><h3 id="Point-Variables"><a class="docs-heading-anchor" href="#Point-Variables">Point Variables</a><a id="Point-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Variables" title="Permalink"></a></h3><p>Now let&#39;s add some point variables. These allow us to consider an infinite variable evaluated at a certain infinite parameter point. For example, let&#39;s define a point variable for <code>y(0)</code> with the alias <code>y0</code> that is fixed at a value of 0:</p><pre><code class="language-julia-repl">julia&gt; @point_variable(model, y(0), y0 == 0)
y0</code></pre><p>Here we create a Julia variable <code>y0</code> which points to the point variable <code>y(0)</code>. Notice that in the second argument we specify the infinite variable indexed at the appropriate parameter value(s). Point variables automatically inherit attributes of the infinite variable (e.g., bounds, start values, etc.), but these are overwritten with properties specified for the point variable. In this case the lower bound inherited from <code>y(t)</code> is overwritten by instead fixing <code>y(0)</code> to a value of 0.  </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Point variables are provided for enhancing the generality of <code>InfiniteOpt</code>, but typically can be avoided by using infinite variables in combination with <a href="../constraint/#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a> to define bounded constraints ( e.g., initial conditions).</p></div></div><h3 id="Hold-Variables"><a class="docs-heading-anchor" href="#Hold-Variables">Hold Variables</a><a id="Hold-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Hold-Variables" title="Permalink"></a></h3><p>Finally, we can add hold variables to our model. These denote variables that hold a single value over the infinite domain or some portion of it (e.g., design variables, first stage variables, etc.). Let&#39;s add a hold variable <span>$0 \leq d \leq 42$</span> that is an integer variable and defined over all infinite domains (i.e., time and space):</p><pre><code class="language-julia-repl">julia&gt; @hold_variable(model, 0 &lt;= d &lt;= 42, Int)
d</code></pre><p>This creates a Julia variable <code>d</code> that points to the hold variable <code>d</code> which has a lower bound of 0, an upper bound of 42, and is an integer variable. Thus, <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a> follows the same exact syntax as <a href="../../JuMP/#JuMP.@variable"><code>JuMP.@variable</code></a> except that it also allows the user to specify a subdomain over which the hold variable is valid. For example, let&#39;s add a hold variable <code>z</code> that is only valid over the subdomain <span>$t \in [0, 5]$</span> via the <code>parameter_bounds</code> keyword argument:</p><pre><code class="language-julia-repl">julia&gt; anon = @hold_variable(model, parameter_bounds = (t in [0, 5]),
                             base_name = &quot;z&quot;)
z</code></pre><p>Here we make an anonymous variable for the sake of example whose reference is stored to the Julia variable <code>anon</code> and points to a hold variable <code>z</code> which is only valid for <span>$t \in [0, 5]$</span>. Thus, this will be enforced in any constraints that involve <code>anon</code>, meaning they will automatically be bounded to such a subdomain. Any number of parameters bounds (bounds on the parameters of the infinite domain) can be added in a tuple like argument as explained in the documentation for <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a>.</p><p>Now we have defined variables that we can use in the objective, measures, and constraints. Please note that the above tutorial only shows a small portion of the capabilities and options available in defining variables. A full description is provided in the documentation below.</p><h2 id="Variable-Definition-Methodology"><a class="docs-heading-anchor" href="#Variable-Definition-Methodology">Variable Definition Methodology</a><a id="Variable-Definition-Methodology-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Definition-Methodology" title="Permalink"></a></h2><p>The <a href="#InfiniteOpt.@infinite_variable"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a> macros all follow a similar methodology behind the scenes and these commonalities are discussed in this section for conciseness. Defining/initializing a variable principally involves the following steps:</p><ol><li>Define the variable information pertaining to <code>JuMP.VariableInfo</code> (e.g., bounds, indicate if it is integer, etc.)</li><li>Construct a concrete subtype of <a href="#InfiniteOpt.InfOptVariable"><code>InfOptVariable</code></a> to store the variable information</li><li>Add the <code>InfOptVariable</code> object to an <code>InfiniteModel</code> and assign a name</li><li>Create a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> that points to the variable object stored in the model</li></ol><p>The <code>JuMP.VariableInfo</code> data structure stores the following variable information:</p><ul><li><code>has_lb::Bool</code>: Specifies a <code>Bool</code> it has a lower bound</li><li><code>lower_bound::Real</code>: Specifies lower bound value</li><li><code>has_ub::Bool</code>: Specifies a <code>Bool</code> it has a upper bound</li><li><code>upper_bound::Real</code>: Specifies upper bound value</li><li><code>has_fix::Bool</code>: Specifies a <code>Bool</code> it is fixed</li><li><code>fixed_value::Real</code>: Specifies the fixed value</li><li><code>has_start::Bool</code>: Specifies a <code>Bool</code> it has a start value</li><li><code>start::Union{Real, Function}</code>: Specifies the start guess value, this can be a                                 function for infinite variables that intakes a                                 support and maps it to a guess value (allowing                                 to specify guess trajectories)</li><li><code>binary</code>: Specifies <code>Bool</code> if it is binary</li><li><code>integer</code>: Specifies <code>Bool</code> if it is integer.</li></ul><p>Thus, the user specifies this information to prepare such an object:</p><pre><code class="language-julia-repl">julia&gt; info = VariableInfo(true, 0., true, 42., false, 0., false, 0., false, true)
VariableInfo{Float64,Float64,Float64,Float64}(true, 0.0, true, 42.0, false, 0.0, false, 0.0, false, true)</code></pre><p>Here we specified a lower bound of 0, an upper bound of 42, and that it is integer.</p><p>The variable objects (<code>InfOptVariable</code> subtypes) are defined via <a href="../measure/#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>build_variable</code></a> which requires that the user provide a <code>JuMP.VariableInfo</code> object, the variable type to be defined (<code>Infinite</code>, <code>Point</code>, or <code>Hold</code>), and any necessary keyword arguments required for that variable type (i.e., <code>parameter_refs</code>, <code>infinite_variable_ref</code>, and/or <code>parameter_values</code>). For example, let&#39;s build an infinite variable <code>y(t)</code> that has an lower bound of 0, an upper bound of 42, and is integer:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; info = VariableInfo(true, 0, true, 42, false, 0, false, 0, false, true);

julia&gt; inf_var = build_variable(error, info, Infinite, parameter_refs = (t));</code></pre><p>Thus, we create an <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a> object with the desired properties. Note that in this case the <code>parameter_refs</code> keyword argument is required to indicate which infinite parameter(s) this infinite variable will depend on.</p><p>Once a variable has been built, it needs to be added to our <code>model</code> and a Julia variable should be defined to reference it. Variables are added via <a href="#JuMP.add_variable-Tuple{InfiniteModel,InfOptVariable,String}"><code>add_variable</code></a> which adds a variable object to the model, assigns a name to the variable, adds any constraints associated with the <code>JuMP.VariableInfo</code>, and returns an appropriate variable reference variable (a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>). For example, let&#39;s add <code>inf_var</code> to <code>model</code>:</p><pre><code class="language-julia-repl">julia&gt; var_ref = add_variable(model, inf_var, &quot;y&quot;)
y(t)</code></pre><p>Thus, we have added an infinite variable <code>y</code> that is parameterized by <code>t</code> with the variable information mentioned above and now have a <code>GeneralVariableRef</code> called <code>var_ref</code> that can be used in defining our infinite model.</p><p>Note that the use of <code>GeneralVariableRef</code>s and the corresponding concrete subtypes of <a href="../expression/#InfiniteOpt.DispatchVariableRef"><code>DispatchVariableRef</code></a>s is discussed on the <a href="../expression/#expr_page">Expressions</a> page.</p><h2 id="Macro-Variable-Definition"><a class="docs-heading-anchor" href="#Macro-Variable-Definition">Macro Variable Definition</a><a id="Macro-Variable-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-Variable-Definition" title="Permalink"></a></h2><p>The <a href="#InfiniteOpt.@infinite_variable"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a> macros automate the variable definition process discussed above in the <a href="#Variable-Definition-Methodology">Variable Definition Methodology</a> section via a straightforward symbolic syntax. The only key difference is that non-anonymous macro calls will register variable names to ensure they are not repeated. Anonymous macro calls forgo this step and exactly follow the process described above. This section will highlight the details of using these macros.</p><h3 id="var_macro_gen_usage"><a class="docs-heading-anchor" href="#var_macro_gen_usage">General Usage</a><a id="var_macro_gen_usage-1"></a><a class="docs-heading-anchor-permalink" href="#var_macro_gen_usage" title="Permalink"></a></h3><p>Here we discuss the features that the variable macros have in common (generally these pertain to <code>JuMP</code>-like features). To illustrate this via example, let&#39;s setup a model with a variety of infinite parameters <span>$t \in [0,10]$</span>, <span>$x \in [-1, 1]^3$</span>, and <span>$\xi \in \mathcal{N}(0, 1)$</span>:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP, Distributions

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @infinite_parameter(model, x[1:3] in [-1, 1], independent = true);

julia&gt; @infinite_parameter(model, ξ in Normal());</code></pre><p>We will first consider anonymous variable macro calls which generally are less convenient than non-anonymous macro calls which offer a much more intuitive mathematical syntax. However, anonymous variables can be useful and provide a good foundation to understanding non-anonymous variables. Furthermore, we&#39;ll use hold variables as the motivating examples since they best exemplify commonalities between the macros. First, let&#39;s consider single anonymous definition a hold variable:</p><pre><code class="language-julia-repl">julia&gt; var_ref = @hold_variable(model)
noname</code></pre><p>Here we just added a nameless hold variable to <code>model</code> and defined <code>var_ref</code> as a <code>GeneralVariableRef</code> that points to it. We can add a name via the <code>base_name</code> keyword argument:</p><pre><code class="language-julia-repl">julia&gt; var_ref1 = @hold_variable(model, base_name = &quot;d&quot;)
d

julia&gt; var_ref2 = @hold_variable(model, base_name = &quot;d&quot;)
d</code></pre><p>Now we&#39;ve made 2 more hold variables both called <code>d</code>. Thus, the anonymous syntax allows us to define variables with the same name. Moreover, any variable information can be specified via the appropriate keywords which include:</p><ul><li><code>lower_bound::Real</code>: specifies lower bound</li><li><code>upper_bound::Real</code>: specifies upper bound</li><li><code>start::Union{Real, Function}</code>: specifies the initial guess value the solver will use,                                 for infinite variables this can be a function that                                 takes as input a realization of the infinite parameters                                 (using the same format as <code>parameter_refs</code>) and return the                                 guess value for such as realization (e.g., functionally                                 define a trajectory).</li><li><code>binary::Bool</code>: specifies if is binary variable</li><li><code>integer::Bool</code>: specifies if is integer variable.</li></ul><p>Anonymous variables must use these keyword arguments since symbolic definition is only permitted for non-anonymous macro calls. For example, let&#39;s define a hold variable <span>$0 \leq d \leq 5$</span> that is integer:</p><pre><code class="language-julia-repl">julia&gt; var_ref = @hold_variable(model, base_name = &quot;d&quot;, lower_bound = 0,
                                upper_bound = 5, integer = true)
d</code></pre><p>We can also define arrays of variables using any indices of our choice. For example, let&#39;s define a 3-dimensional vector with indices <code>[1, 2, 3]</code>:</p><pre><code class="language-julia-repl">julia&gt; var_refs = @hold_variable(model, [i = 1:3], start = [0, 2, 1][i],
                                 base_name = &quot;d&quot;)
3-element Array{GeneralVariableRef,1}:
 d[1]
 d[2]
 d[3]</code></pre><p>Thus, we define 3 variables named <code>d[i]</code> and each with different start values and define <code>var_refs</code> which is a vector of <code>GeneralVariableRef</code>s that uses the indices we specified. Note the syntax <code>i = indices</code> is used to define an iteration variable to use with the keyword arguments to assign different values for each variable being defined. Note the above example is equivalent to:</p><pre><code class="language-julia-repl">julia&gt; starts = [0, 2, 1];

julia&gt; var_refs = Vector{GeneralVariableRef}(undef, 3);

julia&gt; for i = eachindex(var_refs)
          var_refs[i] = @hold_variable(model, base_name = &quot;d&quot;, start = starts[i])
       end</code></pre><p>Other non-standard indices can also be used such as the following examples:</p><pre><code class="language-julia-repl">julia&gt; var_refs2 = @hold_variable(model, [2:4], base_name = &quot;d&quot;)
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, 2:4
And data, a 3-element Array{GeneralVariableRef,1}:
 d[2]
 d[3]
 d[4]

julia&gt; var_refs3 = @hold_variable(model, [[:A, :C, :Z]], base_name = &quot;d&quot;)
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, Symbol[:A, :C, :Z]
And data, a 3-element Array{GeneralVariableRef,1}:
 d[A]
 d[C]
 d[Z]

julia&gt; var_refs3 = @hold_variable(model, [i=1:2, j=i:2], base_name = &quot;d&quot;)
JuMP.Containers.SparseAxisArray{GeneralVariableRef,2,Tuple{Int64,Int64}} with 3 entries:
  [1, 2]  =  d[1,2]
  [2, 2]  =  d[2,2]
  [1, 1]  =  d[1,1]</code></pre><p>Here we see that a variety of indices can be used and this is explained more fully in the documentation of <code>JuMP</code>.</p><p><code>JuMP</code> employs 2 special array container types: <code>DenseAxisArray</code>s and <code>SparseAxisArray</code>s which help facilitate this special indexing. The variable macros will by default automatically detect which container type should be used. However, the user can specify a particular container type using the <code>container</code> keyword. For example, if we want to use indices <code>a:b</code> where <code>a = 1</code> and <code>b = 3</code>, a <code>DenseAxisArray</code> will be used by default, but we can force it to be a regular <code>Array</code>:</p><pre><code class="language-julia-repl">julia&gt; a = 1; b = 3;

julia&gt; var_refs1 = @hold_variable(model, [a:b], base_name = &quot;d&quot;)
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, 1:3
And data, a 3-element Array{GeneralVariableRef,1}:
 d[1]
 d[2]
 d[3]

julia&gt; var_refs2 = @hold_variable(model, [a:b], base_name = &quot;d&quot;, container = Array)
3-element Array{GeneralVariableRef,1}:
 d[1]
 d[2]
 d[3]</code></pre><p>For more information on <code>JuMP</code> containers please visit their page <a href="http://www.juliaopt.org/JuMP.jl/stable/containers/">here</a>.</p><p>Now that we have a foundation with anonymous variable macro calls, let&#39;s focus on non-anonymous calls which offer a much more straightforward syntax. These calls can still implement all of the same keyword arguments. Moreover, they automatically create a Julia variable with the variable name provided and register this name to ensure subsequent automatic Julia variables do not overwrite it.</p><p>The supported symbolic syntax principally implements the following keyword arguments:</p><ul><li><code>base_name</code></li><li><code>lower_bound</code></li><li><code>upper_bound</code></li><li><code>integer</code></li><li><code>binary</code></li><li><code>parameter_refs</code> (for infinite variables)</li><li><code>infinite_variable_ref</code> (for point variables)</li><li><code>parameter_values</code> (for point variables).</li></ul><p>These are implemented via the syntax <code>@[type]_variable(model, expr, integrality_arg, keyword_args...)</code>. Here <code>expr</code> specifies the name, bounds, and/or variable specific keyword arguments. It can use the following forms (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>):</p><ul><li><code>varexpr</code> creating variables described by <code>varexpr</code></li><li><code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>Thus, providing an intuitive means to specify bounds. The expressions <code>varexpr</code> specifies the name, dimensions, and/or type specific keywords and can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of name <code>varname</code></li><li><code>varname[...]</code> creating a container of variables with indices <code>...</code></li><li><code>varname(params)</code> creating an infinite variable dependent on <code>params</code></li><li><code>varname[...](params)</code> creating infinite variables dependent on <code>params</code>.</li></ul><p>The <code>integrality_arg</code> optionally is used to indicate if the variable(s) is/are integer or binary using <code>Int</code> or <code>Bin</code>, respectively.  </p><p>For example, let&#39;s define a hold variable <span>$0 \leq d \leq 3$</span> that is integer:</p><pre><code class="language-julia-repl">julia&gt; @hold_variable(model, 0 &lt;= d &lt;= 3, Int)
d</code></pre><p>Note this is equivalent to</p><pre><code class="language-julia-repl">julia&gt; d = @hold_variable(model, base_name = &quot;d&quot;, lower_bound = 0, upper_bound = 3,
                          integer = true)
d</code></pre><p>with the exception that the non-anonymous definition registers <code>d</code> as variable name that cannot be duplicated. For one more example let&#39;s define a vector of variables <span>$a \in \mathbb{R}_+^3$</span> with starting values of 0:</p><pre><code class="language-julia-repl">julia&gt; @hold_variable(model, a[1:3] &gt;= 0, start = 0)
3-element Array{GeneralVariableRef,1}:
 a[1]
 a[2]
 a[3]</code></pre><p>Thus, highlighting how keyword arguments can still be used.</p><h3 id="Infinite-Variables-2"><a class="docs-heading-anchor" href="#Infinite-Variables-2">Infinite Variables</a><a class="docs-heading-anchor-permalink" href="#Infinite-Variables-2" title="Permalink"></a></h3><p>Infinite variables entail decision variables that depend on infinite parameter(s). Thus, <a href="#InfiniteOpt.@infinite_variable"><code>@infinite_variable</code></a> follows the general definition methodology with this additional consideration.</p><p>Let&#39;s first consider a basic anonymous definition of an infinite variable <span>$y(t, x)$</span>:</p><pre><code class="language-julia-repl">julia&gt; y = @infinite_variable(model, parameter_refs = (t, x), base_name = &quot;y&quot;)
y(t, x)</code></pre><p>Here we created an infinite variable with the base name <span>$y$</span> that depends on <span>$t$</span> and <span>$x$</span>. Notice that each group of parameters are specified in a particular element of the <code>parameter_refs</code> tuple, this is the required format. Moreover, the keyword argument <code>parameter_refs</code> is required to specify what parameterizes the infinite variable. Because we used an anonymous call, we can still make another variable with the same name. For example let&#39;s define another infinite variable also called <span>$y$</span> that only depends on <span>$t$</span>:</p><pre><code class="language-julia-repl">julia&gt; y2 = @infinite_variable(model, parameter_refs = (t), base_name = &quot;y&quot;)
y(t)</code></pre><p>More conveniently, we can equivalently define <span>$y(t, x)$</span> symbolically:</p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, y(t, x))
y(t, x)</code></pre><p>We can also use this symbolic syntax to add constraint information as described in the previous section. For example, let&#39;s define a vector of infinite variables <span>$z(t) \in \{0, 1, 2\}^3$</span>:</p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, 0 &lt;= z[1:3](t) &lt;= 2, Int)
3-element Array{GeneralVariableRef,1}:
 z[1](t)
 z[2](t)
 z[3](t)</code></pre><p>In many cases, it is important to specify a guess trajectory for an infinite variable. Currently, this can be done by defining a start value function and specifying via the <code>start</code> keyword. In particular, the arguments of this function must match the format of the infinite parameters and return a start value for a given realization (point) of the infinite parameters:</p><pre><code class="language-julia-repl">julia&gt; my_traj_func(t_val, x_vals) = t_val + sum(x_vals) # replace with actual functionality
my_traj_func (generic function with 1 method)

julia&gt; @infinite_variable(model, y2(t, x), start = (t_val, x_vals) -&gt; my_traj_func(t_val, x_vals))
y2(t, x)</code></pre><p>Notice that above we use an anonymous function in the macro call, this is done to avoid ambiguity in case we have multiple <code>my_traj_func</code> definitions. In general it is recommended that anonymous functions be used.</p><h3 id="Point-Variables-2"><a class="docs-heading-anchor" href="#Point-Variables-2">Point Variables</a><a class="docs-heading-anchor-permalink" href="#Point-Variables-2" title="Permalink"></a></h3><p>Point variables denote infinite variables (or derivatives) evaluated at a particular point in the infinite decision space (i.e., particular infinite parameter values). These are commonly employed when using initial and terminal conditions, and to build discrete characterizations of complex operators such as derivatives. The <a href="#InfiniteOpt.@point_variable"><code>@point_variable</code></a> macro is employed to define such variables. Principally, it follows the general variable definition paradigm, but allows us to specify the infinite variable it refers to and the parameter values it is evaluated at. Also, note that by default it inherits the characteristics of the infinite variable (e.g., bounds), but these are overwritten as specified in the point variable macro.</p><p>To begin let&#39;s consider defining a boundary point <span>$y(0, -1)$</span> based on the infinite variable <span>$y(t, x)$</span> and enforce that it be nonnegative. Note that -1 need be a 3 element vector in this case to match the dimensions of <span>$x$</span>. The anonymous syntax would be:</p><pre><code class="language-julia-repl">julia&gt; y0 = @point_variable(model, infinite_variable_ref = y,
                            parameter_values = (0, [-1, -1, -1]), lower_bound = 0)
y(0, [-1, -1, -1])</code></pre><p>This creates a point variable <code>y(0, [-1, -1, -1]) ≥ 0</code> that is added to <code>model</code> and assigns to the associated <code>GeneralVariableRef</code> to the Julia variable <code>y0</code>. Equivalently, this can accomplished much more conveniently via:</p><pre><code class="language-julia-repl">julia&gt; @point_variable(model, y(0, [-1, -1, -1]), y0 &gt;= 0)
y0</code></pre><p>Here the 2nd argument specifies the infinite variable and parameter values, and the next argument is used to provide a convenient alias that can be used in combination with the typical symbolic variable syntax described in the previous sections. Let&#39;s also demonstrate how this works for multi-dimensional infinite variables. For example consider defining <span>$z(0) = 0$</span> for <span>$z(t) \in \{0, 1, 2\}^3$</span>:</p><pre><code class="language-julia-repl">julia&gt; @point_variable(model, z[i](0), z0[i = 1:3] == 0)
3-element Array{GeneralVariableRef,1}:
 z0[1]
 z0[2]
 z0[3]</code></pre><h3 id="Hold-Variables-2"><a class="docs-heading-anchor" href="#Hold-Variables-2">Hold Variables</a><a class="docs-heading-anchor-permalink" href="#Hold-Variables-2" title="Permalink"></a></h3><p>Hold variables denote decision variables that are constant (agnostic) over the infinite domain or some sub-domain of it. This is accomplished via the <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a> macro as demonstrated in the <a href="#var_macro_gen_usage">General Usage</a> section. By default and as shown in the above examples, hold variables are valid over the entire infinite domain. However, this scope can be limited via the <code>parameter_bounds</code> keyword argument.</p><p>For example, let&#39;s define a hold variable <span>$b \in \{0, 1\}$</span> that is valid over the entire infinite domain (any infinite parameter value):</p><pre><code class="language-julia-repl">julia&gt; @hold_variable(model, b, Bin)
b</code></pre><p>Again, this follows the methodology outlined above. Now let&#39;s suppose we want to define a hold variable <span>$0 \leq c \leq 42$</span> that is only valid over the time interval <span>$t \in [0, 5]$</span> which is a subset of the entire range being considered. This can be accomplished via <code>parameter_bounds</code>:</p><pre><code class="language-julia-repl">julia&gt; @hold_variable(model, 0 &lt;= c &lt;= 42, parameter_bounds = (t in [0, 5]))
c</code></pre><p>Thus, we defined <code>c</code> and it can only be used in constraints and measures in accordance with this limited sub-domain. When such a limited hold variable is used in a constraint, the constraint parameter bounds be overlapped with those of <code>c</code> if possible. Otherwise, an error will be thrown. This is further explained on the <a href="../constraint/#constr_page">Constraints</a> page.</p><p>Any number of parameters can be specified in a hold variable&#39;s sub-domain. For example, let&#39;s define <code>e</code> such over the domain <span>$t \in [0, 1]$</span>, <span>$x = -1$</span>:</p><pre><code class="language-julia-repl">julia&gt; @hold_variable(model, e, parameter_bounds = (t in [0, 1], x == -1))
e</code></pre><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><p><code>InfiniteOpt</code> contains a large suite of methods to query information about variables. This suite is comprised of extensions to all current <code>JuMP</code> query methods and many more that are specific to <code>InfiniteOpt</code>. A number of the more commonly used ones are explained in this section, but all of the available methods are explained in the <a href="#var_methods">Methods/Macros</a> section (i.e., the manual) below.</p><h3 id="General-Information"><a class="docs-heading-anchor" href="#General-Information">General Information</a><a id="General-Information-1"></a><a class="docs-heading-anchor-permalink" href="#General-Information" title="Permalink"></a></h3><p>Here we describe some methods used to query general variable information such as the name. Variable names can be extracted via <a href="#JuMP.name-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>name</code></a> which returns the name of a variable. The index of a variable (where it is stored in the infinite model) is accessed via <a href="../expression/#JuMP.index-Tuple{GeneralVariableRef}"><code>index</code></a> and the infinite model it belongs to is given by <a href="../expression/#JuMP.owner_model-Tuple{GeneralVariableRef}"><code>owner_model</code></a>. These methods are demonstrated below:</p><pre><code class="language-julia-repl">julia&gt; name(y)
&quot;y&quot;

julia&gt; index(y)
InfiniteVariableIndex(3)

julia&gt; model_where_stored = owner_model(y);</code></pre><p>Also, <a href="#JuMP.all_variables-Tuple{InfiniteModel,Type{InfOptVariable}}"><code>num_variables</code></a> is useful in returning the total number of decision variables currently stored in an infinite model:</p><pre><code class="language-julia-repl">julia&gt; num_variables(model)
45

julia&gt; num_variables(model, PointVariable)
5</code></pre><p>Similarly, <a href="#JuMP.all_variables-Tuple{InfiniteModel,Type{InfOptVariable}}"><code>all_variables</code></a> returns a list of all the variables currently added to the model.</p><p>Finally, <a href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>variable_by_name</code></a> can be employed to return the appropriate <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> based off of the variable name if it is unique. Returns <code>nothing</code> if such a name cannot be found and errors if it is not unique. For example, we can request the reference associated with <code>&quot;c&quot;</code>:</p><pre><code class="language-julia-repl">julia&gt; variable_by_name(model, &quot;c&quot;)
c</code></pre><h3 id="Variable-Constraint-Info"><a class="docs-heading-anchor" href="#Variable-Constraint-Info">Variable Constraint Info</a><a id="Variable-Constraint-Info-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Constraint-Info" title="Permalink"></a></h3><p>As described above, variables in <code>InfiniteOpt</code> can have constraints associated with them like <code>JuMP</code> variables. These constraints include:</p><ul><li>lower bounds</li><li>upper bounds</li><li>fixed values</li><li>binary specifications</li><li>integer specifications.</li></ul><p>Thus, a number of methods exist to query information about these constraints.</p><p>First, the <code>[has/is]_[variable constraint type]</code> methods indicate whether or not a variable has that particular constraint type. For example, to query if a variable <code>d</code> has a lower bound we can use <a href="#JuMP.has_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>has_lower_bound</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(d)
true</code></pre><p>Thus, <code>d</code> does have a lower bound. The other methods are <a href="#JuMP.has_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>has_upper_bound</code></a>, <a href="#JuMP.is_fixed-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>is_fixed</code></a>, <a href="#JuMP.is_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>is_binary</code></a>, and <a href="#JuMP.is_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>is_integer</code></a>.</p><p>Next, the <code>[ConstraintType]Ref</code> methods return an appropriate explicit type <a href="../constraint/#InfiniteOpt.InfOptConstraintRef"><code>InfOptConstraintRef</code></a> that points to the constraint (errors if no such constraint exists). For example, the upper bound constraint of <code>d</code> can be obtained via <a href="#JuMP.UpperBoundRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>UpperBoundRef</code></a>:</p><pre><code class="language-julia-repl">julia&gt; UpperBoundRef(d)
d ≤ 3.0</code></pre><p>The other methods are <a href="#JuMP.LowerBoundRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>LowerBoundRef</code></a>, <a href="#JuMP.FixRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>FixRef</code></a>, <a href="#JuMP.BinaryRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>BinaryRef</code></a>, and <a href="#JuMP.IntegerRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>IntegerRef</code></a>.</p><p>Finally, variable constraints that entail values (i.e., lower bounds, upper bounds, and fixed values) have their values queried via the appropriate method. For example, the lower bound value of <code>d</code> is obtained via <a href="#JuMP.lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>lower_bound</code></a>:</p><pre><code class="language-julia-repl">julia&gt; lower_bound(d)
0.0</code></pre><p>Note these methods error when no such constraint is associated with the variable. The other methods are <a href="#JuMP.upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>upper_bound</code></a> and <a href="#JuMP.fix_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>fix_value</code></a>.</p><h3 id="Variable-Use"><a class="docs-heading-anchor" href="#Variable-Use">Variable Use</a><a id="Variable-Use-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Use" title="Permalink"></a></h3><p><code>InfiniteOpt</code> defines a number of methods to track if and how variables are used in an infinite model. For example, <a href="#InfiniteOpt.used_by_constraint-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>used_by_constraint</code></a> is used to determine if a variable is used by a constraint. For example, let&#39;s see if <code>c</code> is used by a constraint:</p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(c)
true</code></pre><p>Other methods include <a href="#InfiniteOpt.used_by_measure-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>used_by_measure</code></a> and <a href="#InfiniteOpt.used_by_objective-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>used_by_objective</code></a>. For infinite variables, <a href="../expression/#InfiniteOpt.used_by_point_variable-Tuple{GeneralVariableRef}"><code>used_by_point_variable</code></a> can also be used in a similar manner.</p><p>Finally, in general <a href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>is_used</code></a> can be used to determine if a variable is used at all in the infinite model or not. For example, if we check <code>e</code> using <code>is_used</code> we find that it isn&#39;t:</p><pre><code class="language-julia-repl">julia&gt; is_used(e)
false</code></pre><h3 id="Type-Specific"><a class="docs-heading-anchor" href="#Type-Specific">Type Specific</a><a id="Type-Specific-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Specific" title="Permalink"></a></h3><p><code>InfiniteOpt</code> also employs a few methods for specific variable types that return information pertaining to that particular variable type. For infinite variables, <a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>parameter_refs</code></a> returns the tuple of infinite parameters that the variable depends on. For example, consider <code>y(t, x)</code>:</p><pre><code class="language-julia-repl">julia&gt; parameter_refs(y)
(t, GeneralVariableRef[x[1], x[2], x[3]])</code></pre><p>For point variables, <a href="#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>infinite_variable_ref</code></a> and <a href="#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>parameter_values</code></a> return the infinite variable it depends on and the infinite parameter point values, respectively. For example, consider the point variable <code>y0</code>:</p><pre><code class="language-julia-repl">julia&gt; infinite_variable_ref(y0)
y(t, x)

julia&gt; parameter_values(y0)
(0.0, [-1.0, -1.0, -1.0])</code></pre><p>For hold variables, <a href="#InfiniteOpt.has_parameter_bounds-Tuple{HoldVariableRef}"><code>has_parameter_bounds</code></a> returns if a hold variable has parameter bounds (i.e., a specified sub-domain) and <a href="#InfiniteOpt.parameter_bounds-Tuple{HoldVariableRef}"><code>parameter_bounds</code></a> returns those bounds if there are any. For example, consider <code>c</code>:</p><pre><code class="language-julia-repl">julia&gt; has_parameter_bounds(c)
true

julia&gt; parameter_bounds(c)
Subdomain bounds (1): t ∈ [0, 5]</code></pre><h2 id="Modification"><a class="docs-heading-anchor" href="#Modification">Modification</a><a id="Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Modification" title="Permalink"></a></h2><p><code>InfiniteOpt</code> employs a wide variety of methods to modify/delete variables. These are comprised of <code>JuMP</code> extensions and methods native only to <code>InfiniteOpt</code>. This section will highlight some of the more commonly used ones. All of the methods/macros are detailed in the <a href="#var_methods">Methods/Macros</a> section (i.e., the manual) below.</p><h3 id="Deletion"><a class="docs-heading-anchor" href="#Deletion">Deletion</a><a id="Deletion-1"></a><a class="docs-heading-anchor-permalink" href="#Deletion" title="Permalink"></a></h3><p>Like <code>JuMP v0.19+</code>, <code>InfiniteOpt</code> fully supports deletion throughout its data types. Any variable and its dependencies can be deleted via <a href="#JuMP.delete-Tuple{InfiniteModel,Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>delete</code></a>. Thus, when <code>delete</code> is invoked any bound/type constraints associated with the variable will be removed and it will be removed from any other constraints, measures, and/or objectives. For example, if we delete <code>y(t, x)</code> it will be removed along with its bounds and the point variable <code>y0</code> will also be removed since it is a dependent:</p><pre><code class="language-julia-repl">julia&gt; delete(model, y)</code></pre><p>Another class of deletion methods correspond to variable constraints. For example, <a href="#JuMP.delete_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>delete_lower_bound</code></a> is used to delete a lower bound associated with a variable if it has one. Let&#39;s illustrate this by deleting the lower bound of <code>d</code>:</p><pre><code class="language-julia-repl">julia&gt; delete_lower_bound(d)

julia&gt; has_lower_bound(d)
false</code></pre><p>Other similar methods are <a href="#JuMP.delete_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>delete_upper_bound</code></a>, <a href="#JuMP.unfix-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>unfix</code></a>, <a href="#JuMP.unset_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>unset_binary</code></a>, and <a href="#JuMP.unset_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>unset_integer</code></a>.</p><p>Finally, <a href="#InfiniteOpt.delete_parameter_bounds-Tuple{HoldVariableRef}"><code>delete_parameter_bounds</code></a> can be used on hold variables to delete all of their parameter bounds. For example, let&#39;s delete all of the parameter bounds associated with <code>c</code>:</p><pre><code class="language-julia-repl">julia&gt; parameter_bounds(c)
Subdomain bounds (1): t ∈ [0, 5]

julia&gt; delete_parameter_bounds(c)

julia&gt; has_parameter_bounds(c)
false</code></pre><h3 id="Variable-Constraints"><a class="docs-heading-anchor" href="#Variable-Constraints">Variable Constraints</a><a id="Variable-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Constraints" title="Permalink"></a></h3><p>Another class of methods seek to add/modify variable constraints such as bounds. For example, <a href="../../JuMP/#JuMP.set_lower_bound-Tuple{VariableRef,Number}"><code>set_lower_bound</code></a> specifies the lower bound of a variable. We can add a lower bound of 0 to <code>c</code> by:</p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(c, 0)

julia&gt; lower_bound(c)
0.0</code></pre><p>Thus, adding a lower bound to <code>c</code>. Furthermore, we can later modify the lower bound using the same method:</p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(c, -2)

julia&gt; lower_bound(c)
-2.0</code></pre><p>Other similar methods are <a href="#JuMP.set_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>set_upper_bound</code></a>, <a href="#JuMP.fix-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>fix</code></a>, <a href="#JuMP.set_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>set_binary</code></a>, and <a href="#JuMP.set_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>set_integer</code></a>.</p><h3 id="Type-Specific-2"><a class="docs-heading-anchor" href="#Type-Specific-2">Type Specific</a><a class="docs-heading-anchor-permalink" href="#Type-Specific-2" title="Permalink"></a></h3><p>Finally, we consider methods unique to <code>InfiniteOpt</code> that exist to modify specific variable types.</p><p>For hold variables, the parameter bounds can be modified via <a href="#InfiniteOpt.@add_parameter_bounds"><code>@add_parameter_bounds</code></a> and <a href="#InfiniteOpt.@set_parameter_bounds"><code>@set_parameter_bounds</code></a> which facilitate an intuitive symbolic syntax to add and/or overwrite existing parameter bounds for a hold variable. For example, let&#39;s add the bounds <span>$t \in [0, 5]$</span> and <span>$x = 0$</span> to <code>c</code>:</p><pre><code class="language-julia-repl">julia&gt; @add_parameter_bounds(c, (t in [0, 5], x == 0))</code></pre><p>A number of other techniques exist for the various variable types can be found in  the manual below.</p><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.HoldVariable"><code>InfiniteOpt.HoldVariable</code></a></li><li><a href="#InfiniteOpt.HoldVariableIndex"><code>InfiniteOpt.HoldVariableIndex</code></a></li><li><a href="#InfiniteOpt.HoldVariableRef"><code>InfiniteOpt.HoldVariableRef</code></a></li><li><a href="#InfiniteOpt.InfOptVariable"><code>InfiniteOpt.InfOptVariable</code></a></li><li><a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteOpt.InfiniteVariable</code></a></li><li><a href="#InfiniteOpt.InfiniteVariableIndex"><code>InfiniteOpt.InfiniteVariableIndex</code></a></li><li><a href="#InfiniteOpt.InfiniteVariableRef"><code>InfiniteOpt.InfiniteVariableRef</code></a></li><li><a href="#InfiniteOpt.ParameterBounds"><code>InfiniteOpt.ParameterBounds</code></a></li><li><a href="#InfiniteOpt.PointVariable"><code>InfiniteOpt.PointVariable</code></a></li><li><a href="#InfiniteOpt.PointVariableIndex"><code>InfiniteOpt.PointVariableIndex</code></a></li><li><a href="#InfiniteOpt.PointVariableRef"><code>InfiniteOpt.PointVariableRef</code></a></li><li><a href="#InfiniteOpt.VariableData"><code>InfiniteOpt.VariableData</code></a></li><li><a href="#InfiniteOpt.Collections.VectorTuple"><code>InfiniteOpt.Collections.VectorTuple</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfOptVariable" href="#InfiniteOpt.InfOptVariable"><code>InfiniteOpt.InfOptVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfOptVariable &lt;: JuMP.AbstractVariable</code></pre><p>An abstract type for infinite, reduced, point, and hold variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL639-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteVariable" href="#InfiniteOpt.InfiniteVariable"><code>InfiniteOpt.InfiniteVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteVariable{P &lt;: GeneralVariableRef} &lt;: InfOptVariable</code></pre><p>A <code>DataType</code> for storing core infinite variable information. Note that indices that refer to the same dependent parameter group must be in the same tuple element. It is important to note that <code>info.start</code> should contain a start value function that generates the start value for a given infinite parameter support. This function should map a support to a start value using user-formatting if <code>is_vector_start = false</code>, otherwise it should do the mapping using a single support vector as input. Also, the variable reference type <code>P</code> must pertain to infinite parameters.</p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{Float64, Float64, Float64, Function}</code>: JuMP variable information.</li><li><code>parameter_refs::VectorTuple{P}</code>: The infinite parameter references that                                   parameterize the variable.</li><li><code>parameter_nums::Vector{Int}</code>: The parameter numbers of <code>parameter_refs</code>.</li><li><code>object_nums::Vector{Int}</code>: The parameter object numbers associated with <code>parameter_refs</code>.</li><li><code>is_vector_start::Bool</code>: Does the start function take support values formatted as vectors?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL646-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.PointVariable" href="#InfiniteOpt.PointVariable"><code>InfiniteOpt.PointVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointVariable{I &lt;: GeneralVariableRef} &lt;: InfOptVariable</code></pre><p>A <code>DataType</code> for storing point variable information. Note that the elements <code>parameter_values</code> field must match the format of the parameter reference tuple defined in <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a></p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{Float64, Float64, Float64, Float64}</code> JuMP Variable information.</li><li><code>infinite_variable_ref::I</code> The infinite variable/derivative reference   associated with the point variable.</li><li><code>parameter_values::Vector{Float64}</code> The infinite parameter values   defining the point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL696-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ParameterBounds" href="#InfiniteOpt.ParameterBounds"><code>InfiniteOpt.ParameterBounds</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParameterBounds{P &lt;: GeneralVariableRef}</code></pre><p>A <code>DataType</code> for storing intervaled bounds of parameters. This is used to define subdomains of <a href="#InfiniteOpt.HoldVariable"><code>HoldVariable</code></a>s and <a href="../constraint/#InfiniteOpt.BoundedScalarConstraint"><code>BoundedScalarConstraint</code></a>s. Note that the GeneralVariableRef must pertain to infinite parameters.</p><p><strong>Fields</strong></p><ul><li><code>intervals::Dict{GeneralVariableRef, IntervalSet}</code>: A dictionary of interval bounds on infinite parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL621-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.HoldVariable" href="#InfiniteOpt.HoldVariable"><code>InfiniteOpt.HoldVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HoldVariable{P &lt;: GeneralVariableRef} &lt;: InfOptVariable</code></pre><p>A <code>DataType</code> for storing hold variable information.</p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{Float64, Float64, Float64, Float64}</code> JuMP variable information.</li><li><code>parameter_bounds::ParameterBounds{P}</code> Valid parameter sub-domains</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL716-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.VariableData" href="#InfiniteOpt.VariableData"><code>InfiniteOpt.VariableData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VariableData{V &lt;: InfOptVariable} &lt;: AbstractDataObject</code></pre><p>A mutable <code>DataType</code> for storing <code>InfOptVariable</code>s and their data.</p><p><strong>Fields</strong></p><ul><li><code>variable::V</code>: The scalar variable.</li><li><code>name::String</code>: The name used for printing.</li><li><code>lower_bound_index::Union{ConstraintIndex, Nothing}</code>: Index of lower bound constraint.</li><li><code>upper_bound_index::Union{ConstraintIndex, Nothing}</code>: Index of upper bound constraint.</li><li><code>fix_index::Union{ConstraintIndex, Nothing}</code>: Index on fixing constraint.</li><li><code>zero_one_index::Union{ConstraintIndex, Nothing}</code>: Index of binary constraint.</li><li><code>integrality_index::Union{ConstraintIndex, Nothing}</code>: Index of integer constraint.</li><li><code>measure_indices::Vector{MeasureIndex}</code>: Indices of dependent measures.</li><li><code>constraint_indices::Vector{ConstraintIndex}</code>: Indices of dependent constraints.</li><li><code>in_objective::Bool</code>: Is this used in objective?</li><li><code>point_var_indices::Vector{PointVariableIndex}</code>: Indices of dependent point variables.</li><li><code>reduced_var_indices::Vector{ReducedVariableIndex}</code>: Indices of dependent reduced variables.</li><li><code>derivative_indices::Vector{DerivativeIndex}</code>: Indices of dependent derivatives.</li><li><code>deriv_constr_indices::Vector{ConstraintIndex}</code>: Indices of dependent derivative evaluation constraints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL730-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteVariableIndex" href="#InfiniteOpt.InfiniteVariableIndex"><code>InfiniteOpt.InfiniteVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL72-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.PointVariableIndex" href="#InfiniteOpt.PointVariableIndex"><code>InfiniteOpt.PointVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.PointVariable"><code>PointVariable</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.HoldVariableIndex" href="#InfiniteOpt.HoldVariableIndex"><code>InfiniteOpt.HoldVariableIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HoldVariableIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.HoldVariable"><code>HoldVariable</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.InfiniteVariableRef" href="#InfiniteOpt.InfiniteVariableRef"><code>InfiniteOpt.InfiniteVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InfiniteVariableRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for untranscripted infinite dimensional variable references (e.g., second stage variables, time dependent variables).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::InfiniteVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL1349-L1358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.PointVariableRef" href="#InfiniteOpt.PointVariableRef"><code>InfiniteOpt.PointVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointVariableRef &lt;: FiniteVariableRef</code></pre><p>A <code>DataType</code> for variables defined at a transcipted point (e.g., second stage variable at a particular scenario, dynamic variable at a discretized time point).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::PointVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL1422-L1431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.HoldVariableRef" href="#InfiniteOpt.HoldVariableRef"><code>InfiniteOpt.HoldVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HoldVariableRef &lt;: FiniteVariableRef</code></pre><p>A <code>DataType</code> for finite fixed variable references (e.g., first stage variables, steady-state variables).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::HoldVariableIndex</code>: Index of the variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/datatypes.jl#LL1437-L1446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Collections.VectorTuple" href="#InfiniteOpt.Collections.VectorTuple"><code>InfiniteOpt.Collections.VectorTuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorTuple{T}</code></pre><p>A collection DataType for storing a <code>Tuple</code> of singular elements of type <code>T</code> and/or <code>AbstractArray{&lt;:T}</code>s in a convenient vector form that utilizes linear indexing. Moreover <code>VectorTuple</code>s can be modified using standard vector operations such as <code>empty!</code>, <code>push!</code>, and <code>deleteat!</code>. <code>VectorTuple</code>s should be defined from an original tuple via <code>VectorTuple(tuple)</code> or by listing the tuple elements <code>VectorTuple(items...)</code>. Note this is still an experimental type and is primarily intended to store infinite parameter reference tuples and point variable support value tuples. Some of the notable capabilities are exemplified below.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tuple = (3, [-2, 4], ones(2, 2))
(3, [-2, 4], [1.0 1.0; 1.0 1.0])

julia&gt; vt = VectorTuple(tuple) # make by listing items (notice everything is a vector)
([3.0], [3.0, 4.0], [1.0, 1.0, 1.0, 1.0])

julia&gt; vt[2] # linear indexing
-2.0

julia&gt; vt[2, 2] # tuple indexing (note the second index is treated linearly)
4.0

julia&gt; vt[6:end] # linear slicing
2-element Array{Float64,1}:
 1.0
 1.0

julia&gt; vt[2:3, :] # tuple slicing
2-element Array{Array{Float64,1},1}:
 [-2.0, 4.0]
 [1.0, 1.0, 1.0, 1.0]

julia&gt; tuple2 = Tuple(vt) # rebuild original Tuple with original indices
([3.0], [-2.0, 4.0], [1.0 1.0; 1.0 1.0])

julia&gt; push!(vt, [42., 42]) # add new tuple element
([3.0], [-2.0, 4.0], [1.0, 1.0, 1.0, 1.0], [42.0, 42.0])

julia&gt; deleteat!(vt, 4) # delete an element via linear indexing
([3.0], [-2.0, 4.0], [1.0, 1.0, 1.0])

julia&gt; Tuple(vt) # The 3rd element becomes a SparseAxisArray because of deletion
([3.0], [-2.0, 4.0],   [1, 2]  =  1.0
  [2, 2]  =  1.0
  [2, 1]  =  1.0)

julia&gt; deleteat!(vt, 3, tuple_index = true) # delete a whole tuple element
([3.0], [-2.0, 4.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/Collections/VectorTuple.jl#LL1-L55">source</a></section></article><h2 id="var_methods"><a class="docs-heading-anchor" href="#var_methods">Methods/Macros</a><a id="var_methods-1"></a><a class="docs-heading-anchor-permalink" href="#var_methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.@add_parameter_bounds"><code>InfiniteOpt.@add_parameter_bounds</code></a></li><li><a href="#InfiniteOpt.@hold_variable"><code>InfiniteOpt.@hold_variable</code></a></li><li><a href="#InfiniteOpt.@infinite_variable"><code>InfiniteOpt.@infinite_variable</code></a></li><li><a href="#InfiniteOpt.@point_variable"><code>InfiniteOpt.@point_variable</code></a></li><li><a href="#InfiniteOpt.@set_parameter_bounds"><code>InfiniteOpt.@set_parameter_bounds</code></a></li><li><a href="#InfiniteOpt.add_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds{GeneralVariableRef}}"><code>InfiniteOpt.add_parameter_bounds</code></a></li><li><a href="#InfiniteOpt.delete_parameter_bounds-Tuple{HoldVariableRef}"><code>InfiniteOpt.delete_parameter_bounds</code></a></li><li><a href="#InfiniteOpt.has_parameter_bounds-Tuple{HoldVariableRef}"><code>InfiniteOpt.has_parameter_bounds</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.parameter_bounds-Tuple{HoldVariableRef}"><code>InfiniteOpt.parameter_bounds</code></a></li><li><a href="#InfiniteOpt.parameter_list-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.parameter_values</code></a></li><li><a href="#InfiniteOpt.raw_parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a></li><li><a href="#InfiniteOpt.raw_parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.raw_parameter_values</code></a></li><li><a href="#InfiniteOpt.reset_start_value_function-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.reset_start_value_function</code></a></li><li><a href="#InfiniteOpt.set_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds{GeneralVariableRef}}"><code>InfiniteOpt.set_parameter_bounds</code></a></li><li><a href="#InfiniteOpt.set_start_value_function-Tuple{InfiniteVariableRef,Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a></li><li><a href="#InfiniteOpt.start_value_function-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.start_value_function</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#InfiniteOpt.used_by_point_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.used_by_point_variable</code></a></li><li><a href="#InfiniteOpt.used_by_reduced_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.used_by_reduced_variable</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.add_variable-Tuple{InfiniteModel,InfOptVariable,String}"><code>JuMP.add_variable</code></a></li><li><a href="#JuMP.all_variables-Tuple{InfiniteModel,Type{InfOptVariable}}"><code>JuMP.all_variables</code></a></li><li><a href="#JuMP.build_variable-Tuple{Function,VariableInfo,Type{#s38} where #s38&lt;:InfOptVariableType}"><code>JuMP.build_variable</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_lower_bound</code></a></li><li><a href="#JuMP.delete_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_upper_bound</code></a></li><li><a href="#JuMP.fix-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.fix</code></a></li><li><a href="#JuMP.fix_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.is_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_fixed-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.name-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>JuMP.name</code></a></li><li><a href="#JuMP.num_variables-Tuple{InfiniteModel,Type{InfOptVariable}}"><code>JuMP.num_variables</code></a></li><li><a href="#JuMP.relax_integrality-Tuple{InfiniteModel}"><code>JuMP.relax_integrality</code></a></li><li><a href="#JuMP.set_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_binary</code></a></li><li><a href="#JuMP.set_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_integer</code></a></li><li><a href="#JuMP.set_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_lower_bound</code></a></li><li><a href="#JuMP.set_name-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef},String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_start_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_start_value</code></a></li><li><a href="#JuMP.set_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_upper_bound</code></a></li><li><a href="#JuMP.start_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.start_value</code></a></li><li><a href="#JuMP.unfix-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unfix</code></a></li><li><a href="#JuMP.unset_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_binary</code></a></li><li><a href="#JuMP.unset_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_integer</code></a></li><li><a href="#JuMP.upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>JuMP.variable_by_name</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@infinite_variable" href="#InfiniteOpt.@infinite_variable"><code>InfiniteOpt.@infinite_variable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@infinte_variable(model::InfiniteModel, kw_args...)::GeneralVariableRef</code></pre><p>Add an <em>anonymous</em> infinite variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable reference. Note that the <code>parameter_refs</code> keyword is required in this case.</p><pre><code class="language-julia">@infinite_variable(model::InfiniteModel, varexpr, args...,
                   kw_args...)::GeneralVariableRef</code></pre><p>Add an infinite variable to <code>model</code> described by the expression <code>var_expr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. The expression <code>varexpr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>) of the form:</p><ul><li><code>varexpr</code> creating variables described by <code>varexpr</code></li><li><code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>The expression <code>varexpr</code> can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of name <code>varname</code></li><li><code>varname(params...)</code> creating a scalar real variable of name <code>varname</code> with infinite parameters <code>params...</code> see <code>parameter_refs</code> for format.</li><li><code>varname[...]</code> or <code>[...]</code> creating a container of variables.</li><li><code>varname[...](params...)</code> or <code>[...]</code> creating a container of variables with infinite parameters <code>params...</code> in the first case.</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>parameter_refs</code>: This is mandatory if not specified in <code>varexpr</code>. Can be a single parameter reference, a single parameter array with parameters defined in the same call of <a href="../parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a>, or a tuple where each element is either of the first two options listed.</li><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>. Furthermore, the parameter reference tuple is appended on the end of the name i.e., <code>base_name(params...)</code> or <code>base_name[...](params...)</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.          This can be a single value enforced over the entire infinite variable          domain or it can be a function that maps a support value to a scalar          guess value. Note that the function arguments must match the format          of <code>parameter_refs</code>.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 1])
t

julia&gt; @infinite_parameter(model, w[1:2] in Normal())
2-element Array{GeneralVariableRef,1}:
 w[1]
 w[2]

julia&gt; @infinite_variable(model, x(t, w) &gt;= 0)
x(t, w)

julia&gt; x = @infinite_variable(model, parameter_refs = (t, w), base_name = &quot;x&quot;,
                              lower_bound = 0)
x(t, w)

julia&gt; lb = [0, 1]; ub = [10, 12];

julia&gt; @infinite_variable(model, lb[i] &lt;= y[i = 1:2](t) &lt;= ub[i], Int)
2-element Array{GeneralVariableRef,1}:
 y[1](t)
 y[2](t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/macros.jl#LL769-L854">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@point_variable" href="#InfiniteOpt.@point_variable"><code>InfiniteOpt.@point_variable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@point_variable(model::InfiniteModel, kw_args...)::GeneralVariableRef</code></pre><p>Add an <em>anonymous</em> point variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable reference. Note that the <code>infinite_variable_ref</code> and <code>parameter_values</code> keywords are required in this case.</p><pre><code class="language-julia">@point_variable(model::InfiniteModel, infvarexpr, varexpr, args...,
                kw_args...)::GeneralVariableRef</code></pre><p>Add a point variable to <code>model</code> described by the expression <code>varexpr</code>, the positional arguments <code>args</code>, and the keyword arguments <code>kw_args</code> and the infinite variable expr <code>infvarexpr</code>. The expression <code>infvarexpr</code> specifies the infinite variable this point variable corresponds to and the values at which the parameters are evaluated and must be of the form: <code>infvar(param_values...)</code> where the parameter values <code>param_values...</code> are listed in the same format as they are in the definition of <code>infvar</code>. The expression <code>varexpr</code> is used to define variable specific bounds and whose name is used as an alias for the point variable which is simply the infinite variable evaluated at the values indicated. The expression <code>varexpr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>) of the form:</p><ul><li><code>varexpr</code> creating variables described by <code>varexpr</code></li><li><code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>Note that by default a point variable inherits all of the same properties as the infinite variable it corresponds to, but that these can be overwritten by specifying properties such as lower bounds, fix values, etc.</p><p>The expression <code>varexpr</code> can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of alias name <code>varname</code></li><li><code>varname[...]</code> or <code>[...]</code> creating a container of variables.</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>infinite_variable_ref</code>: Sets the infinite variable reference that the point variable is associated with.</li><li><code>parameter_values</code>: Sets the values of the infinite parameters of the infinite variable at which this poitn variable is evaluated at. MUST be of the SAME FORMAT of that specified for the parameters in the definition of the infinite variable.</li><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>. This serves as the alias for <code>infvarexpr</code> (the infinite variable evaluated at particular parameter values).</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 1])
t

julia&gt; @infinite_parameter(model, w[1:2] in Normal())
2-element Array{GeneralVariableRef,1}:
 w[1]
 w[2]

julia&gt; @infinite_variable(model, x(t, w) &gt;= 0)
x(t, w)

julia&gt; @point_variable(model, x(0, [0, 0]), x0 &lt;= 1)
x0

julia&gt; x0 = @point_variable(model, x(0, [0, 0]), upper_bound = 1, base_name = &quot;x0&quot;)
x0

julia&gt; x0 = @point_variable(model, upper_bound = 1, base_name = &quot;x0&quot;,
                            infinite_variable_ref = x, parameter_values = (0, [0, 0]))
x0

julia&gt; @point_variable(model, x([0, 1][i], [0, 0]), xf[i = 1:2])
2-element Array{GeneralVariableRef,1}:
 xf[1]
 xf[2]

julia&gt; lb = [0, 1]; ub = [10, 12];

julia&gt; @infinite_variable(model, lb[i] &lt;= y[i = 1:2](t) &lt;= ub[i], Int)
2-element Array{GeneralVariableRef,1}:
 y[1](t)
 y[2](t)

julia&gt; @point_variable(model, y[i](0), y0[i = 1:2], Bin)
2-element Array{GeneralVariableRef,1}:
 y0[1]
 y0[2]

julia&gt; y0 = @point_variable(model, [i = 1:2], binary = true, base_name = &quot;y0&quot;,
                             infinite_variable_ref = y[i], parameter_values = 0)
2-element Array{GeneralVariableRef,1}:
 y0[1]
 y0[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/macros.jl#LL933-L1047">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@hold_variable" href="#InfiniteOpt.@hold_variable"><code>InfiniteOpt.@hold_variable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@hold_variable(model::InfiniteModel, kw_args...)::GeneralVariableRef</code></pre><p>Add an <em>anonymous</em> hold variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable reference.</p><pre><code class="language-julia">@hold_variable(model::InfiniteModel, varexpr, args...,
               kw_args...)::GeneralVariableRef</code></pre><p>Add a hold variable to <code>model</code> described by the expression <code>varexpr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. The expression <code>varexpr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>) of the form:</p><ul><li><code>varexpr</code> creating variables described by <code>varexpr</code></li><li><code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>The expression <code>varexpr</code> can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of name <code>varname</code></li><li><code>varname[...]</code> or <code>[...]</code> creating a container of variables.</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li></ul><p>Specifiying a hold variable which applies only to sub-domain of the model&#39;s infinite parameter(s) domain can be done via the <code>parameter_bounds</code> keyword argument. It is specified as a tuple of parameter bound expressions which can be of the form:</p><ul><li><code>(param in [lb, ub], ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code> (note <code>∈</code> can be used in place of <code>in</code>)</li><li><code>(params in [lb, ub], ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(lb &lt;= param &lt;= ub, ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code></li><li><code>(lb &lt;= params &lt;= ub, ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(param == value, ...)</code> enforcing <code>param</code> to be equal to <code>value</code></li><li><code>(params == value, ...)</code> enforcing that all parameter references in <code>params</code>                           each to be equal to <code>value</code></li><li>Any combination of the above forms. Must be inside parentheses and comma separated.</li></ul><p>Please note that when specifying value conditions on dependent infinite parameters, a value must be provided for each parameter in the dependent container otherwise an error will be thrown.</p><p>The other recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @hold_variable(model, x)
x

julia&gt; @hold_variable(model, 0 &lt;= y &lt;= 4, Bin)
y

julia&gt; y = @hold_variable(model, lower_bound = 0, upper_bound = 4,
                            binary = true, base_name = &quot;y&quot;)
y

julia&gt; @hold_variable(model, z[2:3] == 0)
1-dimensional DenseAxisArray{GeneralVariableRef,1,...} with index sets:
    Dimension 1, 2:3
And data, a 2-element Array{GeneralVariableRef,1}:
 z[2]
 z[3]

julia&gt; @hold_variable(model, d, parameter_bounds = (t in [0, 5]))
d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/macros.jl#LL1099-L1191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function,VariableInfo,Type{#s38} where #s38&lt;:InfOptVariableType}" href="#JuMP.build_variable-Tuple{Function,VariableInfo,Type{#s38} where #s38&lt;:InfOptVariableType}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, info::JuMP.VariableInfo,
                    var_type::Type{&lt;:InfOptVariableType};
                    [parameter_refs::Union{GeneralVariableRef,
                                          AbstractArray{&lt;:GeneralVariableRef},
                                          Tuple, Nothing} = nothing,
                    infinite_variable_ref::Union{GeneralVariableRef,
                                                 Nothing} = nothing,
                    parameter_values::Union{Number, AbstractArray{&lt;:Real},
                                            Tuple, Nothing} = nothing,
                    parameter_bounds::Union{ParameterBounds{GeneralVariableRef},
                                            Nothing} = nothing]
                    )::InfOptVariable</code></pre><p>Extend the <code>JuMP.build_variable</code> function to accomodate <code>InfiniteOpt</code> variable types. Returns the appropriate variable Datatype (i.e., <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a>, <a href="#InfiniteOpt.PointVariable"><code>PointVariable</code></a>, and <a href="#InfiniteOpt.HoldVariable"><code>HoldVariable</code></a>). Primarily, this method is to be used internally by the appropriate constructor macros <a href="#InfiniteOpt.@infinite_variable"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a>. However, it can be called manually to build <code>InfiniteOpt</code> variables. Errors if an unneeded keyword argument is given or if the keywoard arguments are formatted incorrectly (e.g., <code>parameter_refs</code> contains repeated parameter references when an infinite variable is defined). Also errors if needed keyword arguments are negated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @independent_parameter(m, t in [0, 1])
t

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);

julia&gt; inf_var = build_variable(error, info, Infinite, parameter_refs = t)
InfiniteVariable{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Function}(false, 0.0, false, 0.0, false, 0.0, false, start_func, false, false), (t,), Int64[], Int64[], true)

julia&gt; ivref = add_variable(m, inf_var, &quot;var_name&quot;)
var_name(t)

julia&gt; pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,
                               parameter_values = 0.5)
PointVariable{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Float64}(false, 0.0, false, 0.0, false, 0.0, true, 0.0, false, false), var_name(t), [0.5])

julia&gt; hd_var = build_variable(error, info, Hold)
HoldVariable{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Float64}(false, 0.0, false, 0.0, false, 0.0, false, 0.0, false, false), Subdomain bounds (0): )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL18-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_variable-Tuple{InfiniteModel,InfOptVariable,String}" href="#JuMP.add_variable-Tuple{InfiniteModel,InfOptVariable,String}"><code>JuMP.add_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.add_variable(model::InfiniteModel, var::InfOptVariable,
                  [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Extend the <a href="../../JuMP/#JuMP.add_variable"><code>JuMP.add_variable</code></a> function to accomodate <code>InfiniteOpt</code> variable types. Adds a variable to an infinite model <code>model</code> and returns a <a href="../expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a>. Primarily intended to be an internal function of the constructor macros <a href="#InfiniteOpt.@infinite_variable"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a>. However, it can be used in combination with <a href="../measure/#JuMP.build_variable-Tuple{Function,GeneralVariableRef,Dict{Int64,Float64}}"><code>JuMP.build_variable</code></a> to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in <code>var</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 10]);

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, true, 0, false, false);

julia&gt; inf_var = build_variable(error, info, Infinite, parameter_refs = t);

julia&gt; ivref = add_variable(m, inf_var, &quot;var_name&quot;)
var_name(t)

julia&gt; pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,
                               parameter_values = 0.5);

julia&gt; pvref = add_variable(m, pt_var, &quot;var_alias&quot;)
var_alias

julia&gt; hd_var = build_variable(error, info, Hold);

julia&gt; hvref = add_variable(m, hd_var, &quot;var_name&quot;)
var_name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL114-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}" href="#InfiniteOpt.used_by_constraint-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(vref::DecisionVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_constraint(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL188-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}" href="#InfiniteOpt.used_by_measure-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(vref::DecisionVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_measure(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL173-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}" href="#InfiniteOpt.used_by_objective-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_objective(vref::DecisionVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_objective(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL203-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}" href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(vref::DecisionVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL218-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_point_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}" href="#InfiniteOpt.used_by_point_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.used_by_point_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_point_variable(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a point variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_point_variable(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL244-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_reduced_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}" href="#InfiniteOpt.used_by_reduced_variable-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.used_by_reduced_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_reduced_variable(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a reduced infinite variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; used_by_reduced_variable(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL229-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{Union{DerivativeRef, InfiniteVariableRef}}" href="#InfiniteOpt.is_used-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(vref::Union{InfiniteVariableRef, DerivativeRef})::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_used(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL274-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}" href="#JuMP.delete-Tuple{InfiniteModel,Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, vref::DecisionVariableRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete <code>InfiniteOpt</code> variables and their dependencies. Errors if variable is invalid, meaning it has already been deleted or it belongs to another model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z ≥ 0.0
 g(t) + z ≥ 42.0, ∀ t ∈ [0, 6]
 g(0.5) = 0

julia&gt; delete(model, g)

julia&gt; print(model)
Min measure(t) + z
Subject to
 z ≥ 0.0
 z ≥ 42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL1164-L1188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_variables-Tuple{InfiniteModel,Type{InfOptVariable}}" href="#JuMP.num_variables-Tuple{InfiniteModel,Type{InfOptVariable}}"><code>JuMP.num_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.num_variables(model::InfiniteModel,
                   [type::Type{InfOptVariable} = InfOptVariable])::Int</code></pre><p>Extend <a href="../../JuMP/#JuMP.num_variables-Tuple{Model}"><code>JuMP.num_variables</code></a> to return the number of <code>InfiniteOpt</code> variables assigned to <code>model</code>. By default, the total number of infinite, reduced, point, and hold variables is returned. The amount of a particular type is obtained by specifying the concrete variable type of <a href="#InfiniteOpt.InfOptVariable"><code>InfOptVariable</code></a> via <code>type</code>. Type options include:</p><ul><li><code>InfOptVariable</code>: all variables</li><li><code>InfiniteVariable</code>: all infinite variables</li><li><code>ReducedVariable</code>: all reduced variables</li><li><code>PointVariable</code>: all point variables</li><li><code>HoldVariable</code>: all hold variables</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_variables(model)
3

julia&gt; num_variables(model, InfiniteVariable)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL1050-L1073">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_variables-Tuple{InfiniteModel,Type{InfOptVariable}}" href="#JuMP.all_variables-Tuple{InfiniteModel,Type{InfOptVariable}}"><code>JuMP.all_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.all_variables(model::InfiniteModel,
                   type::Type{InfOptVariable} = InfOptVariable
                   )::Vector{GeneralVariableRef}</code></pre><p>Extend <a href="../../JuMP/#JuMP.all_variables-Tuple{Model}"><code>JuMP.all_variables</code></a> to return a list of all the variable references associated with <code>model</code>. By default, all of the infinite, reduced, point, and hold variables is returned. Those of a particular type is obtained by specifying the concrete variable type of <a href="#InfiniteOpt.InfOptVariable"><code>InfOptVariable</code></a> via <code>type</code>. Type options include:</p><ul><li><code>InfOptVariable</code>: all variables</li><li><code>InfiniteVariable</code>: all infinite variables</li><li><code>ReducedVariable</code>: all reduced variables</li><li><code>PointVariable</code>: all point variables</li><li><code>HoldVariable</code>: all hold variables</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all_variables(model)
4-element Array{GeneralVariableRef,1}:
 y(t)
 w(t, x)
 y(0)
 z

julia&gt; all_variables(model, PointVariable)
1-element Array{GeneralVariableRef,1}:
 y(0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL1090-L1119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}" href="#JuMP.name-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef}}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(vref::DecisionVariableRef)::String</code></pre><p>Extend <a href="../../JuMP/#JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> to return the names of <code>InfiniteOpt</code> variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; name(vref)
&quot;var_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL236-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef},String}" href="#JuMP.set_name-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef, ReducedVariableRef},String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(vref::DecisionVariableRef, name::String)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> to set names of decision variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_name(vref, &quot;var_name&quot;)

julia&gt; name(vref)
&quot;var_name&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL253-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.variable_by_name-Tuple{InfiniteModel,String}" href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>JuMP.variable_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.variable_by_name(model::InfiniteModel,
                      name::String)::Union{GeneralVariableRef, Nothing}</code></pre><p>Extend <a href="../../JuMP/#JuMP.variable_by_name-Tuple{Model,String}"><code>JuMP.variable_by_name</code></a> for <code>InfiniteModel</code> objects. Return the variable reference assoociated with a variable name. Errors if multiple variables have the same name. Returns nothing if no such name exists.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; variable_by_name(m, &quot;var_name&quot;)
var_name

julia&gt; variable_by_name(m, &quot;fake_name&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL298-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.has_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a> to return a <code>Bool</code> whether an <code>InfiniteOpt</code> variable has a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_lower_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL367-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(vref::UserDecisionVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a> to return the lower bound of an <code>InfiniteOpt</code> variable. Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; lower_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL381-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}" href="#JuMP.set_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_lower_bound(vref::UserDecisionVariableRef, lower::Real)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_lower_bound-Tuple{VariableRef,Number}"><code>JuMP.set_lower_bound</code></a> to specify the lower bound of an <code>InfiniteOpt</code> variable <code>vref</code>. Errors if <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_lower_bound(vref, -1)

julia&gt; lower_bound(vref)
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL416-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.LowerBoundRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>JuMP.LowerBoundRef</code></a> to extract a constraint reference for the lower bound of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">var ≥ 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL456-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.delete_lower_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete_lower_bound(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete_lower_bound-Tuple{VariableRef}"><code>JuMP.delete_lower_bound</code></a> to delete lower bound of <code>vref</code>. Errors if it doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_lower_bound(vref)

julia&gt; has_lower_bound(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL473-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.has_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a> to return a <code>Bool</code> whether an <code>InfiniteOpt</code> variable has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_upper_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL499-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(vref::UserDecisionVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> to return the upper bound of an <code>InfiniteOpt</code> variable. Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; upper_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL513-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}" href="#JuMP.set_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_upper_bound(vref::UserDecisionVariableRef, upper::Real)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_upper_bound-Tuple{VariableRef,Number}"><code>JuMP.set_upper_bound</code></a> to specify the upper bound of an <code>InfiniteOpt</code> variable <code>vref</code>. Errors if <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_upper_bound(vref, 1)

julia&gt; upper_bound(vref)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL547-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.UpperBoundRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>JuMP.UpperBoundRef</code></a> to extract a constraint reference for the upper bound of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = UpperBoundRef(vref)
var ≤ 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL587-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.delete_upper_bound-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete_upper_bound(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete_upper_bound-Tuple{VariableRef}"><code>JuMP.delete_upper_bound</code></a> to delete the upper bound of <code>vref</code>. Errors if it doesn&#39;t have an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; delete_upper_bound(vref)

julia&gt; has_upper_bound(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL605-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_fixed-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_fixed(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_fixed-Tuple{VariableRef}"><code>JuMP.is_fixed</code></a> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_fixed(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL631-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.fix_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix_value(vref::UserDecisionVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.fix_value-Tuple{VariableRef}"><code>JuMP.fix_value</code></a> to return the fix value of an <code>InfiniteOpt</code> variable. Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fix_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL645-L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}" href="#JuMP.fix-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.fix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix(vref::UserDecisionVariableRef, value::Real;
         force::Bool = false)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.fix-Tuple{VariableRef,Number}"><code>JuMP.fix</code></a> to fix the value of an <code>InfiniteOpt</code> variable. Errors if variable has a lower and/or an upper bound(s) unless <code>force = true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fix(vref, 3)

julia&gt; fix_value(vref)
3.0

julia&gt; fix(vref2, 2, force = true)

julia&gt; fix_value(vref2)
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL679-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.FixRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.FixRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.FixRef-Tuple{VariableRef}"><code>JuMP.FixRef</code></a> to return the constraint reference of the fix constraint associated with <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cref = FixRef(vref)
var = 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL738-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unfix-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unfix-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unfix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.unfix(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.unfix-Tuple{VariableRef}"><code>JuMP.unfix</code></a> to unfix <code>vref</code>. Errors if it is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; unfix(vref)

julia&gt; is_fixed(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL757-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.start_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.start_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.start_value(vref::UserDecisionVariableRef)::Union{Nothing, Float64}</code></pre><p>Extend <a href="../../JuMP/#JuMP.start_value-Tuple{VariableRef}"><code>JuMP.start_value</code></a> to return starting value of <code>InfiniteOpt</code> variable if it has one. Returns <code>nothing</code> otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; start_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL783-L794">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_start_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}" href="#JuMP.set_start_value-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef},Real}"><code>JuMP.set_start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_start_value(vref::UserDecisionVariableRef, value::Real)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_start_value-Tuple{VariableRef,Number}"><code>JuMP.set_start_value</code></a> to specify the start value of <code>InfiniteOpt</code> variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_start_value(vref, 1)

julia&gt; start_value(vref)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL803-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.start_value_function-Tuple{Union{DerivativeRef, InfiniteVariableRef}}" href="#InfiniteOpt.start_value_function-Tuple{Union{DerivativeRef, InfiniteVariableRef}}"><code>InfiniteOpt.start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_value_function(vref::Union{InfiniteVariableRef, DerivativeRef})::Union{Nothing, Function}</code></pre><p>Return the function that is used to generate the start values of <code>vref</code> for particular support values. Returns <code>nothing</code> if no start behavior has been specified.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; start_value_function(vref)
my_start_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL390-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_start_value_function-Tuple{InfiniteVariableRef,Union{Function, Real}}" href="#InfiniteOpt.set_start_value_function-Tuple{InfiniteVariableRef,Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_start_value_function(vref::InfiniteVariableRef,
                         start::Union{Real, Function})::Nothing</code></pre><p>Set the start value function of <code>vref</code>. If <code>start::Real</code> then a function is generated to such that the start value will be <code>start</code> for the entire infinite domain. If <code>start::Function</code> then this function should map to a scalar start value given a support value arguments matching the format of the parameter elements in <code>parameter_refs(vref)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_start_value_function(vref, 1) # all start values will be 1

julia&gt; set_start_value_function(vref, my_func) # each value will be made via my_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL411-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.reset_start_value_function-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.reset_start_value_function-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.reset_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_start_value_function(vref::InfiniteVariableRef)::Nothing</code></pre><p>Remove the existing start value function and return to the default. Generally, this is triggered by deleting an infinite parameter that <code>vref</code> depends on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; reset_start_value_function(vref)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL444-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_binary(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_binary-Tuple{VariableRef}"><code>JuMP.is_binary</code></a> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is binary.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL830-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.set_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_binary(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_binary-Tuple{VariableRef}"><code>JuMP.set_binary</code></a> to specify an <code>InfiniteOpt</code> variable as a binary variable. Errors if <code>vref</code> is an integer variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_binary(vref)

julia&gt; is_binary(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL858-L872">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.BinaryRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.BinaryRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.BinaryRef-Tuple{VariableRef}"><code>JuMP.BinaryRef</code></a> to return a constraint reference to the constraint constrainting <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL894-L906">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unset_binary-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.unset_binary(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.unset_binary-Tuple{VariableRef}"><code>JuMP.unset_binary</code></a> to unset <code>vref</code> as a binary variable. Errors if it is not binary.</p><pre><code class="language-julia-repl">julia&gt; unset_binary(vref)

julia&gt; is_binary(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL913-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_integer(vref::UserDecisionVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_integer-Tuple{VariableRef}"><code>JuMP.is_integer</code></a> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is integer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL938-L949">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.set_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_integer(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_integer-Tuple{VariableRef}"><code>JuMP.set_integer</code></a> to specify an <code>InfiniteOpt</code> variable as a integer variable. Errors if <code>vref</code> is an binary variable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_integer(vref)

julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL967-L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.IntegerRef-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.IntegerRef(vref::UserDecisionVariableRef)::InfOptConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.IntegerRef-Tuple{VariableRef}"><code>JuMP.IntegerRef</code></a> to return a constraint reference to the constraint constrainting <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL1003-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unset_integer-Tuple{Union{DerivativeRef, HoldVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.unset_integer(vref::UserDecisionVariableRef)::Nothing</code></pre><p>Extend <a href="../../JuMP/#JuMP.unset_integer-Tuple{VariableRef}"><code>JuMP.unset_integer</code></a> to unset <code>vref</code> as an integer variable. Errors if it is not an integer variable.</p><pre><code class="language-julia-repl">julia&gt; unset_integer(vref)

julia&gt; is_integer(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL1022-L1034">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(vref::InfiniteVariableRef)::Tuple</code></pre><p>Return the parameter references associated with the infinite variable <code>vref</code>. This is formatted as a Tuple of containing the parameter references as they inputted to define <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, T(t))
T(t)

julia&gt; parameter_refs(T)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL322-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.parameter_list-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(vref::InfiniteVariableRef)::Vector{GeneralVariableRef}</code></pre><p>Return a vector of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL342-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(vref::InfiniteVariableRef)::VectorTuple{GeneralVariableRef}</code></pre><p>Return the raw <a href="#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the parameter references that <code>vref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/infinite_variables.jl#LL310-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@set_parameter_bounds" href="#InfiniteOpt.@set_parameter_bounds"><code>InfiniteOpt.@set_parameter_bounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@set_parameter_bounds(ref, bound_expr; [force::Bool = false])::Nothing</code></pre><p>Specify new parameter bounds for a constraint reference or hold variable reference <code>ref</code>. These bounds correspond to bounding a constraint in an equivalent way to using <a href="../constraint/#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a> or to limiting the scope of a hold variable in an equivalent way to using the <code>parameter_bounds</code> keyword argument in <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a>. Here <code>(bound_expr)</code> can be of the form:</p><ul><li><code>(param in [lb, ub], ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code> (note <code>∈</code> can be used in place of <code>in</code>)</li><li><code>(params in [lb, ub], ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(lb &lt;= param &lt;= ub, ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code></li><li><code>(lb &lt;= params &lt;= ub, ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(param == value, ...)</code> enforcing <code>param</code> to be equal to <code>value</code></li><li><code>(params == value, ...)</code> enforcing that all parameter references in <code>params</code>                           each to be equal to <code>value</code></li><li>Any combination of the above forms. Must be inside parentheses and comma separated.</li></ul><p>Please note that when specifying value conditions on dependent infinite parameters, a value must be provided for each parameter in the dependent container otherwise an error will be thrown.</p><p>Errors if the constraint or variable corresponding to <code>ref</code> already has bounds. However, using <code>force = true</code> can be used ignore the current bounds and overwrite them with new ones. Also, note that bounds on dependent constraints of hold variables will be updated to account for changes in hold variable bounds.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_variable(model, x(t))
x(t)

julia&gt; @hold_variable(model, y)
y

julia&gt; @constraint(model, con, x + y == 0)
con : x(t) + y = 0.0, ∀ t ∈ [0, 10]

julia&gt; @set_parameter_bounds(y, t in [0, 5])

julia&gt; con
con : x(t) + y = 0.0, ∀ t ∈ [0, 5]

julia&gt; @set_parameter_bounds(con, t == 0, force = true)

julia&gt; con
con : x(t) + y = 0.0, ∀ t = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/macros.jl#LL1651-L1707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@add_parameter_bounds" href="#InfiniteOpt.@add_parameter_bounds"><code>InfiniteOpt.@add_parameter_bounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@add_parameter_bounds(ref, bound_expr)::Nothing</code></pre><p>Add new parameter bounds for a constraint reference or hold variable reference <code>ref</code>. These bounds correspond to bounding a constraint in an equivalent way to using <a href="../constraint/#InfiniteOpt.@BDconstraint"><code>@BDconstraint</code></a> or to limiting the scope of a hold variable in an equivalent way to using the <code>parameter_bounds</code> keyword argument in <a href="#InfiniteOpt.@hold_variable"><code>@hold_variable</code></a>. Here <code>(bound_expr)</code> can be of the form:</p><ul><li><code>(param in [lb, ub], ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code> (note <code>∈</code> can be used in place of <code>in</code>)</li><li><code>(params in [lb, ub], ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(lb &lt;= param &lt;= ub, ...)</code> enforcing <code>param</code> to be in a sub-domain from <code>lb</code>                            to <code>ub</code></li><li><code>(lb &lt;= params &lt;= ub, ...)</code> enforcing that all parameter references in <code>params</code>                             each be a in sub-domain from <code>lb</code> to <code>ub</code></li><li><code>(param == value, ...)</code> enforcing <code>param</code> to be equal to <code>value</code></li><li><code>(params == value, ...)</code> enforcing that all parameter references in <code>params</code>                           each to be equal to <code>value</code></li><li>Any combination of the above forms. Must be inside parentheses and comma separated.</li></ul><p>Please note that when specifying value conditions on dependent infinite parameters, a value must be provided for each parameter in the dependent container otherwise an error will be thrown.</p><p>Errors if the new bounds cause irreconcilable differences with existing measures and constraints. For example, this occurs when adding hold variable bounds that are outside the domain of a bounded constraint that uses that hold variable. Also, note that bounds on dependent constraints of hold variables will be updated to account for changes in hold variable bounds.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_parameter(model, q in [-2, 2])
q

julia&gt; @infinite_variable(model, x(t, q))
x(t, q)

julia&gt; @hold_variable(model, y)
y

julia&gt; @constraint(model, con, x + y == 0)
con : x(t, q) + y = 0.0, ∀ t ∈ [0, 10], q ∈ [-2, 2]

julia&gt; @add_parameter_bounds(y, t in [0, 5])

julia&gt; con
con : x(t, q) + y = 0.0, ∀ t ∈ [0, 5]

julia&gt; @add_parameter_bounds(con, q == 0)

julia&gt; con
con : x(t, q) + y = 0.0, ∀ t ∈ [0, 5], q = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/macros.jl#LL1735-L1795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.has_parameter_bounds-Tuple{HoldVariableRef}" href="#InfiniteOpt.has_parameter_bounds-Tuple{HoldVariableRef}"><code>InfiniteOpt.has_parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_parameter_bounds(vref::HoldVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is limited to a sub-domain as defined by parameter bound.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @hold_variable(model, vref, parameter_bounds = (t in [0, 2]))
vref

julia&gt; has_parameter_bounds(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/hold_variables.jl#LL189-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_bounds-Tuple{HoldVariableRef}" href="#InfiniteOpt.parameter_bounds-Tuple{HoldVariableRef}"><code>InfiniteOpt.parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_bounds(vref::HoldVariableRef)::ParameterBounds</code></pre><p>Return the <a href="#InfiniteOpt.ParameterBounds"><code>ParameterBounds</code></a> object associated with the hold variable <code>vref</code>. It contains a dictionary where each key is a parameter reference which points to an <code>IntervalSet</code> that that defines a sub-domain for <code>vref</code> relative to that parameter reference.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @hold_variable(model, vref, parameter_bounds = (t in [0, 2]))
vref

julia&gt; parameter_bounds(vref)
Subdomain bounds (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/hold_variables.jl#LL164-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds{GeneralVariableRef}}" href="#InfiniteOpt.set_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds{GeneralVariableRef}}"><code>InfiniteOpt.set_parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_parameter_bounds(vref::HoldVariableRef,
                     bounds::ParameterBounds{GeneralVariableRef};
                     [force::Bool = false])::Nothing</code></pre><p>Specify a new dictionary of parameter bounds <code>bounds</code> for the hold variable <code>vref</code>. These are stored in a <a href="#InfiniteOpt.ParameterBounds"><code>ParameterBounds</code></a> object which contains a dictionary. Note the dictionary keys must be infinite parameter references and the values must be <code>IntervalSet</code>s that indicate a particular sub-domain for which <code>vref</code> is defined. This is meant to be primarily used by <a href="#InfiniteOpt.@set_parameter_bounds"><code>@set_parameter_bounds</code></a> which provides a more intuitive syntax.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @hold_variable(model, vref)
vref

julia&gt; set_parameter_bounds(vref, ParameterBounds(Dict(t =&gt; IntervalSet(0, 2))))

julia&gt; parameter_bounds(vref)
Subdomain bounds (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/hold_variables.jl#LL342-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds{GeneralVariableRef}}" href="#InfiniteOpt.add_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds{GeneralVariableRef}}"><code>InfiniteOpt.add_parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_parameter_bounds(vref::HoldVariableRef,
                     new_bounds::ParameterBounds{GeneralVariableRef}
                     )::Nothing</code></pre><p>Add additional parameter bounds to <code>vref</code> such that it is defined over the sub-domain based on the intersection of the existing bounds and <code>new_bounds</code>. This is primarily meant to be used by <a href="#InfiniteOpt.@add_parameter_bounds"><code>@add_parameter_bounds</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @hold_variable(model, vref)
vref

julia&gt; add_parameter_bounds(vref, ParameterBounds(t =&gt; IntervalSet(0, 2)))

julia&gt; parameter_bounds(vref)
Subdomain bounds (1): t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/hold_variables.jl#LL427-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.delete_parameter_bounds-Tuple{HoldVariableRef}" href="#InfiniteOpt.delete_parameter_bounds-Tuple{HoldVariableRef}"><code>InfiniteOpt.delete_parameter_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_parameter_bounds(vref::HoldVariableRef)::Nothing</code></pre><p>Delete all the parameter bounds of the hold variable <code>vref</code>. Any constraints that employ <code>vref</code> will be updated accordingly.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x[1:2] in [0, 10])
2-element Array{ParameterRef,1}:
 x[1]
 x[2]

julia&gt; @hold_variable(model, z, parameter_bounds = (x in [0, 1]))
z

julia&gt; delete_parameter_bounds(z)

julia&gt; parameter_bounds(z)
Subdomain bounds (0):</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/hold_variables.jl#LL489-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_variable_ref(vref::PointVariableRef)::GeneralVariableRef</code></pre><p>Return the <code>InfiniteVariableRef</code> associated with the point variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, T(t))
T(t)

julia&gt; vref = @point_variable(model, T(0))
T(0)

julia&gt; infinite_variable_ref(vref)
T(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/point_variables.jl#LL259-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_values-Tuple{PointVariableRef}" href="#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.parameter_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_values(vref::PointVariableRef)::Tuple</code></pre><p>Return the support point associated with the point variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_variable(model, T(t))
T(t)

julia&gt; vref = @point_variable(model, T(0))
T(0)

julia&gt; parameter_values(vref)
(0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/point_variables.jl#LL290-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_values-Tuple{PointVariableRef}" href="#InfiniteOpt.raw_parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.raw_parameter_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_values(vref::PointVariableRef)::Vector{Float64}</code></pre><p>Return the raw support point values associated with the point variable <code>vref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/point_variables.jl#LL281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.relax_integrality-Tuple{InfiniteModel}" href="#JuMP.relax_integrality-Tuple{InfiniteModel}"><code>JuMP.relax_integrality</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.relax_integrality(model::InfiniteModel)::Function</code></pre><p>Modifies <code>model</code> to &quot;relax&quot; all binary and integrality constraints on variables. Specifically,</p><ul><li>Binary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval <span>$[0, 1]$</span>.</li><li>Integrality constraints are deleted without modifying variable bounds.</li><li>All other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.</li></ul><p>Returns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; undo_relax = relax_integrality(model);

julia&gt; print(model)
Min x + integral{t ∈ [0, 10]}(y(t))
Subject to
 x ≥ 0.0
 y(t) ≥ 1.0
 x ≤ 1.0
 y(t) ≤ 10.0

julia&gt; undo_relax()

julia&gt; print(model)
Min x + integral{t ∈ [0, 10]}(y(t))
Subject to
 y(t) ≥ 1.0
 y(t) ≤ 10.0
 y(t) integer
 x binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/3e11073a7d41d4e3e7f8ece5d1364ad6011c9957/src/variable_basics.jl#LL1248-L1286">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../finite_parameter/">« Finite Parameters</a><a class="docs-footer-nextpage" href="../derivative/">Derivatives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 22 October 2020 03:43">Thursday 22 October 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
