<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Expressions · InfiniteOpt.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178297470-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178297470-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InfiniteOpt.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/quick_start/">Quick Start</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Optimal Control</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Optimal Control/consumption_savings/">Consumption Savings Problem</a></li><li><a class="tocitem" href="../../examples/Optimal Control/hovercraft/">Hovercraft Path Planning</a></li><li><a class="tocitem" href="../../examples/Optimal Control/pandemic_control/">Pandemic Control</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Stochastic Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/Stochastic Optimization/farmer/">Two-Stage Stochastic Program</a></li><li><a class="tocitem" href="../../examples/Stochastic Optimization/flexible_design/">Power Network Flexibility Design</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../domains/">Infinite Domains</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../derivative/">Derivatives</a></li><li class="is-active"><a class="tocitem" href>Expressions</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#par_func_docs"><span>Parameter Functions</span></a></li><li><a class="tocitem" href="#Variable-Hierarchy"><span>Variable Hierarchy</span></a></li><li><a class="tocitem" href="#Affine-Expressions"><span>Affine Expressions</span></a></li><li><a class="tocitem" href="#Quadratic-Expressions"><span>Quadratic Expressions</span></a></li><li><a class="tocitem" href="#Nonlinear-Expressions"><span>Nonlinear Expressions</span></a></li></ul></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/model/">Infinite Models</a></li><li><a class="tocitem" href="../../manual/domains/">Infinite Domains</a></li><li><a class="tocitem" href="../../manual/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../../manual/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../../manual/variable/">Variables</a></li><li><a class="tocitem" href="../../manual/derivative/">Derivatives</a></li><li><a class="tocitem" href="../../manual/expression/">Expressions</a></li><li><a class="tocitem" href="../../manual/measure/">Measures</a></li><li><a class="tocitem" href="../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../manual/constraint/">Constraints</a></li><li><a class="tocitem" href="../../manual/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../../manual/optimize/">Optimization</a></li><li><a class="tocitem" href="../../manual/result/">Results</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../develop/extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/start_guide/">Getting Started</a></li><li><a class="tocitem" href="../../develop/style/">Style Guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Expressions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Expressions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/expression.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="expr_docs"><a class="docs-heading-anchor" href="#expr_docs">Expressions</a><a id="expr_docs-1"></a><a class="docs-heading-anchor-permalink" href="#expr_docs" title="Permalink"></a></h1><p>A guide for the defining and understanding the variable expressions  used in <code>InfiniteOpt</code>. See the <a href="../../manual/expression/#expr_manual">technical manual</a> for more  details.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Nonlinear objects as defined by <code>JuMP.@NL[macro_name]</code> are not currently  supported by <code>InfiniteOpt</code>. See <a href="#Nonlinear-Expressions">Nonlinear Expressions</a> for more  information and possible workarounds. </p></div></div><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Expressions in <code>InfiniteOpt</code> (also called functions) refer to mathematical  statements involving variables and numbers. Thus, these comprise the  mathematical expressions used that are used in measures, objectives, and  constraints. Programmatically, <code>InfiniteOpt</code> simply extends <code>JuMP</code> expression  types and methods principally pertaining to affine and quadratic mathematical  expressions. A natively supported abstraction for general nonlinear expressions  is planned for development since that of <code>JuMP</code> is not readily extendable.</p><h2 id="par_func_docs"><a class="docs-heading-anchor" href="#par_func_docs">Parameter Functions</a><a id="par_func_docs-1"></a><a class="docs-heading-anchor-permalink" href="#par_func_docs" title="Permalink"></a></h2><p>As described further below, InfiniteOpt.jl only supports affine and quadratic  expressions in its current rendition. However, there several use cases where we  might want to provide a more complex known function of infinite parameter(s) (e.g.,  nonlinear setpoint tracking). Thus, we provide parameter function objects  that given a particular realization of infinite parameters will output a scalar  value. Note that this can be interpreted as an infinite variable that is  constrained to a particular known function. This is accomplished via  <a href="../../manual/expression/#InfiniteOpt.@parameter_function"><code>@parameter_function</code></a> or <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a> and is exemplified  by defining a parameter function <code>f(t)</code> that uses <code>sin(t)</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using InfiniteOpt;

julia&gt; model = InfiniteModel();

julia&gt; @infinite_parameter(model, t in [0, 10]);

julia&gt; @parameter_function(model, f == sin(t))
f(t)</code></pre><p>Here we created an parameter function object, added it to <code>model</code>, and  then created a Julia variable <code>f</code> that serves as a <code>GeneralVariableRef</code> that points  to it. From here we can treat <code>f</code> as a normal infinite variable and use it with  measures, derivatives, and constraints. For example, we can do the following:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, y, Infinite(t));

julia&gt; df = deriv(f, t)
∂/∂t[f(t)]

julia&gt; meas = integral(y - f, t)
∫{t ∈ [0, 10]}[y(t) - f(t)]

julia&gt; @constraint(model, y - f &lt;= 0)
y(t) - f(t) ≤ 0.0, ∀ t ∈ [0, 10]</code></pre><p>We can also define parameter functions that depend on multiple infinite  parameters even use an anonymous function if prefer:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, x[1:2] in [-1, 1]);

julia&gt; @parameter_function(model, myname == (t, x) -&gt; t + sum(x))
myname(t, x)</code></pre><p>In many applications, we may also desire to define an array of parameter functions  that each use a different realization of some parent function by varying some  additional positional/keyword arguments. We readily support this behavior since  parameter functions can be defined with additional known arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; @parameter_function(model, pfunc_alt[i = 1:3] == t -&gt; mysin(t, as[i], b = 0))
3-element Vector{GeneralVariableRef}:
 pfunc_alt[1](t)
 pfunc_alt[2](t)
 pfunc_alt[3](t)</code></pre><p>The main recommended use case for <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a> is that it is  amendable to defining complex anonymous functions via a do-block which is useful  for applications like defining a time-varied setpoint:</p><pre><code class="language-julia-repl hljs">julia&gt; setpoint = parameter_function(t, name = &quot;setpoint&quot;) do t_supp
                    if t_supp &lt;= 5
                        return 2.0
                    else 
                        return 10.2
                    end
                 end
setpoint(t)</code></pre><p>Please consult the following links for more information about defining parameter  functions: <a href="../../manual/expression/#InfiniteOpt.@parameter_function"><code>@parameter_function</code></a> and <a href="../../manual/expression/#InfiniteOpt.parameter_function"><code>parameter_function</code></a>.</p><p>Beyond this, there are number of query and modification methods that can be  employed for parameter functions and these are detailed in the  <a href="../../manual/expression/#par_func_manual">technical manual</a> Section below.</p><h2 id="Variable-Hierarchy"><a class="docs-heading-anchor" href="#Variable-Hierarchy">Variable Hierarchy</a><a id="Variable-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Hierarchy" title="Permalink"></a></h2><p>Expressions employ variable reference types inherited from <code>JuMP.AbstractVariableRef</code> to form expression objects. <code>InfiniteOpt</code> uses a hierarchy of such types to organize the complexities associated with modeling infinite dimensional programs. The figure below summarizes this hierarchy of variable reference types where the abstract types are depicted in green and the concrete types are shown blue.</p><p><img src="../../assets/variable_tree.png" alt="tree"/></p><p>In consistently with <code>JuMP</code> expression support, <a href="../../manual/expression/#InfiniteOpt.GeneralVariableRef"><code>GeneralVariableRef</code></a> exists as a variable reference type that is able to represent any of the above concrete subtypes of <a href="../../manual/expression/#InfiniteOpt.DispatchVariableRef"><code>DispatchVariableRef</code></a>. This allows the expression containers to be homogeneous in variable type. This is a paradigm shift from previous versions of <code>InfiniteOpt</code> that used the hierarchy of types directly to construct expressions. This behavior led to stability and performance limitations and thus a has been discontinued.</p><p>However, the variable hierarchy is still used to create for variable methods. To accomplish this appropriate <code>GeneralVariableRef</code> dispatch methods are implemented (which are detailed in User Methods section at the bottom of this page) that utilize <a href="../../manual/expression/#InfiniteOpt.dispatch_variable_ref"><code>dispatch_variable_ref</code></a> to create the appropriate concrete subtype of <code>DispatchVariableRef</code> and call the appropriate underlying method. These dispatch methods have been implemented for all public methods and the underlying methods are what are documented in the method manuals throughout the User Guide pages.</p><h2 id="Affine-Expressions"><a class="docs-heading-anchor" href="#Affine-Expressions">Affine Expressions</a><a id="Affine-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-Expressions" title="Permalink"></a></h2><p>An affine expression pertains to a mathematical function of the form:</p><p class="math-container">\[f_a(x) = a_1x_1 + ... + a_nx_n + b\]</p><p>where <span>$x \in \mathbb{R}^n$</span> denote variables, <span>$a \in \mathbb{R}^n$</span> denote  coefficients, and <span>$b \in \mathbb{R}$</span> denotes a constant value. Such  expressions, are prevalent in any problem than involves linear constraints  and/or objectives.</p><p>In <code>InfiniteOpt</code>, affine expressions can be defined directly  using <code>Julia</code>&#39;s arithmetic operators (i.e., <code>+</code>, <code>-</code>, <code>*</code>, etc.) or using  <code>@expression</code>.  For example, let&#39;s define the expression  <span>$2y(t) + z - 3t$</span> noting that the following methods are equivalent:</p><pre><code class="language-julia-repl hljs">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @variable(model, y, Infinite(t))
y(t)

julia&gt; @variable(model, z)
z

julia&gt; expr = 2y + z - 3t
2 y(t) + z - 3 t

julia&gt; expr = 2 * y + z - 3 * t
2 y(t) + z - 3 t

julia&gt; expr = @expression(model, 2y + z - 3t)
2 y(t) + z - 3 t

julia&gt; typeof(expr)
GenericAffExpr{Float64, GeneralVariableRef}</code></pre><p>Notice that coefficients to variables can simply be put alongside variables  without having to use the <code>*</code> operator. Also, note that all of these expressions  are stored in a container referred to as a <code>GenericAffExpr</code> which is a <code>JuMP</code>  object for storing affine expressions.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Where possible, it is preferable to use  <a href="https://jump.dev/JuMP.jl/v0.21.10/reference/expressions/#JuMP.@expression"><code>@expression</code></a>  for defining expressions as it is much more efficient than explicitly using  the standard operators.</p></div></div><p><code>GenericAffExpr</code> objects contain 2 fields which are:</p><ul><li><code>constant::CoefType</code> The constant value of the affine expression.</li><li><code>terms::OrderDict{VarType, CoefType}</code> A dictionary mapping variables to coefficients.</li></ul><p>For example, let&#39;s see what these fields look like in the above example:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.terms
OrderedCollections.OrderedDict{GeneralVariableRef, Float64} with 3 entries:
  y(t) =&gt; 2.0
  z    =&gt; 1.0
  t    =&gt; -3.0

julia&gt; expr.constant
0.0</code></pre><p>Notice that the ordered dictionary preserves the order in which the variables  appear in the expression.</p><p>More information can be found in the documentation for affine expressions in  <a href="https://jump.dev/JuMP.jl/v0.21.10/reference/expressions/#Affine-expressions"><code>JuMP</code></a>.</p><h2 id="Quadratic-Expressions"><a class="docs-heading-anchor" href="#Quadratic-Expressions">Quadratic Expressions</a><a id="Quadratic-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Expressions" title="Permalink"></a></h2><p>A quadratic function pertains to a mathematical function of the form:</p><p class="math-container">\[f_q(x) = a_1x_1^2 + a_2 x_1 x_2 + ... + a_m x_n^2 + f_a(x)\]</p><p>where <span>$x \in \mathbb{R}^n$</span> are the variables, <span>$f_a(x): \mathbb{R}^n \mapsto \mathbb{R}$</span> is an affine function, and <span>$m = n(n+1)/2$</span> is the number of unique combinations of variables <span>$x$</span>. Like affine expressions, quadratic expressions can be defined via <code>Julia</code>&#39;s arithmetic operators or via <code>@expression</code>. For example, let&#39;s define <span>$2y^2(t) - zy(t) + 42t - 3$</span> using the following equivalent methods:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = 2y^2 - z * y + 42t - 3
2 y(t)² - z*y(t) + 42 t - 3

julia&gt; expr = @expression(model, 2y^2 - z * y + 42t - 3)
2 y(t)² - y(t)*z + 42 t - 3

julia&gt; typeof(expr)
GenericQuadExpr{Float64, GeneralVariableRef}</code></pre><p>Again, notice that coefficients need not employ <code>*</code>. Also, the object used to  store the expression is a <code>GenericQuadExpr</code> which is a <code>JuMP</code> object used for  storing quadratic expressions.</p><p><code>GenericQuadExpr</code> object contains 2 data fields which are:</p><ul><li><code>aff::GenericAffExpr{CoefType,VarType}</code> An affine expression</li><li><code>terms::OrderedDict{UnorderedPair{VarType}, CoefType}</code> A dictionary mapping quadratic variable pairs to coefficients.</li></ul><p>Here the <code>UnorderedPair</code> type is unique to <code>JuMP</code> and contains the fields:</p><ul><li><code>a::AbstractVariableRef</code> One variable in a quadratic pair</li><li><code>b::AbstractVariableRef</code> The other variable in a quadratic pair.</li></ul><p>Thus, this form can be used to store arbitrary quadratic expressions. For  example, let&#39;s look at what these fields look like in the above example:</p><pre><code class="language-julia-repl hljs">julia&gt; expr.aff
42 t - 3

julia&gt; typeof(expr.aff)
GenericAffExpr{Float64, GeneralVariableRef}

julia&gt; expr.terms
OrderedCollections.OrderedDict{UnorderedPair{GeneralVariableRef}, Float64} with 2 entries:
  UnorderedPair{GeneralVariableRef}(y(t), y(t)) =&gt; 2.0
  UnorderedPair{GeneralVariableRef}(y(t), z)    =&gt; -1.0</code></pre><p>Notice again that the ordered dictionary preserves the order.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Polynomial expressions can be represented by introducing dumby variables  and nested quadratic/affine expressions. For instance, <span>$z^3 + 2$</span> can be  expressed by introducing a dumby variable <span>$x = z^2$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, x)
x

julia&gt; @constraint(model, x == z^2)
-z² + x = 0.0

julia&gt; expr = @expression(model, z * x + 2)
z*x + 2</code></pre></div></div><p>More information can be found in the documentation for quadratic expressions in  <a href="https://jump.dev/JuMP.jl/v0.21.10/reference/expressions/#Quadratic-expressions"><code>JuMP</code></a>.</p><h2 id="Nonlinear-Expressions"><a class="docs-heading-anchor" href="#Nonlinear-Expressions">Nonlinear Expressions</a><a id="Nonlinear-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Expressions" title="Permalink"></a></h2><p>General nonlinear expressions as generated via <code>JuMP.@NLexpression</code>,  <code>JuMP.@NLobjective</code>, and/or <code>JuMP.@NLconstraint</code> macros in <code>JuMP</code> are not  currently for <code>InfiniteOpt</code>. This is because <code>JuMP</code> does not readily support  nonlinear extensions. However, a fundamental overhaul is planned to resolve this  problem (check the status on  <a href="https://github.com/jump-dev/MathOptInterface.jl/issues/846">GitHub</a>).</p><h3 id="Workarounds"><a class="docs-heading-anchor" href="#Workarounds">Workarounds</a><a id="Workarounds-1"></a><a class="docs-heading-anchor-permalink" href="#Workarounds" title="Permalink"></a></h3><p>In the meantime, this limitation can often be overcome by reformulating the  problem formulation. </p><p>One common case involves expressions that entail integer powers that are greater  than 2. This can readily be remedied by adding placeholder variables. For example,  consider the expression <span>$z^2x - 3z$</span>. We can reformulate by introducing  <span>$z&#39; = z^2$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; @variable(model, z_squared)
z_squared

julia&gt; @constraint(model, z_squared == z^2)
-z² + z_squared = 0.0

julia&gt; @expression(model, z_squared * x - 3z)
z_squared*x - 3 z</code></pre><p>We can also reformulate for a variety of nonlinear function types:</p><table><tr><th style="text-align: center">Function</th><th style="text-align: center">Example</th><th style="text-align: center">Reformulation Method</th></tr><tr><td style="text-align: center">Square Root</td><td style="text-align: center"><span>$\sqrt{z}$</span></td><td style="text-align: center">Make a squared reformulation variable</td></tr><tr><td style="text-align: center">Indicator</td><td style="text-align: center"><span>$\mathbb{1}_{z \geq \alpha}$</span></td><td style="text-align: center">Use <a href="https://jump.dev/JuMP.jl/v0.21.10/manual/constraints/#Indicator-constraints"><code>JuMP</code>&#39;s indicator constraint syntax</a></td></tr><tr><td style="text-align: center">Indicator</td><td style="text-align: center"><span>$\mathbb{1}_{z \geq \alpha}$</span></td><td style="text-align: center">Replace with big-M constraints (<a href="https://www.gurobi.com/documentation/9.1/refman/dealing_with_big_m_constra.html">reference</a>)</td></tr><tr><td style="text-align: center">Max/Min</td><td style="text-align: center"><span>$\max(z, a)$</span></td><td style="text-align: center">Linear programming cuts or big-m constraints (<a href="https://or.stackexchange.com/questions/711/how-to-formulate-linearize-a-maximum-function-in-a-constraint/712#712">reference</a>)</td></tr></table><p>In other cases, it may be possible to use a formulation that uses vector  constraints. For example, it might be possible to model your problem using  semi-definite and/or conic constraints. </p><p>Also note that any nonlinearites that only involve infinite parameters (i.e.,  no decision variables) are enabled via parameter functions. See  <a href="#par_func_docs">Parameter Functions</a> for more information.</p><p>For problems that cannot be readily reformulated, <code>JuMP</code> can be used directly. In  this case the user will need to first transform the formulation into a finite  representation (e.g., discretize it). </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../derivative/">« Derivatives</a><a class="docs-footer-nextpage" href="../measure/">Measures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 22 October 2021 00:26">Friday 22 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
